var tipuesearch = {"pages":[{"title":" AoC-2023 ","text":"AoC-2023 Advent of Code 2023 with Modern Fortran. Compiling All the cases can be compiled and run using the Fortran Package Manager . to run individual cases: fpm run --profile release problem_01 to run them all: fpm run --profile release --all Current status Problem Stars Solution Runtime 1 ⭐⭐ problem_01.f90 12 ms 2 ⭐⭐ problem_02.f90 4 ms 3 ⭐⭐ problem_03.f90 2 ms 4 ⭐⭐ problem_04.f90 5 ms 5 ⭐⭐ problem_05.f90 622 ms 6 ⭐⭐ problem_06.f90 45 ms 7 ⭐⭐ problem_07.f90 17 ms 8 ⭐⭐ problem_08.f90 11 ms 9 ⭐⭐ problem_09.f90 23 ms 10 ⭐⭐ problem_10.f90 708 ms † 11 ⭐⭐ problem_11.f90 1 ms 12 ⭐⭐ problem_12.f90 + problem_12b.f90 754 ms + 232 ms 13 ⭐⭐ problem_13.f90 3 ms 14 ⭐⭐ problem_14.f90 257 ms 15 ⭐⭐ problem_15.f90 3 ms 16 ⭐⭐ problem_16.f90 27 ms 17 ⭐⭐ problem_17.f90 + problem_17b.f90 minutes 18 ⭐⭐ problem_18.f90 2 ms 19 ⭐⭐ problem_19.f90 + problem_19b.f90 44 ms + 47 ms 20 ☆☆ problem_20.f90 21 ⭐☆ problem_21.f90 1 ms 22 ☆☆ problem_22.f90 23 ⭐⭐ problem_23.f90 3689 ms 24 ☆☆ problem_24.f90 25 ☆☆ problem_25.f90 † With OpenMP enabled (i.e, add --flag \"-fopenmp\" to the FPM call). Previous Years AoC-2020 AoC-2021 AoC-2022 AoC-2023 ## Documentation The API documentation for the current master branch can be found here .  This is generated by processing the source files with FORD . Developer Info Jacob Williams","tags":"home","loc":"index.html"},{"title":"clock – AoC-2023 ","text":"type, public :: clock Components Type Visibility Attributes Name Initial integer(kind=int64), private :: begin integer(kind=int64), private :: end integer(kind=int64), private :: rate Type-Bound Procedures procedure, public :: tic => clock_start private  subroutine clock_start (me) Start the clock Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me procedure, public :: toc => clock_end private  subroutine clock_end (me, case_str) Print runtime in milliseconds form the start of the clock. Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me character(len=*), intent(in) :: case_str description of the case Source Code type , public :: clock private integer ( int64 ) :: begin , end , rate contains procedure , public :: tic => clock_start procedure , public :: toc => clock_end end type clock","tags":"","loc":"type/clock.html"},{"title":"string – AoC-2023 ","text":"type, public :: string a type containing an allocatable character string.\nso we can have an array of strings of different lengths. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: str Type-Bound Procedures procedure, public :: to_int => string_to_int convert to integer private pure elemental function string_to_int (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer procedure, public :: to_int_64 => string_to_int_64 private pure elemental function string_to_int_64 (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer(kind=int64) Source Code type , public :: string !! a type containing an allocatable character string. !! so we can have an array of strings of different lengths. character ( len = :), allocatable :: str contains procedure , public :: to_int => string_to_int !! convert to integer procedure , public :: to_int_64 => string_to_int_64 end type string","tags":"","loc":"type/string.html"},{"title":"int64_vec – AoC-2023 ","text":"type, public :: int64_vec an type that contains an allocatable int64 array.\nso we can have an array of these. Components Type Visibility Attributes Name Initial integer(kind=int64), public, dimension(:), allocatable :: vals Source Code type , public :: int64_vec !! an type that contains an allocatable int64 array. !! so we can have an array of these. integer ( int64 ), dimension (:), allocatable :: vals end type int64_vec","tags":"","loc":"type/int64_vec.html"},{"title":"lens – AoC-2023 ","text":"type, public :: lens Inherited by type~~lens~~InheritedByGraph type~lens lens type~box box type~box->type~lens lenses Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: label integer(kind=ip), public :: focal_length = 0 Source Code type :: lens character ( len = :), allocatable :: label integer ( ip ) :: focal_length = 0 end type lens","tags":"","loc":"type/lens.html"},{"title":"box – AoC-2023 ","text":"type, public :: box Inherits type~~box~~InheritsGraph type~box box type~lens lens type~box->type~lens lenses Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( lens ), public, dimension(:), allocatable :: lenses the lenses in the box Type-Bound Procedures procedure, public :: add_lens public  subroutine add_lens (me, l) Arguments Type Intent Optional Attributes Name class( box ), intent(inout) :: me type( lens ), intent(in) :: l lense to add procedure, public :: remove_lens public  subroutine remove_lens (me, label) remove the lens with the label (if present) Arguments Type Intent Optional Attributes Name class( box ), intent(inout) :: me character(len=*), intent(in) :: label Source Code type :: box type ( lens ), dimension (:), allocatable :: lenses !! the lenses in the box contains procedure :: add_lens procedure :: remove_lens end type box","tags":"","loc":"type/box.html"},{"title":"interval – AoC-2023 ","text":"type :: interval Inherited by type~~interval~~InheritedByGraph type~interval interval type~part part type~part->type~interval xmas Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(2) :: v [start, end] of the interval Source Code type :: interval integer ( ip ), dimension ( 2 ) :: v !! [start, end] of the interval end type interval","tags":"","loc":"type/interval.html"},{"title":"part – AoC-2023 ","text":"type :: part Inherits type~~part~~InheritsGraph type~part part type~interval interval type~part->type~interval xmas Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( interval ), public, dimension(4) :: xmas Source Code type :: part type ( interval ), dimension ( 4 ) :: xmas ! [x,m,a,s] ranges end type part","tags":"","loc":"type/part.html"},{"title":"rule – AoC-2023 ","text":"type :: rule Inherited by type~~rule~~InheritedByGraph type~rule rule type~workflow workflow type~workflow->type~rule rules Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, public :: accept = .false. logical, public :: reject = .false. integer, public :: operator = 0 integer, public :: operator_arg = 0 integer, public :: operator_val = 0 character(len=:), public, allocatable :: goto Source Code type :: rule logical :: accept = . false . logical :: reject = . false . integer :: operator = 0 ! 1:<, 2:> integer :: operator_arg = 0 ! 1:x, 2:m, 3:a, 4:s integer :: operator_val = 0 ! value to compare to character ( len = :), allocatable :: goto ! where to next (workflow name) end type rule","tags":"","loc":"type/rule.html"},{"title":"workflow – AoC-2023 ","text":"type :: workflow Inherits type~~workflow~~InheritsGraph type~workflow workflow type~rule rule type~workflow->type~rule rules Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name type( rule ), public, dimension(:), allocatable :: rules Source Code type :: workflow character ( len = :), allocatable :: name type ( rule ), dimension (:), allocatable :: rules end type workflow","tags":"","loc":"type/workflow.html"},{"title":"hand – AoC-2023 ","text":"type :: hand Components Type Visibility Attributes Name Initial character(len=1), public, dimension(5) :: cards the cards in a hand integer(kind=ip), public :: bid = 0 integer, public :: type = 0 Source Code type :: hand character ( len = 1 ), dimension ( 5 ) :: cards !! the cards in a hand integer ( ip ) :: bid = 0 ! the bit for the hand integer :: type = 0 ! the hand type end type hand","tags":"","loc":"type/hand.html"},{"title":"fx – AoC-2023 ","text":"type, private :: fx an [x,f(x)] cached pair.\nx is a vector and f is a scalar value. Inherited by type~~fx~~InheritedByGraph type~fx fx type~function_cache function_cache type~function_cache->type~fx c Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer(kind=ip), private, dimension(:), allocatable :: x vector of input values integer(kind=ip), private :: f scalar output function Source Code type :: fx !! an [x,f(x)] cached pair. !! x is a vector and f is a scalar value. private integer ( ip ), dimension (:), allocatable :: x !! vector of input values integer ( ip ) :: f !! scalar output function end type fx","tags":"","loc":"type/fx.html"},{"title":"function_cache – AoC-2023 ","text":"type, public :: function_cache a vector function cache. Inherits type~~function_cache~~InheritsGraph type~function_cache function_cache type~fx fx type~function_cache->type~fx c Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( fx ), private, dimension(:), allocatable :: c the cache of f(x) integer, private :: chunk_size = 100 for resizing vectors\nin the unique function Type-Bound Procedures procedure, public :: initialize => initialize_cache private  subroutine initialize_cache (me, isize, chunk_size) Initialize the cache. Must be called first before use. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: isize the size of the hash table integer, intent(in), optional :: chunk_size chunk size to speed up reallocation\nof arrays. A good value is a guess for\nthe actual number of elements of f that\nwill be saved per value of x [default is 100] procedure, public :: get => get_from_cache private  subroutine get_from_cache (me, x, i, f, found) Check if the x vector is in the cache, if so return f .\nNote that only some of the elements may be present, so it will return\nthe ones there are there, and indicate which ones were found. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer(kind=ip), intent(in), dimension(:) :: x independant variable vector integer(kind=ip), intent(out) :: i index in the hash table integer(kind=ip), intent(out) :: f f(x) from the cache (if it was found) logical, intent(out) :: found if x was found in the cache procedure, public :: put => put_in_cache private  subroutine put_in_cache (me, i, x, f) Put a value into the cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer(kind=ip), intent(in) :: i index in the hash table integer(kind=ip), intent(in), dimension(:) :: x independant variable vector integer(kind=ip), intent(in) :: f function procedure, public :: destroy => destroy_cache private  subroutine destroy_cache (me) Destroy a cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(out) :: me Source Code type , public :: function_cache !! a vector function cache. private type ( fx ), dimension (:), allocatable :: c !! the cache of `f(x)` integer :: chunk_size = 100 !! for resizing vectors !! in the [[unique]] function contains private procedure , public :: initialize => initialize_cache procedure , public :: get => get_from_cache procedure , public :: put => put_in_cache procedure , public :: destroy => destroy_cache end type function_cache","tags":"","loc":"type/function_cache.html"},{"title":"node – AoC-2023 ","text":"type :: node Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(:), allocatable :: inext the node connected to this one integer(kind=ip), public, dimension(:), allocatable :: idist distance to inext nodes Source Code type :: node integer ( ip ), dimension (:), allocatable :: inext !! the node connected to this one integer ( ip ), dimension (:), allocatable :: idist !! distance to inext nodes end type node","tags":"","loc":"type/node.html"},{"title":"mapping – AoC-2023 ","text":"type :: mapping Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(:), allocatable :: dest_start integer(kind=ip), public, dimension(:), allocatable :: dest_end integer(kind=ip), public, dimension(:), allocatable :: src_start integer(kind=ip), public, dimension(:), allocatable :: src_end Source Code type :: mapping ! save the source and destination start and end values integer ( ip ), dimension (:), allocatable :: dest_start , dest_end , src_start , src_end end type mapping","tags":"","loc":"type/mapping.html"},{"title":"part – AoC-2023 ","text":"type :: part Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(4) :: xmas Source Code type :: part integer ( ip ), dimension ( 4 ) :: xmas ! [x,m,a,s] end type part","tags":"","loc":"type/part~2.html"},{"title":"rule – AoC-2023 ","text":"type :: rule Inherited by type~~rule~2~~InheritedByGraph type~rule~2 rule type~workflow~2 workflow type~workflow~2->type~rule~2 rules Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, public :: accept = .false. logical, public :: reject = .false. integer, public :: operator = 0 integer, public :: operator_arg = 0 integer, public :: operator_val = 0 character(len=:), public, allocatable :: goto Source Code type :: rule logical :: accept = . false . logical :: reject = . false . integer :: operator = 0 ! 1:<, 2:> integer :: operator_arg = 0 ! 1:x, 2:m, 3:a, 4:s integer :: operator_val = 0 ! value to compare to character ( len = :), allocatable :: goto ! where to next (workflow name) end type rule","tags":"","loc":"type/rule~2.html"},{"title":"workflow – AoC-2023 ","text":"type :: workflow Inherits type~~workflow~2~~InheritsGraph type~workflow~2 workflow type~rule~2 rule type~workflow~2->type~rule~2 rules Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name type( rule ), public, dimension(:), allocatable :: rules Source Code type :: workflow character ( len = :), allocatable :: name type ( rule ), dimension (:), allocatable :: rules end type workflow","tags":"","loc":"type/workflow~2.html"},{"title":"node – AoC-2023 ","text":"type :: node Components Type Visibility Attributes Name Initial character(len=3), public :: name = '' character(len=3), public, dimension(2) :: lr integer, public, dimension(2) :: lr_idx Source Code type :: node character ( len = 3 ) :: name = '' character ( len = 3 ), dimension ( 2 ) :: lr integer , dimension ( 2 ) :: lr_idx ! the indices in the nodes array of the l,r nodes end type node","tags":"","loc":"type/node~2.html"},{"title":"item – AoC-2023 ","text":"type :: item Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(NSTATE) :: state = 0 state: [i, j, direction, and # of moves] integer(kind=ip), public :: dist = huge(1) distance for this one logical, public :: visited = .false. if this one is done integer(kind=ip), public :: iprev = -1 index in the queue of the previous one Source Code type :: item integer ( ip ), dimension ( NSTATE ) :: state = 0 !! state: [i, j, direction, and # of moves] integer ( ip ) :: dist = huge ( 1 ) !! distance for this one logical :: visited = . false . !! if this one is done integer ( ip ) :: iprev = - 1 !! index in the queue of the previous one end type item","tags":"","loc":"type/item.html"},{"title":"item – AoC-2023 ","text":"type :: item Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(NSTATE) :: state = 0 state: [i, j, direction, and # of moves] integer(kind=ip), public :: dist = huge(1) distance for this one logical, public :: visited = .false. if this one is done integer(kind=ip), public :: iprev = -1 index in the queue of the previous one Source Code type :: item integer ( ip ), dimension ( NSTATE ) :: state = 0 !! state: [i, j, direction, and # of moves] integer ( ip ) :: dist = huge ( 1 ) !! distance for this one logical :: visited = . false . !! if this one is done integer ( ip ) :: iprev = - 1 !! index in the queue of the previous one end type item","tags":"","loc":"type/item~2.html"},{"title":"char_to_int – AoC-2023","text":"private pure function char_to_int(str) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer Called by proc~~char_to_int~~CalledByGraph proc~char_to_int aoc_utilities::char_to_int interface~int aoc_utilities::int interface~int->proc~char_to_int proc~char_array_to_int aoc_utilities::char_array_to_int interface~int->proc~char_array_to_int proc~char_array_to_int->proc~char_to_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function char_to_int ( str ) result ( i ) character ( len =* ), intent ( in ) :: str integer :: i read ( str , * ) i end function char_to_int","tags":"","loc":"proc/char_to_int.html"},{"title":"string_to_int – AoC-2023","text":"private pure elemental function string_to_int(me) result(i) Basic string to integer routine Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer Called by proc~~string_to_int~~CalledByGraph proc~string_to_int aoc_utilities::string%string_to_int interface~int aoc_utilities::int interface~int->proc~string_to_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental function string_to_int ( me ) result ( i ) class ( string ), intent ( in ) :: me integer :: i i = int ( me % str ) end function string_to_int","tags":"","loc":"proc/string_to_int.html"},{"title":"string_to_int_64 – AoC-2023","text":"private pure elemental function string_to_int_64(me) result(i) Basic string to integer routine Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer(kind=int64) Called by proc~~string_to_int_64~~CalledByGraph proc~string_to_int_64 aoc_utilities::string%string_to_int_64 program~problem_24 problem_24 program~problem_24->proc~string_to_int_64 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental function string_to_int_64 ( me ) result ( i ) class ( string ), intent ( in ) :: me integer ( int64 ) :: i i = int ( me % str , int64 ) end function string_to_int_64","tags":"","loc":"proc/string_to_int_64.html"},{"title":"char_to_int64 – AoC-2023","text":"private pure function char_to_int64(str, kind) result(i) Basic string to integer(ip) routine.\nHacky hack just so we can overload as int() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: kind Return Value integer(kind=int64) Called by proc~~char_to_int64~~CalledByGraph proc~char_to_int64 aoc_utilities::char_to_int64 interface~int aoc_utilities::int interface~int->proc~char_to_int64 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function char_to_int64 ( str , kind ) result ( i ) character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: kind integer ( int64 ) :: i if ( kind /= int64 ) error stop 'error' read ( str , * ) i end function char_to_int64","tags":"","loc":"proc/char_to_int64.html"},{"title":"char_array_to_int – AoC-2023","text":"private pure function char_array_to_int(str_array) result(i) Character array to integer routine Arguments Type Intent Optional Attributes Name character(len=1), intent(in), dimension(:) :: str_array example ['1','3'] --> 13 Return Value integer Calls proc~~char_array_to_int~~CallsGraph proc~char_array_to_int aoc_utilities::char_array_to_int proc~char_to_int aoc_utilities::char_to_int proc~char_array_to_int->proc~char_to_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~char_array_to_int~~CalledByGraph proc~char_array_to_int aoc_utilities::char_array_to_int interface~int aoc_utilities::int interface~int->proc~char_array_to_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function char_array_to_int ( str_array ) result ( i ) character ( len = 1 ), dimension (:), intent ( in ) :: str_array !! example ['1','3'] --> 13 integer :: i character ( len = :), allocatable :: str integer :: k str = '' do k = 1 , size ( str_array ) str = str // str_array ( k ) end do i = char_to_int ( str ) end function char_array_to_int","tags":"","loc":"proc/char_array_to_int.html"},{"title":"int_array_to_char_array – AoC-2023","text":"public pure function int_array_to_char_array(iarray) result(carray) integer array to Character array Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: iarray Return Value character(len=1), dimension(:,:), allocatable Source Code pure function int_array_to_char_array ( iarray ) result ( carray ) integer , dimension (:,:), intent ( in ) :: iarray character ( len = 1 ), dimension (:,:), allocatable :: carray integer :: i , j allocate ( carray ( size ( iarray , 1 ), size ( iarray , 2 ))) do i = 1 , size ( iarray , 1 ) do j = 1 , size ( iarray , 2 ) write ( carray ( i , j ), '(I1)' ) iarray ( i , j ) end do end do end function int_array_to_char_array","tags":"","loc":"proc/int_array_to_char_array.html"},{"title":"read_file_to_char_array – AoC-2023","text":"public  function read_file_to_char_array(filename, border) result(array) Read a file into a 2d character array. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=1), intent(in), optional :: border if true, extra border is added with this char Return Value character(len=1), dimension(:,:), allocatable Calls proc~~read_file_to_char_array~~CallsGraph proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_file_to_char_array~~CalledByGraph proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~go~2 problem_23::go proc~go~2->proc~read_file_to_char_array proc~go~6 problem_11::go proc~go~6->proc~read_file_to_char_array program~problem_10 problem_10 program~problem_10->proc~read_file_to_char_array program~problem_16 problem_16 program~problem_16->proc~read_file_to_char_array program~problem_21 problem_21 program~problem_21->proc~read_file_to_char_array program~problem_3 problem_3 program~problem_3->proc~read_file_to_char_array program~problem_11 problem_11 program~problem_11->proc~go~6 program~problem_23 problem_23 program~problem_23->proc~go~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function read_file_to_char_array ( filename , border ) result ( array ) character ( len =* ), intent ( in ) :: filename character ( len = 1 ), intent ( in ), optional :: border !! if true, extra border is added with this char character ( len = 1 ), dimension (:,:), allocatable :: array integer :: i , j , iunit , n_lines , n_cols character ( len = :), allocatable :: line open ( newunit = iunit , file = filename , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) line = read_line ( iunit ); n_cols = len ( line ) rewind ( iunit ) if ( present ( border )) then allocate ( array ( 0 : n_lines + 1 , 0 : n_cols + 1 )) ! padding with border array = border else allocate ( array ( n_lines , n_cols )) end if do i = 1 , n_lines line = read_line ( iunit ) do j = 1 , n_cols array ( i , j ) = line ( j : j ) end do end do close ( iunit ) end function read_file_to_char_array","tags":"","loc":"proc/read_file_to_char_array.html"},{"title":"read_file_to_int_array – AoC-2023","text":"public  function read_file_to_int_array(filename) result(array) Read a file into a 2d character array. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer, dimension(:,:), allocatable Calls proc~~read_file_to_int_array~~CallsGraph proc~read_file_to_int_array aoc_utilities::read_file_to_int_array proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_int_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_int_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_file_to_int_array~~CalledByGraph proc~read_file_to_int_array aoc_utilities::read_file_to_int_array program~problem_17 problem_17 program~problem_17->proc~read_file_to_int_array program~problem_17~2 problem_17 program~problem_17~2->proc~read_file_to_int_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function read_file_to_int_array ( filename ) result ( array ) character ( len =* ), intent ( in ) :: filename integer , dimension (:,:), allocatable :: array integer :: i , iunit , n_lines , n_cols character ( len = :), allocatable :: line open ( newunit = iunit , file = filename , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) line = read_line ( iunit ) n_cols = len ( line ) rewind ( iunit ) allocate ( array ( n_lines , n_cols )) do i = 1 , n_lines line = read_line ( iunit ) read ( line , '(*(I1))' ) array ( i , 1 : n_cols ) end do close ( iunit ) end function read_file_to_int_array","tags":"","loc":"proc/read_file_to_int_array.html"},{"title":"read_file_to_integer_array – AoC-2023","text":"public  function read_file_to_integer_array(filename) result(iarray) Read a file into an integer array (one element per line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer, dimension(:), allocatable Calls proc~~read_file_to_integer_array~~CallsGraph proc~read_file_to_integer_array aoc_utilities::read_file_to_integer_array proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_integer_array->proc~number_of_lines_in_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function read_file_to_integer_array ( filename ) result ( iarray ) character ( len =* ), intent ( in ) :: filename integer , dimension (:), allocatable :: iarray integer :: i , iunit , n_lines , istat open ( newunit = iunit , file = filename , iostat = istat ) if ( istat /= 0 ) error stop ' error reading file' n_lines = number_of_lines_in_file ( iunit ) allocate ( iarray ( n_lines )) do i = 1 , n_lines read ( iunit , '(I10)' ) iarray ( i ) end do close ( iunit ) end function read_file_to_integer_array","tags":"","loc":"proc/read_file_to_integer_array.html"},{"title":"read_file_to_integer64_array – AoC-2023","text":"public  function read_file_to_integer64_array(filename) result(iarray) Read a file into an int64 integer array (one element per line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer(kind=int64), dimension(:), allocatable Calls proc~~read_file_to_integer64_array~~CallsGraph proc~read_file_to_integer64_array aoc_utilities::read_file_to_integer64_array proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_integer64_array->proc~number_of_lines_in_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function read_file_to_integer64_array ( filename ) result ( iarray ) character ( len =* ), intent ( in ) :: filename integer ( int64 ), dimension (:), allocatable :: iarray integer :: i , iunit , n_lines , istat open ( newunit = iunit , file = filename , iostat = istat ) if ( istat /= 0 ) error stop ' error reading file' n_lines = number_of_lines_in_file ( iunit ) allocate ( iarray ( n_lines )) do i = 1 , n_lines read ( iunit , * ) iarray ( i ) end do close ( iunit ) end function read_file_to_integer64_array","tags":"","loc":"proc/read_file_to_integer64_array.html"},{"title":"number_of_lines_in_file – AoC-2023","text":"public  function number_of_lines_in_file(iunit) result(n_lines) Returns the number of lines in a file (assumed to be open) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit the file unit number\n(assumed to be open) Return Value integer the number of lines in the file Called by proc~~number_of_lines_in_file~~CalledByGraph proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~go problem_18::go proc~go->proc~number_of_lines_in_file proc~go~7 problem_12::go proc~go~7->proc~number_of_lines_in_file proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_file_to_int_array aoc_utilities::read_file_to_int_array proc~read_file_to_int_array->proc~number_of_lines_in_file proc~read_file_to_integer64_array aoc_utilities::read_file_to_integer64_array proc~read_file_to_integer64_array->proc~number_of_lines_in_file proc~read_file_to_integer_array aoc_utilities::read_file_to_integer_array proc~read_file_to_integer_array->proc~number_of_lines_in_file program~problem_1 problem_1 program~problem_1->proc~number_of_lines_in_file program~problem_12b problem_12b program~problem_12b->proc~number_of_lines_in_file program~problem_13 problem_13 program~problem_13->proc~number_of_lines_in_file program~problem_19 problem_19 program~problem_19->proc~number_of_lines_in_file program~problem_19b problem_19b program~problem_19b->proc~number_of_lines_in_file program~problem_2 problem_2 program~problem_2->proc~number_of_lines_in_file program~problem_24 problem_24 program~problem_24->proc~number_of_lines_in_file program~problem_4 problem_4 program~problem_4->proc~number_of_lines_in_file program~problem_5 problem_5 program~problem_5->proc~number_of_lines_in_file program~problem_7 problem_7 program~problem_7->proc~number_of_lines_in_file program~problem_8 problem_8 program~problem_8->proc~number_of_lines_in_file program~problem_9 problem_9 program~problem_9->proc~number_of_lines_in_file proc~go~2 problem_23::go proc~go~2->proc~read_file_to_char_array proc~go~6 problem_11::go proc~go~6->proc~read_file_to_char_array program~problem_10 problem_10 program~problem_10->proc~read_file_to_char_array program~problem_12 problem_12 program~problem_12->proc~go~7 program~problem_16 problem_16 program~problem_16->proc~read_file_to_char_array program~problem_17 problem_17 program~problem_17->proc~read_file_to_int_array program~problem_17~2 problem_17 program~problem_17~2->proc~read_file_to_int_array program~problem_18 problem_18 program~problem_18->proc~go program~problem_21 problem_21 program~problem_21->proc~read_file_to_char_array program~problem_3 problem_3 program~problem_3->proc~read_file_to_char_array program~problem_11 problem_11 program~problem_11->proc~go~6 program~problem_23 problem_23 program~problem_23->proc~go~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function number_of_lines_in_file ( iunit ) result ( n_lines ) integer , intent ( in ) :: iunit !! the file unit number !! (assumed to be open) integer :: n_lines !! the number of lines in the file character ( len = 1 ) :: tmp integer :: istat rewind ( iunit ) n_lines = 0 do read ( iunit , fmt = '(A1)' , iostat = istat ) tmp if ( is_iostat_end ( istat )) exit n_lines = n_lines + 1 end do rewind ( iunit ) end function number_of_lines_in_file","tags":"","loc":"proc/number_of_lines_in_file.html"},{"title":"split2 – AoC-2023","text":"private pure function split2(s, token) result(vals) Split a string , given a token. Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: s character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable Calls proc~~split2~~CallsGraph proc~split2 aoc_utilities::split2 proc~split1 aoc_utilities::split1 proc~split2->proc~split1 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~split2~~CalledByGraph proc~split2 aoc_utilities::split2 interface~split aoc_utilities::split interface~split->proc~split2 proc~go problem_18::go proc~go->interface~split proc~go~7 problem_12::go proc~go~7->interface~split proc~parse_nums64 aoc_utilities::parse_nums64 proc~parse_nums64->interface~split proc~parse_rule problem_19b::parse_rule proc~parse_rule->interface~split proc~parse_rule~2 problem_19::parse_rule proc~parse_rule~2->interface~split program~problem_12b problem_12b program~problem_12b->interface~split program~problem_15 problem_15 program~problem_15->interface~split program~problem_19 problem_19 program~problem_19->interface~split program~problem_19->proc~parse_rule~2 program~problem_19b problem_19b program~problem_19b->interface~split program~problem_19b->proc~parse_rule program~problem_2 problem_2 program~problem_2->interface~split program~problem_24 problem_24 program~problem_24->interface~split program~problem_4 problem_4 program~problem_4->interface~split program~problem_7 problem_7 program~problem_7->interface~split interface~parse aoc_utilities::parse interface~parse->proc~parse_nums64 program~problem_12 problem_12 program~problem_12->proc~go~7 program~problem_18 problem_18 program~problem_18->proc~go program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function split2 ( s , token ) result ( vals ) implicit none type ( string ), intent ( in ) :: s character ( len =* ), intent ( in ) :: token type ( string ), dimension (:), allocatable :: vals if ( allocated ( s % str )) then vals = split1 ( s % str , token ) else error stop 'error: string not allocated' end if end function split2","tags":"","loc":"proc/split2.html"},{"title":"split1 – AoC-2023","text":"private pure function split1(str, token) result(vals) Split a character string using a token.\n  This routine is inspired by the Python split function. Example character ( len = :), allocatable :: s type ( string ), dimension (:), allocatable :: vals s = '1,2,3,4,5' call split ( s , ',' , vals ) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable Calls proc~~split1~~CallsGraph proc~split1 aoc_utilities::split1 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~split1~~CalledByGraph proc~split1 aoc_utilities::split1 interface~split aoc_utilities::split interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~split2->proc~split1 proc~go problem_18::go proc~go->interface~split proc~go~7 problem_12::go proc~go~7->interface~split proc~parse_nums64 aoc_utilities::parse_nums64 proc~parse_nums64->interface~split proc~parse_rule problem_19b::parse_rule proc~parse_rule->interface~split proc~parse_rule~2 problem_19::parse_rule proc~parse_rule~2->interface~split program~problem_12b problem_12b program~problem_12b->interface~split program~problem_15 problem_15 program~problem_15->interface~split program~problem_19 problem_19 program~problem_19->interface~split program~problem_19->proc~parse_rule~2 program~problem_19b problem_19b program~problem_19b->interface~split program~problem_19b->proc~parse_rule program~problem_2 problem_2 program~problem_2->interface~split program~problem_24 problem_24 program~problem_24->interface~split program~problem_4 problem_4 program~problem_4->interface~split program~problem_7 problem_7 program~problem_7->interface~split interface~parse aoc_utilities::parse interface~parse->proc~parse_nums64 program~problem_12 problem_12 program~problem_12->proc~go~7 program~problem_18 problem_18 program~problem_18->proc~go program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function split1 ( str , token ) result ( vals ) implicit none character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ) :: token type ( string ), dimension (:), allocatable :: vals integer :: i !! counter integer :: len_str !! significant length of `str` integer :: len_token !! length of the token integer :: n_tokens !! number of tokens integer :: i1 !! index integer :: i2 !! index integer :: j !! counters integer , dimension (:), allocatable :: itokens !! start indices of the !! token locations in `str` len_token = len ( token ) ! length of the token n_tokens = 0 ! initialize the token counter j = 0 ! index to start looking for the next token ! first, count the number of times the token ! appears in the string, and get the token indices. ! ! Examples: !  ',         '    --> 1 !  '1234,67,90'    --> 5,8 !  '123,      '    --> 4 ! length of the string if ( token == ' ' ) then ! in this case, we can't ignore trailing space len_str = len ( str ) else ! safe to ignore trailing space when looking for tokens len_str = len_trim ( str ) end if j = 1 n_tokens = 0 do if ( j > len_str ) exit ! end of string, finished i = index ( str ( j :), token ) ! index of next token in remaining string if ( i <= 0 ) exit ! no more tokens found call expand_vector ( itokens , n_tokens , i + j - 1 ) ! save the token location j = j + i + ( len_token - 1 ) end do call expand_vector ( itokens , n_tokens , finished = . true .) ! resize the vector allocate ( vals ( n_tokens + 1 )) if ( n_tokens > 0 ) then len_str = len ( str ) i1 = 1 i2 = itokens ( 1 ) - 1 if ( i2 >= i1 ) then vals ( 1 )% str = str ( i1 : i2 ) else vals ( 1 )% str = '' !the first character is a token end if !      1 2 3 !    'a,b,c,d' do i = 2 , n_tokens i1 = itokens ( i - 1 ) + len_token i2 = itokens ( i ) - 1 if ( i2 >= i1 ) then vals ( i )% str = str ( i1 : i2 ) else vals ( i )% str = '' !empty element (e.g., 'abc,,def') end if end do i1 = itokens ( n_tokens ) + len_token i2 = len_str if ( itokens ( n_tokens ) + len_token <= len_str ) then vals ( n_tokens + 1 )% str = str ( i1 : i2 ) else vals ( n_tokens + 1 )% str = '' !the last character was a token end if else !no tokens present, so just return the original string: vals ( 1 )% str = str end if end function split1","tags":"","loc":"proc/split1.html"},{"title":"read_line – AoC-2023","text":"public  function read_line(iunit, status_ok) result(line) Reads the next line from a file. Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit logical, intent(out), optional :: status_ok true if no problems Return Value character(len=:), allocatable Called by proc~~read_line~~CalledByGraph proc~read_line aoc_utilities::read_line proc~go problem_18::go proc~go->proc~read_line proc~go~7 problem_12::go proc~go~7->proc~read_line proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~read_file_to_char_array->proc~read_line proc~read_file_to_int_array aoc_utilities::read_file_to_int_array proc~read_file_to_int_array->proc~read_line program~problem_1 problem_1 program~problem_1->proc~read_line program~problem_12b problem_12b program~problem_12b->proc~read_line program~problem_13 problem_13 program~problem_13->proc~read_line program~problem_15 problem_15 program~problem_15->proc~read_line program~problem_19 problem_19 program~problem_19->proc~read_line program~problem_19b problem_19b program~problem_19b->proc~read_line program~problem_2 problem_2 program~problem_2->proc~read_line program~problem_24 problem_24 program~problem_24->proc~read_line program~problem_4 problem_4 program~problem_4->proc~read_line program~problem_5 problem_5 program~problem_5->proc~read_line program~problem_7 problem_7 program~problem_7->proc~read_line program~problem_8 problem_8 program~problem_8->proc~read_line program~problem_9 problem_9 program~problem_9->proc~read_line proc~go~2 problem_23::go proc~go~2->proc~read_file_to_char_array proc~go~6 problem_11::go proc~go~6->proc~read_file_to_char_array program~problem_10 problem_10 program~problem_10->proc~read_file_to_char_array program~problem_12 problem_12 program~problem_12->proc~go~7 program~problem_16 problem_16 program~problem_16->proc~read_file_to_char_array program~problem_17 problem_17 program~problem_17->proc~read_file_to_int_array program~problem_17~2 problem_17 program~problem_17~2->proc~read_file_to_int_array program~problem_18 problem_18 program~problem_18->proc~go program~problem_21 problem_21 program~problem_21->proc~read_file_to_char_array program~problem_3 problem_3 program~problem_3->proc~read_file_to_char_array program~problem_11 problem_11 program~problem_11->proc~go~6 program~problem_23 problem_23 program~problem_23->proc~go~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function read_line ( iunit , status_ok ) result ( line ) integer , intent ( in ) :: iunit character ( len = :), allocatable :: line logical , intent ( out ), optional :: status_ok !! true if no problems integer :: nread !! character count specifier for read statement integer :: istat !! file read io status flag character ( len = chunk_size ) :: buffer !! the file read buffer nread = 0 buffer = '' line = '' if ( present ( status_ok )) status_ok = . true . do ! read in the next block of text from the line: read ( iunit , fmt = '(A)' , advance = 'NO' , size = nread , iostat = istat ) buffer if ( IS_IOSTAT_END ( istat ) . or . IS_IOSTAT_EOR ( istat )) then ! add the last block of text before the end of record if ( nread > 0 ) line = line // buffer ( 1 : nread ) exit else if ( istat == 0 ) then ! all the characters were read line = line // buffer ! add this block of text to the string else ! some kind of error if ( present ( status_ok )) then status_ok = . false . exit else error stop 'Read error' end if end if end do end function read_line","tags":"","loc":"proc/read_line.html"},{"title":"unique32 – AoC-2023","text":"private  function unique32(vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec Return Value integer, dimension(:), allocatable Calls proc~~unique32~~CallsGraph proc~unique32 aoc_utilities::unique32 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~unique32~~CalledByGraph proc~unique32 aoc_utilities::unique32 interface~unique aoc_utilities::unique interface~unique->proc~unique32 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function unique32 ( vec ) result ( vec_unique ) integer , dimension (:), intent ( in ) :: vec integer , dimension (:), allocatable :: vec_unique integer :: i , num logical , dimension ( size ( vec )) :: mask mask = . false . do i = 1 , size ( vec ) !count the number of occurrences of this element: num = count ( vec ( i ) == vec ) if ( num == 1 ) then !there is only one, flag it: mask ( i ) = . true . else !flag this value only if it hasn't already been flagged: if (. not . any ( vec ( i ) == vec . and . mask ) ) mask ( i ) = . true . end if end do !return only flagged elements: allocate ( vec_unique ( count ( mask )) ) vec_unique = pack ( vec , mask ) ! also sort it: call sort ( vec_unique ) end function unique32","tags":"","loc":"proc/unique32.html"},{"title":"unique64 – AoC-2023","text":"private  function unique64(vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: vec Return Value integer(kind=int64), dimension(:), allocatable Calls proc~~unique64~~CallsGraph proc~unique64 aoc_utilities::unique64 interface~sort aoc_utilities::sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~unique64~~CalledByGraph proc~unique64 aoc_utilities::unique64 interface~unique aoc_utilities::unique interface~unique->proc~unique64 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function unique64 ( vec ) result ( vec_unique ) integer ( int64 ), dimension (:), intent ( in ) :: vec integer ( int64 ), dimension (:), allocatable :: vec_unique integer ( int64 ) :: i , num logical , dimension ( size ( vec )) :: mask mask = . false . do i = 1 , size ( vec ) !count the number of occurrences of this element: num = count ( vec ( i ) == vec ) if ( num == 1 ) then !there is only one, flag it: mask ( i ) = . true . else !flag this value only if it hasn't already been flagged: if (. not . any ( vec ( i ) == vec . and . mask ) ) mask ( i ) = . true . end if end do !return only flagged elements: allocate ( vec_unique ( count ( mask )) ) vec_unique = pack ( vec , mask ) ! also sort it: call sort ( vec_unique ) end function unique64","tags":"","loc":"proc/unique64.html"},{"title":"parse_ints – AoC-2023","text":"public  function parse_ints(line) result(ints) parse positive ints from a string that also includes text Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer, dimension(:), allocatable Called by proc~~parse_ints~~CalledByGraph proc~parse_ints aoc_utilities::parse_ints proc~go~7 problem_12::go proc~go~7->proc~parse_ints program~problem_12b problem_12b program~problem_12b->proc~parse_ints program~problem_4 problem_4 program~problem_4->proc~parse_ints program~problem_12 problem_12 program~problem_12->proc~go~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function parse_ints ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer , dimension (:), allocatable :: ints ! array of integers integer :: i , j , n integer :: istart character ( len =* ), parameter :: tokens = '0123456789' n = len ( line ) istart = 0 allocate ( ints ( 0 )) do i = 1 , n if ( index ( tokens , line ( i : i )) > 0 ) then if ( istart == 0 ) istart = i else if ( istart /= 0 ) ints = [ ints , int ( line ( istart : i - 1 ))] ! get previous int istart = 0 end if end do if ( istart /= 0 ) ints = [ ints , int ( line ( istart : n ))] ! get last int end function parse_ints","tags":"","loc":"proc/parse_ints.html"},{"title":"parse_ints64 – AoC-2023","text":"public  function parse_ints64(line) result(ints) Parse positive ints from a string that also includes text Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=int64), dimension(:), allocatable Called by proc~~parse_ints64~~CalledByGraph proc~parse_ints64 aoc_utilities::parse_ints64 program~problem_5 problem_5 program~problem_5->proc~parse_ints64 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function parse_ints64 ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer ( int64 ), dimension (:), allocatable :: ints ! array of integers integer ( int64 ) :: i , j , n integer ( int64 ) :: istart character ( len =* ), parameter :: tokens = '0123456789' n = len ( line ) istart = 0 allocate ( ints ( 0 )) do i = 1 , n if ( index ( tokens , line ( i : i )) > 0 ) then if ( istart == 0 ) istart = i else if ( istart /= 0 ) ints = [ ints , int ( line ( istart : i - 1 ), kind = int64 )] ! get previous int istart = 0 end if end do if ( istart /= 0 ) ints = [ ints , int ( line ( istart : n ), kind = int64 )] ! get last int end function parse_ints64","tags":"","loc":"proc/parse_ints64.html"},{"title":"parse_nums64 – AoC-2023","text":"private  function parse_nums64(line) result(ints) parse space-deliminated int64 sequence (positive or negative) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=int64), dimension(:), allocatable Calls proc~~parse_nums64~~CallsGraph proc~parse_nums64 aoc_utilities::parse_nums64 interface~split aoc_utilities::split proc~parse_nums64->interface~split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~parse_nums64~~CalledByGraph proc~parse_nums64 aoc_utilities::parse_nums64 interface~parse aoc_utilities::parse interface~parse->proc~parse_nums64 program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function parse_nums64 ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer ( int64 ), dimension (:), allocatable :: ints ! array of integers ints = int ( split ( line , ' ' )) end function parse_nums64","tags":"","loc":"proc/parse_nums64.html"},{"title":"startswith_cc – AoC-2023","text":"private pure function startswith_cc(str, substring) starts with function for strings Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical Called by proc~~startswith_cc~~CalledByGraph proc~startswith_cc aoc_utilities::startswith_cc interface~startswith aoc_utilities::startswith interface~startswith->proc~startswith_cc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith program~problem_5 problem_5 program~problem_5->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function startswith_cc ( str , substring ) character ( len =* ), intent ( in ) :: str , substring startswith_cc = index ( str , substring ) == 1 end function startswith_cc","tags":"","loc":"proc/startswith_cc.html"},{"title":"startswith_ss – AoC-2023","text":"private pure function startswith_ss(str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str type( string ), intent(in) :: substring Return Value logical Calls proc~~startswith_ss~~CallsGraph proc~startswith_ss aoc_utilities::startswith_ss interface~startswith aoc_utilities::startswith proc~startswith_ss->interface~startswith interface~startswith->proc~startswith_ss proc~startswith_cc aoc_utilities::startswith_cc interface~startswith->proc~startswith_cc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~startswith_ss~~CalledByGraph proc~startswith_ss aoc_utilities::startswith_ss interface~startswith aoc_utilities::startswith proc~startswith_ss->interface~startswith interface~startswith->proc~startswith_ss proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith program~problem_5 problem_5 program~problem_5->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function startswith_ss ( str , substring ) type ( string ), intent ( in ) :: str , substring startswith_ss = startswith ( str % str , substring % str ) end function startswith_ss","tags":"","loc":"proc/startswith_ss.html"},{"title":"startswith_sc – AoC-2023","text":"private pure function startswith_sc(str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical Calls proc~~startswith_sc~~CallsGraph proc~startswith_sc aoc_utilities::startswith_sc interface~startswith aoc_utilities::startswith proc~startswith_sc->interface~startswith interface~startswith->proc~startswith_sc proc~startswith_cc aoc_utilities::startswith_cc interface~startswith->proc~startswith_cc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_cs->interface~startswith proc~startswith_ss->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~startswith_sc~~CalledByGraph proc~startswith_sc aoc_utilities::startswith_sc interface~startswith aoc_utilities::startswith proc~startswith_sc->interface~startswith interface~startswith->proc~startswith_sc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_cs->interface~startswith proc~startswith_ss->interface~startswith program~problem_5 problem_5 program~problem_5->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function startswith_sc ( str , substring ) type ( string ), intent ( in ) :: str character ( len =* ), intent ( in ) :: substring startswith_sc = startswith ( str % str , substring ) end function startswith_sc","tags":"","loc":"proc/startswith_sc.html"},{"title":"startswith_cs – AoC-2023","text":"private pure function startswith_cs(str, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str type( string ), intent(in) :: substring Return Value logical Calls proc~~startswith_cs~~CallsGraph proc~startswith_cs aoc_utilities::startswith_cs interface~startswith aoc_utilities::startswith proc~startswith_cs->interface~startswith interface~startswith->proc~startswith_cs proc~startswith_cc aoc_utilities::startswith_cc interface~startswith->proc~startswith_cc proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~startswith_cs~~CalledByGraph proc~startswith_cs aoc_utilities::startswith_cs interface~startswith aoc_utilities::startswith proc~startswith_cs->interface~startswith interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith program~problem_5 problem_5 program~problem_5->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function startswith_cs ( str , substring ) character ( len =* ), intent ( in ) :: str type ( string ), intent ( in ) :: substring startswith_cs = startswith ( str , substring % str ) end function startswith_cs","tags":"","loc":"proc/startswith_cs.html"},{"title":"is_number – AoC-2023","text":"public  function is_number(c) returns true if the character is a number from 0 to 9. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical Called by proc~~is_number~~CalledByGraph proc~is_number aoc_utilities::is_number proc~check problem_3::check proc~check->proc~is_number proc~get_number problem_3::get_number proc~check->proc~get_number proc~is_not_number aoc_utilities::is_not_number proc~is_not_number->proc~is_number proc~is_symbol problem_3::is_symbol proc~is_symbol->proc~is_not_number program~problem_3 problem_3 program~problem_3->proc~check program~problem_3->proc~is_not_number program~problem_3->proc~is_symbol program~problem_3->proc~get_number proc~get_number->proc~is_symbol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function is_number ( c ) character ( len = 1 ), intent ( in ) :: c is_number = c >= '0' . and . c <= '9' end function is_number","tags":"","loc":"proc/is_number.html"},{"title":"is_not_number – AoC-2023","text":"public  function is_not_number(c) returns true if the character is not a number. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical Calls proc~~is_not_number~~CallsGraph proc~is_not_number aoc_utilities::is_not_number proc~is_number aoc_utilities::is_number proc~is_not_number->proc~is_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~is_not_number~~CalledByGraph proc~is_not_number aoc_utilities::is_not_number proc~is_symbol problem_3::is_symbol proc~is_symbol->proc~is_not_number program~problem_3 problem_3 program~problem_3->proc~is_not_number program~problem_3->proc~is_symbol proc~get_number problem_3::get_number program~problem_3->proc~get_number proc~check problem_3::check program~problem_3->proc~check proc~get_number->proc~is_symbol proc~check->proc~get_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function is_not_number ( c ) character ( len = 1 ), intent ( in ) :: c is_not_number = . not . is_number ( c ) end function is_not_number","tags":"","loc":"proc/is_not_number.html"},{"title":"str_to_array – AoC-2023","text":"public  function str_to_array(s) result(a) convert the character string to an array of characters Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value character(len=1), dimension(len(s)) Called by proc~~str_to_array~~CalledByGraph proc~str_to_array aoc_utilities::str_to_array program~problem_7 problem_7 program~problem_7->proc~str_to_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function str_to_array ( s ) result ( a ) character ( len =* ), intent ( in ) :: s character ( len = 1 ), dimension ( len ( s )) :: a integer :: i do i = 1 , len ( s ) ! transfer a ( i ) = s ( i : i ) end do end function str_to_array","tags":"","loc":"proc/str_to_array.html"},{"title":"lcm – AoC-2023","text":"public pure function lcm(i, j) LCM. based on code from NCAR Command Language Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: i integer(kind=int64), intent(in) :: j Return Value integer(kind=int64) Called by proc~~lcm~~CalledByGraph proc~lcm aoc_utilities::lcm program~problem_8 problem_8 program~problem_8->proc~lcm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer ( int64 ) function lcm ( i , j ) integer ( int64 ), intent ( in ) :: i , j integer ( int64 ) :: rem , m , n m = abs ( i ) n = abs ( j ) lcm = 0 if ( m <= 0 . or . n <= 0 ) return do rem = mod ( m , n ) if ( rem <= 0 ) exit m = n n = rem end do lcm = abs ( i * j / n ) end function lcm","tags":"","loc":"proc/lcm.html"},{"title":"reverse – AoC-2023","text":"public pure function reverse(ivals) result(ireverse) Reverse an int64 vector Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: ivals Return Value integer(kind=int64), dimension(size(ivals)) Called by proc~~reverse~~CalledByGraph proc~reverse aoc_utilities::reverse program~problem_9 problem_9 program~problem_9->proc~reverse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function reverse ( ivals ) result ( ireverse ) integer ( int64 ), dimension (:), intent ( in ) :: ivals integer ( int64 ), dimension ( size ( ivals )) :: ireverse integer :: i ireverse = [( ivals ( i ), i = size ( ivals ), 1 , - 1 )] end function reverse","tags":"","loc":"proc/reverse.html"},{"title":"diff – AoC-2023","text":"public pure function diff(ivals) result(idiff) Difference int64 vector Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: ivals Return Value integer(kind=int64), dimension(:), allocatable Called by proc~~diff~~CalledByGraph proc~diff aoc_utilities::diff proc~extrapolate problem_9::extrapolate proc~extrapolate->proc~diff program~problem_9 problem_9 program~problem_9->proc~extrapolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function diff ( ivals ) result ( idiff ) integer ( int64 ), dimension (:), intent ( in ) :: ivals integer ( int64 ), dimension (:), allocatable :: idiff integer :: i !! counter idiff = [( ivals ( i + 1 ) - ivals ( i ), i = 1 , size ( ivals ) - 1 )] end function diff","tags":"","loc":"proc/diff.html"},{"title":"parea – AoC-2023","text":"public  function parea(x, y, nb) given a sequence of nb points (x(i),y(i)). parea computes\nthe area bounded by the closed polygonal curve which passes\nthrough the points in the order that they are indexed. the\nfinal point of the curve is assumed to be the first point\ngiven. therefore, it need not be listed at the end of x and\ny. the curve is not required to be simple. Original version from the NSWC Library Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (nb) real(kind=wp), intent(in) :: y (nb) integer, intent(in) :: nb Return Value real(kind=wp) Called by proc~~parea~~CalledByGraph proc~parea aoc_utilities::parea proc~go problem_18::go proc~go->proc~parea program~problem_18 problem_18 program~problem_18->proc~go Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code real ( wp ) function parea ( x , y , nb ) real ( wp ), intent ( in ) :: x ( nb ), y ( nb ) integer , intent ( in ) :: nb real ( wp ) :: a integer :: n , nm1 , i n = nb if ( x ( 1 ) == x ( n ) . and . y ( 1 ) == y ( n )) n = n - 1 if ( n - 3 < 0 ) then parea = 0.0_wp else if ( n - 3 == 0 ) then parea = 0.5_wp * (( x ( 2 ) - x ( 1 )) * ( y ( 3 ) - y ( 1 )) - ( x ( 3 ) - x ( 1 )) * ( y ( 2 ) - y ( 1 ))) else nm1 = n - 1 a = x ( 1 ) * ( y ( 2 ) - y ( n )) + x ( n ) * ( y ( 1 ) - y ( nm1 )) do i = 2 , nm1 a = a + x ( i ) * ( y ( i + 1 ) - y ( i - 1 )) end do parea = 0.5_wp * a end if end function parea","tags":"","loc":"proc/parea.html"},{"title":"manhatten_distance_64 – AoC-2023","text":"private pure function manhatten_distance_64(x1, y1, x2, y2) Manhattan distance between two int64 points. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x1 integer(kind=int64), intent(in) :: y1 integer(kind=int64), intent(in) :: x2 integer(kind=int64), intent(in) :: y2 Return Value integer(kind=int64) Called by proc~~manhatten_distance_64~~CalledByGraph proc~manhatten_distance_64 aoc_utilities::manhatten_distance_64 interface~manhatten_distance aoc_utilities::manhatten_distance interface~manhatten_distance->proc~manhatten_distance_64 proc~go~6 problem_11::go proc~go~6->interface~manhatten_distance program~problem_11 problem_11 program~problem_11->proc~go~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer ( int64 ) function manhatten_distance_64 ( x1 , y1 , x2 , y2 ) integer ( int64 ), intent ( in ) :: x1 , y1 , x2 , y2 manhatten_distance_64 = abs ( x1 - x2 ) + abs ( y1 - y2 ) end function manhatten_distance_64","tags":"","loc":"proc/manhatten_distance_64.html"},{"title":"str_to_int_array_with_mapping – AoC-2023","text":"public pure function str_to_int_array_with_mapping(str, ichars, iints) result(array) Convert a string to a numeric array by mapping characters to integers (user-specified) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=1), intent(in), dimension(:) :: ichars characters to process integer, intent(in), dimension(:) :: iints int values of the chars Return Value integer, dimension(:), allocatable Called by proc~~str_to_int_array_with_mapping~~CalledByGraph proc~str_to_int_array_with_mapping aoc_utilities::str_to_int_array_with_mapping proc~go~7 problem_12::go proc~go~7->proc~str_to_int_array_with_mapping program~problem_13 problem_13 program~problem_13->proc~str_to_int_array_with_mapping program~problem_12 problem_12 program~problem_12->proc~go~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function str_to_int_array_with_mapping ( str , ichars , iints ) result ( array ) character ( len =* ), intent ( in ) :: str character ( len = 1 ), dimension (:), intent ( in ) :: ichars !! characters to process integer , dimension (:), intent ( in ) :: iints !! int values of the chars integer , dimension (:), allocatable :: array integer :: i integer , dimension ( 1 ) :: iloc allocate ( array ( len ( str ))) do i = 1 , len ( str ) iloc = findloc ( ichars , str ( i : i )) if ( iloc ( 1 ) > 0 ) then array ( i ) = iints ( iloc ( 1 )) else error stop 'error: could not map character: ' // str ( i : i ) end if end do end function str_to_int_array_with_mapping","tags":"","loc":"proc/str_to_int_array_with_mapping.html"},{"title":"str_to_int64_array_with_mapping – AoC-2023","text":"public pure function str_to_int64_array_with_mapping(str, ichars, iints) result(array) Convert a string to a numeric array by mapping characters to integers (user-specified) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=1), intent(in), dimension(:) :: ichars characters to process integer(kind=int64), intent(in), dimension(:) :: iints int values of the chars Return Value integer(kind=int64), dimension(:), allocatable Called by proc~~str_to_int64_array_with_mapping~~CalledByGraph proc~str_to_int64_array_with_mapping aoc_utilities::str_to_int64_array_with_mapping program~problem_12b problem_12b program~problem_12b->proc~str_to_int64_array_with_mapping Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function str_to_int64_array_with_mapping ( str , ichars , iints ) result ( array ) character ( len =* ), intent ( in ) :: str character ( len = 1 ), dimension (:), intent ( in ) :: ichars !! characters to process integer ( int64 ), dimension (:), intent ( in ) :: iints !! int values of the chars integer ( int64 ), dimension (:), allocatable :: array integer :: i integer , dimension ( 1 ) :: iloc allocate ( array ( len ( str ))) do i = 1 , len ( str ) iloc = findloc ( ichars , str ( i : i )) if ( iloc ( 1 ) > 0 ) then array ( i ) = iints ( iloc ( 1 )) else error stop 'error: could not map character: ' // str ( i : i ) end if end do end function str_to_int64_array_with_mapping","tags":"","loc":"proc/str_to_int64_array_with_mapping.html"},{"title":"hex2int – AoC-2023","text":"public pure function hex2int(hex) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: hex Return Value integer Called by proc~~hex2int~~CalledByGraph proc~hex2int aoc_utilities::hex2int proc~go problem_18::go proc~go->proc~hex2int program~problem_18 problem_18 program~problem_18->proc~go Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer function hex2int ( hex ) character ( len =* ), intent ( in ) :: hex integer :: i , n , ipower ! 70c71 -> 461937 n = len ( hex ) hex2int = 0 !base 16 (0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f) ipower = - 1 do i = n , 1 , - 1 ipower = ipower + 1 associate ( c => hex ( i : i )) if ( c >= 'a' . and . c <= 'f' ) then hex2int = hex2int + ( 10 + iachar ( c ) - iachar ( 'a' )) * ( 16 ** ipower ) else hex2int = hex2int + ( iachar ( c ) - iachar ( '0' )) * ( 16 ** ipower ) end if end associate end do end function hex2int","tags":"","loc":"proc/hex2int.html"},{"title":"clock_start – AoC-2023","text":"private  subroutine clock_start(me) Start the clock Type Bound clock Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me Called by proc~~clock_start~~CalledByGraph proc~clock_start aoc_utilities::clock%clock_start program~problem_1 problem_1 program~problem_1->proc~clock_start program~problem_10 problem_10 program~problem_10->proc~clock_start program~problem_11 problem_11 program~problem_11->proc~clock_start program~problem_12 problem_12 program~problem_12->proc~clock_start program~problem_12b problem_12b program~problem_12b->proc~clock_start program~problem_13 problem_13 program~problem_13->proc~clock_start program~problem_15 problem_15 program~problem_15->proc~clock_start program~problem_16 problem_16 program~problem_16->proc~clock_start program~problem_17 problem_17 program~problem_17->proc~clock_start program~problem_17~2 problem_17 program~problem_17~2->proc~clock_start program~problem_18 problem_18 program~problem_18->proc~clock_start program~problem_19 problem_19 program~problem_19->proc~clock_start program~problem_19b problem_19b program~problem_19b->proc~clock_start program~problem_2 problem_2 program~problem_2->proc~clock_start program~problem_21 problem_21 program~problem_21->proc~clock_start program~problem_23 problem_23 program~problem_23->proc~clock_start program~problem_24 problem_24 program~problem_24->proc~clock_start program~problem_3 problem_3 program~problem_3->proc~clock_start program~problem_4 problem_4 program~problem_4->proc~clock_start program~problem_5 problem_5 program~problem_5->proc~clock_start program~problem_6 problem_6 program~problem_6->proc~clock_start program~problem_7 problem_7 program~problem_7->proc~clock_start program~problem_8 problem_8 program~problem_8->proc~clock_start program~problem_9 problem_9 program~problem_9->proc~clock_start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine clock_start ( me ) class ( clock ), intent ( inout ) :: me call system_clock ( me % begin , me % rate ) end subroutine clock_start","tags":"","loc":"proc/clock_start.html"},{"title":"clock_end – AoC-2023","text":"private  subroutine clock_end(me, case_str) Print runtime in milliseconds form the start of the clock. Type Bound clock Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me character(len=*), intent(in) :: case_str description of the case Called by proc~~clock_end~~CalledByGraph proc~clock_end aoc_utilities::clock%clock_end program~problem_1 problem_1 program~problem_1->proc~clock_end program~problem_10 problem_10 program~problem_10->proc~clock_end program~problem_11 problem_11 program~problem_11->proc~clock_end program~problem_12 problem_12 program~problem_12->proc~clock_end program~problem_12b problem_12b program~problem_12b->proc~clock_end program~problem_13 problem_13 program~problem_13->proc~clock_end program~problem_15 problem_15 program~problem_15->proc~clock_end program~problem_16 problem_16 program~problem_16->proc~clock_end program~problem_17 problem_17 program~problem_17->proc~clock_end program~problem_17~2 problem_17 program~problem_17~2->proc~clock_end program~problem_18 problem_18 program~problem_18->proc~clock_end program~problem_19 problem_19 program~problem_19->proc~clock_end program~problem_19b problem_19b program~problem_19b->proc~clock_end program~problem_2 problem_2 program~problem_2->proc~clock_end program~problem_21 problem_21 program~problem_21->proc~clock_end program~problem_23 problem_23 program~problem_23->proc~clock_end program~problem_24 problem_24 program~problem_24->proc~clock_end program~problem_3 problem_3 program~problem_3->proc~clock_end program~problem_4 problem_4 program~problem_4->proc~clock_end program~problem_5 problem_5 program~problem_5->proc~clock_end program~problem_6 problem_6 program~problem_6->proc~clock_end program~problem_7 problem_7 program~problem_7->proc~clock_end program~problem_8 problem_8 program~problem_8->proc~clock_end program~problem_9 problem_9 program~problem_9->proc~clock_end Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine clock_end ( me , case_str ) class ( clock ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: case_str !! description of the case integer :: itime !! time in integer milliseconds call system_clock ( me % end ) itime = int ( 1000 * ( me % end - me % begin ) / real ( me % rate , wp )) write ( * , '(a,I4,a)' ) trim ( case_str ) // ' runtime: ' , itime , ' ms' write ( * , '(a)' ) '---------------------------' write ( * , * ) '' end subroutine clock_end","tags":"","loc":"proc/clock_end.html"},{"title":"sort_ascending – AoC-2023","text":"private  subroutine sort_ascending(ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec Calls proc~~sort_ascending~~CallsGraph proc~sort_ascending aoc_utilities::sort_ascending interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap64 aoc_utilities::swap64 interface~swap->proc~swap64 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sort_ascending~~CalledByGraph proc~sort_ascending aoc_utilities::sort_ascending interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine sort_ascending ( ivec ) integer , dimension (:), intent ( inout ) :: ivec integer , parameter :: max_size_for_insertion_sort = 20 !! max size for using insertion sort. call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending","tags":"","loc":"proc/sort_ascending.html"},{"title":"sort_ascending_64 – AoC-2023","text":"private  subroutine sort_ascending_64(ivec) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:) :: ivec Calls proc~~sort_ascending_64~~CallsGraph proc~sort_ascending_64 aoc_utilities::sort_ascending_64 proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sort_ascending_64~~CalledByGraph proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending_64 proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine sort_ascending_64 ( ivec ) integer ( int64 ), dimension (:), intent ( inout ) :: ivec integer ( int64 ), parameter :: max_size_for_insertion_sort = 20 !! max size for using insertion sort. call quicksort ( 1_int64 , size ( ivec , kind = int64 )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array integer ( int64 ), intent ( in ) :: ilow integer ( int64 ), intent ( in ) :: ihigh integer ( int64 ) :: ipivot !! pivot element integer ( int64 ) :: i !! counter integer ( int64 ) :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap64 ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer ( int64 ), intent ( in ) :: ilow integer ( int64 ), intent ( in ) :: ihigh integer ( int64 ), intent ( out ) :: ipivot integer ( int64 ) :: i , ip call swap64 ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap64 ( ivec ( ip ), ivec ( i )) end if end do call swap64 ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending_64","tags":"","loc":"proc/sort_ascending_64.html"},{"title":"swap32 – AoC-2023","text":"private pure elemental subroutine swap32(i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 Called by proc~~swap32~~CalledByGraph proc~swap32 aoc_utilities::swap32 interface~swap aoc_utilities::swap interface~swap->proc~swap32 proc~sort_ascending aoc_utilities::sort_ascending proc~sort_ascending->interface~swap interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap32 ( i1 , i2 ) integer , intent ( inout ) :: i1 integer , intent ( inout ) :: i2 integer :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap32","tags":"","loc":"proc/swap32.html"},{"title":"swap64 – AoC-2023","text":"private pure elemental subroutine swap64(i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: i1 integer(kind=int64), intent(inout) :: i2 Called by proc~~swap64~~CalledByGraph proc~swap64 aoc_utilities::swap64 interface~swap aoc_utilities::swap interface~swap->proc~swap64 proc~sort_ascending_64 aoc_utilities::sort_ascending_64 proc~sort_ascending_64->proc~swap64 interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending_64 proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending->interface~swap proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap64 ( i1 , i2 ) integer ( int64 ), intent ( inout ) :: i1 integer ( int64 ), intent ( inout ) :: i2 integer ( int64 ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap64","tags":"","loc":"proc/swap64.html"},{"title":"swap_str – AoC-2023","text":"private pure elemental subroutine swap_str(i1, i2) Swap two character string values Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: i1 character(len=*), intent(inout) :: i2 Called by proc~~swap_str~~CalledByGraph proc~swap_str aoc_utilities::swap_str interface~swap aoc_utilities::swap interface~swap->proc~swap_str proc~sort_ascending aoc_utilities::sort_ascending proc~sort_ascending->interface~swap interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap_str ( i1 , i2 ) character ( len =* ), intent ( inout ) :: i1 character ( len =* ), intent ( inout ) :: i2 character ( len = len ( i1 )) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_str","tags":"","loc":"proc/swap_str.html"},{"title":"expand_vector – AoC-2023","text":"private pure subroutine expand_vector(vec, n, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) Called by proc~~expand_vector~~CalledByGraph proc~expand_vector aoc_utilities::expand_vector proc~split1 aoc_utilities::split1 proc~split1->proc~expand_vector interface~split aoc_utilities::split interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~split2->proc~split1 proc~go problem_18::go proc~go->interface~split proc~go~7 problem_12::go proc~go~7->interface~split proc~parse_nums64 aoc_utilities::parse_nums64 proc~parse_nums64->interface~split proc~parse_rule problem_19b::parse_rule proc~parse_rule->interface~split proc~parse_rule~2 problem_19::parse_rule proc~parse_rule~2->interface~split program~problem_12b problem_12b program~problem_12b->interface~split program~problem_15 problem_15 program~problem_15->interface~split program~problem_19 problem_19 program~problem_19->interface~split program~problem_19->proc~parse_rule~2 program~problem_19b problem_19b program~problem_19b->interface~split program~problem_19b->proc~parse_rule program~problem_2 problem_2 program~problem_2->interface~split program~problem_24 problem_24 program~problem_24->interface~split program~problem_4 problem_4 program~problem_4->interface~split program~problem_7 problem_7 program~problem_7->interface~split interface~parse aoc_utilities::parse interface~parse->proc~parse_nums64 program~problem_12 problem_12 program~problem_12->proc~go~7 program~problem_18 problem_18 program~problem_18->proc~go program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine expand_vector ( vec , n , val , finished ) integer , dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) integer , dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector","tags":"","loc":"proc/expand_vector.html"},{"title":"locpt – AoC-2023","text":"public pure subroutine locpt(x0, y0, x, y, n, l, m) given a polygonal line connecting the vertices (x(i),y(i))\n  (i = 1,...,n) taken in this order. it is assumed that the\n  polygonal path is a loop, where (x(n),y(n)) = (x(1),y(1))\n  or there is an arc from (x(n),y(n)) to (x(1),y(1)). (x0,y0) is an arbitrary point and l and m are variables.\n  l and m are assigned the following values: l = - 1 if ( x0 , y0 ) is outside the polygonal path l = 0 if ( x0 , y0 ) lies on the polygonal path l = 1 if ( x0 , y0 ) is inside the polygonal path m = 0 if (x0,y0) is on or outside the path. if (x0,y0)\n  is inside the path then m is the winding number of the\n  path around the point (x0,y0). History Original version from the NSWC Library Modified by J. Williams : 08/04/2012 : refactored to modern Fortran Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: y0 real(kind=wp), intent(in), dimension(n) :: x real(kind=wp), intent(in), dimension(n) :: y integer, intent(in) :: n integer, intent(out) :: l integer, intent(out) :: m Called by proc~~locpt~~CalledByGraph proc~locpt aoc_utilities::locpt program~problem_10 problem_10 program~problem_10->proc~locpt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine locpt ( x0 , y0 , x , y , n , l , m ) implicit none !arguments: integer , intent ( in ) :: n real ( wp ), intent ( in ) :: x0 real ( wp ), intent ( in ) :: y0 real ( wp ), dimension ( n ), intent ( in ) :: x real ( wp ), dimension ( n ), intent ( in ) :: y integer , intent ( out ) :: l integer , intent ( out ) :: m !constants: real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) real ( wp ), parameter :: pi = atan2 ( 0.0_wp , - 1.0_wp ) real ( wp ), parameter :: pi2 = 2.0_wp * pi real ( wp ), parameter :: tol = 4.0_wp * eps * pi !local variables: integer :: i , n0 real ( wp ) :: u , v , theta1 , sum , theta , angle , thetai n0 = n if ( x ( 1 ) == x ( n ) . and . y ( 1 ) == y ( n )) n0 = n - 1 l = - 1 m = 0 u = x ( 1 ) - x0 v = y ( 1 ) - y0 if ( u == 0.0_wp . and . v == 0.0_wp ) then l = 0 !(x0, y0) is on the boundary of the path else if ( n0 >= 2 ) then theta1 = atan2 ( v , u ) sum = 0.0_wp theta = theta1 do i = 2 , n0 u = x ( i ) - x0 v = y ( i ) - y0 if ( u == 0.0_wp . and . v == 0.0_wp ) then l = 0 !(x0, y0) is on the boundary of the path exit end if thetai = atan2 ( v , u ) angle = abs ( thetai - theta ) if ( abs ( angle - pi ) < tol ) then l = 0 !(x0, y0) is on the boundary of the path exit end if if ( angle > pi ) angle = angle - pi2 if ( theta > thetai ) angle = - angle sum = sum + angle theta = thetai end do if ( l /= 0 ) then angle = abs ( theta1 - theta ) if ( abs ( angle - pi ) < tol ) then l = 0 !(x0, y0) is on the boundary of the path else if ( angle > pi ) angle = angle - pi2 if ( theta > theta1 ) angle = - angle sum = sum + angle !sum = 2*pi*m where m is the winding number m = abs ( sum ) / pi2 + 0.2_wp if ( m /= 0 ) then l = 1 if ( sum < 0.0_wp ) m = - m end if end if end if end if end if end subroutine locpt","tags":"","loc":"proc/locpt.html"},{"title":"inverse – AoC-2023","text":"public  subroutine inverse(a, ainv, status_ok) inverse of a 2x2 matrix. See: https://caps.gsfc.nasa.gov/simpson/software/m22inv_f90.txt Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: a real(kind=wp), intent(out), dimension(2,2) :: ainv logical, intent(out) :: status_ok Source Code subroutine inverse ( a , ainv , status_ok ) real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: a real ( wp ), dimension ( 2 , 2 ), intent ( out ) :: ainv logical , intent ( out ) :: status_ok real ( wp ), parameter :: eps = 1.0e-10_wp real ( wp ), dimension ( 2 , 2 ) :: cofactor associate ( det => a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 2 , 1 ) ) if ( abs ( det ) <= eps ) then ainv = 0.0_wp status_ok = . false . else cofactor ( 1 , 1 ) = + a ( 2 , 2 ) cofactor ( 1 , 2 ) = - a ( 2 , 1 ) cofactor ( 2 , 1 ) = - a ( 1 , 2 ) cofactor ( 2 , 2 ) = + a ( 1 , 1 ) ainv = transpose ( cofactor ) / det status_ok = . true . end if end associate end subroutine inverse","tags":"","loc":"proc/inverse.html"},{"title":"sort – AoC-2023","text":"public interface sort Calls interface~~sort~~CallsGraph interface~sort aoc_utilities::sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~sort~~CalledByGraph interface~sort aoc_utilities::sort proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine sort_ascending (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_64 (ivec) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:) :: ivec","tags":"","loc":"interface/sort.html"},{"title":"parse – AoC-2023","text":"public interface parse Calls interface~~parse~~CallsGraph interface~parse aoc_utilities::parse proc~parse_nums64 aoc_utilities::parse_nums64 interface~parse->proc~parse_nums64 interface~split aoc_utilities::split proc~parse_nums64->interface~split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~parse~~CalledByGraph interface~parse aoc_utilities::parse program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function parse_nums64 (line) result(ints) parse space-deliminated int64 sequence (positive or negative) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=int64), dimension(:), allocatable","tags":"","loc":"interface/parse.html"},{"title":"split – AoC-2023","text":"public interface split Calls interface~~split~~CallsGraph interface~split aoc_utilities::split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~split~~CalledByGraph interface~split aoc_utilities::split proc~go problem_18::go proc~go->interface~split proc~go~7 problem_12::go proc~go~7->interface~split proc~parse_nums64 aoc_utilities::parse_nums64 proc~parse_nums64->interface~split proc~parse_rule problem_19b::parse_rule proc~parse_rule->interface~split proc~parse_rule~2 problem_19::parse_rule proc~parse_rule~2->interface~split program~problem_12b problem_12b program~problem_12b->interface~split program~problem_15 problem_15 program~problem_15->interface~split program~problem_19 problem_19 program~problem_19->interface~split program~problem_19->proc~parse_rule~2 program~problem_19b problem_19b program~problem_19b->interface~split program~problem_19b->proc~parse_rule program~problem_2 problem_2 program~problem_2->interface~split program~problem_24 problem_24 program~problem_24->interface~split program~problem_4 problem_4 program~problem_4->interface~split program~problem_7 problem_7 program~problem_7->interface~split interface~parse aoc_utilities::parse interface~parse->proc~parse_nums64 program~problem_12 problem_12 program~problem_12->proc~go~7 program~problem_18 problem_18 program~problem_18->proc~go program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function split1 (str, token) result(vals) Split a character string using a token.\n  This routine is inspired by the Python split function. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable private pure function split2 (s, token) result(vals) Split a string , given a token. Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: s character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable","tags":"","loc":"interface/split.html"},{"title":"int – AoC-2023","text":"public interface int Calls interface~~int~~CallsGraph interface~int aoc_utilities::int proc~char_array_to_int aoc_utilities::char_array_to_int interface~int->proc~char_array_to_int proc~char_to_int aoc_utilities::char_to_int interface~int->proc~char_to_int proc~char_to_int64 aoc_utilities::char_to_int64 interface~int->proc~char_to_int64 proc~string_to_int aoc_utilities::string%string_to_int interface~int->proc~string_to_int proc~char_array_to_int->proc~char_to_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure elemental function string_to_int (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer private pure function char_to_int (str) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer private pure function char_to_int64 (str, kind) result(i) Basic string to integer(ip) routine.\nHacky hack just so we can overload as int() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: kind Return Value integer(kind=int64) private pure function char_array_to_int (str_array) result(i) Character array to integer routine Arguments Type Intent Optional Attributes Name character(len=1), intent(in), dimension(:) :: str_array example ['1','3'] --> 13 Return Value integer","tags":"","loc":"interface/int.html"},{"title":"unique – AoC-2023","text":"public interface unique Calls interface~~unique~~CallsGraph interface~unique aoc_utilities::unique proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~unique~~CalledByGraph interface~unique aoc_utilities::unique proc~hand_type problem_7::hand_type proc~hand_type->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function unique32 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec Return Value integer, dimension(:), allocatable private  function unique64 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: vec Return Value integer(kind=int64), dimension(:), allocatable","tags":"","loc":"interface/unique.html"},{"title":"startswith – AoC-2023","text":"public interface startswith test if a string starts with a specified substring Calls interface~~startswith~~CallsGraph interface~startswith aoc_utilities::startswith proc~startswith_cc aoc_utilities::startswith_cc interface~startswith->proc~startswith_cc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~startswith~~CalledByGraph interface~startswith aoc_utilities::startswith proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith program~problem_5 problem_5 program~problem_5->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function startswith_cc (str, substring) starts with function for strings Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_ss (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str type( string ), intent(in) :: substring Return Value logical private pure function startswith_sc (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_cs (str, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str type( string ), intent(in) :: substring Return Value logical","tags":"","loc":"interface/startswith.html"},{"title":"swap – AoC-2023","text":"public interface swap Calls interface~~swap~~CallsGraph interface~swap aoc_utilities::swap proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap64 aoc_utilities::swap64 interface~swap->proc~swap64 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~swap~~CalledByGraph interface~swap aoc_utilities::swap proc~sort_ascending aoc_utilities::sort_ascending proc~sort_ascending->interface~swap interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure elemental subroutine swap32 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap64 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: i1 integer(kind=int64), intent(inout) :: i2 private pure elemental subroutine swap_str (i1, i2) Swap two character string values Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: i1 character(len=*), intent(inout) :: i2","tags":"","loc":"interface/swap.html"},{"title":"manhatten_distance – AoC-2023","text":"public interface manhatten_distance Calls interface~~manhatten_distance~~CallsGraph interface~manhatten_distance aoc_utilities::manhatten_distance proc~manhatten_distance_64 aoc_utilities::manhatten_distance_64 interface~manhatten_distance->proc~manhatten_distance_64 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~manhatten_distance~~CalledByGraph interface~manhatten_distance aoc_utilities::manhatten_distance proc~go~6 problem_11::go proc~go~6->interface~manhatten_distance program~problem_11 problem_11 program~problem_11->proc~go~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function manhatten_distance_64 (x1, y1, x2, y2) Manhattan distance between two int64 points. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x1 integer(kind=int64), intent(in) :: y1 integer(kind=int64), intent(in) :: x2 integer(kind=int64), intent(in) :: y2 Return Value integer(kind=int64)","tags":"","loc":"interface/manhatten_distance.html"},{"title":"step – AoC-2023","text":"recursive subroutine step(array) take all valid steps from any # elements in array Arguments Type Intent Optional Attributes Name character(len=1), intent(inout), dimension(:,:), allocatable :: array Called by proc~~step~~CalledByGraph proc~step problem_21::step program~problem_21 problem_21 program~problem_21->proc~step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine step ( array ) !! take all valid steps from any # elements in array character ( len = 1 ), dimension (:,:), intent ( inout ), allocatable :: array integer :: i , j logical :: steped character ( len = 1 ), dimension (:,:), allocatable :: tmp tmp = array do i = 1 , nrows do j = 1 , ncols if ( array ( i , j ) == 'O' ) then steped = . false . ! try a step in each direction: if ( array ( i - 1 , j ) == '.' ) then tmp ( i - 1 , j ) = 'O' ; steped = . true . end if if ( array ( i + 1 , j ) == '.' ) then tmp ( i + 1 , j ) = 'O' ; steped = . true . end if if ( array ( i , j - 1 ) == '.' ) then tmp ( i , j - 1 ) = 'O' ; steped = . true . end if if ( array ( i , j + 1 ) == '.' ) then tmp ( i , j + 1 ) = 'O' ; steped = . true . end if if ( steped ) tmp ( i , j ) = '.' end if end do end do call move_alloc ( tmp , array ) end subroutine step","tags":"","loc":"proc/step.html"},{"title":"add_lens – AoC-2023","text":"public  subroutine add_lens(me, l) Type Bound box Arguments Type Intent Optional Attributes Name class( box ), intent(inout) :: me type( lens ), intent(in) :: l lense to add Called by proc~~add_lens~~CalledByGraph proc~add_lens problem_15_module::box%add_lens program~problem_15 problem_15 program~problem_15->proc~add_lens Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine add_lens ( me , l ) ! = class ( box ), intent ( inout ) :: me type ( lens ), intent ( in ) :: l !! lense to add integer :: i !! counter if ( allocated ( me % lenses )) then do i = 1 , size ( me % lenses ) if ( me % lenses ( i )% label == l % label ) then me % lenses ( i ) = l ! replace with this one return end if end do me % lenses = [ me % lenses , l ] ! if not found, add to end else me % lenses = [ l ] ! first one in the box end if end subroutine add_lens","tags":"","loc":"proc/add_lens.html"},{"title":"remove_lens – AoC-2023","text":"public  subroutine remove_lens(me, label) remove the lens with the label (if present) Type Bound box Arguments Type Intent Optional Attributes Name class( box ), intent(inout) :: me character(len=*), intent(in) :: label Called by proc~~remove_lens~~CalledByGraph proc~remove_lens problem_15_module::box%remove_lens program~problem_15 problem_15 program~problem_15->proc~remove_lens Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine remove_lens ( me , label ) ! - !! remove the lens with the label (if present) class ( box ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: label integer :: i type ( lens ), dimension (:), allocatable :: tmp if ( allocated ( me % lenses )) then allocate ( tmp ( 0 )) do i = 1 , size ( me % lenses ) if ( me % lenses ( i )% label /= label ) tmp = [ tmp , me % lenses ( i )] end do call move_alloc ( tmp , me % lenses ) end if end subroutine remove_lens","tags":"","loc":"proc/remove_lens.html"},{"title":"hash – AoC-2023","text":"pure elemental function hash(s) Determine the ASCII code for the current character of the string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value integer(kind=ip) Called by proc~~hash~~CalledByGraph proc~hash problem_15::hash program~problem_15 problem_15 program~problem_15->proc~hash Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental integer ( ip ) function hash ( s ) !! Determine the ASCII code for the current character of the string. character ( len =* ), intent ( in ) :: s integer :: i hash = 0 do i = 1 , len ( s ) hash = modulo ( 17_ip * ( hash + iachar ( s ( i : i ))), 256_ip ) end do end function hash","tags":"","loc":"proc/hash.html"},{"title":"process – AoC-2023","text":"recursive function process(iworkflow, irule, p) result(iaccepted) process this part range starting with irule Arguments Type Intent Optional Attributes Name integer, intent(in) :: iworkflow integer, intent(in) :: irule type( part ), intent(in) :: p Return Value integer(kind=ip) Calls proc~~process~~CallsGraph proc~process problem_19b::process proc~process->proc~process proc~get_accepted problem_19b::get_accepted proc~process->proc~get_accepted proc~workflow_name_to_index problem_19b::workflow_name_to_index proc~process->proc~workflow_name_to_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~process~~CalledByGraph proc~process problem_19b::process proc~process->proc~process program~problem_19b problem_19b program~problem_19b->proc~process Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive function process ( iworkflow , irule , p ) result ( iaccepted ) !! process this part range starting with irule integer , intent ( in ) :: iworkflow integer , intent ( in ) :: irule type ( part ), intent ( in ) :: p integer ( ip ) :: iaccepted integer ( ip ), dimension (:), allocatable :: itmp , itmp_t , itmp_f integer ( ip ) :: i type ( part ) :: pt , pf iaccepted = 0 associate ( r => workflows ( iworkflow )% rules ( irule ) ) ! check if we are done if ( r % accept ) then iaccepted = get_accepted ( p ) return else if ( r % reject ) then iaccepted = 0 return end if ! process recursively, by splitting up the intervals when necessary if ( r % operator > 0 ) then ! process the operator select case ( r % operator ) case ( 1 ) ! < ! always create the two sets and process the two cases below ! [note that some sets maybe empty] ! ! example: ![1,200]   < 10   ==> [1,9]    TRUE !                     [10,200] FALSE itmp = [( i , i = p % xmas ( r % operator_arg )% v ( 1 ), p % xmas ( r % operator_arg )% v ( 2 ))] itmp_t = pack ( itmp , mask = itmp < r % operator_val ) !true itmp_f = pack ( itmp , mask = itmp >= r % operator_val ) !false if ( size ( itmp_t ) > 0 ) then ! some are true pt = p pt % xmas ( r % operator_arg )% v = [ itmp_t ( 1 ), itmp_t ( size ( itmp_t ))] if ( r % goto == 'A' ) then iaccepted = iaccepted + get_accepted ( pt ) else if ( r % goto /= 'R' ) then ! go to next workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , pt ) end if end if if ( size ( itmp_f ) > 0 ) then ! some are false pf = p pf % xmas ( r % operator_arg )% v = [ itmp_f ( 1 ), itmp_f ( size ( itmp_f ))] iaccepted = iaccepted + process ( iworkflow , irule + 1 , pf ) ! next rule end if case ( 2 ) ! > itmp = [( i , i = p % xmas ( r % operator_arg )% v ( 1 ), p % xmas ( r % operator_arg )% v ( 2 ))] itmp_t = pack ( itmp , mask = itmp > r % operator_val ) !true itmp_f = pack ( itmp , mask = itmp <= r % operator_val ) !false if ( size ( itmp_t ) > 0 ) then ! some are true pt = p pt % xmas ( r % operator_arg )% v = [ itmp_t ( 1 ), itmp_t ( size ( itmp_t ))] if ( r % goto == 'A' ) then iaccepted = iaccepted + get_accepted ( pt ) else if ( r % goto /= 'R' ) then ! go to next workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , pt ) end if end if if ( size ( itmp_f ) > 0 ) then ! some are false pf = p pf % xmas ( r % operator_arg )% v = [ itmp_f ( 1 ), itmp_f ( size ( itmp_f ))] iaccepted = iaccepted + process ( iworkflow , irule + 1 , pf ) ! next rule end if end select else ! goto another workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , p ) end if end associate !end do end function process","tags":"","loc":"proc/process.html"},{"title":"get_accepted – AoC-2023","text":"function get_accepted(p) count of all the parts in the set Arguments Type Intent Optional Attributes Name type( part ), intent(in) :: p Return Value integer(kind=ip) Called by proc~~get_accepted~~CalledByGraph proc~get_accepted problem_19b::get_accepted proc~process problem_19b::process proc~process->proc~get_accepted proc~process->proc~process program~problem_19b problem_19b program~problem_19b->proc~process Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code integer ( ip ) function get_accepted ( p ) !! count of all the parts in the set type ( part ), intent ( in ) :: p get_accepted = ( 1 + ( p % xmas ( 1 )% v ( 2 ) - p % xmas ( 1 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 2 )% v ( 2 ) - p % xmas ( 2 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 3 )% v ( 2 ) - p % xmas ( 3 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 4 )% v ( 2 ) - p % xmas ( 4 )% v ( 1 ))) end function get_accepted","tags":"","loc":"proc/get_accepted.html"},{"title":"workflow_name_to_index – AoC-2023","text":"function workflow_name_to_index(name) result(idx) get the index of this workflow in the array Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value integer Called by proc~~workflow_name_to_index~~CalledByGraph proc~workflow_name_to_index problem_19b::workflow_name_to_index proc~process problem_19b::process proc~process->proc~workflow_name_to_index proc~process->proc~process program~problem_19b problem_19b program~problem_19b->proc~workflow_name_to_index program~problem_19b->proc~process Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function workflow_name_to_index ( name ) result ( idx ) !! get the index of this workflow in the array character ( len =* ), intent ( in ) :: name integer :: idx do idx = 1 , size ( workflows ) if ( name == workflows ( idx )% name ) return ! found it end do if ( idx > size ( workflows )) error stop 'workflow not found: ' // name end function workflow_name_to_index","tags":"","loc":"proc/workflow_name_to_index.html"},{"title":"parse_rule – AoC-2023","text":"function parse_rule(s) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value type( rule ) Calls proc~~parse_rule~~CallsGraph proc~parse_rule problem_19b::parse_rule interface~split aoc_utilities::split proc~parse_rule->interface~split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~parse_rule~~CalledByGraph proc~parse_rule problem_19b::parse_rule program~problem_19b problem_19b program~problem_19b->proc~parse_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function parse_rule ( s ) result ( r ) character ( len =* ), intent ( in ) :: s type ( rule ) :: r type ( string ), dimension (:), allocatable :: v character ( len =* ), parameter :: xmas = 'xmas' ! 1,2,3,4 if ( s == 'A' ) then r % accept = . true . else if ( s == 'R' ) then r % reject = . true . else if ( index ( s , '>' ) > 0 ) then v = split ( s ( 3 :), ':' ) ! example: a<2006:qkq r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 2 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else if ( index ( s , '<' ) > 0 ) then v = split ( s ( 3 :), ':' ) r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 1 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else r % goto = s ! it's a workflow name end if end if end function parse_rule","tags":"","loc":"proc/parse_rule.html"},{"title":"pipe_info – AoC-2023","text":"pure function pipe_info(p) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: p Return Value character(len=2) Called by proc~~pipe_info~~CalledByGraph proc~pipe_info problem_10::pipe_info proc~move problem_10::move proc~move->proc~pipe_info proc~move->proc~move program~problem_10 problem_10 program~problem_10->proc~move Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/pipe_info.html"},{"title":"move – AoC-2023","text":"recursive subroutine move(i, j, direction, distance, save_path) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: direction integer, intent(inout), dimension(:,:) :: distance logical, intent(in) :: save_path to save the path coordinates Calls proc~~move~~CallsGraph proc~move problem_10::move proc~move->proc~move proc~pipe_info problem_10::pipe_info proc~move->proc~pipe_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~move~~CalledByGraph proc~move problem_10::move proc~move->proc~move program~problem_10 problem_10 program~problem_10->proc~move Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine move ( i , j , direction , distance , save_path ) integer , intent ( in ) :: i , j , direction integer , dimension (:,:), intent ( inout ) :: distance logical , intent ( in ) :: save_path !! to save the path coordinates integer :: inew , jnew , imove logical :: valid_move select case ( direction ) case ( 1 ); inew = i - 1 ; jnew = j ! north case ( 2 ); inew = i + 1 ; jnew = j ! south case ( 3 ); inew = i ; jnew = j + 1 ! east case ( 4 ); inew = i ; jnew = j - 1 ! west end select if ( visited ( inew , jnew ) . or . array ( inew , jnew ) == '.' ) return ! can we move in this direction? valid_move = . false . associate ( current_pipe => array ( i , j ), & current_distance => distance ( i , j ), & move_to => array ( inew , jnew ) ) select case ( current_pipe ) case ( 'S' ) ! don't know what the first pip is, so have to try them all select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '|' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south end select case ( '-' ) select case ( direction ) case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'L' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select case ( 'J' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '7' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'F' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select end select if ( valid_move ) then distance ( inew , jnew ) = current_distance + 1 visited ( inew , jnew ) = . true . do imove = 1 , 4 call move ( inew , jnew , imove , distance , save_path ) end do if ( save_path ) then x = [ x , real ( inew , wp )] ! save cordinates of point on the path y = [ y , real ( jnew , wp )] end if end if end associate end subroutine move","tags":"","loc":"proc/move.html"},{"title":"hand_type – AoC-2023","text":"function hand_type(me, with_jokers) returns the type of hand Arguments Type Intent Optional Attributes Name class( hand ), intent(in) :: me logical, intent(in) :: with_jokers if considering jokers Return Value integer Calls proc~~hand_type~~CallsGraph proc~hand_type problem_7::hand_type interface~unique aoc_utilities::unique proc~hand_type->interface~unique proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hand_type~~CalledByGraph proc~hand_type problem_7::hand_type proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code integer function hand_type ( me , with_jokers ) !! returns the type of hand class ( hand ), intent ( in ) :: me logical , intent ( in ) :: with_jokers !! if considering jokers integer , dimension ( 5 ) :: i integer , dimension (:), allocatable :: u integer :: n_jokers , n_unique character ( len = 1 ), dimension ( 5 ) :: h h = me % cards i = ichar ( h ) ! convert to code u = unique ( i ) ! unique elements n_unique = size ( u ) if ( with_jokers . and . any ( h == 'J' )) then ! have to pick best hand for all jokers ! just do it by inspection n_jokers = count ( h == 'J' ) select case ( n_jokers ) case ( 5 ) hand_type = FIVE_OF_A_KIND !jjjjj case ( 4 ) hand_type = FIVE_OF_A_KIND !jjjja case ( 3 ) ! can always turn to 4 or 5 of a kind if ( n_unique == 2 ) then !jjjaa hand_type = FIVE_OF_A_KIND else ! jjjab hand_type = FOUR_OF_A_KIND end if case ( 2 ) if ( n_unique == 2 ) then !jjaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then !jjaab hand_type = FOUR_OF_A_KIND else !jjabc hand_type = THREE_OF_A_KIND end if case ( 1 ) if ( n_unique == 2 ) then !jaaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then if ( any ([ count ( i == u ( 1 )) == 3 , & count ( i == u ( 2 )) == 3 , & count ( i == u ( 3 )) == 3 ]) ) then !jaaab hand_type = FOUR_OF_A_KIND elseif ( ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 ) . or . & ( count ( i == u ( 2 )) == 2 . and . count ( i == u ( 2 )) == 2 ) ) then !jaabb hand_type = FULL_HOUSE end if else if ( n_unique == 4 ) then !jaabc hand_type = THREE_OF_A_KIND else if ( n_unique == 5 ) then !jabcd hand_type = ONE_PAIR end if end select else !Every hand is exactly one type. From strongest to weakest, they are: select case ( n_unique ) case ( 1 ) ! aaaaa hand_type = FIVE_OF_A_KIND case ( 2 ) ! aaaab, aaabb if (( count ( i == u ( 1 )) == 4 . and . count ( i == u ( 2 )) == 1 ) . or . & ( count ( i == u ( 1 )) == 1 . and . count ( i == u ( 2 )) == 4 ) ) then hand_type = FOUR_OF_A_KIND else if (( count ( i == u ( 1 )) == 3 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 3 ) ) then hand_type = FULL_HOUSE end if case ( 3 ) ! aaabc, aabcc if ( any ([ count ( i == u ( 1 )) == 3 , count ( i == u ( 2 )) == 3 , count ( i == u ( 3 )) == 3 ]) ) then hand_type = THREE_OF_A_KIND else if ( any ([ count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 , & count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 , & count ( i == u ( 2 )) == 2 . and . count ( i == u ( 3 )) == 2 ]) ) then hand_type = TWO_PAIR end if case ( 4 ) !aabcd hand_type = ONE_PAIR case ( 5 ) !abcde hand_type = HIGH_CARD ! High card, where all cards' labels are distinct: 23456 end select end if end function hand_type","tags":"","loc":"proc/hand_type.html"},{"title":"beats – AoC-2023","text":"function beats(hand1, hand2, with_jokers) return true if hand1 beats hand2 (has a higher score) Arguments Type Intent Optional Attributes Name class( hand ), intent(inout) :: hand1 class( hand ), intent(inout) :: hand2 logical, intent(in) :: with_jokers if considering jokers Return Value logical Calls proc~~beats~~CallsGraph proc~beats problem_7::beats proc~hand_type problem_7::hand_type proc~beats->proc~hand_type proc~index_in_cards problem_7::index_in_cards proc~beats->proc~index_in_cards interface~unique aoc_utilities::unique proc~hand_type->interface~unique proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~beats~~CalledByGraph proc~beats problem_7::beats program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function beats ( hand1 , hand2 , with_jokers ) !! return true if hand1 beats hand2 (has a higher score) class ( hand ), intent ( inout ) :: hand1 , hand2 logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i associate ( h1 => hand1 % cards , h2 => hand2 % cards ) ! recompute type if it hasn't already been computed if ( hand1 % type == 0 ) hand1 % type = hand_type ( hand1 , with_jokers ) if ( hand2 % type == 0 ) hand2 % type = hand_type ( hand2 , with_jokers ) if ( hand1 % type == hand2 % type ) then ! lower index is stronger do i = 1 , 5 if ( h1 ( i ) /= h2 ( i )) then beats = index_in_cards ( h1 ( i ), with_jokers ) < & index_in_cards ( h2 ( i ), with_jokers ) ! lower is stronger return end if end do else ! one hand beat the other beats = hand1 % type < hand2 % type ! lower score is better (1-7) end if end associate end function beats","tags":"","loc":"proc/beats.html"},{"title":"index_in_cards – AoC-2023","text":"function index_in_cards(c, with_jokers) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c logical, intent(in) :: with_jokers if considering jokers Return Value integer Called by proc~~index_in_cards~~CalledByGraph proc~index_in_cards problem_7::index_in_cards proc~beats problem_7::beats proc~beats->proc~index_in_cards program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code integer function index_in_cards ( c , with_jokers ) character ( len = 1 ), intent ( in ) :: c logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i do i = 1 , size ( cards_with_joker ) if ( with_jokers ) then if ( c == cards_with_joker ( i )) then index_in_cards = i return end if else if ( c == cards ( i )) then index_in_cards = i return end if end if end do error stop 'card not found' end function index_in_cards","tags":"","loc":"proc/index_in_cards.html"},{"title":"swap_hands – AoC-2023","text":"pure elemental subroutine swap_hands(i1, i2) swap function for hand type Arguments Type Intent Optional Attributes Name type( hand ), intent(inout) :: i1 type( hand ), intent(inout) :: i2 Called by proc~~swap_hands~~CalledByGraph proc~swap_hands problem_7::swap_hands program~problem_7 problem_7 program~problem_7->proc~swap_hands Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap_hands ( i1 , i2 ) !! swap function for hand type type ( hand ), intent ( inout ) :: i1 type ( hand ), intent ( inout ) :: i2 type ( hand ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_hands","tags":"","loc":"proc/swap_hands.html"},{"title":"destination – AoC-2023","text":"pure function destination(initial, direction, steps) result(final) get destination point Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(2) :: initial character(len=1), intent(in) :: direction integer(kind=ip), intent(in) :: steps Return Value integer(kind=ip), dimension(2) x,y of desination point Called by proc~~destination~~CalledByGraph proc~destination problem_18::destination proc~go problem_18::go proc~go->proc~destination program~problem_18 problem_18 program~problem_18->proc~go Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function destination ( initial , direction , steps ) result ( final ) !! get destination point integer ( ip ), dimension ( 2 ), intent ( in ) :: initial character ( len = 1 ), intent ( in ) :: direction integer ( ip ), intent ( in ) :: steps integer ( ip ), dimension ( 2 ) :: final !! x,y of desination point select case ( direction ) case ( 'R' ); final = [ initial ( 1 ), initial ( 2 ) + steps ] case ( 'L' ); final = [ initial ( 1 ), initial ( 2 ) - steps ] case ( 'D' ); final = [ initial ( 1 ) + steps , initial ( 2 )] case ( 'U' ); final = [ initial ( 1 ) - steps , initial ( 2 )] end select end function destination","tags":"","loc":"proc/destination.html"},{"title":"go – AoC-2023","text":"subroutine go(partb, iresult) Arguments Type Intent Optional Attributes Name logical, intent(in) :: partb if solving part b integer(kind=ip), intent(out) :: iresult Calls proc~~go~~CallsGraph proc~go problem_18::go interface~split aoc_utilities::split proc~go->interface~split proc~destination problem_18::destination proc~go->proc~destination proc~hex2int aoc_utilities::hex2int proc~go->proc~hex2int proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~go->proc~number_of_lines_in_file proc~parea aoc_utilities::parea proc~go->proc~parea proc~read_line aoc_utilities::read_line proc~go->proc~read_line proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~go~~CalledByGraph proc~go problem_18::go program~problem_18 problem_18 program~problem_18->proc~go Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine go ( partb , iresult ) logical , intent ( in ) :: partb !! if solving part b integer ( ip ), intent ( out ) :: iresult integer :: iunit , iline , n_lines , n character ( len = :), allocatable :: line , hex type ( string ), dimension (:), allocatable :: vals character ( len = 1 ) :: direction integer ( ip ), dimension ( 2 ) :: iloc , iloc2 integer ( ip ) :: ival , isteps real ( wp ), dimension (:), allocatable :: xvec , yvec character ( len = 1 ), dimension ( 0 : 3 ) :: direction_str = [ 'R' , 'D' , 'L' , 'U' ] ! directions for part b : 0,1,2,3 ! open(newunit=iunit, file='inputs/day18_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day18.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) iloc = [ 0 , 0 ] ! where to start isteps = 0 xvec = [ 0 ]; yvec = [ 0 ] do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ! direction, number, (hex) if ( partb ) then ! values encoded in hex hex = vals ( 3 )% str ival = hex2int ( hex ( 3 : 7 )) direction = direction_str ( int ( hex ( 8 : 8 ))) else direction = vals ( 1 )% str ival = int ( vals ( 2 )% str ) end if isteps = isteps + ival ! keep track of the total perimeter size iloc2 = destination ( iloc , direction , ival ) ! destination oint xvec = [ xvec , real ( iloc2 ( 1 ), wp )] ! save the points of the polygon yvec = [ yvec , real ( iloc2 ( 2 ), wp )] ! iloc = iloc2 ! update for next move end do close ( iunit ) ! the area including the boundary = area + 1/2 the perimeter + 1 ! using NSWC parea function! n = size ( xvec ) iresult = int ( abs ( parea ( yvec , xvec , n )) + real ( isteps , wp ) / 2_ip + 1_ip , ip ) end subroutine go","tags":"","loc":"proc/go.html"},{"title":"vector_djb_hash – AoC-2023","text":"private pure function vector_djb_hash(r) result(hash) DJB hash algorithm for a integer(ip) vector. See also J. Shahbazian, Fortran hashing algorithm, July 6, 2013 Fortran Dev Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: r the vector Return Value integer(kind=ip) the hash value Called by proc~~vector_djb_hash~~CalledByGraph proc~vector_djb_hash aoc_cache_module::vector_djb_hash proc~get_from_cache aoc_cache_module::function_cache%get_from_cache proc~get_from_cache->proc~vector_djb_hash proc~go~4 problem_12b::go proc~go~4->proc~get_from_cache proc~ipoint problem_12b::ipoint proc~go~4->proc~ipoint proc~ipound problem_12b::ipound proc~go~4->proc~ipound proc~index_in_queue problem_17::index_in_queue proc~index_in_queue->proc~get_from_cache proc~check~2 problem_17::check proc~check~2->proc~index_in_queue proc~ipoint->proc~go~4 proc~ipound->proc~go~4 program~problem_12b problem_12b program~problem_12b->proc~go~4 program~problem_17 problem_17 program~problem_17->proc~check~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function vector_djb_hash ( r ) result ( hash ) integer ( ip ), dimension (:), intent ( in ) :: r !! the vector integer ( ip ) :: hash !! the hash value integer :: i !! counter hash = 5381_ip do i = 1 , size ( r ) hash = ishft ( hash , 5_ip ) + hash + r ( i ) end do end function vector_djb_hash","tags":"","loc":"proc/vector_djb_hash.html"},{"title":"initialize_cache – AoC-2023","text":"private  subroutine initialize_cache(me, isize, chunk_size) Initialize the cache. Must be called first before use. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: isize the size of the hash table integer, intent(in), optional :: chunk_size chunk size to speed up reallocation\nof arrays. A good value is a guess for\nthe actual number of elements of f that\nwill be saved per value of x [default is 100] Calls proc~~initialize_cache~~CallsGraph proc~initialize_cache aoc_cache_module::function_cache%initialize_cache proc~destroy_cache aoc_cache_module::function_cache%destroy_cache proc~initialize_cache->proc~destroy_cache Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~initialize_cache~~CalledByGraph proc~initialize_cache aoc_cache_module::function_cache%initialize_cache program~problem_12b problem_12b program~problem_12b->proc~initialize_cache program~problem_17 problem_17 program~problem_17->proc~initialize_cache Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize_cache ( me , isize , chunk_size ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: isize !! the size of the hash table integer , intent ( in ), optional :: chunk_size !! chunk size to speed up reallocation !! of arrays. A good value is a guess for !! the actual number of elements of `f` that !! will be saved per value of `x` [default is 100] call me % destroy () allocate ( me % c ( 0 : isize - 1 )) if ( present ( chunk_size )) then me % chunk_size = chunk_size else me % chunk_size = 100 end if end subroutine initialize_cache","tags":"","loc":"proc/initialize_cache.html"},{"title":"get_from_cache – AoC-2023","text":"private  subroutine get_from_cache(me, x, i, f, found) Check if the x vector is in the cache, if so return f .\nNote that only some of the elements may be present, so it will return\nthe ones there are there, and indicate which ones were found. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer(kind=ip), intent(in), dimension(:) :: x independant variable vector integer(kind=ip), intent(out) :: i index in the hash table integer(kind=ip), intent(out) :: f f(x) from the cache (if it was found) logical, intent(out) :: found if x was found in the cache Calls proc~~get_from_cache~~CallsGraph proc~get_from_cache aoc_cache_module::function_cache%get_from_cache proc~vector_djb_hash aoc_cache_module::vector_djb_hash proc~get_from_cache->proc~vector_djb_hash Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_from_cache~~CalledByGraph proc~get_from_cache aoc_cache_module::function_cache%get_from_cache proc~go~4 problem_12b::go proc~go~4->proc~get_from_cache proc~ipoint problem_12b::ipoint proc~go~4->proc~ipoint proc~ipound problem_12b::ipound proc~go~4->proc~ipound proc~index_in_queue problem_17::index_in_queue proc~index_in_queue->proc~get_from_cache proc~check~2 problem_17::check proc~check~2->proc~index_in_queue proc~ipoint->proc~go~4 proc~ipound->proc~go~4 program~problem_12b problem_12b program~problem_12b->proc~go~4 program~problem_17 problem_17 program~problem_17->proc~check~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_from_cache ( me , x , i , f , found ) implicit none class ( function_cache ), intent ( inout ) :: me integer ( ip ), dimension (:), intent ( in ) :: x !! independant variable vector integer ( ip ), intent ( out ) :: i !! index in the hash table integer ( ip ), intent ( out ) :: f !! `f(x)` from the cache (if it was found) logical , intent ( out ) :: found !! if `x` was found in the cache integer :: j !! counter ! initialize: found = . false . if ( allocated ( me % c )) then ! get index in the hash table: i = mod ( abs ( vector_djb_hash ( x )), int ( size ( me % c ), ip ) ) ! check the table: if ( allocated ( me % c ( i )% x )) then if ( size ( me % c ( i )% x ) == size ( x )) then if ( all ( me % c ( i )% x == x )) then found = . true . f = me % c ( i )% f end if end if end if else error stop 'Error: the cache has not been initialized.' end if end subroutine get_from_cache","tags":"","loc":"proc/get_from_cache.html"},{"title":"put_in_cache – AoC-2023","text":"private  subroutine put_in_cache(me, i, x, f) Put a value into the cache. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer(kind=ip), intent(in) :: i index in the hash table integer(kind=ip), intent(in), dimension(:) :: x independant variable vector integer(kind=ip), intent(in) :: f function Called by proc~~put_in_cache~~CalledByGraph proc~put_in_cache aoc_cache_module::function_cache%put_in_cache proc~go~4 problem_12b::go proc~go~4->proc~put_in_cache proc~ipoint problem_12b::ipoint proc~go~4->proc~ipoint proc~ipound problem_12b::ipound proc~go~4->proc~ipound proc~index_in_queue problem_17::index_in_queue proc~index_in_queue->proc~put_in_cache proc~check~2 problem_17::check proc~check~2->proc~index_in_queue proc~ipoint->proc~go~4 proc~ipound->proc~go~4 program~problem_12b problem_12b program~problem_12b->proc~go~4 program~problem_17 problem_17 program~problem_17->proc~check~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine put_in_cache ( me , i , x , f ) implicit none class ( function_cache ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: i !! index in the hash table integer ( ip ), dimension (:), intent ( in ) :: x !! independant variable vector integer ( ip ), intent ( in ) :: f !! function integer ( ip ), parameter :: null = huge ( 1 ) !! an unusual value to initialize arrays if ( allocated ( me % c )) then if ( i <= size ( me % c )) then ! add to the cache me % c ( i )% x = x me % c ( i )% f = f else error stop 'Error: invalid index in hash table.' end if else error stop 'Error: the cache has not been initialized.' end if end subroutine put_in_cache","tags":"","loc":"proc/put_in_cache.html"},{"title":"destroy_cache – AoC-2023","text":"private  subroutine destroy_cache(me) Destroy a cache. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(out) :: me Called by proc~~destroy_cache~~CalledByGraph proc~destroy_cache aoc_cache_module::function_cache%destroy_cache proc~initialize_cache aoc_cache_module::function_cache%initialize_cache proc~initialize_cache->proc~destroy_cache program~problem_12b problem_12b program~problem_12b->proc~initialize_cache program~problem_17 problem_17 program~problem_17->proc~initialize_cache Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy_cache ( me ) implicit none class ( function_cache ), intent ( out ) :: me end subroutine destroy_cache","tags":"","loc":"proc/destroy_cache.html"},{"title":"is_node – AoC-2023","text":"pure function is_node(i, j) returns true if a node is at these coordinates Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value logical Source Code pure logical function is_node ( i , j ) !! returns true if a node is at these coordinates integer ( ip ), intent ( in ) :: i , j is_node = any ( inodes == i . and . jnodes == j ) end function is_node","tags":"","loc":"proc/is_node.html"},{"title":"node_number – AoC-2023","text":"pure function node_number(i, j) returns the index of these coordinates in\nthe list of nodes (0 if it is not a node) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value integer(kind=ip) Called by proc~~node_number~~CalledByGraph proc~node_number problem_23::node_number proc~build_graph problem_23::build_graph proc~build_graph->proc~node_number proc~build_graph->proc~build_graph proc~go~2 problem_23::go proc~go~2->proc~build_graph program~problem_23 problem_23 program~problem_23->proc~go~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer ( ip ) function node_number ( i , j ) !! returns the index of these coordinates in !! the list of nodes (0 if it is not a node) integer ( ip ), intent ( in ) :: i , j integer ( ip ), dimension ( 1 ) :: iloc iloc = findloc ( inodes == i . and . jnodes == j , . true .) node_number = iloc ( 1 ) end function node_number","tags":"","loc":"proc/node_number.html"},{"title":"count_adjacent – AoC-2023","text":"pure function count_adjacent(i, j) result(icount) count the number of adjacent cells not a tree Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value integer(kind=ip) Calls proc~~count_adjacent~~CallsGraph proc~count_adjacent problem_23::count_adjacent proc~not_tree problem_23::not_tree proc~count_adjacent->proc~not_tree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~count_adjacent~~CalledByGraph proc~count_adjacent problem_23::count_adjacent proc~go~2 problem_23::go proc~go~2->proc~count_adjacent program~problem_23 problem_23 program~problem_23->proc~go~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function count_adjacent ( i , j ) result ( icount ) !! count the number of adjacent cells not a tree integer ( ip ), intent ( in ) :: i , j integer ( ip ) :: icount icount = 0 if ( i >= 1 ) icount = icount + count ([ not_tree ( i - 1 , j )]) if ( i <= nrows ) icount = icount + count ([ not_tree ( i + 1 , j )]) if ( j <= ncols ) icount = icount + count ([ not_tree ( i , j + 1 )]) if ( j >= 1 ) icount = icount + count ([ not_tree ( i , j - 1 )]) end function count_adjacent","tags":"","loc":"proc/count_adjacent.html"},{"title":"get_cell – AoC-2023","text":"pure function get_cell(i, j) result(a) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i coordinates integer(kind=ip), intent(in) :: j coordinates Return Value character(len=1) Called by proc~~get_cell~~CalledByGraph proc~get_cell problem_23::get_cell proc~build_graph problem_23::build_graph proc~build_graph->proc~get_cell proc~build_graph->proc~build_graph proc~go~2 problem_23::go proc~go~2->proc~build_graph program~problem_23 problem_23 program~problem_23->proc~go~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function get_cell ( i , j ) result ( a ) integer ( ip ), intent ( in ) :: i , j !! coordinates character ( len = 1 ) :: a if ( slopes ) then a = array ( i , j ) else a = '.' ! ignore the slopes for part b end if end function get_cell","tags":"","loc":"proc/get_cell.html"},{"title":"not_tree – AoC-2023","text":"pure function not_tree(i, j) returns true if the cell isn't a tree Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i coordinates integer(kind=ip), intent(in) :: j coordinates Return Value logical Called by proc~~not_tree~~CalledByGraph proc~not_tree problem_23::not_tree proc~count_adjacent problem_23::count_adjacent proc~count_adjacent->proc~not_tree proc~go~2 problem_23::go proc~go~2->proc~count_adjacent program~problem_23 problem_23 program~problem_23->proc~go~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function not_tree ( i , j ) !! returns true if the cell isn't a tree integer ( ip ), intent ( in ) :: i , j !! coordinates if ( i < 1 . or . i > nrows . or . j < 1 . or . j > ncols ) then not_tree = . false . ! off the board, call it a tree else not_tree = array ( i , j ) /= '#' end if end function not_tree","tags":"","loc":"proc/not_tree.html"},{"title":"go – AoC-2023","text":"subroutine go(case, filename, parta) solve the case Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: case case name for printing character(len=*), intent(in) :: filename input file to read logical, intent(in) :: parta if this is part a, then consider the slopes Calls proc~~go~2~~CallsGraph proc~go~2 problem_23::go proc~build_graph problem_23::build_graph proc~go~2->proc~build_graph proc~count_adjacent problem_23::count_adjacent proc~go~2->proc~count_adjacent proc~dijkstra problem_23::dijkstra proc~go~2->proc~dijkstra proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~go~2->proc~read_file_to_char_array proc~traverse problem_23::traverse proc~go~2->proc~traverse proc~build_graph->proc~build_graph proc~add_edge problem_23::add_edge proc~build_graph->proc~add_edge proc~get_cell problem_23::get_cell proc~build_graph->proc~get_cell proc~node_number problem_23::node_number proc~build_graph->proc~node_number proc~not_tree problem_23::not_tree proc~count_adjacent->proc~not_tree proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line proc~traverse->proc~traverse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~go~2~~CalledByGraph proc~go~2 problem_23::go program~problem_23 problem_23 program~problem_23->proc~go~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine go ( case , filename , parta ) !! solve the case character ( len =* ), intent ( in ) :: case !! case name for printing character ( len =* ), intent ( in ) :: filename !! input file to read logical , intent ( in ) :: parta !! if this is part a, then consider the slopes integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: istart , iend , idist , i , j logical , parameter :: use_dijkstra = . false . !.... doesn't work yet .... don't know why ....... ! initialize: max_dist = 0 slopes = parta if ( allocated ( nodes )) deallocate ( nodes ) if ( allocated ( visited )) deallocate ( visited ) if ( allocated ( nodes_visited )) deallocate ( nodes_visited ) if ( allocated ( inodes )) deallocate ( inodes ) if ( allocated ( jnodes )) deallocate ( jnodes ) if ( allocated ( node_dist )) deallocate ( node_dist ) if ( allocated ( node_prev )) deallocate ( node_prev ) ! read the data file: array = read_file_to_char_array ( filename ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) iloc = findloc ( array ( 1 ,:), '.' ); istart = iloc ( 1 ) ! get start and end columns iloc = findloc ( array ( nrows ,:), '.' ); iend = iloc ( 1 ) ! ! identify the coordinates of all the nodes: inodes = [ 1 ] ! start node jnodes = [ istart ] do i = 1 , nrows do j = 1 , ncols if ( count_adjacent ( i , j ) >= 3 ) then inodes = [ inodes , i ] jnodes = [ jnodes , j ] end if end do end do inodes = [ inodes , nrows ] ! end node jnodes = [ jnodes , iend ] total_nodes = size ( inodes ) ! for each node, find the other nodes they are ! connected to and the distances between them (the edges) allocate ( nodes ( total_nodes )) allocate ( visited ( nrows , ncols )) do i = 1 , total_nodes visited = . false . idist = 0 call build_graph ( i , inodes ( i ), jnodes ( i ), idist , visited ) end do if ( use_dijkstra ) then !write(*,*) 'hello use_dijkstra'         ! ... something wrong here... don't get the right answer ! based on AOC 2021, Problem 15 allocate ( node_dist ( total_nodes )); node_dist = - 1 ; node_dist ( 1 ) = 0 allocate ( node_prev ( total_nodes )); node_prev = - 1 allocate ( nodes_visited ( total_nodes )); nodes_visited = . false . do iloc = maxloc ( node_dist , mask = . not . nodes_visited ) i = iloc ( 1 ) nodes_visited ( i ) = . true . if ( i == total_nodes ) exit ! we are done! !write(*,*) 'visited ', i if ( allocated ( nodes ( i )% inext )) then do j = 1 , size ( nodes ( i )% inext ) ! adjacent nodes to this one call dijkstra ( i , j ) end do end if !if (all(nodes_visited)) exit ! done end do !write(*,*) case, node_dist(size(node_dist)) ! result for this case (last node) !write(*,*) nodes_visited !write(*,*) node_dist else ! start at first, and find the longest that gets to the last. ! recursively traverse the graph. visited = . false . allocate ( nodes_visited ( total_nodes )); nodes_visited = . false . call traverse ( 1_ip , 0_ip , nodes_visited ) write ( * , * ) case , max_dist ! result for this case end if end subroutine go","tags":"","loc":"proc/go~2.html"},{"title":"dijkstra – AoC-2023","text":"subroutine dijkstra(u, inext) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: u integer(kind=ip), intent(in) :: inext Called by proc~~dijkstra~~CalledByGraph proc~dijkstra problem_23::dijkstra proc~go~2 problem_23::go proc~go~2->proc~dijkstra program~problem_23 problem_23 program~problem_23->proc~go~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dijkstra ( u , inext ) integer ( ip ), intent ( in ) :: u ! current integer ( ip ), intent ( in ) :: inext ! index in inext array of the next node integer ( ip ) :: idist associate ( next_node => nodes ( u )% inext ( inext ), & distance_to_next_node => nodes ( u )% idist ( inext )) if ( nodes_visited ( next_node )) return ! already visited this one idist = node_dist ( u ) + distance_to_next_node ! add distance from u to v if ( idist > node_dist ( next_node )) then !write(*,*) 'highest so far: ', idist node_dist ( next_node ) = idist node_prev ( next_node ) = u end if end associate end subroutine dijkstra","tags":"","loc":"proc/dijkstra.html"},{"title":"build_graph – AoC-2023","text":"recursive subroutine build_graph(node_num, i, j, idist, visited) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: node_num current node number integer(kind=ip), intent(in) :: i current position integer(kind=ip), intent(in) :: j current position integer(kind=ip), intent(in) :: idist current distance (number of steps) logical, intent(in), dimension(:,:) :: visited elements visited in this path (not counting this one) Calls proc~~build_graph~~CallsGraph proc~build_graph problem_23::build_graph proc~build_graph->proc~build_graph proc~add_edge problem_23::add_edge proc~build_graph->proc~add_edge proc~get_cell problem_23::get_cell proc~build_graph->proc~get_cell proc~node_number problem_23::node_number proc~build_graph->proc~node_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~build_graph~~CalledByGraph proc~build_graph problem_23::build_graph proc~build_graph->proc~build_graph proc~go~2 problem_23::go proc~go~2->proc~build_graph program~problem_23 problem_23 program~problem_23->proc~go~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine build_graph ( node_num , i , j , idist , visited ) integer ( ip ), intent ( in ) :: node_num !! current node number integer ( ip ), intent ( in ) :: i , j !! current position integer ( ip ), intent ( in ) :: idist !! current distance (number of steps) logical , dimension (:,:), intent ( in ) :: visited !! elements visited in this path (not counting this one) logical , dimension (:,:), allocatable :: tmp_visited integer ( ip ) :: child_node_num if ( i < 1 . or . i > nrows . or . j < 1 . or . j > ncols ) return if ( visited ( i , j )) return if ( array ( i , j ) == '#' ) return ! can't continue from here ! go until we hit another node child_node_num = node_number ( i , j ) if ( child_node_num > 0 . and . child_node_num /= node_num ) then ! we have reached another node call add_edge ( node_num , child_node_num , idist ) else ! continue processing this edge tmp_visited = visited !make a copy and mark this one tmp_visited ( i , j ) = . true . ! we are here now associate ( a => get_cell ( i , j )) ! paths (.), forest (#), and steep slopes (&#94;, >, v, and <). select case ( a ) case ( '.' ) ! path call build_graph ( node_num , i - 1 , j , idist + 1 , tmp_visited ) call build_graph ( node_num , i + 1 , j , idist + 1 , tmp_visited ) call build_graph ( node_num , i , j + 1 , idist + 1 , tmp_visited ) call build_graph ( node_num , i , j - 1 , idist + 1 , tmp_visited ) ! these don't have a choice, must go in these directions: case ( '&#94;' ); call build_graph ( node_num , i - 1 , j , idist + 1 , tmp_visited ) case ( 'v' ); call build_graph ( node_num , i + 1 , j , idist + 1 , tmp_visited ) case ( '>' ); call build_graph ( node_num , i , j + 1 , idist + 1 , tmp_visited ) case ( '<' ); call build_graph ( node_num , i , j - 1 , idist + 1 , tmp_visited ) end select end associate end if end subroutine build_graph","tags":"","loc":"proc/build_graph.html"},{"title":"traverse – AoC-2023","text":"recursive subroutine traverse(node_num, idist, nodes_visited) traverse the graph until we get to the end and check the max distance Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: node_num current node integer(kind=ip), intent(in) :: idist distance to get here logical, intent(in), dimension(:) :: nodes_visited Called by proc~~traverse~~CalledByGraph proc~traverse problem_23::traverse proc~traverse->proc~traverse proc~go~2 problem_23::go proc~go~2->proc~traverse program~problem_23 problem_23 program~problem_23->proc~go~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine traverse ( node_num , idist , nodes_visited ) !! traverse the graph until we get to the end and check the max distance integer ( ip ), intent ( in ) :: node_num !! current node integer ( ip ), intent ( in ) :: idist !! distance to get here logical , dimension (:), intent ( in ) :: nodes_visited logical , dimension (:), allocatable :: tmp_nodes_visited integer :: i if ( nodes_visited ( node_num )) return ! already visited this node if ( node_num == total_nodes ) then ! reached the destination if ( idist > max_dist ) max_dist = idist ! best so far else ! are their child nodes? if ( allocated ( nodes ( node_num )% inext )) then tmp_nodes_visited = nodes_visited tmp_nodes_visited ( node_num ) = . true . ! mark this node do i = 1 , size ( nodes ( node_num )% inext ) call traverse ( nodes ( node_num )% inext ( i ), idist + nodes ( node_num )% idist ( i ), tmp_nodes_visited ) end do end if end if end subroutine traverse","tags":"","loc":"proc/traverse.html"},{"title":"add_edge – AoC-2023","text":"subroutine add_edge(inode, ichild, idist) add an edge to this node (path to another node with the specified distance) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: inode integer(kind=ip), intent(in) :: ichild integer(kind=ip), intent(in) :: idist Called by proc~~add_edge~~CalledByGraph proc~add_edge problem_23::add_edge proc~build_graph problem_23::build_graph proc~build_graph->proc~add_edge proc~build_graph->proc~build_graph proc~go~2 problem_23::go proc~go~2->proc~build_graph program~problem_23 problem_23 program~problem_23->proc~go~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine add_edge ( inode , ichild , idist ) !! add an edge to this node (path to another node with the specified distance) integer ( ip ), intent ( in ) :: inode , ichild , idist if (. not . allocated ( nodes ( inode )% inext )) then allocate ( nodes ( inode )% inext ( 0 )) allocate ( nodes ( inode )% idist ( 0 )) end if nodes ( inode )% inext = [ nodes ( inode )% inext , ichild ] nodes ( inode )% idist = [ nodes ( inode )% idist , idist ] end subroutine add_edge","tags":"","loc":"proc/add_edge.html"},{"title":"go – AoC-2023","text":"function go(expansion_factor) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: expansion_factor Return Value integer(kind=ip) Calls proc~~go~6~~CallsGraph proc~go~6 problem_11::go interface~manhatten_distance aoc_utilities::manhatten_distance proc~go~6->interface~manhatten_distance proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~go~6->proc~read_file_to_char_array proc~manhatten_distance_64 aoc_utilities::manhatten_distance_64 interface~manhatten_distance->proc~manhatten_distance_64 proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~go~6~~CalledByGraph proc~go~6 problem_11::go program~problem_11 problem_11 program~problem_11->proc~go~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code integer ( ip ) function go ( expansion_factor ) integer ( ip ), intent ( in ) :: expansion_factor integer :: i , j , nrows , ncols , n_galaxies , n , k character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:,:), allocatable :: idists integer ( ip ), dimension (:), allocatable :: igal , jgal integer ( ip ), dimension (:,:), allocatable :: ix , iy ! array = read_file_to_char_array('inputs/day11_test.txt') array = read_file_to_char_array ( 'inputs/day11.txt' ) nrows = size ( array , 1 ); ncols = size ( array , 2 ) n_galaxies = count ( array == '#' ) ! track the real indices after expansion ix = transpose ( spread ([( i , i = 1 , ncols )], 1 , nrows )) ! row indices iy = spread ([( i , i = 1 , nrows )], 1 , ncols ) ! col indices igal = pack ( ix , array == '#' ) ! indices of galaxies jgal = pack ( iy , array == '#' ) ! expand the array, keeping track of the new row indices do i = 1 , nrows ! add rows if necessary if ( all ( array ( i ,:) == '.' )) ix ( i :,:) = ix ( i :,:) + expansion_factor - 1 ! new row end do do j = 1 , ncols ! add cols if necessary if ( all ( array (:, j ) == '.' )) iy (:, j :) = iy (:, j :) + expansion_factor - 1 ! new column end do ! now compute all the distances: allocate ( idists ( n_galaxies , n_galaxies )); idists = 0 do i = 1 , n_galaxies do j = 1 , n_galaxies if ( j <= i ) cycle ! only need the lower diagonal idists ( i , j ) = manhatten_distance ( ix ( igal ( i ), jgal ( i )), iy ( igal ( i ), jgal ( i )),& ix ( igal ( j ), jgal ( j )), iy ( igal ( j ), jgal ( j ))) end do end do go = sum ( idists ) end function go","tags":"","loc":"proc/go~6.html"},{"title":"go – AoC-2023","text":"recursive subroutine go(i, j, direction_from) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i grid coordinate integer, intent(in) :: j grid coordinate integer, intent(in) :: direction_from direction coming from (TOP,BOTTOM,LEFT,RIGHT Called by proc~~go~3~~CalledByGraph proc~go~3 problem_16::go proc~go~3->proc~go~3 program~problem_16 problem_16 program~problem_16->proc~go~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine go ( i , j , direction_from ) integer , intent ( in ) :: i , j !! grid coordinate integer , intent ( in ) :: direction_from !! direction coming from (TOP,BOTTOM,LEFT,RIGHT integer :: k if ( i > nrows . or . i < 1 . or . j > ncols . or . j < 1 ) return ! off the board if ( visited ( direction_from , i , j )) return ! this case has already been done visited ( direction_from , i , j ) = . true . ! mark this one as visited in this direction associate ( c => array ( i , j )) select case ( c ) case ( '.' ) ! continue in same direction k = 1 do ! loop until we hit something else ! (to avoid unnecessary recursion) select case ( direction_from ) case ( TOP ) ! V if (( i + k ) > nrows ) return if ( array ( i + k , j ) /= '.' ) then call go ( i + k , j , direction_from ) return end if visited ( direction_from , i + k , j ) = . true . case ( BOTTOM ) ! &#94; if (( i - k ) < 1 ) return if ( array ( i - k , j ) /= '.' ) then call go ( i - k , j , direction_from ) return end if visited ( direction_from , i - k , j ) = . true . case ( LEFT ) ! --> if (( j + k ) > ncols ) return if ( array ( i , j + k ) /= '.' ) then call go ( i , j + k , direction_from ) return end if visited ( direction_from , i , j + k ) = . true . case ( RIGHT ) ! <-- if (( j - k ) < 1 ) return if ( array ( i , j - k ) /= '.' ) then call go ( i , j - k , direction_from ) return end if visited ( direction_from , i , j - k ) = . true . end select k = k + 1 end do case ( '-' ) select case ( direction_from ) case ( TOP , BOTTOM ) ! V, &#94; call go ( i , j + 1 , LEFT ) ! split call go ( i , j - 1 , RIGHT ) case ( LEFT ) ! --> call go ( i , j + 1 , LEFT ) case ( RIGHT ) ! <-- call go ( i , j - 1 , RIGHT ) end select case ( '|' ) select case ( direction_from ) case ( TOP ) ! V call go ( i + 1 , j , TOP ) case ( BOTTOM ) ! &#94; call go ( i - 1 , j , BOTTOM ) case ( LEFT , RIGHT ) ! -->, <-- call go ( i + 1 , j , TOP ) call go ( i - 1 , j , BOTTOM ) end select case ( '/' ) select case ( direction_from ) case ( TOP ) ! V call go ( i , j - 1 , RIGHT ) case ( BOTTOM ) ! &#94; call go ( i , j + 1 , LEFT ) case ( LEFT ) ! --> call go ( i - 1 , j , BOTTOM ) case ( RIGHT ) ! <-- call go ( i + 1 , j , TOP ) end select case ( '\\' ) select case ( direction_from ) case ( TOP ) ! V call go ( i , j + 1 , LEFT ) case ( BOTTOM ) ! &#94; call go ( i , j - 1 , RIGHT ) case ( LEFT ) ! --> call go ( i + 1 , j , TOP ) case ( RIGHT ) ! <-- call go ( i - 1 , j , BOTTOM ) end select end select end associate end subroutine go","tags":"","loc":"proc/go~3.html"},{"title":"go – AoC-2023","text":"recursive function go(ipattern, ints) result(ival) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ipattern integer(kind=ip), intent(in), dimension(:) :: ints Return Value integer(kind=ip) Calls proc~~go~4~~CallsGraph proc~go~4 problem_12b::go proc~get_from_cache aoc_cache_module::function_cache%get_from_cache proc~go~4->proc~get_from_cache proc~ipoint problem_12b::ipoint proc~go~4->proc~ipoint proc~ipound problem_12b::ipound proc~go~4->proc~ipound proc~put_in_cache aoc_cache_module::function_cache%put_in_cache proc~go~4->proc~put_in_cache proc~vector_djb_hash aoc_cache_module::vector_djb_hash proc~get_from_cache->proc~vector_djb_hash proc~ipoint->proc~go~4 proc~ipound->proc~go~4 ints_tmp ints_tmp proc~ipound->ints_tmp ipattern_tmp ipattern_tmp proc~ipound->ipattern_tmp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~go~4~~CalledByGraph proc~go~4 problem_12b::go proc~ipoint problem_12b::ipoint proc~go~4->proc~ipoint proc~ipound problem_12b::ipound proc~go~4->proc~ipound proc~ipoint->proc~go~4 proc~ipound->proc~go~4 program~problem_12b problem_12b program~problem_12b->proc~go~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive function go ( ipattern , ints ) result ( ival ) integer ( ip ), dimension (:), intent ( in ) :: ipattern integer ( ip ), dimension (:), intent ( in ) :: ints integer ( ip ) :: ival integer ( ip ) :: idx logical :: found ! first check the cache: call cache % get ([ ipattern , ints ], idx , ival , found ) if (. not . found ) then if ( size ( ints ) == 0 ) then ! no more ints ival = merge ( 0 , 1 , any ( ipattern == NUMBER )) ! if any more numbers, invalid else if ( size ( ipattern ) == 0 ) then ival = 0 ! too many ints else ! process next element in pattern select case ( ipattern ( 1 )) case ( NUMBER ); ival = ipound ( ipattern , ints ) case ( POINT ); ival = ipoint ( ipattern , ints ) case ( QUESTION ); ival = ipoint ( ipattern , ints ) + ipound ( ipattern , ints ) end select end if ! cache this function call: call cache % put ( idx ,[ ipattern , ints ], ival ) end if end function go","tags":"","loc":"proc/go~4.html"},{"title":"ipound – AoC-2023","text":"recursive function ipound(ipattern, ints) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ipattern first char is a # integer(kind=ip), intent(in), dimension(:) :: ints Return Value integer(kind=ip) Calls proc~~ipound~~CallsGraph proc~ipound problem_12b::ipound ints_tmp ints_tmp proc~ipound->ints_tmp ipattern_tmp ipattern_tmp proc~ipound->ipattern_tmp proc~go~4 problem_12b::go proc~ipound->proc~go~4 proc~go~4->proc~ipound proc~get_from_cache aoc_cache_module::function_cache%get_from_cache proc~go~4->proc~get_from_cache proc~ipoint problem_12b::ipoint proc~go~4->proc~ipoint proc~put_in_cache aoc_cache_module::function_cache%put_in_cache proc~go~4->proc~put_in_cache proc~vector_djb_hash aoc_cache_module::vector_djb_hash proc~get_from_cache->proc~vector_djb_hash proc~ipoint->proc~go~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ipound~~CalledByGraph proc~ipound problem_12b::ipound proc~go~4 problem_12b::go proc~ipound->proc~go~4 proc~go~4->proc~ipound proc~ipoint problem_12b::ipoint proc~go~4->proc~ipoint proc~ipoint->proc~go~4 program~problem_12b problem_12b program~problem_12b->proc~go~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive integer ( ip ) function ipound ( ipattern , ints ) integer ( ip ), dimension (:), intent ( in ) :: ipattern !! first char is a # integer ( ip ), dimension (:), intent ( in ) :: ints integer ( ip ), dimension (:), allocatable :: this_group ! check for the number of # that correspond to the first group if ( size ( ipattern ) >= ints ( 1 )) then this_group = ipattern ( 1 : ints ( 1 )) where ( this_group == QUESTION ) this_group = NUMBER ! replace ? with # if ( any ( this_group /= NUMBER )) then ! can't fit all the #'s so not valid ipound = 0 return else ! so far so good end if else ! not enough room to hold all the #'s ipound = 0 return end if if ( size ( ipattern ) == ints ( 1 )) then ! if this is the last group, then we are done ipound = merge ( 1 , 0 , size ( ints ) == 1 ) else ! the next character after this number must be a ? or . if ( size ( ipattern ) >= ints ( 1 ) + 1 ) then if ( any ( ipattern ( ints ( 1 ) + 1 ) == [ QUESTION , POINT ])) then block integer ( ip ), dimension (:), allocatable :: ipattern_tmp , ints_tmp ! to handle edge cases ! skip it and process the next group if ( size ( ipattern ) >= ints ( 1 ) + 2 ) then ipattern_tmp = ipattern ( ints ( 1 ) + 2 :) else allocate ( ipattern_tmp ( 0 )) end if if ( size ( ints ) >= 2 ) then ints_tmp = ints ( 2 :) else allocate ( ints_tmp ( 0 )) end if ipound = go ( ipattern_tmp , ints_tmp ) return end block end if end if ! not valid at this point ipound = 0 end if end function ipound","tags":"","loc":"proc/ipound.html"},{"title":"ipoint – AoC-2023","text":"recursive function ipoint(ipattern, ints) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ipattern first char is a . integer(kind=ip), intent(in), dimension(:) :: ints Return Value integer(kind=ip) Calls proc~~ipoint~~CallsGraph proc~ipoint problem_12b::ipoint proc~go~4 problem_12b::go proc~ipoint->proc~go~4 proc~go~4->proc~ipoint proc~get_from_cache aoc_cache_module::function_cache%get_from_cache proc~go~4->proc~get_from_cache proc~ipound problem_12b::ipound proc~go~4->proc~ipound proc~put_in_cache aoc_cache_module::function_cache%put_in_cache proc~go~4->proc~put_in_cache proc~vector_djb_hash aoc_cache_module::vector_djb_hash proc~get_from_cache->proc~vector_djb_hash proc~ipound->proc~go~4 ints_tmp ints_tmp proc~ipound->ints_tmp ipattern_tmp ipattern_tmp proc~ipound->ipattern_tmp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ipoint~~CalledByGraph proc~ipoint problem_12b::ipoint proc~go~4 problem_12b::go proc~ipoint->proc~go~4 proc~go~4->proc~ipoint proc~ipound problem_12b::ipound proc~go~4->proc~ipound proc~ipound->proc~go~4 program~problem_12b problem_12b program~problem_12b->proc~go~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive integer ( ip ) function ipoint ( ipattern , ints ) integer ( ip ), dimension (:), intent ( in ) :: ipattern !! first char is a . integer ( ip ), dimension (:), intent ( in ) :: ints if ( size ( ipattern ) <= 1 ) then ipoint = go ([ integer ( ip ) :: ], ints ) ! done, pass in empty array else ipoint = go ( ipattern ( 2 :), ints ) ! skip it and go to next one end if end function ipoint","tags":"","loc":"proc/ipoint.html"},{"title":"in_seed_list – AoC-2023","text":"function in_seed_list(iseed) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: iseed Return Value logical Called by proc~~in_seed_list~~CalledByGraph proc~in_seed_list problem_5::in_seed_list program~problem_5 problem_5 program~problem_5->proc~in_seed_list Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function in_seed_list ( iseed ) ! for part b, is the seed in the initial list integer ( ip ), intent ( in ) :: iseed integer :: i do i = 1 , size ( seeds_list ), 2 if ( iseed >= seeds_list ( i ) . and . iseed <= seeds_list ( i ) + seeds_list ( i + 1 ) - 1 ) then in_seed_list = . true . return end if end do in_seed_list = . false . end function in_seed_list","tags":"","loc":"proc/in_seed_list.html"},{"title":"map – AoC-2023","text":"pure function map(ival, m, reverse) result(idest) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: ival type( mapping ), intent(in) :: m logical, intent(in) :: reverse Return Value integer(kind=ip) Called by proc~~map~~CalledByGraph proc~map problem_5::map proc~traverse~2 problem_5::traverse proc~traverse~2->proc~map program~problem_5 problem_5 program~problem_5->proc~traverse~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function map ( ival , m , reverse ) result ( idest ) integer ( ip ), intent ( in ) :: ival type ( mapping ), intent ( in ) :: m logical , intent ( in ) :: reverse ! if reversed, go from: dest -> src integer ( ip ) :: idest integer :: i if ( reverse ) then do i = 1 , size ( m % src_start ) ! locate ival (dest) in the dest start:end range if ( ival >= m % dest_start ( i ) . and . ival <= m % dest_end ( i )) then ! found it, map to dest idest = m % src_start ( i ) + ( ival - m % dest_start ( i )) ! this is the resultant isource return end if end do else do i = 1 , size ( m % src_start ) ! locate ival (source) in the source start:end range if ( ival >= m % src_start ( i ) . and . ival <= m % src_end ( i )) then ! found it, map to dest idest = m % dest_start ( i ) + ( ival - m % src_start ( i )) return end if end do end if idest = ival ! if not found in any of the sets end function map","tags":"","loc":"proc/map.html"},{"title":"traverse – AoC-2023","text":"pure function traverse(iseed, reverse) result(ilocation) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: iseed logical, intent(in) :: reverse if reverse, then ilocation -> iseed Return Value integer(kind=ip) Calls proc~~traverse~2~~CallsGraph proc~traverse~2 problem_5::traverse proc~map problem_5::map proc~traverse~2->proc~map Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~traverse~2~~CalledByGraph proc~traverse~2 problem_5::traverse program~problem_5 problem_5 program~problem_5->proc~traverse~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function traverse ( iseed , reverse ) result ( ilocation ) integer ( ip ), intent ( in ) :: iseed logical , intent ( in ) :: reverse !! if reverse, then ilocation -> iseed integer ( ip ) :: ilocation integer :: i ilocation = iseed ! initialize if ( reverse ) then do i = NSTAGES , 1 , - 1 ilocation = map ( ilocation , mappings ( i ), reverse ) ! this is really iseed end do else do i = 1 , NSTAGES ilocation = map ( ilocation , mappings ( i ), reverse ) end do end if end function traverse","tags":"","loc":"proc/traverse~2.html"},{"title":"populate – AoC-2023","text":"subroutine populate(nums, m) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(3) :: nums type( mapping ), intent(inout) :: m Called by proc~~populate~~CalledByGraph proc~populate problem_5::populate program~problem_5 problem_5 program~problem_5->proc~populate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine populate ( nums , m ) integer ( ip ), dimension ( 3 ), intent ( in ) :: nums ! the three numbers from the line: ! [dest range start, src range start, range length type ( mapping ), intent ( inout ) :: m ! structure to add this data to associate ( dest => nums ( 1 ), source => nums ( 2 ), range => nums ( 3 ) ) m % dest_start = [ m % dest_start , dest ] m % dest_end = [ m % dest_end , dest + range - 1 ] m % src_start = [ m % src_start , source ] m % src_end = [ m % src_end , source + range - 1 ] end associate end subroutine populate","tags":"","loc":"proc/populate.html"},{"title":"extrapolate – AoC-2023","text":"pure function extrapolate(ivals) result(iextrap) extrapolate the next value in the sequence using\na difference table. Straightfoward implemention:\ncreate the full table, and then evaluate it. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals Return Value integer(kind=ip) Calls proc~~extrapolate~~CallsGraph proc~extrapolate problem_9::extrapolate proc~diff aoc_utilities::diff proc~extrapolate->proc~diff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~extrapolate~~CalledByGraph proc~extrapolate problem_9::extrapolate program~problem_9 problem_9 program~problem_9->proc~extrapolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function extrapolate ( ivals ) result ( iextrap ) !! extrapolate the next value in the sequence using !! a difference table. Straightfoward implemention: !! create the full table, and then evaluate it. integer ( ip ), dimension (:), intent ( in ) :: ivals integer ( ip ) :: iextrap integer :: i , n type ( int64_vec ), dimension (:), allocatable :: diff_table !! difference table (vector of vectors) ! create the difference table: diff_table = [ int64_vec ( ivals )]; n = 1 do n = n + 1 diff_table = [ diff_table , int64_vec ( diff ( diff_table ( n - 1 )% vals ))] ! next line is diff of previous line if ( all ( diff_table ( n )% vals == 0 )) exit end do ! extrapolate iextrap = 0 do i = n - 1 , 1 , - 1 associate ( ilast => diff_table ( i )% vals ( size ( diff_table ( i )% vals )) ) iextrap = iextrap + ilast end associate end do end function extrapolate","tags":"","loc":"proc/extrapolate.html"},{"title":"match – AoC-2023","text":"function match(ipattern, ints) returns true if the pattern is valid for the int list. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: ipattern integer, intent(in), dimension(:) :: ints Return Value logical Called by proc~~match~~CalledByGraph proc~match problem_12::match proc~test problem_12::test proc~test->proc~match proc~test->proc~test proc~go~7 problem_12::go proc~go~7->proc~test program~problem_12 problem_12 program~problem_12->proc~go~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function match ( ipattern , ints ) !! returns true if the pattern is valid for the int list. integer , dimension (:), intent ( in ) :: ipattern integer , dimension (:), intent ( in ) :: ints integer :: i , iacc , int_checked integer , dimension ( 1 ) :: ifirst , iend logical :: accumulating ! .##..###... -> 2,3 ! start and end indices (ignoring leading and trailing spaces) ifirst = findloc ( ipattern , 1 ) iend = findloc ( ipattern , 1 , back = . true .) if ( ifirst ( 1 ) == 0 . or . iend ( 1 ) == 0 ) then ! all blank match = . false .; return end if ! step through the pattern and stop once we find it invalid accumulating = . true . iacc = 0 int_checked = 0 ! the count of ints that have been checked match = . true . ! initialize do i = ifirst ( 1 ), iend ( 1 ) select case ( ipattern ( i )) case ( POINT ) if ( accumulating ) then int_checked = int_checked + 1 ! check the next one if ( int_checked > size ( ints )) then ! too many ints match = . false . return else if ( ints ( int_checked ) /= iacc ) then ! doesn't match match = . false . return end if accumulating = . false . iacc = 0 end if case ( NUMBER ) if ( accumulating ) then iacc = iacc + 1 else ! start of a new number accumulating = . true . iacc = 1 end if if ( i == iend ( 1 )) then ! last number int_checked = int_checked + 1 ! check the next one if ( int_checked /= size ( ints )) then ! not enough ints match = . false . return else if ( ints ( int_checked ) /= iacc ) then ! doesn't match match = . false . return end if end if end select end do end function match","tags":"","loc":"proc/match.html"},{"title":"go – AoC-2023","text":"subroutine go(expand, isum) Arguments Type Intent Optional Attributes Name logical, intent(in) :: expand integer(kind=ip), intent(out) :: isum Calls proc~~go~7~~CallsGraph proc~go~7 problem_12::go interface~split aoc_utilities::split proc~go~7->interface~split proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~go~7->proc~number_of_lines_in_file proc~parse_ints aoc_utilities::parse_ints proc~go~7->proc~parse_ints proc~read_line aoc_utilities::read_line proc~go~7->proc~read_line proc~str_to_int_array_with_mapping aoc_utilities::str_to_int_array_with_mapping proc~go~7->proc~str_to_int_array_with_mapping proc~test problem_12::test proc~go~7->proc~test proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~test->proc~test proc~match problem_12::match proc~test->proc~match proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~go~7~~CalledByGraph proc~go~7 problem_12::go program~problem_12 problem_12 program~problem_12->proc~go~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine go ( expand , isum ) logical , intent ( in ) :: expand integer ( ip ), intent ( out ) :: isum integer :: iunit , n_lines , n_unknowns integer ( ip ) :: n_perms character ( len = :), allocatable :: line , pattern type ( string ), dimension (:), allocatable :: vals ! open(newunit=iunit, file='inputs/day12_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day12.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ints = parse_ints ( vals ( 2 )% str ) ! integer list  1,1,3 pattern = vals ( 1 )% str ! the pattern   #.#.### ! will convert the pattern to an array of numbers: ipattern = str_to_int_array_with_mapping ( pattern ,[ '.' , '#' , '?' ],& [ POINT , NUMBER , QUESTION ]) ! 1010111 if ( expand ) then ! brute force it ipattern = [ ipattern , QUESTION , ipattern , QUESTION , & ipattern , QUESTION , ipattern , QUESTION , & ipattern ] ints = [ ints , ints , ints , ints , ints ] end if n_unknowns = count ( ipattern == 2 ) n_valid = 0 ! number of valid permutations n_perms = 2 ** n_unknowns ! number of permutations ipattern_tmp = ipattern ! recursively test all the permutations if ( allocated ( a )) deallocate ( a ) allocate ( a ( n_unknowns )) call test ( 1 , n_unknowns ) isum = isum + n_valid ! write(*,*) iline, 'n_valid = ', n_valid end do end subroutine go","tags":"","loc":"proc/go~7.html"},{"title":"test – AoC-2023","text":"recursive subroutine test(i, n) each ? can be either a . or a #\ncheck pattern to match the int list Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: n Calls proc~~test~~CallsGraph proc~test problem_12::test proc~test->proc~test proc~match problem_12::match proc~test->proc~match Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~test~~CalledByGraph proc~test problem_12::test proc~test->proc~test proc~go~7 problem_12::go proc~go~7->proc~test program~problem_12 problem_12 program~problem_12->proc~go~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine test ( i , n ) !! each ? can be either a . or a # !! check pattern to match the int list integer , intent ( in ) :: i , n integer :: ix integer , dimension ( * ), parameter :: icoeffs = [ POINT , NUMBER ] !! set of coefficients ['.', '#'] ! what we are not doing here is accounting for permutations ! that we know do not match, because the begin with a sequence ! that doesn't match. those need to be skipped... if ( i > n ) then ! so we have an array of 0s and 1s -> replace the 2s in the ipattern with these !     ipattern: 2220111  -> ???.### !            a: 011      -> .## !       result: 0110111  -> .##.### !write(*,'(a,1x,i5,1x, *(I1))') 'test:', iline, ipattern_tmp ipattern_tmp = unpack ( a , mask = ipattern == QUESTION , field = ipattern ) if ( match ( ipattern_tmp , ints )) n_valid = n_valid + 1 else do ix = 1 , 2 a ( i ) = icoeffs ( ix ) call test ( i + 1 , n ) end do end if end subroutine test","tags":"","loc":"proc/test.html"},{"title":"go – AoC-2023","text":"subroutine go(puzzle, ileft, iskip) compute the number of cols to left of mirror (0 if none)\ncall with transpose(puzzle) to get number of rows above. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: puzzle integer, intent(out) :: ileft integer, intent(in), optional :: iskip don't consider this column Called by proc~~go~5~~CalledByGraph proc~go~5 problem_13::go program~problem_13 problem_13 program~problem_13->proc~go~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine go ( puzzle , ileft , iskip ) !! compute the number of cols to left of mirror (0 if none) !! call with transpose(puzzle) to get number of rows above. integer , dimension (:,:), intent ( in ) :: puzzle integer , intent ( out ) :: ileft integer , intent ( in ), optional :: iskip !! don't consider this column integer :: nrows , ncols , i , j logical :: mirror nrows = size ( puzzle , 1 ) ncols = size ( puzzle , 2 ) ileft = 0 do i = 1 , ncols - 1 if ( present ( iskip )) then if ( i == iskip ) cycle end if mirror = . true . do j = 1 , min ( i , ncols - i ) if ( any ( puzzle (:, i - j + 1 ) /= puzzle (:, i + j )) ) then mirror = . false . ! no mirror on this line exit end if end do if ( mirror ) then ileft = i exit end if end do end subroutine go","tags":"","loc":"proc/go~5.html"},{"title":"rating – AoC-2023","text":"pure function rating(p) Arguments Type Intent Optional Attributes Name type( part ), intent(in) :: p Return Value integer(kind=ip) Called by proc~~rating~~CalledByGraph proc~rating problem_19::rating program~problem_19 problem_19 program~problem_19->proc~rating Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer ( ip ) function rating ( p ) type ( part ), intent ( in ) :: p rating = sum ( p % xmas ) end function rating","tags":"","loc":"proc/rating.html"},{"title":"process – AoC-2023","text":"function process(p) result(accepted) process this part through all the workflows. Arguments Type Intent Optional Attributes Name type( part ), intent(in) :: p Return Value logical Calls proc~~process~2~~CallsGraph proc~process~2 problem_19::process proc~workflow_name_to_index~2 problem_19::workflow_name_to_index proc~process~2->proc~workflow_name_to_index~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~process~2~~CalledByGraph proc~process~2 problem_19::process program~problem_19 problem_19 program~problem_19->proc~process~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function process ( p ) result ( accepted ) !! process this part through all the workflows. type ( part ), intent ( in ) :: p logical :: accepted integer :: i , irule i = workflow_name_to_index ( 'in' ) ! start at the first workflow irule = 1 ! first rule do associate ( r => workflows ( i )% rules ( irule ) ) ! check if we are done if ( r % accept ) then ; accepted = . true .; return ; end if if ( r % reject ) then ; accepted = . false .; return ; end if if ( r % operator > 0 ) then ! process the operator select case ( r % operator ) case ( 1 ) ! < if ( p % xmas ( r % operator_arg ) < r % operator_val ) then ! check if done if ( r % goto == 'A' ) then ; accepted = . true .; return ; end if if ( r % goto == 'R' ) then ; accepted = . false .; return ; end if ! go to next workflow: i = workflow_name_to_index ( r % goto ) !write(*,*) 'goto '//r%goto irule = 1 ! start at first rule of new workflow else irule = irule + 1 ! next rule end if case ( 2 ) ! > if ( p % xmas ( r % operator_arg ) > r % operator_val ) then ! check if done if ( r % goto == 'A' ) then ; accepted = . true .; return ; end if if ( r % goto == 'R' ) then ; accepted = . false .; return ; end if ! go to next workflow: i = workflow_name_to_index ( r % goto ) irule = 1 ! start at first rule of new workflow else irule = irule + 1 ! next rule end if end select else ! goto another workflow i = workflow_name_to_index ( r % goto ) irule = 1 ! start at first rule of new workflow end if end associate end do end function process","tags":"","loc":"proc/process~2.html"},{"title":"workflow_name_to_index – AoC-2023","text":"function workflow_name_to_index(name) result(idx) get the index of this workflow in the array Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value integer Called by proc~~workflow_name_to_index~2~~CalledByGraph proc~workflow_name_to_index~2 problem_19::workflow_name_to_index proc~process~2 problem_19::process proc~process~2->proc~workflow_name_to_index~2 program~problem_19 problem_19 program~problem_19->proc~process~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function workflow_name_to_index ( name ) result ( idx ) !! get the index of this workflow in the array character ( len =* ), intent ( in ) :: name integer :: idx do idx = 1 , size ( workflows ) if ( name == workflows ( idx )% name ) return ! found it end do if ( idx > size ( workflows )) error stop 'workflow not found: ' // name end function workflow_name_to_index","tags":"","loc":"proc/workflow_name_to_index~2.html"},{"title":"parse_rule – AoC-2023","text":"function parse_rule(s) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value type( rule ) Calls proc~~parse_rule~2~~CallsGraph proc~parse_rule~2 problem_19::parse_rule interface~split aoc_utilities::split proc~parse_rule~2->interface~split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~parse_rule~2~~CalledByGraph proc~parse_rule~2 problem_19::parse_rule program~problem_19 problem_19 program~problem_19->proc~parse_rule~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function parse_rule ( s ) result ( r ) character ( len =* ), intent ( in ) :: s type ( rule ) :: r type ( string ), dimension (:), allocatable :: v character ( len =* ), parameter :: xmas = 'xmas' ! 1,2,3,4 if ( s == 'A' ) then r % accept = . true . else if ( s == 'R' ) then r % reject = . true . else if ( index ( s , '>' ) > 0 ) then v = split ( s ( 3 :), ':' ) ! example: a<2006:qkq r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 2 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else if ( index ( s , '<' ) > 0 ) then v = split ( s ( 3 :), ':' ) r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 1 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else r % goto = s ! it's a workflow name end if end if end function parse_rule","tags":"","loc":"proc/parse_rule~2.html"},{"title":"check – AoC-2023","text":"function check(i, j) if the char is part of a number, then get it and append to ivals Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Return Value logical Calls proc~~check~~CallsGraph proc~check problem_3::check proc~get_number problem_3::get_number proc~check->proc~get_number proc~is_number aoc_utilities::is_number proc~check->proc~is_number proc~is_symbol problem_3::is_symbol proc~get_number->proc~is_symbol proc~is_not_number aoc_utilities::is_not_number proc~is_symbol->proc~is_not_number proc~is_not_number->proc~is_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check~~CalledByGraph proc~check problem_3::check program~problem_3 problem_3 program~problem_3->proc~check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function check ( i , j ) !! if the char is part of a number, then get it and append to ivals integer , intent ( in ) :: i , j check = is_number ( array ( i , j )) if ( check ) ivals = [ ivals , get_number ( i , j )] end function check","tags":"","loc":"proc/check.html"},{"title":"is_symbol – AoC-2023","text":"function is_symbol(c) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical Calls proc~~is_symbol~~CallsGraph proc~is_symbol problem_3::is_symbol proc~is_not_number aoc_utilities::is_not_number proc~is_symbol->proc~is_not_number proc~is_number aoc_utilities::is_number proc~is_not_number->proc~is_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~is_symbol~~CalledByGraph proc~is_symbol problem_3::is_symbol proc~get_number problem_3::get_number proc~get_number->proc~is_symbol program~problem_3 problem_3 program~problem_3->proc~is_symbol program~problem_3->proc~get_number proc~check problem_3::check program~problem_3->proc~check proc~check->proc~get_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function is_symbol ( c ) character ( len = 1 ), intent ( in ) :: c is_symbol = is_not_number ( c ) . and . c /= '.' end function is_symbol","tags":"","loc":"proc/is_symbol.html"},{"title":"get_number – AoC-2023","text":"function get_number(i, j) get the full number contining the character at i,j Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Return Value integer(kind=int64) Calls proc~~get_number~~CallsGraph proc~get_number problem_3::get_number proc~is_symbol problem_3::is_symbol proc~get_number->proc~is_symbol proc~is_not_number aoc_utilities::is_not_number proc~is_symbol->proc~is_not_number proc~is_number aoc_utilities::is_number proc~is_not_number->proc~is_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_number~~CalledByGraph proc~get_number problem_3::get_number proc~check problem_3::check proc~check->proc~get_number program~problem_3 problem_3 program~problem_3->proc~get_number program~problem_3->proc~check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code integer ( int64 ) function get_number ( i , j ) !! get the full number contining the character at i,j integer , intent ( in ) :: i , j jstart = j jend = j do if ( array ( i , jstart - 1 ) == '.' . or . is_symbol ( array ( i , jstart - 1 ))) exit jstart = jstart - 1 end do do if ( array ( i , jend + 1 ) == '.' . or . is_symbol ( array ( i , jend + 1 ))) exit jend = jend + 1 end do get_number = int ( array ( i , jstart : jend )) end function get_number","tags":"","loc":"proc/get_number.html"},{"title":"moves – AoC-2023","text":"pure function moves(istart, iend) result(imoves) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: istart indices for start and end nodes integer(kind=ip), intent(in) :: iend indices for start and end nodes Return Value integer(kind=ip) Called by proc~~moves~~CalledByGraph proc~moves problem_8::moves program~problem_8 problem_8 program~problem_8->proc~moves Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function moves ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart , iend !! indices for start and end nodes integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( idx == iend ) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves","tags":"","loc":"proc/moves.html"},{"title":"moves_any_z – AoC-2023","text":"pure function moves_any_z(istart, iend) result(imoves) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: istart indices for start and end nodes integer(kind=ip), intent(in), dimension(:) :: iend Return Value integer(kind=ip) Called by proc~~moves_any_z~~CalledByGraph proc~moves_any_z problem_8::moves_any_z program~problem_8 problem_8 program~problem_8->proc~moves_any_z Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function moves_any_z ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart !! indices for start and end nodes integer ( ip ), dimension (:), intent ( in ) :: iend integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( any ( idx == iend )) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves_any_z","tags":"","loc":"proc/moves_any_z.html"},{"title":"all_in_set – AoC-2023","text":"pure function all_in_set(ivals, iset) returns true if all the elements of ivals are in the set iset Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals integer(kind=ip), intent(in), dimension(:) :: iset Return Value logical Source Code pure logical function all_in_set ( ivals , iset ) !! returns true if all the elements of ivals are in the set iset integer ( ip ), dimension (:), intent ( in ) :: ivals , iset integer :: i all_in_set = . true . do i = 1 , size ( ivals ) if (. not . any ( ivals ( i ) == iset )) then all_in_set = . false . exit end if end do end function all_in_set","tags":"","loc":"proc/all_in_set.html"},{"title":"find_node – AoC-2023","text":"pure function find_node(name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value integer(kind=ip) Called by proc~~find_node~~CalledByGraph proc~find_node problem_8::find_node program~problem_8 problem_8 program~problem_8->proc~find_node Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer ( ip ) function find_node ( name ) character ( len =* ), intent ( in ) :: name integer ( ip ) :: i do i = 1 , size ( nodes ) if ( name == nodes ( i )% name ) then find_node = i return end if end do error stop 'could not find node' end function find_node","tags":"","loc":"proc/find_node.html"},{"title":"index_in_queue – AoC-2023","text":"function index_in_queue(state) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state Return Value integer(kind=ip) index in the queue. -1 if not present Calls proc~~index_in_queue~~CallsGraph proc~index_in_queue problem_17::index_in_queue proc~get_from_cache aoc_cache_module::function_cache%get_from_cache proc~index_in_queue->proc~get_from_cache proc~put_in_cache aoc_cache_module::function_cache%put_in_cache proc~index_in_queue->proc~put_in_cache proc~vector_djb_hash aoc_cache_module::vector_djb_hash proc~get_from_cache->proc~vector_djb_hash Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~index_in_queue~~CalledByGraph proc~index_in_queue problem_17::index_in_queue proc~check~2 problem_17::check proc~check~2->proc~index_in_queue program~problem_17 problem_17 program~problem_17->proc~check~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function index_in_queue ( state ) result ( idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ) :: idx !! index in the queue. -1 if not present integer ( ip ) :: i logical :: found integer ( ip ) :: cache_idx , cache_ival call cache % get ( state , cache_idx , cache_ival , found ) if ( found ) then idx = cache_ival else idx = - 1 if (. not . allocated ( queue )) error stop 'error: queue not allocated' do i = 1 , queue_size if ( all ( state == queue ( i )% state )) then idx = i exit end if end do if ( idx /= - 1 ) call cache % put ( cache_idx , state , idx ) end if end function index_in_queue","tags":"","loc":"proc/index_in_queue.html"},{"title":"check – AoC-2023","text":"subroutine check(idx, idirection) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: idx integer(kind=ip), intent(in) :: idirection direction to move from current Calls proc~~check~2~~CallsGraph proc~check~2 problem_17::check proc~add_to_queue problem_17::add_to_queue proc~check~2->proc~add_to_queue proc~index_in_queue problem_17::index_in_queue proc~check~2->proc~index_in_queue proc~expand_queue problem_17::expand_queue proc~add_to_queue->proc~expand_queue proc~get_from_cache aoc_cache_module::function_cache%get_from_cache proc~index_in_queue->proc~get_from_cache proc~put_in_cache aoc_cache_module::function_cache%put_in_cache proc~index_in_queue->proc~put_in_cache proc~vector_djb_hash aoc_cache_module::vector_djb_hash proc~get_from_cache->proc~vector_djb_hash Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check~2~~CalledByGraph proc~check~2 problem_17::check program~problem_17 problem_17 program~problem_17->proc~check~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine check ( idx , idirection ) implicit none integer ( ip ), intent ( in ) :: idx ! current item in the queue to process integer ( ip ), intent ( in ) :: idirection !! direction to move from current integer ( ip ) :: alt integer ( ip ), dimension ( 2 ) :: v ! neighbor to move to integer ( ip ) :: imovesv , idxv , distv integer ( ip ), dimension ( NSTATE ) :: istate logical :: in_queue associate ( i => queue ( idx )% state ( 1 ), & j => queue ( idx )% state ( 2 ), & direction => queue ( idx )% state ( 3 ), & n_moves => queue ( idx )% state ( 4 )) if ( direction ==- idirection ) return ! can't reverse ! the one to go to: if ( direction == idirection ) then if ( n_moves == MAX_MOVES_IN_DIR ) return ! can't move in this direction anymore imovesv = n_moves + 1 else if ( n_moves /= 0 . and . n_moves < 4 ) return ! must move at last 4 before a turn! imovesv = 1 ! reset on change of direction end if select case ( idirection ) case ( UP ); v = [ i - 1 , j ] case ( DOWN ); v = [ i + 1 , j ] case ( LEFT ); v = [ i , j - 1 ] case ( RIGHT ); v = [ i , j + 1 ] end select if ( v ( 1 ) < 1 . or . v ( 2 ) < 1 . or . v ( 1 ) > n_rows . or . v ( 2 ) > n_cols ) return ! can't go off the board if ( v ( 1 ) == n_rows . and . v ( 2 ) == n_cols . and . imovesv < 4 ) return ! require at least 4 to end istate = [ v ( 1 ), v ( 2 ), idirection , imovesv ] ! new state idxv = index_in_queue ( istate ) ! is it already in the queue in_queue = idxv > 0 ! if this one is already part of another path if ( in_queue ) then if ( queue ( idxv )% visited ) return ! already visited this one distv = queue ( idxv )% dist ! distance in the queue else !call add_to_queue(istate, idxv) ! add this to the queue for processing ! always add it ?? distv = huge ( 1_ip ) ! not processed yet, so huge number end if !alt = queue(idx)%dist + map(queue(idxv)%state(1), queue(idxv)%state(2)) alt = queue ( idx )% dist + map ( v ( 1 ), v ( 2 )) ! new distance if ( alt < distv ) then ! the new one is better, so replace values in the queue if (. not . in_queue ) call add_to_queue ( istate , idxv ) ! only add it if we accept it ???? ! accept this step queue ( idxv )% dist = alt ! new best dist queue ( idxv )% iprev = idx ! previous end if end associate end subroutine check","tags":"","loc":"proc/check~2.html"},{"title":"add_to_queue – AoC-2023","text":"subroutine add_to_queue(state, idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state integer(kind=ip), intent(out) :: idx index of the element in the queue Calls proc~~add_to_queue~~CallsGraph proc~add_to_queue problem_17::add_to_queue proc~expand_queue problem_17::expand_queue proc~add_to_queue->proc~expand_queue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~add_to_queue~~CalledByGraph proc~add_to_queue problem_17::add_to_queue proc~check~2 problem_17::check proc~check~2->proc~add_to_queue program~problem_17 problem_17 program~problem_17->proc~add_to_queue program~problem_17->proc~check~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine add_to_queue ( state , idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ), intent ( out ) :: idx !! index of the element in the queue if ( allocated ( queue )) then call expand_queue ( queue , queue_size , item ( state = state )) idx = queue_size else queue = [ item ( state = state )] queue_size = 1 idx = 1 end if end subroutine add_to_queue","tags":"","loc":"proc/add_to_queue.html"},{"title":"expand_queue – AoC-2023","text":"pure subroutine expand_queue(vec, n, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name type( item ), intent(inout), dimension(:), allocatable :: vec integer(kind=ip), intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call type( item ), intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) Called by proc~~expand_queue~~CalledByGraph proc~expand_queue problem_17::expand_queue proc~add_to_queue problem_17::add_to_queue proc~add_to_queue->proc~expand_queue proc~check~2 problem_17::check proc~check~2->proc~add_to_queue program~problem_17 problem_17 program~problem_17->proc~add_to_queue program~problem_17->proc~check~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine expand_queue ( vec , n , val , finished ) integer ( ip ), parameter :: chunk_size = 1000 type ( item ), dimension (:), allocatable , intent ( inout ) :: vec integer ( ip ), intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call type ( item ), intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) type ( item ), dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_queue","tags":"","loc":"proc/expand_queue.html"},{"title":"go – AoC-2023","text":"function go(time, distance) result(iproduct) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: time integer(kind=ip), intent(in), dimension(:) :: distance Return Value integer(kind=ip) Called by proc~~go~8~~CalledByGraph proc~go~8 problem_6::go program~problem_6 problem_6 program~problem_6->proc~go~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function go ( time , distance ) result ( iproduct ) integer ( ip ), dimension (:), intent ( in ) :: time integer ( ip ), dimension (:), intent ( in ) :: distance integer ( ip ) :: iproduct integer ( ip ) :: i , ihold , iways , idistance iproduct = 1 do i = 1 , size ( time ) iways = 0 do ihold = 1 , time ( i ) ! time to hold the button idistance = ihold * ( time ( i ) - ihold ) if ( idistance > distance ( i )) iways = iways + 1 end do iproduct = iproduct * iways end do end function go","tags":"","loc":"proc/go~8.html"},{"title":"index_in_queue – AoC-2023","text":"function index_in_queue(state) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state Return Value integer(kind=ip) index in the queue. -1 if not present Called by proc~~index_in_queue~2~~CalledByGraph proc~index_in_queue~2 problem_17::index_in_queue proc~check~3 problem_17::check proc~check~3->proc~index_in_queue~2 program~problem_17~2 problem_17 program~problem_17~2->proc~check~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function index_in_queue ( state ) result ( idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ) :: idx !! index in the queue. -1 if not present integer :: i idx = - 1 if (. not . allocated ( queue )) error stop 'error: queue not allocated' do i = 1 , size ( queue ) if ( all ( state == queue ( i )% state )) then idx = i return end if end do end function index_in_queue","tags":"","loc":"proc/index_in_queue~2.html"},{"title":"check – AoC-2023","text":"subroutine check(idx, idirection) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: idx integer(kind=ip), intent(in) :: idirection direction to move from current Calls proc~~check~3~~CallsGraph proc~check~3 problem_17::check proc~add_to_queue~2 problem_17::add_to_queue proc~check~3->proc~add_to_queue~2 proc~index_in_queue~2 problem_17::index_in_queue proc~check~3->proc~index_in_queue~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check~3~~CalledByGraph proc~check~3 problem_17::check program~problem_17~2 problem_17 program~problem_17~2->proc~check~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine check ( idx , idirection ) implicit none integer ( ip ), intent ( in ) :: idx ! current item in the queue to process integer ( ip ), intent ( in ) :: idirection !! direction to move from current integer ( ip ) :: alt integer ( ip ), dimension ( 2 ) :: v ! neighbor to move to integer ( ip ) :: imovesv , idxv , distv integer ( ip ), dimension ( NSTATE ) :: istate logical :: in_queue associate ( i => queue ( idx )% state ( 1 ), & j => queue ( idx )% state ( 2 ), & direction => queue ( idx )% state ( 3 ), & n_moves => queue ( idx )% state ( 4 )) if ( direction ==- idirection ) return ! can't reverse ! the one to go to: if ( direction == idirection ) then if ( n_moves == MAX_MOVES_IN_DIR ) return ! can't move in this direction anymore imovesv = n_moves + 1 else imovesv = 1 ! reset on change of direction end if select case ( idirection ) case ( UP ); v = [ i - 1 , j ] case ( DOWN ); v = [ i + 1 , j ] case ( LEFT ); v = [ i , j - 1 ] case ( RIGHT ); v = [ i , j + 1 ] end select if ( v ( 1 ) < 1 . or . v ( 2 ) < 1 . or . v ( 1 ) > n_rows . or . v ( 2 ) > n_cols ) return ! can't go off the board istate = [ v ( 1 ), v ( 2 ), idirection , imovesv ] ! new state idxv = index_in_queue ( istate ) ! is it already in the queue in_queue = idxv > 0 ! if this one is already part of another path if ( in_queue ) then if ( queue ( idxv )% visited ) return ! already visited this one distv = queue ( idxv )% dist ! distance in the queue else !call add_to_queue(istate, idxv) ! add this to the queue for processing ! always add it ?? distv = huge ( 1_ip ) ! not processed yet, so huge number end if !alt = queue(idx)%dist + map(queue(idxv)%state(1), queue(idxv)%state(2)) alt = queue ( idx )% dist + map ( v ( 1 ), v ( 2 )) ! new distance if ( alt < distv ) then ! the new one is better, so replace values in the queue if (. not . in_queue ) call add_to_queue ( istate , idxv ) ! only add it if we accept it ???? ! accept this step queue ( idxv )% dist = alt ! new best dist queue ( idxv )% iprev = idx ! previous end if end associate end subroutine check","tags":"","loc":"proc/check~3.html"},{"title":"add_to_queue – AoC-2023","text":"subroutine add_to_queue(state, idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state integer(kind=ip), intent(out) :: idx index of the element in the queue Called by proc~~add_to_queue~2~~CalledByGraph proc~add_to_queue~2 problem_17::add_to_queue proc~check~3 problem_17::check proc~check~3->proc~add_to_queue~2 program~problem_17~2 problem_17 program~problem_17~2->proc~add_to_queue~2 program~problem_17~2->proc~check~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine add_to_queue ( state , idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ), intent ( out ) :: idx !! index of the element in the queue if ( allocated ( queue )) then queue = [ queue , item ( state = state )] idx = size ( queue ) else queue = [ item ( state = state )] idx = 1 end if end subroutine add_to_queue","tags":"","loc":"proc/add_to_queue~2.html"},{"title":"aoc_utilities – AoC-2023","text":"Helper classes and routines for Advent of Code Author Jacob Williams hex string to int value. lowercase letters assumed!\n  no error checking here! Uses iso_fortran_env module~~aoc_utilities~~UsesGraph module~aoc_utilities aoc_utilities iso_fortran_env iso_fortran_env module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aoc_utilities~~UsedByGraph module~aoc_utilities aoc_utilities module~problem_15_module problem_15_module module~problem_15_module->module~aoc_utilities program~problem_1 problem_1 program~problem_1->module~aoc_utilities program~problem_10 problem_10 program~problem_10->module~aoc_utilities program~problem_11 problem_11 program~problem_11->module~aoc_utilities program~problem_12 problem_12 program~problem_12->module~aoc_utilities program~problem_12b problem_12b program~problem_12b->module~aoc_utilities program~problem_13 problem_13 program~problem_13->module~aoc_utilities program~problem_15 problem_15 program~problem_15->module~aoc_utilities program~problem_15->module~problem_15_module program~problem_16 problem_16 program~problem_16->module~aoc_utilities program~problem_17 problem_17 program~problem_17->module~aoc_utilities program~problem_17~2 problem_17 program~problem_17~2->module~aoc_utilities program~problem_18 problem_18 program~problem_18->module~aoc_utilities program~problem_19 problem_19 program~problem_19->module~aoc_utilities program~problem_19b problem_19b program~problem_19b->module~aoc_utilities program~problem_2 problem_2 program~problem_2->module~aoc_utilities program~problem_21 problem_21 program~problem_21->module~aoc_utilities program~problem_23 problem_23 program~problem_23->module~aoc_utilities program~problem_24 problem_24 program~problem_24->module~aoc_utilities program~problem_3 problem_3 program~problem_3->module~aoc_utilities program~problem_4 problem_4 program~problem_4->module~aoc_utilities program~problem_5 problem_5 program~problem_5->module~aoc_utilities program~problem_6 problem_6 program~problem_6->module~aoc_utilities program~problem_7 problem_7 program~problem_7->module~aoc_utilities program~problem_8 problem_8 program~problem_8->module~aoc_utilities program~problem_9 problem_9 program~problem_9->module~aoc_utilities Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, private, parameter :: chunk_size = 100 for dynamic allocations type( clock ), public :: clk a public clock to use for timing in the problems Interfaces public        interface sort private  subroutine sort_ascending (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_64 (ivec) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:) :: ivec public        interface parse private  function parse_nums64 (line) result(ints) parse space-deliminated int64 sequence (positive or negative) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=int64), dimension(:), allocatable public        interface split private pure function split1 (str, token) result(vals) Split a character string using a token.\n  This routine is inspired by the Python split function. Example character ( len = :), allocatable :: s type ( string ), dimension (:), allocatable :: vals s = '1,2,3,4,5' call split ( s , ',' , vals ) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable private pure function split2 (s, token) result(vals) Split a string , given a token. Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: s character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable public        interface int private pure elemental function string_to_int (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer private pure function char_to_int (str) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer private pure function char_to_int64 (str, kind) result(i) Basic string to integer(ip) routine.\nHacky hack just so we can overload as int() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: kind Return Value integer(kind=int64) private pure function char_array_to_int (str_array) result(i) Character array to integer routine Arguments Type Intent Optional Attributes Name character(len=1), intent(in), dimension(:) :: str_array example ['1','3'] --> 13 Return Value integer public        interface unique private  function unique32 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec Return Value integer, dimension(:), allocatable private  function unique64 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: vec Return Value integer(kind=int64), dimension(:), allocatable public        interface startswith test if a string starts with a specified substring private pure function startswith_cc (str, substring) starts with function for strings Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_ss (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str type( string ), intent(in) :: substring Return Value logical private pure function startswith_sc (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_cs (str, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str type( string ), intent(in) :: substring Return Value logical public        interface swap private pure elemental subroutine swap32 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap64 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: i1 integer(kind=int64), intent(inout) :: i2 private pure elemental subroutine swap_str (i1, i2) Swap two character string values Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: i1 character(len=*), intent(inout) :: i2 public        interface manhatten_distance private pure function manhatten_distance_64 (x1, y1, x2, y2) Manhattan distance between two int64 points. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x1 integer(kind=int64), intent(in) :: y1 integer(kind=int64), intent(in) :: x2 integer(kind=int64), intent(in) :: y2 Return Value integer(kind=int64) Derived Types type, public :: clock Components Type Visibility Attributes Name Initial integer(kind=int64), private :: begin integer(kind=int64), private :: end integer(kind=int64), private :: rate Type-Bound Procedures procedure, public :: tic => clock_start procedure, public :: toc => clock_end type, public :: string a type containing an allocatable character string.\nso we can have an array of strings of different lengths. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: str Type-Bound Procedures procedure, public :: to_int => string_to_int convert to integer procedure, public :: to_int_64 => string_to_int_64 type, public :: int64_vec an type that contains an allocatable int64 array.\nso we can have an array of these. Components Type Visibility Attributes Name Initial integer(kind=int64), public, dimension(:), allocatable :: vals Functions private pure function char_to_int (str) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer private pure elemental function string_to_int (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer private pure elemental function string_to_int_64 (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer(kind=int64) private pure function char_to_int64 (str, kind) result(i) Basic string to integer(ip) routine.\nHacky hack just so we can overload as int() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: kind Return Value integer(kind=int64) private pure function char_array_to_int (str_array) result(i) Character array to integer routine Arguments Type Intent Optional Attributes Name character(len=1), intent(in), dimension(:) :: str_array example ['1','3'] --> 13 Return Value integer public pure function int_array_to_char_array (iarray) result(carray) integer array to Character array Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: iarray Return Value character(len=1), dimension(:,:), allocatable public  function read_file_to_char_array (filename, border) result(array) Read a file into a 2d character array. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=1), intent(in), optional :: border if true, extra border is added with this char Return Value character(len=1), dimension(:,:), allocatable public  function read_file_to_int_array (filename) result(array) Read a file into a 2d character array. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer, dimension(:,:), allocatable public  function read_file_to_integer_array (filename) result(iarray) Read a file into an integer array (one element per line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer, dimension(:), allocatable public  function read_file_to_integer64_array (filename) result(iarray) Read a file into an int64 integer array (one element per line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer(kind=int64), dimension(:), allocatable public  function number_of_lines_in_file (iunit) result(n_lines) Returns the number of lines in a file (assumed to be open) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit the file unit number\n(assumed to be open) Return Value integer the number of lines in the file private pure function split2 (s, token) result(vals) Split a string , given a token. Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: s character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable private pure function split1 (str, token) result(vals) Split a character string using a token.\n  This routine is inspired by the Python split function. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable public  function read_line (iunit, status_ok) result(line) Reads the next line from a file. Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit logical, intent(out), optional :: status_ok true if no problems Return Value character(len=:), allocatable private  function unique32 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec Return Value integer, dimension(:), allocatable private  function unique64 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: vec Return Value integer(kind=int64), dimension(:), allocatable public  function parse_ints (line) result(ints) parse positive ints from a string that also includes text Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer, dimension(:), allocatable public  function parse_ints64 (line) result(ints) Parse positive ints from a string that also includes text Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=int64), dimension(:), allocatable private  function parse_nums64 (line) result(ints) parse space-deliminated int64 sequence (positive or negative) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=int64), dimension(:), allocatable private pure function startswith_cc (str, substring) starts with function for strings Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_ss (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str type( string ), intent(in) :: substring Return Value logical private pure function startswith_sc (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_cs (str, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str type( string ), intent(in) :: substring Return Value logical public  function is_number (c) returns true if the character is a number from 0 to 9. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical public  function is_not_number (c) returns true if the character is not a number. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical public  function str_to_array (s) result(a) convert the character string to an array of characters Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value character(len=1), dimension(len(s)) public pure function lcm (i, j) LCM. based on code from NCAR Command Language Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: i integer(kind=int64), intent(in) :: j Return Value integer(kind=int64) public pure function reverse (ivals) result(ireverse) Reverse an int64 vector Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: ivals Return Value integer(kind=int64), dimension(size(ivals)) public pure function diff (ivals) result(idiff) Difference int64 vector Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: ivals Return Value integer(kind=int64), dimension(:), allocatable public  function parea (x, y, nb) given a sequence of nb points (x(i),y(i)). parea computes\nthe area bounded by the closed polygonal curve which passes\nthrough the points in the order that they are indexed. the\nfinal point of the curve is assumed to be the first point\ngiven. therefore, it need not be listed at the end of x and\ny. the curve is not required to be simple. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (nb) real(kind=wp), intent(in) :: y (nb) integer, intent(in) :: nb Return Value real(kind=wp) private pure function manhatten_distance_64 (x1, y1, x2, y2) Manhattan distance between two int64 points. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x1 integer(kind=int64), intent(in) :: y1 integer(kind=int64), intent(in) :: x2 integer(kind=int64), intent(in) :: y2 Return Value integer(kind=int64) public pure function str_to_int_array_with_mapping (str, ichars, iints) result(array) Convert a string to a numeric array by mapping characters to integers (user-specified) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=1), intent(in), dimension(:) :: ichars characters to process integer, intent(in), dimension(:) :: iints int values of the chars Return Value integer, dimension(:), allocatable public pure function str_to_int64_array_with_mapping (str, ichars, iints) result(array) Convert a string to a numeric array by mapping characters to integers (user-specified) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=1), intent(in), dimension(:) :: ichars characters to process integer(kind=int64), intent(in), dimension(:) :: iints int values of the chars Return Value integer(kind=int64), dimension(:), allocatable public pure function hex2int (hex) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: hex Return Value integer Subroutines private  subroutine clock_start (me) Start the clock Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me private  subroutine clock_end (me, case_str) Print runtime in milliseconds form the start of the clock. Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me character(len=*), intent(in) :: case_str description of the case private  subroutine sort_ascending (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_64 (ivec) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:) :: ivec private pure elemental subroutine swap32 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap64 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: i1 integer(kind=int64), intent(inout) :: i2 private pure elemental subroutine swap_str (i1, i2) Swap two character string values Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: i1 character(len=*), intent(inout) :: i2 private pure subroutine expand_vector (vec, n, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) public pure subroutine locpt (x0, y0, x, y, n, l, m) given a polygonal line connecting the vertices (x(i),y(i))\n  (i = 1,...,n) taken in this order. it is assumed that the\n  polygonal path is a loop, where (x(n),y(n)) = (x(1),y(1))\n  or there is an arc from (x(n),y(n)) to (x(1),y(1)). Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: y0 real(kind=wp), intent(in), dimension(n) :: x real(kind=wp), intent(in), dimension(n) :: y integer, intent(in) :: n integer, intent(out) :: l integer, intent(out) :: m public  subroutine inverse (a, ainv, status_ok) inverse of a 2x2 matrix. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: a real(kind=wp), intent(out), dimension(2,2) :: ainv logical, intent(out) :: status_ok","tags":"","loc":"module/aoc_utilities.html"},{"title":"problem_15_module – AoC-2023","text":"A module for problem 15, part 2. Uses aoc_utilities iso_fortran_env module~~problem_15_module~~UsesGraph module~problem_15_module problem_15_module iso_fortran_env iso_fortran_env module~problem_15_module->iso_fortran_env module~aoc_utilities aoc_utilities module~problem_15_module->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~problem_15_module~~UsedByGraph module~problem_15_module problem_15_module program~problem_15 problem_15 program~problem_15->module~problem_15_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: lens Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: label integer(kind=ip), public :: focal_length = 0 type, public :: box Components Type Visibility Attributes Name Initial type( lens ), public, dimension(:), allocatable :: lenses the lenses in the box Type-Bound Procedures procedure, public :: add_lens procedure, public :: remove_lens Subroutines public  subroutine add_lens (me, l) Arguments Type Intent Optional Attributes Name class( box ), intent(inout) :: me type( lens ), intent(in) :: l lense to add public  subroutine remove_lens (me, label) remove the lens with the label (if present) Arguments Type Intent Optional Attributes Name class( box ), intent(inout) :: me character(len=*), intent(in) :: label","tags":"","loc":"module/problem_15_module.html"},{"title":"aoc_cache_module – AoC-2023","text":"For caching function evaluations. This is based on the cache module from NumDiff .\nIt has been modified to cache integers ( int64 ) instead of reals. Uses iso_fortran_env module~~aoc_cache_module~~UsesGraph module~aoc_cache_module aoc_cache_module iso_fortran_env iso_fortran_env module~aoc_cache_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aoc_cache_module~~UsedByGraph module~aoc_cache_module aoc_cache_module program~problem_12b problem_12b program~problem_12b->module~aoc_cache_module program~problem_17 problem_17 program~problem_17->module~aoc_cache_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, private :: fx an [x,f(x)] cached pair.\nx is a vector and f is a scalar value. Components Type Visibility Attributes Name Initial integer(kind=ip), private, dimension(:), allocatable :: x vector of input values integer(kind=ip), private :: f scalar output function type, public :: function_cache a vector function cache. Components Type Visibility Attributes Name Initial type( fx ), private, dimension(:), allocatable :: c the cache of f(x) integer, private :: chunk_size = 100 for resizing vectors\nin the unique function Type-Bound Procedures procedure, public :: initialize => initialize_cache procedure, public :: get => get_from_cache procedure, public :: put => put_in_cache procedure, public :: destroy => destroy_cache Functions private pure function vector_djb_hash (r) result(hash) DJB hash algorithm for a integer(ip) vector. Read more… Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: r the vector Return Value integer(kind=ip) the hash value Subroutines private  subroutine initialize_cache (me, isize, chunk_size) Initialize the cache. Must be called first before use. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: isize the size of the hash table integer, intent(in), optional :: chunk_size chunk size to speed up reallocation\nof arrays. A good value is a guess for\nthe actual number of elements of f that\nwill be saved per value of x [default is 100] private  subroutine get_from_cache (me, x, i, f, found) Check if the x vector is in the cache, if so return f .\nNote that only some of the elements may be present, so it will return\nthe ones there are there, and indicate which ones were found. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer(kind=ip), intent(in), dimension(:) :: x independant variable vector integer(kind=ip), intent(out) :: i index in the hash table integer(kind=ip), intent(out) :: f f(x) from the cache (if it was found) logical, intent(out) :: found if x was found in the cache private  subroutine put_in_cache (me, i, x, f) Put a value into the cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer(kind=ip), intent(in) :: i index in the hash table integer(kind=ip), intent(in), dimension(:) :: x independant variable vector integer(kind=ip), intent(in) :: f function private  subroutine destroy_cache (me) Destroy a cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(out) :: me","tags":"","loc":"module/aoc_cache_module.html"},{"title":"problem_24 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_24~~UsesGraph program~problem_24 problem_24 iso_fortran_env iso_fortran_env program~problem_24->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_24->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_24~~CallsGraph program~problem_24 problem_24 interface~split aoc_utilities::split program~problem_24->interface~split proc~clock_end aoc_utilities::clock%clock_end program~problem_24->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_24->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_24->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_24->proc~read_line proc~string_to_int_64 aoc_utilities::string%string_to_int_64 program~problem_24->proc~string_to_int_64 proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit integer :: n_lines integer :: i integer :: j character(len=:), allocatable :: line type( string ), dimension(:), allocatable :: vals type( string ), dimension(:), allocatable :: rvals type( string ), dimension(:), allocatable :: vvals integer(kind=ip), dimension(:), allocatable :: xvec integer(kind=ip), dimension(:), allocatable :: yvec integer(kind=ip), dimension(:), allocatable :: zvec integer(kind=ip), dimension(:), allocatable :: vxvec integer(kind=ip), dimension(:), allocatable :: vyvec integer(kind=ip), dimension(:), allocatable :: vzvec integer(kind=ip) :: n_intersections real(kind=wp), dimension(2) :: tvec real(kind=wp), dimension(2) :: xy_inter integer(kind=ip) :: min_val integer(kind=ip) :: max_val Source Code program problem_24 use iso_fortran_env , only : wp => real64 , ip => int64 ! use long ints use aoc_utilities implicit none integer :: iunit , n_lines , i , j character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals , rvals , vvals integer ( ip ), dimension (:), allocatable :: xvec , yvec , zvec , vxvec , vyvec , vzvec integer ( ip ) :: n_intersections real ( wp ), dimension ( 2 ) :: tvec real ( wp ), dimension ( 2 ) :: xy_inter integer ( ip ) :: min_val , max_val call clk % tic () ! read the data: ! open(newunit=iunit, file='inputs/day24_test.txt', status='OLD'); min_val=7_ip; max_val = 27_ip open ( newunit = iunit , file = 'inputs/day24.txt' , status = 'OLD' ); min_val = 20000000000000 0.0_wp ; max_val = 40000000000000 0.0_wp n_lines = number_of_lines_in_file ( iunit ) allocate ( xvec ( 0 ), yvec ( 0 ), zvec ( 0 ), vxvec ( 0 ), vyvec ( 0 ), vzvec ( 0 )) do i = 1 , n_lines line = read_line ( iunit ) vals = split ( line , '@' ) rvals = split ( trim ( vals ( 1 )% str ), ',' ) xvec = [ xvec , rvals ( 1 )% to_int_64 ()] yvec = [ yvec , rvals ( 2 )% to_int_64 ()] zvec = [ zvec , rvals ( 3 )% to_int_64 ()] vvals = split ( trim ( vals ( 2 )% str ), ',' ) vxvec = [ vxvec , vvals ( 1 )% to_int_64 ()] vyvec = [ vyvec , vvals ( 2 )% to_int_64 ()] vzvec = [ vzvec , vvals ( 3 )% to_int_64 ()] end do close ( iunit ) n_intersections = 0 do i = 1 , n_lines do j = 1 , i - 1 associate ( x => xvec ( i ), y => yvec ( i ), & dx => vxvec ( i ), dy => vyvec ( i ), & u => xvec ( j ), v => yvec ( j ), & du => vxvec ( j ), dv => vyvec ( j ) ) if ( dy * du /= dv * dx ) then tvec = [( dv * ( x - u ) - du * ( y - v )) / ( dy * du - dx * dv ), & ( dy * ( u - x ) - dx * ( v - y )) / ( dv * dx - du * dy ) ] xy_inter = [ x + tvec ( 1 ) * dx , y + tvec ( 1 ) * dy ] if ( all ( tvec > 0.0_wp ) . and . & all ([ xy_inter >= min_val . and . xy_inter <= max_val ])) then n_intersections = n_intersections + 1 end if end if end associate end do end do write ( * , * ) '21a : ' , n_intersections call clk % toc ( '24' ) end program problem_24","tags":"","loc":"program/problem_24.html"},{"title":"problem_21 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_21~~UsesGraph program~problem_21 problem_21 iso_fortran_env iso_fortran_env program~problem_21->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_21->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_21~~CallsGraph program~problem_21 problem_21 proc~clock_end aoc_utilities::clock%clock_end program~problem_21->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_21->proc~clock_start proc~read_file_to_char_array aoc_utilities::read_file_to_char_array program~problem_21->proc~read_file_to_char_array proc~step problem_21::step program~problem_21->proc~step proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial character(len=1), dimension(:,:), allocatable :: array integer :: nrows integer :: ncols integer :: i integer :: j integer, dimension(2) :: iloc integer, dimension(:,:), allocatable :: icount Subroutines recursive subroutine step (array) take all valid steps from any # elements in array Arguments Type Intent Optional Attributes Name character(len=1), intent(inout), dimension(:,:), allocatable :: array Source Code program problem_21 use aoc_utilities use iso_fortran_env , only : wp => real64 , ip => int64 implicit none character ( len = 1 ), dimension (:,:), allocatable :: array integer :: nrows , ncols , i , j integer , dimension ( 2 ) :: iloc integer , dimension (:,:), allocatable :: icount call clk % tic () ! array = read_file_to_char_array('inputs/day21_test.txt', border='#') array = read_file_to_char_array ( 'inputs/day21.txt' , border = '.' ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) allocate ( icount ( nrows , ncols )); icount = 0 iloc = findloc ( array , 'S' ) ! find starting point i = iloc ( 1 ) j = iloc ( 2 ) array ( i , j ) = 'O' ! starting here do i = 1 , 64 call step ( array ) end do write ( * , * ) '21a: ' , count ( array == 'O' ) call clk % toc ( '21' ) contains recursive subroutine step ( array ) !! take all valid steps from any # elements in array character ( len = 1 ), dimension (:,:), intent ( inout ), allocatable :: array integer :: i , j logical :: steped character ( len = 1 ), dimension (:,:), allocatable :: tmp tmp = array do i = 1 , nrows do j = 1 , ncols if ( array ( i , j ) == 'O' ) then steped = . false . ! try a step in each direction: if ( array ( i - 1 , j ) == '.' ) then tmp ( i - 1 , j ) = 'O' ; steped = . true . end if if ( array ( i + 1 , j ) == '.' ) then tmp ( i + 1 , j ) = 'O' ; steped = . true . end if if ( array ( i , j - 1 ) == '.' ) then tmp ( i , j - 1 ) = 'O' ; steped = . true . end if if ( array ( i , j + 1 ) == '.' ) then tmp ( i , j + 1 ) = 'O' ; steped = . true . end if if ( steped ) tmp ( i , j ) = '.' end if end do end do call move_alloc ( tmp , array ) end subroutine step end program problem_21","tags":"","loc":"program/problem_21.html"},{"title":"problem_15 – AoC-2023","text":"Uses aoc_utilities problem_15_module iso_fortran_env program~~problem_15~~UsesGraph program~problem_15 problem_15 iso_fortran_env iso_fortran_env program~problem_15->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_15->module~aoc_utilities module~problem_15_module problem_15_module program~problem_15->module~problem_15_module module~aoc_utilities->iso_fortran_env module~problem_15_module->iso_fortran_env module~problem_15_module->module~aoc_utilities Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_15~~CallsGraph program~problem_15 problem_15 interface~split aoc_utilities::split program~problem_15->interface~split proc~add_lens problem_15_module::box%add_lens program~problem_15->proc~add_lens proc~clock_end aoc_utilities::clock%clock_end program~problem_15->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_15->proc~clock_start proc~hash problem_15::hash program~problem_15->proc~hash proc~read_line aoc_utilities::read_line program~problem_15->proc~read_line proc~remove_lens problem_15_module::box%remove_lens program~problem_15->proc~remove_lens proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: iunit integer :: j type( string ), dimension(:), allocatable :: vals type( string ), dimension(:), allocatable :: vals2 integer(kind=ip), dimension(:), allocatable :: ivals type( box ), dimension(0:255) :: boxes integer(kind=ip) :: ibox character(len=:), allocatable :: label integer(kind=ip) :: ival integer(kind=ip) :: focusing_power integer(kind=ip) :: lens_focusing_power Functions pure elemental function hash (s) Determine the ASCII code for the current character of the string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value integer(kind=ip) Source Code program problem_15 use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities use problem_15_module implicit none integer :: i , iunit , j type ( string ), dimension (:), allocatable :: vals , vals2 integer ( ip ), dimension (:), allocatable :: ivals type ( box ), dimension ( 0 : 255 ) :: boxes ! for part 2 integer ( ip ) :: ibox ! 0-255 character ( len = :), allocatable :: label integer ( ip ) :: ival , focusing_power , lens_focusing_power call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day15_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day15.txt' , status = 'OLD' ) vals = split ( read_line ( iunit ), ',' ) close ( iunit ) allocate ( ivals ( size ( vals ))) do i = 1 , size ( vals ) ! part 1: ivals ( i ) = hash ( vals ( i )% str ) ! part 2: if ( index ( vals ( i )% str , '=' ) > 0 ) then vals2 = split ( vals ( i )% str , '=' ) label = vals2 ( 1 )% str ibox = hash ( label ) ival = int ( vals2 ( 2 )% str ) ! focal length call boxes ( ibox )% add_lens ( lens ( label , ival )) else if ( index ( vals ( i )% str , '-' ) > 0 ) then vals2 = split ( vals ( i )% str , '-' ) label = vals2 ( 1 )% str ibox = hash ( label ) call boxes ( ibox )% remove_lens ( label ) end if end do write ( * , * ) '15a: ' , sum ( ivals ) focusing_power = 0 do i = 0 , 255 ! all the boxes if ( allocated ( boxes ( i )% lenses )) then do j = 1 , size ( boxes ( i )% lenses ) ! all the lenses in the box lens_focusing_power = ( i + 1 ) * ( j ) * ( boxes ( i )% lenses ( j )% focal_length ) focusing_power = focusing_power + lens_focusing_power end do end if end do write ( * , * ) '15b: ' , focusing_power call clk % toc ( '15' ) contains pure elemental integer ( ip ) function hash ( s ) !! Determine the ASCII code for the current character of the string. character ( len =* ), intent ( in ) :: s integer :: i hash = 0 do i = 1 , len ( s ) hash = modulo ( 17_ip * ( hash + iachar ( s ( i : i ))), 256_ip ) end do end function hash end program problem_15","tags":"","loc":"program/problem_15.html"},{"title":"problem_19b – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_19b~~UsesGraph program~problem_19b problem_19b iso_fortran_env iso_fortran_env program~problem_19b->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_19b->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. reformulated to operate on ranges of the x,m,a,s ratings Calls program~~problem_19b~~CallsGraph program~problem_19b problem_19b interface~split aoc_utilities::split program~problem_19b->interface~split proc~clock_end aoc_utilities::clock%clock_end program~problem_19b->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_19b->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_19b->proc~number_of_lines_in_file proc~parse_rule problem_19b::parse_rule program~problem_19b->proc~parse_rule proc~process problem_19b::process program~problem_19b->proc~process proc~read_line aoc_utilities::read_line program~problem_19b->proc~read_line proc~workflow_name_to_index problem_19b::workflow_name_to_index program~problem_19b->proc~workflow_name_to_index proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~parse_rule->interface~split proc~process->proc~process proc~process->proc~workflow_name_to_index proc~get_accepted problem_19b::get_accepted proc~process->proc~get_accepted proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit integer :: n_lines integer :: iline integer :: i character(len=:), allocatable :: line type( string ), dimension(:), allocatable :: vals logical :: accepted integer(kind=ip) :: total_accepted type( part ) :: parts type( workflow ), dimension(:), allocatable :: workflows type( workflow ), allocatable :: w Derived Types type :: interval Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(2) :: v [start, end] of the interval type :: part Components Type Visibility Attributes Name Initial type( interval ), public, dimension(4) :: xmas type :: rule Components Type Visibility Attributes Name Initial logical, public :: accept = .false. logical, public :: reject = .false. integer, public :: operator = 0 integer, public :: operator_arg = 0 integer, public :: operator_val = 0 character(len=:), public, allocatable :: goto type :: workflow Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name type( rule ), public, dimension(:), allocatable :: rules Functions recursive function process (iworkflow, irule, p) result(iaccepted) process this part range starting with irule Arguments Type Intent Optional Attributes Name integer, intent(in) :: iworkflow integer, intent(in) :: irule type( part ), intent(in) :: p Return Value integer(kind=ip) function get_accepted (p) count of all the parts in the set Arguments Type Intent Optional Attributes Name type( part ), intent(in) :: p Return Value integer(kind=ip) function workflow_name_to_index (name) result(idx) get the index of this workflow in the array Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value integer function parse_rule (s) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value type( rule ) Source Code program problem_19b !! reformulated to operate on ranges of the x,m,a,s ratings use aoc_utilities use iso_fortran_env , only : wp => real64 , ip => int64 implicit none integer :: iunit , n_lines , iline , i character ( len = :), allocatable :: line !, name type ( string ), dimension (:), allocatable :: vals logical :: accepted integer ( ip ) :: total_accepted type :: interval integer ( ip ), dimension ( 2 ) :: v !! [start, end] of the interval end type interval type :: part type ( interval ), dimension ( 4 ) :: xmas ! [x,m,a,s] ranges end type part type ( part ) :: parts type :: rule logical :: accept = . false . logical :: reject = . false . integer :: operator = 0 ! 1:<, 2:> integer :: operator_arg = 0 ! 1:x, 2:m, 3:a, 4:s integer :: operator_val = 0 ! value to compare to character ( len = :), allocatable :: goto ! where to next (workflow name) end type rule type :: workflow character ( len = :), allocatable :: name type ( rule ), dimension (:), allocatable :: rules end type workflow type ( workflow ), dimension (:), allocatable :: workflows type ( workflow ), allocatable :: w call clk % tic () ! open(newunit=iunit, file='inputs/day19_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day19.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( workflows ( 0 )) do iline = 1 , n_lines line = read_line ( iunit ) if ( line == '' ) exit ! done - dont need the parts list for part b ! parsing workflows : qqz{s>2770:qs,m<1801:hdj,R} if ( allocated ( w )) deallocate ( w ); allocate ( w ) ! blank one vals = split ( line , '{' ) w % name = vals ( 1 )% str ! workflow name !write(*,*) '--->'//w%name//'<-----' vals ( 2 )% str = vals ( 2 )% str ( 1 : len ( vals ( 2 )% str ) - 1 ) ! remove last bracket vals = split ( vals ( 2 )% str , ',' ) ! workflow rules ! add each rule to the workflow allocate ( w % rules ( 0 )) do i = 1 , size ( vals ) w % rules = [ w % rules , parse_rule ( vals ( i )% str )] end do workflows = [ workflows , w ] end do parts = part ( xmas = [ interval ([ 1 , 4000 ]), & interval ([ 1 , 4000 ]), & interval ([ 1 , 4000 ]),& interval ([ 1 , 4000 ])]) i = workflow_name_to_index ( 'in' ) ! start at the first workflow total_accepted = process ( i , 1 , parts ) write ( * , * ) '19b: ' , total_accepted call clk % toc ( '19b' ) contains recursive function process ( iworkflow , irule , p ) result ( iaccepted ) !! process this part range starting with irule integer , intent ( in ) :: iworkflow integer , intent ( in ) :: irule type ( part ), intent ( in ) :: p integer ( ip ) :: iaccepted integer ( ip ), dimension (:), allocatable :: itmp , itmp_t , itmp_f integer ( ip ) :: i type ( part ) :: pt , pf iaccepted = 0 associate ( r => workflows ( iworkflow )% rules ( irule ) ) ! check if we are done if ( r % accept ) then iaccepted = get_accepted ( p ) return else if ( r % reject ) then iaccepted = 0 return end if ! process recursively, by splitting up the intervals when necessary if ( r % operator > 0 ) then ! process the operator select case ( r % operator ) case ( 1 ) ! < ! always create the two sets and process the two cases below ! [note that some sets maybe empty] ! ! example: ![1,200]   < 10   ==> [1,9]    TRUE !                     [10,200] FALSE itmp = [( i , i = p % xmas ( r % operator_arg )% v ( 1 ), p % xmas ( r % operator_arg )% v ( 2 ))] itmp_t = pack ( itmp , mask = itmp < r % operator_val ) !true itmp_f = pack ( itmp , mask = itmp >= r % operator_val ) !false if ( size ( itmp_t ) > 0 ) then ! some are true pt = p pt % xmas ( r % operator_arg )% v = [ itmp_t ( 1 ), itmp_t ( size ( itmp_t ))] if ( r % goto == 'A' ) then iaccepted = iaccepted + get_accepted ( pt ) else if ( r % goto /= 'R' ) then ! go to next workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , pt ) end if end if if ( size ( itmp_f ) > 0 ) then ! some are false pf = p pf % xmas ( r % operator_arg )% v = [ itmp_f ( 1 ), itmp_f ( size ( itmp_f ))] iaccepted = iaccepted + process ( iworkflow , irule + 1 , pf ) ! next rule end if case ( 2 ) ! > itmp = [( i , i = p % xmas ( r % operator_arg )% v ( 1 ), p % xmas ( r % operator_arg )% v ( 2 ))] itmp_t = pack ( itmp , mask = itmp > r % operator_val ) !true itmp_f = pack ( itmp , mask = itmp <= r % operator_val ) !false if ( size ( itmp_t ) > 0 ) then ! some are true pt = p pt % xmas ( r % operator_arg )% v = [ itmp_t ( 1 ), itmp_t ( size ( itmp_t ))] if ( r % goto == 'A' ) then iaccepted = iaccepted + get_accepted ( pt ) else if ( r % goto /= 'R' ) then ! go to next workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , pt ) end if end if if ( size ( itmp_f ) > 0 ) then ! some are false pf = p pf % xmas ( r % operator_arg )% v = [ itmp_f ( 1 ), itmp_f ( size ( itmp_f ))] iaccepted = iaccepted + process ( iworkflow , irule + 1 , pf ) ! next rule end if end select else ! goto another workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , p ) end if end associate !end do end function process integer ( ip ) function get_accepted ( p ) !! count of all the parts in the set type ( part ), intent ( in ) :: p get_accepted = ( 1 + ( p % xmas ( 1 )% v ( 2 ) - p % xmas ( 1 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 2 )% v ( 2 ) - p % xmas ( 2 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 3 )% v ( 2 ) - p % xmas ( 3 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 4 )% v ( 2 ) - p % xmas ( 4 )% v ( 1 ))) end function get_accepted function workflow_name_to_index ( name ) result ( idx ) !! get the index of this workflow in the array character ( len =* ), intent ( in ) :: name integer :: idx do idx = 1 , size ( workflows ) if ( name == workflows ( idx )% name ) return ! found it end do if ( idx > size ( workflows )) error stop 'workflow not found: ' // name end function workflow_name_to_index function parse_rule ( s ) result ( r ) character ( len =* ), intent ( in ) :: s type ( rule ) :: r type ( string ), dimension (:), allocatable :: v character ( len =* ), parameter :: xmas = 'xmas' ! 1,2,3,4 if ( s == 'A' ) then r % accept = . true . else if ( s == 'R' ) then r % reject = . true . else if ( index ( s , '>' ) > 0 ) then v = split ( s ( 3 :), ':' ) ! example: a<2006:qkq r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 2 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else if ( index ( s , '<' ) > 0 ) then v = split ( s ( 3 :), ':' ) r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 1 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else r % goto = s ! it's a workflow name end if end if end function parse_rule end program problem_19b","tags":"","loc":"program/problem_19b.html"},{"title":"problem_10 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_10~~UsesGraph program~problem_10 problem_10 iso_fortran_env iso_fortran_env program~problem_10->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_10->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_10~~CallsGraph program~problem_10 problem_10 proc~clock_end aoc_utilities::clock%clock_end program~problem_10->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_10->proc~clock_start proc~locpt aoc_utilities::locpt program~problem_10->proc~locpt proc~move problem_10::move program~problem_10->proc~move proc~read_file_to_char_array aoc_utilities::read_file_to_char_array program~problem_10->proc~read_file_to_char_array proc~move->proc~move proc~pipe_info problem_10::pipe_info proc~move->proc~pipe_info proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: j integer :: nrows integer :: ncols integer :: imove integer :: l integer :: m logical, dimension(:,:), allocatable :: icounts character(len=1), dimension(:,:), allocatable :: array integer, dimension(:,:), allocatable :: distance integer, dimension(:,:), allocatable :: distance_reverse logical, dimension(:,:), allocatable :: visited real(kind=wp), dimension(:), allocatable :: x path cooidinates real(kind=wp), dimension(:), allocatable :: y path cooidinates integer, dimension(2) :: Sij i,j of the S char in array Functions pure function pipe_info (p) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: p Return Value character(len=2) Subroutines recursive subroutine move (i, j, direction, distance, save_path) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: direction integer, intent(inout), dimension(:,:) :: distance logical, intent(in) :: save_path to save the path coordinates Source Code program problem_10 use iso_fortran_env , ip => int64 , wp => real64 use aoc_utilities implicit none integer :: i , j , nrows , ncols , imove , l , m logical , dimension (:,:), allocatable :: icounts character ( len = 1 ), dimension (:,:), allocatable :: array integer , dimension (:,:), allocatable :: distance , distance_reverse logical , dimension (:,:), allocatable :: visited real ( wp ), dimension (:), allocatable :: x , y !! path cooidinates integer , dimension ( 2 ) :: Sij !! i,j of the S char in array call clk % tic () array = read_file_to_char_array ( 'inputs/day10.txt' , '.' ) ! pad with . to simplify edge logic nrows = size ( array , 1 ) ncols = size ( array , 2 ) allocate ( distance ( nrows , ncols )); distance = - 1 allocate ( distance_reverse ( nrows , ncols )); distance_reverse = - 1 allocate ( visited ( nrows , ncols )) ! start at the S coordinate: Sij = findloc ( array , 'S' ) x = [ Sij ( 1 )] ! to store the path for part b y = [ Sij ( 2 )] ! traverse the maze: visited = . false .; visited ( Sij ( 1 ), Sij ( 2 )) = . true .; distance ( Sij ( 1 ), Sij ( 2 )) = 0 do imove = 1 , 4 call move ( Sij ( 1 ), Sij ( 2 ), imove , distance , . true .) end do ! traverse the maze again in reverse: visited = . false .; visited ( Sij ( 1 ), Sij ( 2 )) = . true .; distance_reverse ( Sij ( 1 ), Sij ( 2 )) = 0 do imove = 4 , 1 , - 1 call move ( Sij ( 1 ), Sij ( 2 ), imove , distance_reverse , . false .) end do ! where they match is the distance furthest away from the start write ( * , * ) '10a: ' , pack ( distance , mask = ( distance == distance_reverse . and . distance > 0 )) ! for part b, use locpt to test all the points ! allow openmp to be used here to do each row in parallel allocate ( icounts ( nrows , ncols )); icounts = . false . !$OMP PARALLEL DO SHARED(icounts,x,y) PRIVATE(i,j,l,m) do i = 2 , nrows - 1 ! we can skip the padding do j = 2 , ncols - 1 if ( any ( i == x . and . j == y )) cycle ! skip if on path call locpt ( real ( i , wp ), real ( j , wp ), x , y , size ( x ), l , m ) if ( l == 1 ) icounts ( i , j ) = . true . ! if (i,j) is inside the polygonal path end do end do !$OMP END PARALLEL DO write ( * , * ) '10b: ' , count ( icounts ) call clk % toc ( '10' ) contains recursive subroutine move ( i , j , direction , distance , save_path ) integer , intent ( in ) :: i , j , direction integer , dimension (:,:), intent ( inout ) :: distance logical , intent ( in ) :: save_path !! to save the path coordinates integer :: inew , jnew , imove logical :: valid_move select case ( direction ) case ( 1 ); inew = i - 1 ; jnew = j ! north case ( 2 ); inew = i + 1 ; jnew = j ! south case ( 3 ); inew = i ; jnew = j + 1 ! east case ( 4 ); inew = i ; jnew = j - 1 ! west end select if ( visited ( inew , jnew ) . or . array ( inew , jnew ) == '.' ) return ! can we move in this direction? valid_move = . false . associate ( current_pipe => array ( i , j ), & current_distance => distance ( i , j ), & move_to => array ( inew , jnew ) ) select case ( current_pipe ) case ( 'S' ) ! don't know what the first pip is, so have to try them all select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '|' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south end select case ( '-' ) select case ( direction ) case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'L' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select case ( 'J' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '7' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'F' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select end select if ( valid_move ) then distance ( inew , jnew ) = current_distance + 1 visited ( inew , jnew ) = . true . do imove = 1 , 4 call move ( inew , jnew , imove , distance , save_path ) end do if ( save_path ) then x = [ x , real ( inew , wp )] ! save cordinates of point on the path y = [ y , real ( jnew , wp )] end if end if end associate end subroutine move pure character ( len = 2 ) function pipe_info ( p ) character ( len = 1 ), intent ( in ) :: p select case ( p ) case ( '|' ); pipe_info = 'NS' ! | is a vertical pipe connecting north and south. case ( '-' ); pipe_info = 'EW' ! - is a horizontal pipe connecting east and west. case ( 'L' ); pipe_info = 'NE' ! L is a 90-degree bend connecting north and east. case ( 'J' ); pipe_info = 'NW' ! J is a 90-degree bend connecting north and west. case ( '7' ); pipe_info = 'SW' ! 7 is a 90-degree bend connecting south and west. case ( 'F' ); pipe_info = 'SE' ! F is a 90-degree bend connecting south and east. end select end function pipe_info end program problem_10","tags":"","loc":"program/problem_10.html"},{"title":"problem_7 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_7~~UsesGraph program~problem_7 problem_7 iso_fortran_env iso_fortran_env program~problem_7->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_7->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_7~~CallsGraph program~problem_7 problem_7 interface~split aoc_utilities::split program~problem_7->interface~split proc~beats problem_7::beats program~problem_7->proc~beats proc~clock_end aoc_utilities::clock%clock_end program~problem_7->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_7->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_7->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_7->proc~read_line proc~str_to_array aoc_utilities::str_to_array program~problem_7->proc~str_to_array proc~swap_hands problem_7::swap_hands program~problem_7->proc~swap_hands proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~hand_type problem_7::hand_type proc~beats->proc~hand_type proc~index_in_cards problem_7::index_in_cards proc~beats->proc~index_in_cards interface~unique aoc_utilities::unique proc~hand_type->interface~unique proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: iunit integer :: n_lines integer :: icase character(len=:), allocatable :: line type( string ), dimension(:), allocatable :: vals logical :: done type( hand ), dimension(:), allocatable :: hands array of hands character(len=1), parameter,               dimension(2) :: cases = ['a', 'b'] character(len=1), parameter,               dimension(*) :: cards = ['A', 'K', 'Q', 'J', 'T', '9', '8', '7', '6', '5', '4', '3', '2'] character(len=1), parameter,               dimension(*) :: cards_with_joker = ['A', 'K', 'Q', 'T', '9', '8', '7', '6', '5', '4', '3', '2', 'J'] integer, parameter :: FIVE_OF_A_KIND = 1 integer, parameter :: FOUR_OF_A_KIND = 2 integer, parameter :: FULL_HOUSE = 3 integer, parameter :: THREE_OF_A_KIND = 4 integer, parameter :: TWO_PAIR = 5 integer, parameter :: ONE_PAIR = 6 integer, parameter :: HIGH_CARD = 7 Derived Types type :: hand Components Type Visibility Attributes Name Initial character(len=1), public, dimension(5) :: cards the cards in a hand integer(kind=ip), public :: bid = 0 integer, public :: type = 0 Functions function hand_type (me, with_jokers) returns the type of hand Arguments Type Intent Optional Attributes Name class( hand ), intent(in) :: me logical, intent(in) :: with_jokers if considering jokers Return Value integer function beats (hand1, hand2, with_jokers) return true if hand1 beats hand2 (has a higher score) Arguments Type Intent Optional Attributes Name class( hand ), intent(inout) :: hand1 class( hand ), intent(inout) :: hand2 logical, intent(in) :: with_jokers if considering jokers Return Value logical function index_in_cards (c, with_jokers) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c logical, intent(in) :: with_jokers if considering jokers Return Value integer Subroutines pure elemental subroutine swap_hands (i1, i2) swap function for hand type Arguments Type Intent Optional Attributes Name type( hand ), intent(inout) :: i1 type( hand ), intent(inout) :: i2 Source Code program problem_7 use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none integer :: i , iunit , n_lines , icase character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals logical :: done type :: hand character ( len = 1 ), dimension ( 5 ) :: cards !! the cards in a hand integer ( ip ) :: bid = 0 ! the bit for the hand integer :: type = 0 ! the hand type end type hand type ( hand ), dimension (:), allocatable :: hands !! array of hands character ( len = 1 ), dimension ( 2 ), parameter :: cases = [ 'a' , 'b' ] character ( len = 1 ), dimension ( * ), parameter :: cards = [ 'A' , 'K' , 'Q' , 'J' , 'T' , & '9' , '8' , '7' , '6' , '5' , & '4' , '3' , '2' ] character ( len = 1 ), dimension ( * ), parameter :: cards_with_joker = [ 'A' , 'K' , 'Q' , 'T' , & '9' , '8' , '7' , '6' , '5' , & '4' , '3' , '2' , 'J' ] integer , parameter :: FIVE_OF_A_KIND = 1 ! the hand types integer , parameter :: FOUR_OF_A_KIND = 2 integer , parameter :: FULL_HOUSE = 3 integer , parameter :: THREE_OF_A_KIND = 4 integer , parameter :: TWO_PAIR = 5 integer , parameter :: ONE_PAIR = 6 integer , parameter :: HIGH_CARD = 7 call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day7_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day7.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( hands ( n_lines )) do i = 1 , n_lines line = read_line ( iunit ); vals = split ( line , ' ' ) hands ( i )% cards = str_to_array ( vals ( 1 )% str ) hands ( i )% bid = int ( vals ( 2 )) end do close ( iunit ) do icase = 1 , 2 ! first time normally, second time processing the jokers ! sort the list from worst to best to determinte the rank of each hand hands % type = 0 ! reinitialize since they need to be recomputed do ! bubble sort ! done = . true . do i = 1 , n_lines - 1 if ( beats ( hands ( i ), hands ( i + 1 ), icase == 2 )) then call swap_hands ( hands ( i ), hands ( i + 1 )); done = . false . end if end do if ( done ) exit end do write ( * , * ) '7' // cases ( icase ) // ':' , sum ( hands % bid * [( i , i = 1 , n_lines )]) end do call clk % toc ( '7' ) contains integer function hand_type ( me , with_jokers ) !! returns the type of hand class ( hand ), intent ( in ) :: me logical , intent ( in ) :: with_jokers !! if considering jokers integer , dimension ( 5 ) :: i integer , dimension (:), allocatable :: u integer :: n_jokers , n_unique character ( len = 1 ), dimension ( 5 ) :: h h = me % cards i = ichar ( h ) ! convert to code u = unique ( i ) ! unique elements n_unique = size ( u ) if ( with_jokers . and . any ( h == 'J' )) then ! have to pick best hand for all jokers ! just do it by inspection n_jokers = count ( h == 'J' ) select case ( n_jokers ) case ( 5 ) hand_type = FIVE_OF_A_KIND !jjjjj case ( 4 ) hand_type = FIVE_OF_A_KIND !jjjja case ( 3 ) ! can always turn to 4 or 5 of a kind if ( n_unique == 2 ) then !jjjaa hand_type = FIVE_OF_A_KIND else ! jjjab hand_type = FOUR_OF_A_KIND end if case ( 2 ) if ( n_unique == 2 ) then !jjaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then !jjaab hand_type = FOUR_OF_A_KIND else !jjabc hand_type = THREE_OF_A_KIND end if case ( 1 ) if ( n_unique == 2 ) then !jaaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then if ( any ([ count ( i == u ( 1 )) == 3 , & count ( i == u ( 2 )) == 3 , & count ( i == u ( 3 )) == 3 ]) ) then !jaaab hand_type = FOUR_OF_A_KIND elseif ( ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 ) . or . & ( count ( i == u ( 2 )) == 2 . and . count ( i == u ( 2 )) == 2 ) ) then !jaabb hand_type = FULL_HOUSE end if else if ( n_unique == 4 ) then !jaabc hand_type = THREE_OF_A_KIND else if ( n_unique == 5 ) then !jabcd hand_type = ONE_PAIR end if end select else !Every hand is exactly one type. From strongest to weakest, they are: select case ( n_unique ) case ( 1 ) ! aaaaa hand_type = FIVE_OF_A_KIND case ( 2 ) ! aaaab, aaabb if (( count ( i == u ( 1 )) == 4 . and . count ( i == u ( 2 )) == 1 ) . or . & ( count ( i == u ( 1 )) == 1 . and . count ( i == u ( 2 )) == 4 ) ) then hand_type = FOUR_OF_A_KIND else if (( count ( i == u ( 1 )) == 3 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 3 ) ) then hand_type = FULL_HOUSE end if case ( 3 ) ! aaabc, aabcc if ( any ([ count ( i == u ( 1 )) == 3 , count ( i == u ( 2 )) == 3 , count ( i == u ( 3 )) == 3 ]) ) then hand_type = THREE_OF_A_KIND else if ( any ([ count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 , & count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 , & count ( i == u ( 2 )) == 2 . and . count ( i == u ( 3 )) == 2 ]) ) then hand_type = TWO_PAIR end if case ( 4 ) !aabcd hand_type = ONE_PAIR case ( 5 ) !abcde hand_type = HIGH_CARD ! High card, where all cards' labels are distinct: 23456 end select end if end function hand_type logical function beats ( hand1 , hand2 , with_jokers ) !! return true if hand1 beats hand2 (has a higher score) class ( hand ), intent ( inout ) :: hand1 , hand2 logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i associate ( h1 => hand1 % cards , h2 => hand2 % cards ) ! recompute type if it hasn't already been computed if ( hand1 % type == 0 ) hand1 % type = hand_type ( hand1 , with_jokers ) if ( hand2 % type == 0 ) hand2 % type = hand_type ( hand2 , with_jokers ) if ( hand1 % type == hand2 % type ) then ! lower index is stronger do i = 1 , 5 if ( h1 ( i ) /= h2 ( i )) then beats = index_in_cards ( h1 ( i ), with_jokers ) < & index_in_cards ( h2 ( i ), with_jokers ) ! lower is stronger return end if end do else ! one hand beat the other beats = hand1 % type < hand2 % type ! lower score is better (1-7) end if end associate end function beats integer function index_in_cards ( c , with_jokers ) character ( len = 1 ), intent ( in ) :: c logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i do i = 1 , size ( cards_with_joker ) if ( with_jokers ) then if ( c == cards_with_joker ( i )) then index_in_cards = i return end if else if ( c == cards ( i )) then index_in_cards = i return end if end if end do error stop 'card not found' end function index_in_cards pure elemental subroutine swap_hands ( i1 , i2 ) !! swap function for hand type type ( hand ), intent ( inout ) :: i1 type ( hand ), intent ( inout ) :: i2 type ( hand ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_hands end program problem_7","tags":"","loc":"program/problem_7.html"},{"title":"problem_1 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_1~~UsesGraph program~problem_1 problem_1 iso_fortran_env iso_fortran_env program~problem_1->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_1->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_1~~CallsGraph program~problem_1 problem_1 proc~clock_end aoc_utilities::clock%clock_end program~problem_1->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_1->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_1->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_1->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit logical :: status_ok character(len=:), allocatable :: line integer :: n_lines integer :: i integer :: j integer :: k integer :: n integer :: isum integer :: ifirst integer :: ilast integer :: idxfirst integer :: idxlast character(len=*), parameter,               dimension(9) :: ichars = ['one&nbsp;&nbsp;', 'two&nbsp;&nbsp;', 'three', 'four ', 'five ', 'six&nbsp;&nbsp;', 'seven', 'eight', 'nine '] Source Code program problem_1 use iso_fortran_env use aoc_utilities implicit none integer :: iunit logical :: status_ok character ( len = :), allocatable :: line integer :: n_lines integer :: i , j , k , n , isum , ifirst , ilast , idxfirst , idxlast character ( len =* ), dimension ( 9 ), parameter :: ichars = [ & 'one  ' , & 'two  ' , & 'three' , & 'four ' , & 'five ' , & 'six  ' , & 'seven' , & 'eight' , & 'nine ' ] call clk % tic () isum = 0 open ( newunit = iunit , file = 'inputs/day1.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) do i = 1 , n_lines ! remove all the chars before the first and after the last number line = read_line ( iunit , status_ok ) n = len ( line ) do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) exit ! done line ( j : j ) = ' ' end do do j = n , 1 , - 1 if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) exit ! done line ( j : j ) = ' ' end do line = trim ( adjustl ( line )) n = len ( line ) isum = isum + 10 * int ( line ( 1 : 1 )) + int ( line ( n : n )) end do write ( * , * ) '1a: sum:' , isum close ( iunit ) ! -------- part 2 ----------- open ( newunit = iunit , file = 'inputs/day1.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do i = 1 , n_lines line = read_line ( iunit , status_ok ) n = len ( line ) ! keep track of the index of the first and last number (digit or string) ifirst = huge ( 1 ) idxfirst = huge ( 1 ) do j = 1 , size ( ichars ) k = min ( index ( line , trim ( ichars ( j ))), index ( line , trim ( ichars ( j )), back = . true .) ) ! accounts for duplicates if ( k > 0 . and . k <= idxfirst ) then ifirst = j idxfirst = k end if end do do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) then if ( j <= idxfirst ) then ifirst = int ( line ( j : j )) idxfirst = j end if end if end do ilast = 0 idxlast = 0 do j = 1 , size ( ichars ) k = max ( index ( line , trim ( ichars ( j ))), index ( line , trim ( ichars ( j )), back = . true .) ) ! accounts for duplicates if ( k > 0 . and . k >= idxlast ) then ilast = j idxlast = k end if end do do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) then if ( j >= idxlast ) then ilast = int ( line ( j : j )) idxlast = j end if end if end do isum = isum + 10 * ifirst + ilast end do write ( * , * ) '1b: sum:' , isum call clk % toc ( '1' ) end program problem_1","tags":"","loc":"program/problem_1.html"},{"title":"problem_18 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_18~~UsesGraph program~problem_18 problem_18 iso_fortran_env iso_fortran_env program~problem_18->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_18->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_18~~CallsGraph program~problem_18 problem_18 proc~clock_end aoc_utilities::clock%clock_end program~problem_18->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_18->proc~clock_start proc~go problem_18::go program~problem_18->proc~go interface~split aoc_utilities::split proc~go->interface~split proc~destination problem_18::destination proc~go->proc~destination proc~hex2int aoc_utilities::hex2int proc~go->proc~hex2int proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~go->proc~number_of_lines_in_file proc~parea aoc_utilities::parea proc~go->proc~parea proc~read_line aoc_utilities::read_line proc~go->proc~read_line proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer(kind=ip) :: iresult Functions pure function destination (initial, direction, steps) result(final) get destination point Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(2) :: initial character(len=1), intent(in) :: direction integer(kind=ip), intent(in) :: steps Return Value integer(kind=ip), dimension(2) x,y of desination point Subroutines subroutine go (partb, iresult) Arguments Type Intent Optional Attributes Name logical, intent(in) :: partb if solving part b integer(kind=ip), intent(out) :: iresult Source Code program problem_18 use aoc_utilities use iso_fortran_env , only : wp => real64 , ip => int64 implicit none integer ( ip ) :: iresult call clk % tic () call go (. false ., iresult ); write ( * , * ) '18a:' , iresult call go (. true ., iresult ); write ( * , * ) '18b:' , iresult call clk % toc ( '18' ) contains subroutine go ( partb , iresult ) logical , intent ( in ) :: partb !! if solving part b integer ( ip ), intent ( out ) :: iresult integer :: iunit , iline , n_lines , n character ( len = :), allocatable :: line , hex type ( string ), dimension (:), allocatable :: vals character ( len = 1 ) :: direction integer ( ip ), dimension ( 2 ) :: iloc , iloc2 integer ( ip ) :: ival , isteps real ( wp ), dimension (:), allocatable :: xvec , yvec character ( len = 1 ), dimension ( 0 : 3 ) :: direction_str = [ 'R' , 'D' , 'L' , 'U' ] ! directions for part b : 0,1,2,3 ! open(newunit=iunit, file='inputs/day18_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day18.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) iloc = [ 0 , 0 ] ! where to start isteps = 0 xvec = [ 0 ]; yvec = [ 0 ] do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ! direction, number, (hex) if ( partb ) then ! values encoded in hex hex = vals ( 3 )% str ival = hex2int ( hex ( 3 : 7 )) direction = direction_str ( int ( hex ( 8 : 8 ))) else direction = vals ( 1 )% str ival = int ( vals ( 2 )% str ) end if isteps = isteps + ival ! keep track of the total perimeter size iloc2 = destination ( iloc , direction , ival ) ! destination oint xvec = [ xvec , real ( iloc2 ( 1 ), wp )] ! save the points of the polygon yvec = [ yvec , real ( iloc2 ( 2 ), wp )] ! iloc = iloc2 ! update for next move end do close ( iunit ) ! the area including the boundary = area + 1/2 the perimeter + 1 ! using NSWC parea function! n = size ( xvec ) iresult = int ( abs ( parea ( yvec , xvec , n )) + real ( isteps , wp ) / 2_ip + 1_ip , ip ) end subroutine go pure function destination ( initial , direction , steps ) result ( final ) !! get destination point integer ( ip ), dimension ( 2 ), intent ( in ) :: initial character ( len = 1 ), intent ( in ) :: direction integer ( ip ), intent ( in ) :: steps integer ( ip ), dimension ( 2 ) :: final !! x,y of desination point select case ( direction ) case ( 'R' ); final = [ initial ( 1 ), initial ( 2 ) + steps ] case ( 'L' ); final = [ initial ( 1 ), initial ( 2 ) - steps ] case ( 'D' ); final = [ initial ( 1 ) + steps , initial ( 2 )] case ( 'U' ); final = [ initial ( 1 ) - steps , initial ( 2 )] end select end function destination end program problem_18","tags":"","loc":"program/problem_18.html"},{"title":"problem_23 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_23~~UsesGraph program~problem_23 problem_23 iso_fortran_env iso_fortran_env program~problem_23->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_23->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. alternate one... collapse the maze into a graph Calls program~~problem_23~~CallsGraph program~problem_23 problem_23 proc~clock_end aoc_utilities::clock%clock_end program~problem_23->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_23->proc~clock_start proc~go~2 problem_23::go program~problem_23->proc~go~2 proc~build_graph problem_23::build_graph proc~go~2->proc~build_graph proc~count_adjacent problem_23::count_adjacent proc~go~2->proc~count_adjacent proc~dijkstra problem_23::dijkstra proc~go~2->proc~dijkstra proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~go~2->proc~read_file_to_char_array proc~traverse problem_23::traverse proc~go~2->proc~traverse proc~build_graph->proc~build_graph proc~add_edge problem_23::add_edge proc~build_graph->proc~add_edge proc~get_cell problem_23::get_cell proc~build_graph->proc~get_cell proc~node_number problem_23::node_number proc~build_graph->proc~node_number proc~not_tree problem_23::not_tree proc~count_adjacent->proc~not_tree proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line proc~traverse->proc~traverse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( node ), dimension(:), allocatable :: nodes the list of nodes logical :: slopes a=true, b=false logical, dimension(:,:), allocatable :: visited logical, dimension(:), allocatable :: nodes_visited integer(kind=ip), dimension(:), allocatable :: inodes node coordinates integer(kind=ip), dimension(:), allocatable :: jnodes node coordinates integer(kind=ip) :: max_dist integer(kind=ip) :: total_nodes integer(kind=ip) :: nrows integer(kind=ip) :: ncols character(len=1), dimension(:,:), allocatable :: array integer(kind=ip), dimension(:), allocatable :: node_dist integer(kind=ip), dimension(:), allocatable :: node_prev Derived Types type :: node Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(:), allocatable :: inext the node connected to this one integer(kind=ip), public, dimension(:), allocatable :: idist distance to inext nodes Functions pure function is_node (i, j) returns true if a node is at these coordinates Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value logical pure function node_number (i, j) returns the index of these coordinates in\nthe list of nodes (0 if it is not a node) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value integer(kind=ip) pure function count_adjacent (i, j) result(icount) count the number of adjacent cells not a tree Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value integer(kind=ip) pure function get_cell (i, j) result(a) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i coordinates integer(kind=ip), intent(in) :: j coordinates Return Value character(len=1) pure function not_tree (i, j) returns true if the cell isn't a tree Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i coordinates integer(kind=ip), intent(in) :: j coordinates Return Value logical Subroutines subroutine go (case, filename, parta) solve the case Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: case case name for printing character(len=*), intent(in) :: filename input file to read logical, intent(in) :: parta if this is part a, then consider the slopes subroutine dijkstra (u, inext) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: u integer(kind=ip), intent(in) :: inext recursive subroutine build_graph (node_num, i, j, idist, visited) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: node_num current node number integer(kind=ip), intent(in) :: i current position integer(kind=ip), intent(in) :: j current position integer(kind=ip), intent(in) :: idist current distance (number of steps) logical, intent(in), dimension(:,:) :: visited elements visited in this path (not counting this one) recursive subroutine traverse (node_num, idist, nodes_visited) traverse the graph until we get to the end and check the max distance Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: node_num current node integer(kind=ip), intent(in) :: idist distance to get here logical, intent(in), dimension(:) :: nodes_visited subroutine add_edge (inode, ichild, idist) add an edge to this node (path to another node with the specified distance) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: inode integer(kind=ip), intent(in) :: ichild integer(kind=ip), intent(in) :: idist Source Code program problem_23 !! alternate one... collapse the maze into a graph ! Process: !   1. locate the start and end nodes (top and bottom) !   2. find all the cells that have 3 or 4 adjacent cells: ! !      1    2    3    4 !     ###  #.#  ###  #.# !-->  #.#  #.#  ...  ... !     #.#  #.#  #.#  #.# ! !     those are the nodes, and the paths between them are the edges !   3. compute the edges between each node combination and construct the graph !   4. DFS all paths to find the longest. use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none type :: node integer ( ip ), dimension (:), allocatable :: inext !! the node connected to this one integer ( ip ), dimension (:), allocatable :: idist !! distance to inext nodes end type node type ( node ), dimension (:), allocatable :: nodes !! the list of nodes logical :: slopes !! a=true, b=false logical , dimension (:,:), allocatable :: visited logical , dimension (:), allocatable :: nodes_visited integer ( ip ), dimension (:), allocatable :: inodes , jnodes !! node coordinates integer ( ip ) :: max_dist , total_nodes , nrows , ncols character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:), allocatable :: node_dist integer ( ip ), dimension (:), allocatable :: node_prev call clk % tic () ! call go('23a', 'inputs/day23_test.txt', .true. ) ! call go('23b', 'inputs/day23_test.txt', .false.) call go ( '23a' , 'inputs/day23.txt' , . true . ) call go ( '23b' , 'inputs/day23.txt' , . false .) call clk % toc ( '23' ) contains subroutine go ( case , filename , parta ) !! solve the case character ( len =* ), intent ( in ) :: case !! case name for printing character ( len =* ), intent ( in ) :: filename !! input file to read logical , intent ( in ) :: parta !! if this is part a, then consider the slopes integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: istart , iend , idist , i , j logical , parameter :: use_dijkstra = . false . !.... doesn't work yet .... don't know why ....... ! initialize: max_dist = 0 slopes = parta if ( allocated ( nodes )) deallocate ( nodes ) if ( allocated ( visited )) deallocate ( visited ) if ( allocated ( nodes_visited )) deallocate ( nodes_visited ) if ( allocated ( inodes )) deallocate ( inodes ) if ( allocated ( jnodes )) deallocate ( jnodes ) if ( allocated ( node_dist )) deallocate ( node_dist ) if ( allocated ( node_prev )) deallocate ( node_prev ) ! read the data file: array = read_file_to_char_array ( filename ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) iloc = findloc ( array ( 1 ,:), '.' ); istart = iloc ( 1 ) ! get start and end columns iloc = findloc ( array ( nrows ,:), '.' ); iend = iloc ( 1 ) ! ! identify the coordinates of all the nodes: inodes = [ 1 ] ! start node jnodes = [ istart ] do i = 1 , nrows do j = 1 , ncols if ( count_adjacent ( i , j ) >= 3 ) then inodes = [ inodes , i ] jnodes = [ jnodes , j ] end if end do end do inodes = [ inodes , nrows ] ! end node jnodes = [ jnodes , iend ] total_nodes = size ( inodes ) ! for each node, find the other nodes they are ! connected to and the distances between them (the edges) allocate ( nodes ( total_nodes )) allocate ( visited ( nrows , ncols )) do i = 1 , total_nodes visited = . false . idist = 0 call build_graph ( i , inodes ( i ), jnodes ( i ), idist , visited ) end do if ( use_dijkstra ) then !write(*,*) 'hello use_dijkstra'         ! ... something wrong here... don't get the right answer ! based on AOC 2021, Problem 15 allocate ( node_dist ( total_nodes )); node_dist = - 1 ; node_dist ( 1 ) = 0 allocate ( node_prev ( total_nodes )); node_prev = - 1 allocate ( nodes_visited ( total_nodes )); nodes_visited = . false . do iloc = maxloc ( node_dist , mask = . not . nodes_visited ) i = iloc ( 1 ) nodes_visited ( i ) = . true . if ( i == total_nodes ) exit ! we are done! !write(*,*) 'visited ', i if ( allocated ( nodes ( i )% inext )) then do j = 1 , size ( nodes ( i )% inext ) ! adjacent nodes to this one call dijkstra ( i , j ) end do end if !if (all(nodes_visited)) exit ! done end do !write(*,*) case, node_dist(size(node_dist)) ! result for this case (last node) !write(*,*) nodes_visited !write(*,*) node_dist else ! start at first, and find the longest that gets to the last. ! recursively traverse the graph. visited = . false . allocate ( nodes_visited ( total_nodes )); nodes_visited = . false . call traverse ( 1_ip , 0_ip , nodes_visited ) write ( * , * ) case , max_dist ! result for this case end if end subroutine go subroutine dijkstra ( u , inext ) integer ( ip ), intent ( in ) :: u ! current integer ( ip ), intent ( in ) :: inext ! index in inext array of the next node integer ( ip ) :: idist associate ( next_node => nodes ( u )% inext ( inext ), & distance_to_next_node => nodes ( u )% idist ( inext )) if ( nodes_visited ( next_node )) return ! already visited this one idist = node_dist ( u ) + distance_to_next_node ! add distance from u to v if ( idist > node_dist ( next_node )) then !write(*,*) 'highest so far: ', idist node_dist ( next_node ) = idist node_prev ( next_node ) = u end if end associate end subroutine dijkstra recursive subroutine build_graph ( node_num , i , j , idist , visited ) integer ( ip ), intent ( in ) :: node_num !! current node number integer ( ip ), intent ( in ) :: i , j !! current position integer ( ip ), intent ( in ) :: idist !! current distance (number of steps) logical , dimension (:,:), intent ( in ) :: visited !! elements visited in this path (not counting this one) logical , dimension (:,:), allocatable :: tmp_visited integer ( ip ) :: child_node_num if ( i < 1 . or . i > nrows . or . j < 1 . or . j > ncols ) return if ( visited ( i , j )) return if ( array ( i , j ) == '#' ) return ! can't continue from here ! go until we hit another node child_node_num = node_number ( i , j ) if ( child_node_num > 0 . and . child_node_num /= node_num ) then ! we have reached another node call add_edge ( node_num , child_node_num , idist ) else ! continue processing this edge tmp_visited = visited !make a copy and mark this one tmp_visited ( i , j ) = . true . ! we are here now associate ( a => get_cell ( i , j )) ! paths (.), forest (#), and steep slopes (&#94;, >, v, and <). select case ( a ) case ( '.' ) ! path call build_graph ( node_num , i - 1 , j , idist + 1 , tmp_visited ) call build_graph ( node_num , i + 1 , j , idist + 1 , tmp_visited ) call build_graph ( node_num , i , j + 1 , idist + 1 , tmp_visited ) call build_graph ( node_num , i , j - 1 , idist + 1 , tmp_visited ) ! these don't have a choice, must go in these directions: case ( '&#94;' ); call build_graph ( node_num , i - 1 , j , idist + 1 , tmp_visited ) case ( 'v' ); call build_graph ( node_num , i + 1 , j , idist + 1 , tmp_visited ) case ( '>' ); call build_graph ( node_num , i , j + 1 , idist + 1 , tmp_visited ) case ( '<' ); call build_graph ( node_num , i , j - 1 , idist + 1 , tmp_visited ) end select end associate end if end subroutine build_graph recursive subroutine traverse ( node_num , idist , nodes_visited ) !! traverse the graph until we get to the end and check the max distance integer ( ip ), intent ( in ) :: node_num !! current node integer ( ip ), intent ( in ) :: idist !! distance to get here logical , dimension (:), intent ( in ) :: nodes_visited logical , dimension (:), allocatable :: tmp_nodes_visited integer :: i if ( nodes_visited ( node_num )) return ! already visited this node if ( node_num == total_nodes ) then ! reached the destination if ( idist > max_dist ) max_dist = idist ! best so far else ! are their child nodes? if ( allocated ( nodes ( node_num )% inext )) then tmp_nodes_visited = nodes_visited tmp_nodes_visited ( node_num ) = . true . ! mark this node do i = 1 , size ( nodes ( node_num )% inext ) call traverse ( nodes ( node_num )% inext ( i ), idist + nodes ( node_num )% idist ( i ), tmp_nodes_visited ) end do end if end if end subroutine traverse pure logical function is_node ( i , j ) !! returns true if a node is at these coordinates integer ( ip ), intent ( in ) :: i , j is_node = any ( inodes == i . and . jnodes == j ) end function is_node subroutine add_edge ( inode , ichild , idist ) !! add an edge to this node (path to another node with the specified distance) integer ( ip ), intent ( in ) :: inode , ichild , idist if (. not . allocated ( nodes ( inode )% inext )) then allocate ( nodes ( inode )% inext ( 0 )) allocate ( nodes ( inode )% idist ( 0 )) end if nodes ( inode )% inext = [ nodes ( inode )% inext , ichild ] nodes ( inode )% idist = [ nodes ( inode )% idist , idist ] end subroutine add_edge pure integer ( ip ) function node_number ( i , j ) !! returns the index of these coordinates in !! the list of nodes (0 if it is not a node) integer ( ip ), intent ( in ) :: i , j integer ( ip ), dimension ( 1 ) :: iloc iloc = findloc ( inodes == i . and . jnodes == j , . true .) node_number = iloc ( 1 ) end function node_number pure function count_adjacent ( i , j ) result ( icount ) !! count the number of adjacent cells not a tree integer ( ip ), intent ( in ) :: i , j integer ( ip ) :: icount icount = 0 if ( i >= 1 ) icount = icount + count ([ not_tree ( i - 1 , j )]) if ( i <= nrows ) icount = icount + count ([ not_tree ( i + 1 , j )]) if ( j <= ncols ) icount = icount + count ([ not_tree ( i , j + 1 )]) if ( j >= 1 ) icount = icount + count ([ not_tree ( i , j - 1 )]) end function count_adjacent pure function get_cell ( i , j ) result ( a ) integer ( ip ), intent ( in ) :: i , j !! coordinates character ( len = 1 ) :: a if ( slopes ) then a = array ( i , j ) else a = '.' ! ignore the slopes for part b end if end function get_cell pure logical function not_tree ( i , j ) !! returns true if the cell isn't a tree integer ( ip ), intent ( in ) :: i , j !! coordinates if ( i < 1 . or . i > nrows . or . j < 1 . or . j > ncols ) then not_tree = . false . ! off the board, call it a tree else not_tree = array ( i , j ) /= '#' end if end function not_tree end program problem_23","tags":"","loc":"program/problem_23.html"},{"title":"problem_11 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_11~~UsesGraph program~problem_11 problem_11 iso_fortran_env iso_fortran_env program~problem_11->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_11->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_11~~CallsGraph program~problem_11 problem_11 proc~clock_end aoc_utilities::clock%clock_end program~problem_11->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_11->proc~clock_start proc~go~6 problem_11::go program~problem_11->proc~go~6 interface~manhatten_distance aoc_utilities::manhatten_distance proc~go~6->interface~manhatten_distance proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~go~6->proc~read_file_to_char_array proc~manhatten_distance_64 aoc_utilities::manhatten_distance_64 interface~manhatten_distance->proc~manhatten_distance_64 proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Functions function go (expansion_factor) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: expansion_factor Return Value integer(kind=ip) Source Code program problem_11 use iso_fortran_env , ip => int64 , wp => real64 use aoc_utilities implicit none call clk % tic () write ( * , * ) '11a: ' , go ( 2_ip ) write ( * , * ) '11b: ' , go ( 1000000_ip ) call clk % toc ( '11' ) contains integer ( ip ) function go ( expansion_factor ) integer ( ip ), intent ( in ) :: expansion_factor integer :: i , j , nrows , ncols , n_galaxies , n , k character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:,:), allocatable :: idists integer ( ip ), dimension (:), allocatable :: igal , jgal integer ( ip ), dimension (:,:), allocatable :: ix , iy ! array = read_file_to_char_array('inputs/day11_test.txt') array = read_file_to_char_array ( 'inputs/day11.txt' ) nrows = size ( array , 1 ); ncols = size ( array , 2 ) n_galaxies = count ( array == '#' ) ! track the real indices after expansion ix = transpose ( spread ([( i , i = 1 , ncols )], 1 , nrows )) ! row indices iy = spread ([( i , i = 1 , nrows )], 1 , ncols ) ! col indices igal = pack ( ix , array == '#' ) ! indices of galaxies jgal = pack ( iy , array == '#' ) ! expand the array, keeping track of the new row indices do i = 1 , nrows ! add rows if necessary if ( all ( array ( i ,:) == '.' )) ix ( i :,:) = ix ( i :,:) + expansion_factor - 1 ! new row end do do j = 1 , ncols ! add cols if necessary if ( all ( array (:, j ) == '.' )) iy (:, j :) = iy (:, j :) + expansion_factor - 1 ! new column end do ! now compute all the distances: allocate ( idists ( n_galaxies , n_galaxies )); idists = 0 do i = 1 , n_galaxies do j = 1 , n_galaxies if ( j <= i ) cycle ! only need the lower diagonal idists ( i , j ) = manhatten_distance ( ix ( igal ( i ), jgal ( i )), iy ( igal ( i ), jgal ( i )),& ix ( igal ( j ), jgal ( j )), iy ( igal ( j ), jgal ( j ))) end do end do go = sum ( idists ) end function go end program problem_11","tags":"","loc":"program/problem_11.html"},{"title":"problem_4 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_4~~UsesGraph program~problem_4 problem_4 iso_fortran_env iso_fortran_env program~problem_4->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_4->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_4~~CallsGraph program~problem_4 problem_4 interface~split aoc_utilities::split program~problem_4->interface~split proc~clock_end aoc_utilities::clock%clock_end program~problem_4->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_4->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_4->proc~number_of_lines_in_file proc~parse_ints aoc_utilities::parse_ints program~problem_4->proc~parse_ints proc~read_line aoc_utilities::read_line program~problem_4->proc~read_line proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit integer :: n_lines integer :: i integer :: points integer :: j integer :: iwin type( string ), dimension(:), allocatable :: vals type( string ), dimension(:), allocatable :: vals2 integer, dimension(:), allocatable :: iwinning integer, dimension(:), allocatable :: ihave integer, dimension(:), allocatable :: n_matches character(len=:), allocatable :: line integer, dimension(:,:), allocatable :: card_matrix Source Code program problem_4 use iso_fortran_env use aoc_utilities implicit none integer :: iunit , n_lines , i , points , j , iwin type ( string ), dimension (:), allocatable :: vals , vals2 integer , dimension (:), allocatable :: iwinning , ihave , n_matches character ( len = :), allocatable :: line integer , dimension (:,:), allocatable :: card_matrix call clk % tic () ! open(newunit=iunit, file='inputs/day4_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day4.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( n_matches ( n_lines )) ! for part 2 allocate ( card_matrix ( 0 : n_lines , n_lines )) ! for part 2 ! Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53 points = 0 do i = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ': ' ) vals2 = split ( vals ( 2 ), ' | ' ) iwinning = parse_ints ( vals2 ( 1 )% str ) ! winning list ihave = parse_ints ( vals2 ( 2 )% str ) ! ones you have ! count the number of ones you have in the winning set: iwin = 0 do j = 1 , size ( ihave ) iwin = iwin + count ( ihave ( j ) == iwinning ) end do n_matches ( i ) = iwin points = points + 2 ** ( iwin - 1 ) end do close ( iunit ) write ( * , * ) '4a : points : ' , points card_matrix = 0 card_matrix ( 0 ,:) = 1 ! start with one card each do i = 1 , n_lines associate ( n => n_matches ( i )) if ( n > 0 ) card_matrix ( i , i + 1 : i + n ) = sum ( card_matrix (:, i )) end associate end do write ( * , * ) '4b : scratchcards :' , sum ( card_matrix ) call clk % toc ( '4' ) end program problem_4","tags":"","loc":"program/problem_4.html"},{"title":"problem_2 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_2~~UsesGraph program~problem_2 problem_2 iso_fortran_env iso_fortran_env program~problem_2->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_2->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_2~~CallsGraph program~problem_2 problem_2 interface~split aoc_utilities::split program~problem_2->interface~split proc~clock_end aoc_utilities::clock%clock_end program~problem_2->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_2->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_2->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_2->proc~read_line proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit logical :: status_ok logical :: game_possible character(len=:), allocatable :: line character(len=:), allocatable :: color integer :: n_lines integer :: id integer :: j integer :: k integer :: ipossible integer :: inum integer :: min_red integer :: min_green integer :: min_blue integer :: power type( string ), dimension(:), allocatable :: vals type( string ), dimension(:), allocatable :: trys type( string ), dimension(:), allocatable :: cubes type( string ), dimension(:), allocatable :: num_color integer, parameter :: n_red = 12 integer, parameter :: n_green = 13 integer, parameter :: n_blue = 14 Source Code program problem_2 use iso_fortran_env use aoc_utilities implicit none integer :: iunit logical :: status_ok , game_possible character ( len = :), allocatable :: line , color integer :: n_lines , id , j , k , ipossible , inum , min_red , min_green , min_blue , power type ( string ), dimension (:), allocatable :: vals , trys , cubes , num_color integer , parameter :: n_red = 12 integer , parameter :: n_green = 13 integer , parameter :: n_blue = 14 call clk % tic () !example: Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green open ( newunit = iunit , file = 'inputs/day2.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) ! will parse the line with successive splits ipossible = 0 power = 0 main : do id = 1 , n_lines game_possible = . true . min_red = 0 ; min_green = 0 ; min_blue = 0 line = read_line ( iunit , status_ok ) vals = split ( line , ': ' ) trys = split ( vals ( 2 ), '; ' ) do j = 1 , size ( trys ) cubes = split ( trys ( j ), ', ' ) do k = 1 , size ( cubes ) num_color = split ( cubes ( k ), ' ' ) inum = int ( num_color ( 1 )% str ) color = num_color ( 2 )% str select case ( color ) case ( 'red' ) if ( inum > n_red ) game_possible = . false . if ( inum > min_red ) min_red = inum case ( 'green' ) if ( inum > n_green ) game_possible = . false . if ( inum > min_green ) min_green = inum case ( 'blue' ) if ( inum > n_blue ) game_possible = . false . if ( inum > min_blue ) min_blue = inum end select end do end do power = power + ( min_red * min_green * min_blue ) if ( game_possible ) ipossible = ipossible + id end do main write ( * , * ) '2a: result   :' , ipossible write ( * , * ) '2b: power sum:' , power close ( iunit ) call clk % toc ( '2' ) end program problem_2","tags":"","loc":"program/problem_2.html"},{"title":"problem_16 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_16~~UsesGraph program~problem_16 problem_16 iso_fortran_env iso_fortran_env program~problem_16->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_16->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_16~~CallsGraph program~problem_16 problem_16 proc~clock_end aoc_utilities::clock%clock_end program~problem_16->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_16->proc~clock_start proc~go~3 problem_16::go program~problem_16->proc~go~3 proc~read_file_to_char_array aoc_utilities::read_file_to_char_array program~problem_16->proc~read_file_to_char_array proc~go~3->proc~go~3 proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: j integer :: nrows integer :: ncols integer :: max_count integer :: icount integer :: icase character(len=1), dimension(:,:), allocatable :: array logical, dimension(:,:,:), allocatable :: visited integer, parameter :: TOP = 1 integer, parameter :: BOTTOM = 2 integer, parameter :: LEFT = 3 integer, parameter :: RIGHT = 4 Subroutines recursive subroutine go (i, j, direction_from) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i grid coordinate integer, intent(in) :: j grid coordinate integer, intent(in) :: direction_from direction coming from (TOP,BOTTOM,LEFT,RIGHT Source Code program problem_16 use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none integer :: i , j , nrows , ncols , max_count , icount , icase character ( len = 1 ), dimension (:,:), allocatable :: array logical , dimension (:,:,:), allocatable :: visited ! top,bottom,left,right integer , parameter :: TOP = 1 ! direction traveling FROM integer , parameter :: BOTTOM = 2 integer , parameter :: LEFT = 3 integer , parameter :: RIGHT = 4 call clk % tic () ! read the data file: ! array = read_file_to_char_array('inputs/day16_test.txt') ! pad with wall around the array array = read_file_to_char_array ( 'inputs/day16.txt' ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) ! track if we have already done this case, to avoid unnecessary duplication, ! otherwise it may loop indefinitly? allocate ( visited ( 4 , nrows , ncols )) ! part 1: visited = . false . call go ( 1 , 1 , LEFT ) write ( * , * ) '16a: ' , count ( visited ( 1 ,:,:) . or . & visited ( 2 ,:,:) . or . & visited ( 3 ,:,:) . or . & visited ( 4 ,:,:)) ! part 2, just do all the cases: max_count = 0 do icase = 1 , 2 ! first and last col do i = 1 , nrows visited = . false . if ( icase == 1 ) then ; call go ( i , 1 , LEFT ) else ; call go ( i , ncols , RIGHT ) end if icount = count ( visited ( 1 ,:,:) . or . & visited ( 2 ,:,:) . or . & visited ( 3 ,:,:) . or . & visited ( 4 ,:,:)) if ( icount > max_count ) max_count = icount end do end do do icase = 1 , 2 ! first and last row do j = 1 , ncols visited = . false . if ( icase == 1 ) then ; call go ( 1 , j , TOP ) else ; call go ( nrows , j , BOTTOM ) end if icount = count ( visited ( 1 ,:,:) . or . & visited ( 2 ,:,:) . or . & visited ( 3 ,:,:) . or . & visited ( 4 ,:,:)) if ( icount > max_count ) max_count = icount end do end do write ( * , * ) '16b: ' , max_count call clk % toc ( '16' ) contains recursive subroutine go ( i , j , direction_from ) integer , intent ( in ) :: i , j !! grid coordinate integer , intent ( in ) :: direction_from !! direction coming from (TOP,BOTTOM,LEFT,RIGHT integer :: k if ( i > nrows . or . i < 1 . or . j > ncols . or . j < 1 ) return ! off the board if ( visited ( direction_from , i , j )) return ! this case has already been done visited ( direction_from , i , j ) = . true . ! mark this one as visited in this direction associate ( c => array ( i , j )) select case ( c ) case ( '.' ) ! continue in same direction k = 1 do ! loop until we hit something else ! (to avoid unnecessary recursion) select case ( direction_from ) case ( TOP ) ! V if (( i + k ) > nrows ) return if ( array ( i + k , j ) /= '.' ) then call go ( i + k , j , direction_from ) return end if visited ( direction_from , i + k , j ) = . true . case ( BOTTOM ) ! &#94; if (( i - k ) < 1 ) return if ( array ( i - k , j ) /= '.' ) then call go ( i - k , j , direction_from ) return end if visited ( direction_from , i - k , j ) = . true . case ( LEFT ) ! --> if (( j + k ) > ncols ) return if ( array ( i , j + k ) /= '.' ) then call go ( i , j + k , direction_from ) return end if visited ( direction_from , i , j + k ) = . true . case ( RIGHT ) ! <-- if (( j - k ) < 1 ) return if ( array ( i , j - k ) /= '.' ) then call go ( i , j - k , direction_from ) return end if visited ( direction_from , i , j - k ) = . true . end select k = k + 1 end do case ( '-' ) select case ( direction_from ) case ( TOP , BOTTOM ) ! V, &#94; call go ( i , j + 1 , LEFT ) ! split call go ( i , j - 1 , RIGHT ) case ( LEFT ) ! --> call go ( i , j + 1 , LEFT ) case ( RIGHT ) ! <-- call go ( i , j - 1 , RIGHT ) end select case ( '|' ) select case ( direction_from ) case ( TOP ) ! V call go ( i + 1 , j , TOP ) case ( BOTTOM ) ! &#94; call go ( i - 1 , j , BOTTOM ) case ( LEFT , RIGHT ) ! -->, <-- call go ( i + 1 , j , TOP ) call go ( i - 1 , j , BOTTOM ) end select case ( '/' ) select case ( direction_from ) case ( TOP ) ! V call go ( i , j - 1 , RIGHT ) case ( BOTTOM ) ! &#94; call go ( i , j + 1 , LEFT ) case ( LEFT ) ! --> call go ( i - 1 , j , BOTTOM ) case ( RIGHT ) ! <-- call go ( i + 1 , j , TOP ) end select case ( '\\' ) select case ( direction_from ) case ( TOP ) ! V call go ( i , j + 1 , LEFT ) case ( BOTTOM ) ! &#94; call go ( i , j - 1 , RIGHT ) case ( LEFT ) ! --> call go ( i + 1 , j , TOP ) case ( RIGHT ) ! <-- call go ( i - 1 , j , BOTTOM ) end select end select end associate end subroutine go end program problem_16","tags":"","loc":"program/problem_16.html"},{"title":"problem_12b – AoC-2023","text":"Uses aoc_utilities aoc_cache_module iso_fortran_env program~~problem_12b~~UsesGraph program~problem_12b problem_12b iso_fortran_env iso_fortran_env program~problem_12b->iso_fortran_env module~aoc_cache_module aoc_cache_module program~problem_12b->module~aoc_cache_module module~aoc_utilities aoc_utilities program~problem_12b->module~aoc_utilities module~aoc_cache_module->iso_fortran_env module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. completely reworked solution from part a\nthis one starts with the int list and checks it against the pattern.\nit also employs a function cache to speed it up. Calls program~~problem_12b~~CallsGraph program~problem_12b problem_12b interface~split aoc_utilities::split program~problem_12b->interface~split proc~clock_end aoc_utilities::clock%clock_end program~problem_12b->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_12b->proc~clock_start proc~go~4 problem_12b::go program~problem_12b->proc~go~4 proc~initialize_cache aoc_cache_module::function_cache%initialize_cache program~problem_12b->proc~initialize_cache proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_12b->proc~number_of_lines_in_file proc~parse_ints aoc_utilities::parse_ints program~problem_12b->proc~parse_ints proc~read_line aoc_utilities::read_line program~problem_12b->proc~read_line proc~str_to_int64_array_with_mapping aoc_utilities::str_to_int64_array_with_mapping program~problem_12b->proc~str_to_int64_array_with_mapping proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~get_from_cache aoc_cache_module::function_cache%get_from_cache proc~go~4->proc~get_from_cache proc~ipoint problem_12b::ipoint proc~go~4->proc~ipoint proc~ipound problem_12b::ipound proc~go~4->proc~ipound proc~put_in_cache aoc_cache_module::function_cache%put_in_cache proc~go~4->proc~put_in_cache proc~destroy_cache aoc_cache_module::function_cache%destroy_cache proc~initialize_cache->proc~destroy_cache proc~vector_djb_hash aoc_cache_module::vector_djb_hash proc~get_from_cache->proc~vector_djb_hash proc~ipoint->proc~go~4 proc~ipound->proc~go~4 ints_tmp ints_tmp proc~ipound->ints_tmp ipattern_tmp ipattern_tmp proc~ipound->ipattern_tmp proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer(kind=ip), parameter :: POINT = -1 integer(kind=ip), parameter :: NUMBER = -2 integer(kind=ip), parameter :: QUESTION = -3 integer :: iunit integer :: n_lines integer :: iline character(len=:), allocatable :: line character(len=:), allocatable :: pattern type( string ), dimension(:), allocatable :: vals integer(kind=ip), dimension(:), allocatable :: ints integer(kind=ip), dimension(:), allocatable :: ipattern integer(kind=ip) :: isum integer(kind=ip) :: ival type( function_cache ) :: cache to cache the go function values Functions recursive function go (ipattern, ints) result(ival) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ipattern integer(kind=ip), intent(in), dimension(:) :: ints Return Value integer(kind=ip) recursive function ipound (ipattern, ints) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ipattern first char is a # integer(kind=ip), intent(in), dimension(:) :: ints Return Value integer(kind=ip) recursive function ipoint (ipattern, ints) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ipattern first char is a . integer(kind=ip), intent(in), dimension(:) :: ints Return Value integer(kind=ip) Source Code program problem_12b !! completely reworked solution from part a !! this one starts with the int list and checks it against the pattern. !! it also employs a function cache to speed it up. use iso_fortran_env , ip => int64 , wp => real64 use aoc_utilities use aoc_cache_module implicit none ! note: these are negative because we are appending ! them to the pattern for the cache integer ( ip ), parameter :: POINT = - 1 ! . integer ( ip ), parameter :: NUMBER = - 2 ! # integer ( ip ), parameter :: QUESTION = - 3 ! ? ! some global variables integer :: iunit , n_lines , iline character ( len = :), allocatable :: line , pattern type ( string ), dimension (:), allocatable :: vals integer ( ip ), dimension (:), allocatable :: ints , ipattern integer ( ip ) :: isum , ival type ( function_cache ) :: cache !! to cache the [[go]] function values call clk % tic () call cache % initialize ( isize = 10000 , chunk_size = 1000 ) ! open(newunit=iunit, file='inputs/day12_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day12.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ints = parse_ints ( vals ( 2 )% str ) ! integer list pattern = vals ( 1 )% str ! the pattern ! will convert the pattern to an array of numbers: ipattern = str_to_int64_array_with_mapping ( pattern ,[ '.' , '#' , '?' ],& [ POINT , NUMBER , QUESTION ]) ! expand the input ipattern = [ ipattern , QUESTION , ipattern , QUESTION , & ipattern , QUESTION , ipattern , QUESTION , & ipattern ] ints = [ ints , ints , ints , ints , ints ] ival = go ( ipattern , ints ) isum = isum + ival end do write ( * , * ) '12b: ' , isum call clk % toc ( '12b' ) contains recursive function go ( ipattern , ints ) result ( ival ) integer ( ip ), dimension (:), intent ( in ) :: ipattern integer ( ip ), dimension (:), intent ( in ) :: ints integer ( ip ) :: ival integer ( ip ) :: idx logical :: found ! first check the cache: call cache % get ([ ipattern , ints ], idx , ival , found ) if (. not . found ) then if ( size ( ints ) == 0 ) then ! no more ints ival = merge ( 0 , 1 , any ( ipattern == NUMBER )) ! if any more numbers, invalid else if ( size ( ipattern ) == 0 ) then ival = 0 ! too many ints else ! process next element in pattern select case ( ipattern ( 1 )) case ( NUMBER ); ival = ipound ( ipattern , ints ) case ( POINT ); ival = ipoint ( ipattern , ints ) case ( QUESTION ); ival = ipoint ( ipattern , ints ) + ipound ( ipattern , ints ) end select end if ! cache this function call: call cache % put ( idx ,[ ipattern , ints ], ival ) end if end function go recursive integer ( ip ) function ipound ( ipattern , ints ) integer ( ip ), dimension (:), intent ( in ) :: ipattern !! first char is a # integer ( ip ), dimension (:), intent ( in ) :: ints integer ( ip ), dimension (:), allocatable :: this_group ! check for the number of # that correspond to the first group if ( size ( ipattern ) >= ints ( 1 )) then this_group = ipattern ( 1 : ints ( 1 )) where ( this_group == QUESTION ) this_group = NUMBER ! replace ? with # if ( any ( this_group /= NUMBER )) then ! can't fit all the #'s so not valid ipound = 0 return else ! so far so good end if else ! not enough room to hold all the #'s ipound = 0 return end if if ( size ( ipattern ) == ints ( 1 )) then ! if this is the last group, then we are done ipound = merge ( 1 , 0 , size ( ints ) == 1 ) else ! the next character after this number must be a ? or . if ( size ( ipattern ) >= ints ( 1 ) + 1 ) then if ( any ( ipattern ( ints ( 1 ) + 1 ) == [ QUESTION , POINT ])) then block integer ( ip ), dimension (:), allocatable :: ipattern_tmp , ints_tmp ! to handle edge cases ! skip it and process the next group if ( size ( ipattern ) >= ints ( 1 ) + 2 ) then ipattern_tmp = ipattern ( ints ( 1 ) + 2 :) else allocate ( ipattern_tmp ( 0 )) end if if ( size ( ints ) >= 2 ) then ints_tmp = ints ( 2 :) else allocate ( ints_tmp ( 0 )) end if ipound = go ( ipattern_tmp , ints_tmp ) return end block end if end if ! not valid at this point ipound = 0 end if end function ipound recursive integer ( ip ) function ipoint ( ipattern , ints ) integer ( ip ), dimension (:), intent ( in ) :: ipattern !! first char is a . integer ( ip ), dimension (:), intent ( in ) :: ints if ( size ( ipattern ) <= 1 ) then ipoint = go ([ integer ( ip ) :: ], ints ) ! done, pass in empty array else ipoint = go ( ipattern ( 2 :), ints ) ! skip it and go to next one end if end function ipoint end program problem_12b","tags":"","loc":"program/problem_12b.html"},{"title":"problem_5 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_5~~UsesGraph program~problem_5 problem_5 iso_fortran_env iso_fortran_env program~problem_5->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_5->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_5~~CallsGraph program~problem_5 problem_5 interface~startswith aoc_utilities::startswith program~problem_5->interface~startswith proc~clock_end aoc_utilities::clock%clock_end program~problem_5->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_5->proc~clock_start proc~in_seed_list problem_5::in_seed_list program~problem_5->proc~in_seed_list proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_5->proc~number_of_lines_in_file proc~parse_ints64 aoc_utilities::parse_ints64 program~problem_5->proc~parse_ints64 proc~populate problem_5::populate program~problem_5->proc~populate proc~read_line aoc_utilities::read_line program~problem_5->proc~read_line proc~traverse~2 problem_5::traverse program~problem_5->proc~traverse~2 proc~startswith_cc aoc_utilities::startswith_cc interface~startswith->proc~startswith_cc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~map problem_5::map proc~traverse~2->proc~map proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: iunit integer :: n_lines character(len=:), allocatable :: line type( string ), dimension(:), allocatable :: vals integer(kind=ip), dimension(:), allocatable :: seeds_list integer(kind=ip) :: ilocation_min integer(kind=ip) :: ilocation integer(kind=ip) :: iseed integer(kind=ip), dimension(:), allocatable :: ilocation_min_parallel integer, parameter :: NSTAGES = 7 type( mapping ), dimension(NSTAGES) :: mappings integer :: parsing_state Derived Types type :: mapping Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(:), allocatable :: dest_start integer(kind=ip), public, dimension(:), allocatable :: dest_end integer(kind=ip), public, dimension(:), allocatable :: src_start integer(kind=ip), public, dimension(:), allocatable :: src_end Functions function in_seed_list (iseed) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: iseed Return Value logical pure function map (ival, m, reverse) result(idest) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: ival type( mapping ), intent(in) :: m logical, intent(in) :: reverse Return Value integer(kind=ip) pure function traverse (iseed, reverse) result(ilocation) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: iseed logical, intent(in) :: reverse if reverse, then ilocation -> iseed Return Value integer(kind=ip) Subroutines subroutine populate (nums, m) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(3) :: nums type( mapping ), intent(inout) :: m Source Code program problem_5 use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none integer :: i , iunit , n_lines character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals integer ( ip ), dimension (:), allocatable :: seeds_list integer ( ip ) :: ilocation_min , ilocation , iseed integer ( ip ), dimension (:), allocatable :: ilocation_min_parallel type :: mapping ! save the source and destination start and end values integer ( ip ), dimension (:), allocatable :: dest_start , dest_end , src_start , src_end end type mapping integer , parameter :: NSTAGES = 7 type ( mapping ), dimension ( NSTAGES ) :: mappings ! seed_to_soil, soil_to_fertilizer, fertilizer_to_water, water_to_light, ! light_to_temperature, temperature_to_humidity, humidity_to_location integer :: parsing_state ! index in mappings (1 to NSTAGES) call clk % tic () do i = 1 , NSTAGES allocate ( mappings ( i )% dest_start ( 0 ), mappings ( i )% dest_end ( 0 ),& mappings ( i )% src_start ( 0 ), mappings ( i )% src_end ( 0 )) end do ! open(newunit=iunit, file='inputs/day5_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day5.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) parsing_state = 0 do i = 1 , n_lines line = read_line ( iunit ) if ( line == '' ) cycle ! blank line if ( startswith ( line , 'seeds:' )) then ; seeds_list = parse_ints64 ( line ( 7 :)) else if ( index ( line , 'map:' ) > 0 ) then ; parsing_state = parsing_state + 1 ! one of the 7 stages else ! parse the numbers for the given state: call populate ( parse_ints64 ( line ), mappings ( parsing_state )) end if end do close ( iunit ) ! ------------ part 1 ----------------- ilocation_min = huge ( 1 ) do i = 1 , size ( seeds_list ) ilocation = traverse ( seeds_list ( i ),. false .) if ( ilocation < ilocation_min ) ilocation_min = ilocation end do print * , '5a: ' , ilocation_min ! ------------ part 2 ----------------- !  so it doesn't run in the CI !! if (. false .) then ! brute force, openMP version. just run the part a algorithm for all the seeds. ! takes a minute or so on my computer. allocate ( ilocation_min_parallel ( size ( seeds_list ) / 2 )) ilocation_min_parallel = huge ( 1 ) !$OMP PARALLEL DO SHARED(ilocation_min_parallel) PRIVATE(i,iseed,ilocation) do i = 1 , size ( seeds_list ), 2 do iseed = seeds_list ( i ), seeds_list ( i ) + seeds_list ( i + 1 ) - 1 ilocation = traverse ( iseed , . false .) if ( ilocation < ilocation_min_parallel (( i + 1 ) / 2 )) ilocation_min_parallel (( i + 1 ) / 2 ) = ilocation end do end do !$OMP END PARALLEL DO print * , '5b: ' , minval ( ilocation_min_parallel ) end if ! ------------ part 2 ----------------- ! Alternate version, go backwards from the location to the seed ! and see if it is contained in the seed set. ! this one is pretty fast (< 1 sec) do ilocation = minval ( mappings ( 7 )% dest_start ), maxval ( mappings ( 7 )% dest_end ) ! up to the max ilocation value iseed = traverse ( ilocation , reverse = . true .) ! from ilocation to iseed if ( in_seed_list ( iseed )) exit ! found the min end do print * , '5b: ' , ilocation call clk % toc ( '5' ) contains logical function in_seed_list ( iseed ) ! for part b, is the seed in the initial list integer ( ip ), intent ( in ) :: iseed integer :: i do i = 1 , size ( seeds_list ), 2 if ( iseed >= seeds_list ( i ) . and . iseed <= seeds_list ( i ) + seeds_list ( i + 1 ) - 1 ) then in_seed_list = . true . return end if end do in_seed_list = . false . end function in_seed_list subroutine populate ( nums , m ) integer ( ip ), dimension ( 3 ), intent ( in ) :: nums ! the three numbers from the line: ! [dest range start, src range start, range length type ( mapping ), intent ( inout ) :: m ! structure to add this data to associate ( dest => nums ( 1 ), source => nums ( 2 ), range => nums ( 3 ) ) m % dest_start = [ m % dest_start , dest ] m % dest_end = [ m % dest_end , dest + range - 1 ] m % src_start = [ m % src_start , source ] m % src_end = [ m % src_end , source + range - 1 ] end associate end subroutine populate pure function map ( ival , m , reverse ) result ( idest ) integer ( ip ), intent ( in ) :: ival type ( mapping ), intent ( in ) :: m logical , intent ( in ) :: reverse ! if reversed, go from: dest -> src integer ( ip ) :: idest integer :: i if ( reverse ) then do i = 1 , size ( m % src_start ) ! locate ival (dest) in the dest start:end range if ( ival >= m % dest_start ( i ) . and . ival <= m % dest_end ( i )) then ! found it, map to dest idest = m % src_start ( i ) + ( ival - m % dest_start ( i )) ! this is the resultant isource return end if end do else do i = 1 , size ( m % src_start ) ! locate ival (source) in the source start:end range if ( ival >= m % src_start ( i ) . and . ival <= m % src_end ( i )) then ! found it, map to dest idest = m % dest_start ( i ) + ( ival - m % src_start ( i )) return end if end do end if idest = ival ! if not found in any of the sets end function map pure function traverse ( iseed , reverse ) result ( ilocation ) integer ( ip ), intent ( in ) :: iseed logical , intent ( in ) :: reverse !! if reverse, then ilocation -> iseed integer ( ip ) :: ilocation integer :: i ilocation = iseed ! initialize if ( reverse ) then do i = NSTAGES , 1 , - 1 ilocation = map ( ilocation , mappings ( i ), reverse ) ! this is really iseed end do else do i = 1 , NSTAGES ilocation = map ( ilocation , mappings ( i ), reverse ) end do end if end function traverse end program problem_5","tags":"","loc":"program/problem_5.html"},{"title":"problem_9 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_9~~UsesGraph program~problem_9 problem_9 iso_fortran_env iso_fortran_env program~problem_9->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_9->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_9~~CallsGraph program~problem_9 problem_9 interface~parse aoc_utilities::parse program~problem_9->interface~parse proc~clock_end aoc_utilities::clock%clock_end program~problem_9->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_9->proc~clock_start proc~extrapolate problem_9::extrapolate program~problem_9->proc~extrapolate proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_9->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_9->proc~read_line proc~reverse aoc_utilities::reverse program~problem_9->proc~reverse proc~parse_nums64 aoc_utilities::parse_nums64 interface~parse->proc~parse_nums64 proc~diff aoc_utilities::diff proc~extrapolate->proc~diff interface~split aoc_utilities::split proc~parse_nums64->interface~split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: iunit integer :: n_lines integer(kind=ip) :: isum Functions pure function extrapolate (ivals) result(iextrap) extrapolate the next value in the sequence using\na difference table. Straightfoward implemention:\ncreate the full table, and then evaluate it. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals Return Value integer(kind=ip) Source Code program problem_9 use iso_fortran_env , ip => int64 ! use long ints use aoc_utilities implicit none integer :: i , iunit , n_lines integer ( ip ) :: isum call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day9_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day9.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = sum ([( extrapolate ( parse ( read_line ( iunit ))), i = 1 , n_lines )]) close ( iunit ) write ( * , * ) '9a: sum: ' , isum open ( newunit = iunit , file = 'inputs/day9.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = sum ([( extrapolate ( reverse ( parse ( read_line ( iunit )))), i = 1 , n_lines )]) close ( iunit ) write ( * , * ) '9b: sum: ' , isum call clk % toc ( '9' ) contains pure function extrapolate ( ivals ) result ( iextrap ) !! extrapolate the next value in the sequence using !! a difference table. Straightfoward implemention: !! create the full table, and then evaluate it. integer ( ip ), dimension (:), intent ( in ) :: ivals integer ( ip ) :: iextrap integer :: i , n type ( int64_vec ), dimension (:), allocatable :: diff_table !! difference table (vector of vectors) ! create the difference table: diff_table = [ int64_vec ( ivals )]; n = 1 do n = n + 1 diff_table = [ diff_table , int64_vec ( diff ( diff_table ( n - 1 )% vals ))] ! next line is diff of previous line if ( all ( diff_table ( n )% vals == 0 )) exit end do ! extrapolate iextrap = 0 do i = n - 1 , 1 , - 1 associate ( ilast => diff_table ( i )% vals ( size ( diff_table ( i )% vals )) ) iextrap = iextrap + ilast end associate end do end function extrapolate end program problem_9","tags":"","loc":"program/problem_9.html"},{"title":"problem_12 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_12~~UsesGraph program~problem_12 problem_12 iso_fortran_env iso_fortran_env program~problem_12->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_12->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_12~~CallsGraph program~problem_12 problem_12 proc~clock_end aoc_utilities::clock%clock_end program~problem_12->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_12->proc~clock_start proc~go~7 problem_12::go program~problem_12->proc~go~7 interface~split aoc_utilities::split proc~go~7->interface~split proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~go~7->proc~number_of_lines_in_file proc~parse_ints aoc_utilities::parse_ints proc~go~7->proc~parse_ints proc~read_line aoc_utilities::read_line proc~go~7->proc~read_line proc~str_to_int_array_with_mapping aoc_utilities::str_to_int_array_with_mapping proc~go~7->proc~str_to_int_array_with_mapping proc~test problem_12::test proc~go~7->proc~test proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~test->proc~test proc~match problem_12::match proc~test->proc~match proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: POINT = 0 integer, parameter :: NUMBER = 1 integer, parameter :: QUESTION = 2 integer, dimension(:), allocatable :: a integer, dimension(:), allocatable :: ints integer, dimension(:), allocatable :: ipattern integer, dimension(:), allocatable :: ipattern_tmp integer(kind=ip) :: n_valid integer(kind=ip) :: isum integer :: iline Functions function match (ipattern, ints) returns true if the pattern is valid for the int list. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: ipattern integer, intent(in), dimension(:) :: ints Return Value logical Subroutines subroutine go (expand, isum) Arguments Type Intent Optional Attributes Name logical, intent(in) :: expand integer(kind=ip), intent(out) :: isum recursive subroutine test (i, n) each ? can be either a . or a #\ncheck pattern to match the int list Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: n Source Code program problem_12 use iso_fortran_env , ip => int64 , wp => real64 use aoc_utilities implicit none integer , parameter :: POINT = 0 integer , parameter :: NUMBER = 1 integer , parameter :: QUESTION = 2 ! some global variables integer , dimension (:), allocatable :: a , ints , ipattern , ipattern_tmp integer ( ip ) :: n_valid integer ( ip ) :: isum integer :: iline call clk % tic () call go (. false ., isum ); write ( * , * ) '12a: ' , isum ! call go(.true., isum); write(*,*) '12b: ', isum call clk % toc ( '12' ) contains subroutine go ( expand , isum ) logical , intent ( in ) :: expand integer ( ip ), intent ( out ) :: isum integer :: iunit , n_lines , n_unknowns integer ( ip ) :: n_perms character ( len = :), allocatable :: line , pattern type ( string ), dimension (:), allocatable :: vals ! open(newunit=iunit, file='inputs/day12_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day12.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ints = parse_ints ( vals ( 2 )% str ) ! integer list  1,1,3 pattern = vals ( 1 )% str ! the pattern   #.#.### ! will convert the pattern to an array of numbers: ipattern = str_to_int_array_with_mapping ( pattern ,[ '.' , '#' , '?' ],& [ POINT , NUMBER , QUESTION ]) ! 1010111 if ( expand ) then ! brute force it ipattern = [ ipattern , QUESTION , ipattern , QUESTION , & ipattern , QUESTION , ipattern , QUESTION , & ipattern ] ints = [ ints , ints , ints , ints , ints ] end if n_unknowns = count ( ipattern == 2 ) n_valid = 0 ! number of valid permutations n_perms = 2 ** n_unknowns ! number of permutations ipattern_tmp = ipattern ! recursively test all the permutations if ( allocated ( a )) deallocate ( a ) allocate ( a ( n_unknowns )) call test ( 1 , n_unknowns ) isum = isum + n_valid ! write(*,*) iline, 'n_valid = ', n_valid end do end subroutine go recursive subroutine test ( i , n ) !! each ? can be either a . or a # !! check pattern to match the int list integer , intent ( in ) :: i , n integer :: ix integer , dimension ( * ), parameter :: icoeffs = [ POINT , NUMBER ] !! set of coefficients ['.', '#'] ! what we are not doing here is accounting for permutations ! that we know do not match, because the begin with a sequence ! that doesn't match. those need to be skipped... if ( i > n ) then ! so we have an array of 0s and 1s -> replace the 2s in the ipattern with these !     ipattern: 2220111  -> ???.### !            a: 011      -> .## !       result: 0110111  -> .##.### !write(*,'(a,1x,i5,1x, *(I1))') 'test:', iline, ipattern_tmp ipattern_tmp = unpack ( a , mask = ipattern == QUESTION , field = ipattern ) if ( match ( ipattern_tmp , ints )) n_valid = n_valid + 1 else do ix = 1 , 2 a ( i ) = icoeffs ( ix ) call test ( i + 1 , n ) end do end if end subroutine test logical function match ( ipattern , ints ) !! returns true if the pattern is valid for the int list. integer , dimension (:), intent ( in ) :: ipattern integer , dimension (:), intent ( in ) :: ints integer :: i , iacc , int_checked integer , dimension ( 1 ) :: ifirst , iend logical :: accumulating ! .##..###... -> 2,3 ! start and end indices (ignoring leading and trailing spaces) ifirst = findloc ( ipattern , 1 ) iend = findloc ( ipattern , 1 , back = . true .) if ( ifirst ( 1 ) == 0 . or . iend ( 1 ) == 0 ) then ! all blank match = . false .; return end if ! step through the pattern and stop once we find it invalid accumulating = . true . iacc = 0 int_checked = 0 ! the count of ints that have been checked match = . true . ! initialize do i = ifirst ( 1 ), iend ( 1 ) select case ( ipattern ( i )) case ( POINT ) if ( accumulating ) then int_checked = int_checked + 1 ! check the next one if ( int_checked > size ( ints )) then ! too many ints match = . false . return else if ( ints ( int_checked ) /= iacc ) then ! doesn't match match = . false . return end if accumulating = . false . iacc = 0 end if case ( NUMBER ) if ( accumulating ) then iacc = iacc + 1 else ! start of a new number accumulating = . true . iacc = 1 end if if ( i == iend ( 1 )) then ! last number int_checked = int_checked + 1 ! check the next one if ( int_checked /= size ( ints )) then ! not enough ints match = . false . return else if ( ints ( int_checked ) /= iacc ) then ! doesn't match match = . false . return end if end if end select end do end function match end program problem_12","tags":"","loc":"program/problem_12.html"},{"title":"problem_13 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_13~~UsesGraph program~problem_13 problem_13 iso_fortran_env iso_fortran_env program~problem_13->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_13->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_13~~CallsGraph program~problem_13 problem_13 proc~clock_end aoc_utilities::clock%clock_end program~problem_13->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_13->proc~clock_start proc~go~5 problem_13::go program~problem_13->proc~go~5 proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_13->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_13->proc~read_line proc~str_to_int_array_with_mapping aoc_utilities::str_to_int_array_with_mapping program~problem_13->proc~str_to_int_array_with_mapping Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: iunit integer :: iline integer :: n_lines integer :: ival integer :: isum integer :: ival2 integer :: isum2 integer :: m integer :: n integer :: nrows integer :: ncols integer :: ileft integer :: iabove integer :: ileft2 integer :: iabove2 type( string ), dimension(:), allocatable :: lines integer, dimension(:,:), allocatable :: puzzle integer, dimension(:,:), allocatable :: puzzle2 character(len=:), allocatable :: line integer, parameter :: ASH = 0 . integer, parameter :: ROCK = 1 Subroutines subroutine go (puzzle, ileft, iskip) compute the number of cols to left of mirror (0 if none)\ncall with transpose(puzzle) to get number of rows above. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: puzzle integer, intent(out) :: ileft integer, intent(in), optional :: iskip don't consider this column Source Code program problem_13 use iso_fortran_env , ip => int64 , wp => real64 use aoc_utilities implicit none integer :: i , iunit , iline , n_lines , ival , isum , ival2 , isum2 , & m , n , nrows , ncols , ileft , iabove , ileft2 , iabove2 type ( string ), dimension (:), allocatable :: lines integer , dimension (:,:), allocatable :: puzzle , puzzle2 character ( len = :), allocatable :: line integer , parameter :: ASH = 0 !! . integer , parameter :: ROCK = 1 !! # call clk % tic () ! open(newunit=iunit, file='inputs/day13_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day13.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 isum2 = 0 do iline = 1 , n_lines line = read_line ( iunit ) if ( line == '' . or . iline == n_lines ) then ! process this puzzle ! convert the puzzle to a numeric matrix: if ( allocated ( puzzle )) deallocate ( puzzle ) nrows = size ( lines ) ncols = len ( lines ( 1 )% str ) allocate ( puzzle ( nrows , ncols )) do i = 1 , nrows puzzle ( i ,:) = str_to_int_array_with_mapping ( lines ( i )% str , [ '.' , '#' ], [ ASH , ROCK ]) end do ! part 1 call go ( puzzle , ileft ) call go ( transpose ( puzzle ), iabove ) ival = ileft + 100 * iabove isum = isum + ival ! part 2 main : do m = 1 , nrows do n = 1 , ncols ! permute each with a smudge and find the different non-zero value puzzle2 = puzzle if ( puzzle ( m , n ) == ASH ) then puzzle2 ( m , n ) = ROCK else puzzle2 ( m , n ) = ASH end if ! don't consider the one from part a (since that one still may be valid) call go ( puzzle2 , ileft2 , iskip = ileft ) call go ( transpose ( puzzle2 ), iabove2 , iskip = iabove ) if (( ileft2 /= ileft . or . iabove2 /= iabove ) . and . ( ileft2 /= 0 . or . iabove2 /= 0 )) then ival = ileft2 + 100 * iabove2 ! found it exit main end if end do end do main isum2 = isum2 + ival deallocate ( lines ) else ! accumulate this line in the current puzzle if (. not . allocated ( lines )) allocate ( lines ( 0 )) lines = [ lines , string ( line )] end if end do write ( * , * ) '13a: ' , isum write ( * , * ) '13b: ' , isum2 call clk % toc ( '13' ) contains subroutine go ( puzzle , ileft , iskip ) !! compute the number of cols to left of mirror (0 if none) !! call with transpose(puzzle) to get number of rows above. integer , dimension (:,:), intent ( in ) :: puzzle integer , intent ( out ) :: ileft integer , intent ( in ), optional :: iskip !! don't consider this column integer :: nrows , ncols , i , j logical :: mirror nrows = size ( puzzle , 1 ) ncols = size ( puzzle , 2 ) ileft = 0 do i = 1 , ncols - 1 if ( present ( iskip )) then if ( i == iskip ) cycle end if mirror = . true . do j = 1 , min ( i , ncols - i ) if ( any ( puzzle (:, i - j + 1 ) /= puzzle (:, i + j )) ) then mirror = . false . ! no mirror on this line exit end if end do if ( mirror ) then ileft = i exit end if end do end subroutine go end program problem_13","tags":"","loc":"program/problem_13.html"},{"title":"problem_19 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_19~~UsesGraph program~problem_19 problem_19 iso_fortran_env iso_fortran_env program~problem_19->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_19->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_19~~CallsGraph program~problem_19 problem_19 interface~split aoc_utilities::split program~problem_19->interface~split proc~clock_end aoc_utilities::clock%clock_end program~problem_19->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_19->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_19->proc~number_of_lines_in_file proc~parse_rule~2 problem_19::parse_rule program~problem_19->proc~parse_rule~2 proc~process~2 problem_19::process program~problem_19->proc~process~2 proc~rating problem_19::rating program~problem_19->proc~rating proc~read_line aoc_utilities::read_line program~problem_19->proc~read_line proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~parse_rule~2->interface~split proc~workflow_name_to_index~2 problem_19::workflow_name_to_index proc~process~2->proc~workflow_name_to_index~2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit integer :: n_lines integer :: iline integer :: i character(len=:), allocatable :: line type( string ), dimension(:), allocatable :: vals logical :: accepted integer(kind=ip) :: total_accepted type( part ), dimension(:), allocatable :: parts type( workflow ), dimension(:), allocatable :: workflows type( workflow ), allocatable :: w Derived Types type :: part Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(4) :: xmas type :: rule Components Type Visibility Attributes Name Initial logical, public :: accept = .false. logical, public :: reject = .false. integer, public :: operator = 0 integer, public :: operator_arg = 0 integer, public :: operator_val = 0 character(len=:), public, allocatable :: goto type :: workflow Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name type( rule ), public, dimension(:), allocatable :: rules Functions pure function rating (p) Arguments Type Intent Optional Attributes Name type( part ), intent(in) :: p Return Value integer(kind=ip) function process (p) result(accepted) process this part through all the workflows. Arguments Type Intent Optional Attributes Name type( part ), intent(in) :: p Return Value logical function workflow_name_to_index (name) result(idx) get the index of this workflow in the array Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value integer function parse_rule (s) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value type( rule ) Source Code program problem_19 use aoc_utilities use iso_fortran_env , only : wp => real64 , ip => int64 implicit none integer :: iunit , n_lines , iline , i character ( len = :), allocatable :: line !, name type ( string ), dimension (:), allocatable :: vals logical :: accepted integer ( ip ) :: total_accepted type :: part integer ( ip ), dimension ( 4 ) :: xmas ! [x,m,a,s] end type part type ( part ), dimension (:), allocatable :: parts type :: rule logical :: accept = . false . logical :: reject = . false . integer :: operator = 0 ! 1:<, 2:> integer :: operator_arg = 0 ! 1:x, 2:m, 3:a, 4:s integer :: operator_val = 0 ! value to compare to character ( len = :), allocatable :: goto ! where to next (workflow name) end type rule type :: workflow character ( len = :), allocatable :: name type ( rule ), dimension (:), allocatable :: rules end type workflow type ( workflow ), dimension (:), allocatable :: workflows type ( workflow ), allocatable :: w call clk % tic () ! open(newunit=iunit, file='inputs/day19_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day19.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( workflows ( 0 )) do iline = 1 , n_lines line = read_line ( iunit ) if ( line == '' ) then !now parse part ratings allocate ( parts ( 0 )) end if if ( allocated ( parts )) then ! parsing parts if ( line == '' ) cycle ! {x=787,m=2655,a=1222,s=2876} vals = split ( line , ',' ) parts = [ parts , part ( xmas = [ int ( vals ( 1 )% str ( 4 :)), & int ( vals ( 2 )% str ( 3 :)), & int ( vals ( 3 )% str ( 3 :)), & int ( vals ( 4 )% str ( 3 : len ( vals ( 4 )% str ) - 1 ))])] else ! parsing workflows : qqz{s>2770:qs,m<1801:hdj,R} if ( allocated ( w )) deallocate ( w ); allocate ( w ) ! blank one vals = split ( line , '{' ) w % name = vals ( 1 )% str ! workflow name !write(*,*) '--->'//w%name//'<-----' vals ( 2 )% str = vals ( 2 )% str ( 1 : len ( vals ( 2 )% str ) - 1 ) ! remove last bracket vals = split ( vals ( 2 )% str , ',' ) ! workflow rules ! add each rule to the workflow allocate ( w % rules ( 0 )) do i = 1 , size ( vals ) w % rules = [ w % rules , parse_rule ( vals ( i )% str )] end do workflows = [ workflows , w ] end if end do total_accepted = 0 do i = 1 , size ( parts ) accepted = process ( parts ( i )) !write(*,*) parts(i), accepted if ( accepted ) then total_accepted = total_accepted + rating ( parts ( i )) end if end do write ( * , * ) '19a: ' , total_accepted call clk % toc ( '19' ) contains pure integer ( ip ) function rating ( p ) type ( part ), intent ( in ) :: p rating = sum ( p % xmas ) end function rating function process ( p ) result ( accepted ) !! process this part through all the workflows. type ( part ), intent ( in ) :: p logical :: accepted integer :: i , irule i = workflow_name_to_index ( 'in' ) ! start at the first workflow irule = 1 ! first rule do associate ( r => workflows ( i )% rules ( irule ) ) ! check if we are done if ( r % accept ) then ; accepted = . true .; return ; end if if ( r % reject ) then ; accepted = . false .; return ; end if if ( r % operator > 0 ) then ! process the operator select case ( r % operator ) case ( 1 ) ! < if ( p % xmas ( r % operator_arg ) < r % operator_val ) then ! check if done if ( r % goto == 'A' ) then ; accepted = . true .; return ; end if if ( r % goto == 'R' ) then ; accepted = . false .; return ; end if ! go to next workflow: i = workflow_name_to_index ( r % goto ) !write(*,*) 'goto '//r%goto irule = 1 ! start at first rule of new workflow else irule = irule + 1 ! next rule end if case ( 2 ) ! > if ( p % xmas ( r % operator_arg ) > r % operator_val ) then ! check if done if ( r % goto == 'A' ) then ; accepted = . true .; return ; end if if ( r % goto == 'R' ) then ; accepted = . false .; return ; end if ! go to next workflow: i = workflow_name_to_index ( r % goto ) irule = 1 ! start at first rule of new workflow else irule = irule + 1 ! next rule end if end select else ! goto another workflow i = workflow_name_to_index ( r % goto ) irule = 1 ! start at first rule of new workflow end if end associate end do end function process function workflow_name_to_index ( name ) result ( idx ) !! get the index of this workflow in the array character ( len =* ), intent ( in ) :: name integer :: idx do idx = 1 , size ( workflows ) if ( name == workflows ( idx )% name ) return ! found it end do if ( idx > size ( workflows )) error stop 'workflow not found: ' // name end function workflow_name_to_index function parse_rule ( s ) result ( r ) character ( len =* ), intent ( in ) :: s type ( rule ) :: r type ( string ), dimension (:), allocatable :: v character ( len =* ), parameter :: xmas = 'xmas' ! 1,2,3,4 if ( s == 'A' ) then r % accept = . true . else if ( s == 'R' ) then r % reject = . true . else if ( index ( s , '>' ) > 0 ) then v = split ( s ( 3 :), ':' ) ! example: a<2006:qkq r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 2 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else if ( index ( s , '<' ) > 0 ) then v = split ( s ( 3 :), ':' ) r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 1 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else r % goto = s ! it's a workflow name end if end if end function parse_rule end program problem_19","tags":"","loc":"program/problem_19.html"},{"title":"problem_3 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_3~~UsesGraph program~problem_3 problem_3 iso_fortran_env iso_fortran_env program~problem_3->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_3->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_3~~CallsGraph program~problem_3 problem_3 proc~check problem_3::check program~problem_3->proc~check proc~clock_end aoc_utilities::clock%clock_end program~problem_3->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_3->proc~clock_start proc~get_number problem_3::get_number program~problem_3->proc~get_number proc~is_not_number aoc_utilities::is_not_number program~problem_3->proc~is_not_number proc~is_symbol problem_3::is_symbol program~problem_3->proc~is_symbol proc~read_file_to_char_array aoc_utilities::read_file_to_char_array program~problem_3->proc~read_file_to_char_array proc~check->proc~get_number proc~is_number aoc_utilities::is_number proc~check->proc~is_number proc~get_number->proc~is_symbol proc~is_not_number->proc~is_number proc~is_symbol->proc~is_not_number proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: n_lines integer :: i integer :: j integer :: n_cols integer :: jstart integer :: jend logical :: adjacent logical :: tmp integer(kind=int64) :: isum character(len=1), dimension(:,:), allocatable :: array integer(kind=int64), dimension(:), allocatable :: ivals Functions function check (i, j) if the char is part of a number, then get it and append to ivals Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Return Value logical function is_symbol (c) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical function get_number (i, j) get the full number contining the character at i,j Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Return Value integer(kind=int64) Source Code program problem_3 use iso_fortran_env use aoc_utilities implicit none integer :: n_lines , i , j , n_cols , jstart , jend logical :: adjacent , tmp integer ( int64 ) :: isum character ( len = 1 ), dimension (:,:), allocatable :: array integer ( int64 ), dimension (:), allocatable :: ivals call clk % tic () ! read file: ! pad around with blanks to simplify logic below array = read_file_to_char_array ( 'inputs/day3.txt' , border = '.' ) n_lines = size ( array , 1 ) n_cols = size ( array , 2 ) !----------------- part 1 ----------------- isum = 0 do i = 1 , n_lines ! is this character adjacent to a symbol? jend = 0 do j = 1 , n_cols if ( is_not_number ( array ( i , j ))) cycle if ( j <= jend ) cycle ! skip the cols that we already have jend = 0 adjacent = is_symbol ( array ( i - 1 , j ) ) . or . & is_symbol ( array ( i - 1 , j - 1 )) . or . & is_symbol ( array ( i - 1 , j + 1 )) . or . & is_symbol ( array ( i , j - 1 ) ) . or . & is_symbol ( array ( i , j + 1 ) ) . or . & is_symbol ( array ( i + 1 , j ) ) . or . & is_symbol ( array ( i + 1 , j - 1 )) . or . & is_symbol ( array ( i + 1 , j + 1 )) if ( adjacent ) isum = isum + get_number ( i , j ) ! note: this sets jend end do end do write ( * , * ) '3a: sum :' , isum !----------------- part 2 ----------------- ! now look for '*' and find adjacent numbers .... isum = 0 do i = 1 , n_lines do j = 1 , n_cols if ( array ( i , j ) == '*' ) then ! look for 2 adjacent numbers. if ( allocated ( ivals )) deallocate ( ivals ); allocate ( ivals ( 0 )) ! above tmp = check ( i - 1 , j ) ! if only one on top if (. not . tmp ) then tmp = check ( i - 1 , j - 1 ) tmp = check ( i - 1 , j + 1 ) end if tmp = check ( i , j - 1 ) ! left and right tmp = check ( i , j + 1 ) ! below tmp = check ( i + 1 , j ) ! if only one below if (. not . tmp ) then tmp = check ( i + 1 , j - 1 ) tmp = check ( i + 1 , j + 1 ) end if if ( size ( ivals ) == 2 ) isum = isum + product ( ivals ) ! sum gear ratio end if end do end do write ( * , * ) '3b: result :' , isum call clk % toc ( '3' ) contains logical function check ( i , j ) !! if the char is part of a number, then get it and append to ivals integer , intent ( in ) :: i , j check = is_number ( array ( i , j )) if ( check ) ivals = [ ivals , get_number ( i , j )] end function check logical function is_symbol ( c ) character ( len = 1 ), intent ( in ) :: c is_symbol = is_not_number ( c ) . and . c /= '.' end function is_symbol integer ( int64 ) function get_number ( i , j ) !! get the full number contining the character at i,j integer , intent ( in ) :: i , j jstart = j jend = j do if ( array ( i , jstart - 1 ) == '.' . or . is_symbol ( array ( i , jstart - 1 ))) exit jstart = jstart - 1 end do do if ( array ( i , jend + 1 ) == '.' . or . is_symbol ( array ( i , jend + 1 ))) exit jend = jend + 1 end do get_number = int ( array ( i , jstart : jend )) end function get_number end program problem_3","tags":"","loc":"program/problem_3.html"},{"title":"problem_8 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_8~~UsesGraph program~problem_8 problem_8 iso_fortran_env iso_fortran_env program~problem_8->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_8->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_8~~CallsGraph program~problem_8 problem_8 proc~clock_end aoc_utilities::clock%clock_end program~problem_8->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_8->proc~clock_start proc~find_node problem_8::find_node program~problem_8->proc~find_node proc~lcm aoc_utilities::lcm program~problem_8->proc~lcm proc~moves problem_8::moves program~problem_8->proc~moves proc~moves_any_z problem_8::moves_any_z program~problem_8->proc~moves_any_z proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_8->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_8->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit integer :: n_lines character(len=:), allocatable :: line character(len=:), allocatable :: instructions type( string ), dimension(:), allocatable :: vals integer(kind=ip) :: i integer(kind=ip) :: j integer(kind=ip) :: idx integer(kind=ip) :: idx_zzz integer(kind=ip) :: imoves integer(kind=ip) :: ias integer(kind=ip) :: izs integer(kind=ip), dimension(:), allocatable :: instructions_ints integer(kind=ip), dimension(:), allocatable :: idx_vec integer(kind=ip), dimension(:), allocatable :: idx_zzz_vec integer(kind=ip), dimension(:), allocatable :: imoves_vec type( node ), dimension(:), allocatable :: nodes Derived Types type :: node Components Type Visibility Attributes Name Initial character(len=3), public :: name = '' character(len=3), public, dimension(2) :: lr integer, public, dimension(2) :: lr_idx Functions pure function moves (istart, iend) result(imoves) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: istart indices for start and end nodes integer(kind=ip), intent(in) :: iend indices for start and end nodes Return Value integer(kind=ip) pure function moves_any_z (istart, iend) result(imoves) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: istart indices for start and end nodes integer(kind=ip), intent(in), dimension(:) :: iend Return Value integer(kind=ip) pure function all_in_set (ivals, iset) returns true if all the elements of ivals are in the set iset Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals integer(kind=ip), intent(in), dimension(:) :: iset Return Value logical pure function find_node (name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value integer(kind=ip) Source Code program problem_8 use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none integer :: iunit , n_lines character ( len = :), allocatable :: line , instructions type ( string ), dimension (:), allocatable :: vals integer ( ip ) :: i , j , idx , idx_zzz , imoves , ias , izs integer ( ip ), dimension (:), allocatable :: instructions_ints integer ( ip ), dimension (:), allocatable :: idx_vec , idx_zzz_vec integer ( ip ), dimension (:), allocatable :: imoves_vec type :: node character ( len = 3 ) :: name = '' character ( len = 3 ), dimension ( 2 ) :: lr integer , dimension ( 2 ) :: lr_idx ! the indices in the nodes array of the l,r nodes end type node type ( node ), dimension (:), allocatable :: nodes call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day8_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day8.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( nodes ( n_lines - 2 )) instructions = read_line ( iunit ) allocate ( instructions_ints ( len ( instructions ))) do i = 1 , len ( instructions ) select case ( instructions ( i : i )) ! make an int array for easier access case ( 'L' ); instructions_ints ( i ) = 1 case ( 'R' ); instructions_ints ( i ) = 2 end select end do do i = 0 , n_lines - 1 line = read_line ( iunit ) if ( line == '' ) cycle read ( line , \"(A3,1X,1X,1X,1X,A3,1X,1X,A3,1X)\" ) nodes ( i )% name , nodes ( i )% lr ( 1 ), nodes ( i )% lr ( 2 ) end do close ( iunit ) ! compute all the lr indices: do i = 1 , size ( nodes ) nodes ( i )% lr_idx ( 1 ) = find_node ( nodes ( i )% lr ( 1 )) nodes ( i )% lr_idx ( 2 ) = find_node ( nodes ( i )% lr ( 2 )) end do !******************************************** imoves = moves ( find_node ( 'AAA' ), find_node ( 'ZZZ' )) write ( * , * ) '8a : number of moves:' , imoves !******************************************** ! get indices of the ones that end in A and Z: allocate ( idx_vec ( 0 ), idx_zzz_vec ( 0 )) do i = 1 , size ( nodes ) if ( nodes ( i )% name ( 3 : 3 ) == 'A' ) idx_vec = [ idx_vec , i ] if ( nodes ( i )% name ( 3 : 3 ) == 'Z' ) idx_zzz_vec = [ idx_zzz_vec , i ] end do if ( size ( idx_vec ) /= size ( idx_zzz_vec )) error stop 'error: they need to be the same size?' allocate ( imoves_vec ( size ( idx_vec ))) ! for EACH start, find the number of moves that it takes to get to ONE of the ends. do i = 1 , size ( idx_vec ) imoves_vec ( i ) = moves_any_z ( idx_vec ( i ), idx_zzz_vec ) end do ! don't know why this works ¯\\_(ツ)_/¯ ! I think it's a feature of the specific data given ! (it's a repeating cycle once it gets to the end) write ( * , * ) '8b : number of moves: ' , lcm ( lcm ( lcm ( lcm ( lcm ( imoves_vec ( 1 ),& imoves_vec ( 2 )),& imoves_vec ( 3 )),& imoves_vec ( 4 )),& imoves_vec ( 5 )),& imoves_vec ( 6 )) ! ! ! ! brute force. run all the moves in parallel until they are all done. ! ! ! i = 0 ! imoves = 0 ! do !     if (all_in_set(idx_vec, idx_zzz_vec)) exit !     imoves = imoves + 1 ! another move !     i = i + 1 !     if (i>len(instructions)) i = 1 !     do concurrent (j = 1 : size(idx_vec)) !         idx_vec(j) = nodes(idx_vec(j))%lr_idx(instructions_ints(i)) !     end do ! end do ! write(*,*) '8b : number of moves:', imoves call clk % toc ( '8' ) contains pure function moves ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart , iend !! indices for start and end nodes integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( idx == iend ) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves pure function moves_any_z ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart !! indices for start and end nodes integer ( ip ), dimension (:), intent ( in ) :: iend integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( any ( idx == iend )) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves_any_z pure logical function all_in_set ( ivals , iset ) !! returns true if all the elements of ivals are in the set iset integer ( ip ), dimension (:), intent ( in ) :: ivals , iset integer :: i all_in_set = . true . do i = 1 , size ( ivals ) if (. not . any ( ivals ( i ) == iset )) then all_in_set = . false . exit end if end do end function all_in_set pure integer ( ip ) function find_node ( name ) character ( len =* ), intent ( in ) :: name integer ( ip ) :: i do i = 1 , size ( nodes ) if ( name == nodes ( i )% name ) then find_node = i return end if end do error stop 'could not find node' end function find_node end program problem_8","tags":"","loc":"program/problem_8.html"},{"title":"problem_17 – AoC-2023","text":"Uses aoc_utilities aoc_cache_module iso_fortran_env program~~problem_17~~UsesGraph program~problem_17 problem_17 iso_fortran_env iso_fortran_env program~problem_17->iso_fortran_env module~aoc_cache_module aoc_cache_module program~problem_17->module~aoc_cache_module module~aoc_utilities aoc_utilities program~problem_17->module~aoc_utilities module~aoc_cache_module->iso_fortran_env module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. part b Calls program~~problem_17~~CallsGraph program~problem_17 problem_17 proc~add_to_queue problem_17::add_to_queue program~problem_17->proc~add_to_queue proc~check~2 problem_17::check program~problem_17->proc~check~2 proc~clock_end aoc_utilities::clock%clock_end program~problem_17->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_17->proc~clock_start proc~initialize_cache aoc_cache_module::function_cache%initialize_cache program~problem_17->proc~initialize_cache proc~read_file_to_int_array aoc_utilities::read_file_to_int_array program~problem_17->proc~read_file_to_int_array proc~expand_queue problem_17::expand_queue proc~add_to_queue->proc~expand_queue proc~check~2->proc~add_to_queue proc~index_in_queue problem_17::index_in_queue proc~check~2->proc~index_in_queue proc~destroy_cache aoc_cache_module::function_cache%destroy_cache proc~initialize_cache->proc~destroy_cache proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_int_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_int_array->proc~read_line proc~get_from_cache aoc_cache_module::function_cache%get_from_cache proc~index_in_queue->proc~get_from_cache proc~put_in_cache aoc_cache_module::function_cache%put_in_cache proc~index_in_queue->proc~put_in_cache proc~vector_djb_hash aoc_cache_module::vector_djb_hash proc~get_from_cache->proc~vector_djb_hash Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: NSTATE = 4 number of state dimensions [i,j,direction,moves_in_that_direction] integer, parameter :: N_DIRECTIONS = 4 integer(kind=ip), parameter :: UP = 1 integer(kind=ip), parameter :: DOWN = -1 integer(kind=ip), parameter :: LEFT = 2 integer(kind=ip), parameter :: RIGHT = -2 integer, parameter :: MAX_MOVES_IN_DIR = 10 type( function_cache ) :: cache to cache the queue access ... to try to speed things up !!! type( item ), dimension(:), allocatable :: queue will be expanding integer(kind=ip), dimension(1) :: iloc integer(kind=ip) :: idx integer :: i integer :: j integer :: n_rows integer :: n_cols integer, dimension(:,:), allocatable :: map heat map integer(kind=ip) :: queue_size Derived Types type :: item Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(NSTATE) :: state = 0 state: [i, j, direction, and # of moves] integer(kind=ip), public :: dist = huge(1) distance for this one logical, public :: visited = .false. if this one is done integer(kind=ip), public :: iprev = -1 index in the queue of the previous one Functions function index_in_queue (state) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state Return Value integer(kind=ip) index in the queue. -1 if not present Subroutines subroutine check (idx, idirection) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: idx integer(kind=ip), intent(in) :: idirection direction to move from current subroutine add_to_queue (state, idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state integer(kind=ip), intent(out) :: idx index of the element in the queue pure subroutine expand_queue (vec, n, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name type( item ), intent(inout), dimension(:), allocatable :: vec integer(kind=ip), intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call type( item ), intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) Source Code program problem_17 !! part b use aoc_utilities use iso_fortran_env , ip => int64 use aoc_cache_module implicit none integer , parameter :: NSTATE = 4 !! number of state dimensions [i,j,direction,moves_in_that_direction] integer , parameter :: N_DIRECTIONS = 4 ! 1,2,3,4 integer ( ip ), parameter :: UP = 1 ! direction traveling integer ( ip ), parameter :: DOWN = - 1 integer ( ip ), parameter :: LEFT = 2 integer ( ip ), parameter :: RIGHT = - 2 integer , parameter :: MAX_MOVES_IN_DIR = 10 !3 type ( function_cache ) :: cache !! to cache the queue access ... to try to speed things up !!! ! queue for the states and distances... rather than constructing the 2d array... ! just create this as we go... type :: item integer ( ip ), dimension ( NSTATE ) :: state = 0 !! state: [i, j, direction, and # of moves] integer ( ip ) :: dist = huge ( 1 ) !! distance for this one logical :: visited = . false . !! if this one is done integer ( ip ) :: iprev = - 1 !! index in the queue of the previous one end type item type ( item ), dimension (:), allocatable :: queue !! will be expanding integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: idx integer :: i , j , n_rows , n_cols integer , dimension (:,:), allocatable :: map !! heat map integer ( ip ) :: queue_size ! for the CI ! need a faster version ... write ( * , * ) 'it works but takes a few minutes...' stop call clk % tic () call cache % initialize ( isize = 10000 , chunk_size = 1000 ) ! map = read_file_to_int_array('inputs/day17_test.txt') map = read_file_to_int_array ( 'inputs/day17.txt' ) n_rows = size ( map , 1 ) n_cols = size ( map , 2 ) queue_size = 0 call add_to_queue ([ 1_ip , 1_ip , 0_ip , 0_ip ], idx ) ! start queue ( idx )% dist = 0 do ! find min distance so far for ones not visited iloc = minloc ( queue ( 1 : queue_size )% dist , mask = . not . queue ( 1 : queue_size )% visited ) idx = iloc ( 1 ) ! index in the queue queue ( idx )% visited = . true . if ( queue ( idx )% state ( 1 ) == n_rows . and . queue ( idx )% state ( 2 ) == n_cols ) exit ! destination: we are done ! process ajacent ones: call check ( idx , UP ) call check ( idx , DOWN ) call check ( idx , LEFT ) call check ( idx , RIGHT ) end do write ( * , * ) '17b: ' , queue ( idx )% dist call clk % toc ( '17' ) contains subroutine check ( idx , idirection ) implicit none integer ( ip ), intent ( in ) :: idx ! current item in the queue to process integer ( ip ), intent ( in ) :: idirection !! direction to move from current integer ( ip ) :: alt integer ( ip ), dimension ( 2 ) :: v ! neighbor to move to integer ( ip ) :: imovesv , idxv , distv integer ( ip ), dimension ( NSTATE ) :: istate logical :: in_queue associate ( i => queue ( idx )% state ( 1 ), & j => queue ( idx )% state ( 2 ), & direction => queue ( idx )% state ( 3 ), & n_moves => queue ( idx )% state ( 4 )) if ( direction ==- idirection ) return ! can't reverse ! the one to go to: if ( direction == idirection ) then if ( n_moves == MAX_MOVES_IN_DIR ) return ! can't move in this direction anymore imovesv = n_moves + 1 else if ( n_moves /= 0 . and . n_moves < 4 ) return ! must move at last 4 before a turn! imovesv = 1 ! reset on change of direction end if select case ( idirection ) case ( UP ); v = [ i - 1 , j ] case ( DOWN ); v = [ i + 1 , j ] case ( LEFT ); v = [ i , j - 1 ] case ( RIGHT ); v = [ i , j + 1 ] end select if ( v ( 1 ) < 1 . or . v ( 2 ) < 1 . or . v ( 1 ) > n_rows . or . v ( 2 ) > n_cols ) return ! can't go off the board if ( v ( 1 ) == n_rows . and . v ( 2 ) == n_cols . and . imovesv < 4 ) return ! require at least 4 to end istate = [ v ( 1 ), v ( 2 ), idirection , imovesv ] ! new state idxv = index_in_queue ( istate ) ! is it already in the queue in_queue = idxv > 0 ! if this one is already part of another path if ( in_queue ) then if ( queue ( idxv )% visited ) return ! already visited this one distv = queue ( idxv )% dist ! distance in the queue else !call add_to_queue(istate, idxv) ! add this to the queue for processing ! always add it ?? distv = huge ( 1_ip ) ! not processed yet, so huge number end if !alt = queue(idx)%dist + map(queue(idxv)%state(1), queue(idxv)%state(2)) alt = queue ( idx )% dist + map ( v ( 1 ), v ( 2 )) ! new distance if ( alt < distv ) then ! the new one is better, so replace values in the queue if (. not . in_queue ) call add_to_queue ( istate , idxv ) ! only add it if we accept it ???? ! accept this step queue ( idxv )% dist = alt ! new best dist queue ( idxv )% iprev = idx ! previous end if end associate end subroutine check ! .. need a faster queue... function index_in_queue ( state ) result ( idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ) :: idx !! index in the queue. -1 if not present integer ( ip ) :: i logical :: found integer ( ip ) :: cache_idx , cache_ival call cache % get ( state , cache_idx , cache_ival , found ) if ( found ) then idx = cache_ival else idx = - 1 if (. not . allocated ( queue )) error stop 'error: queue not allocated' do i = 1 , queue_size if ( all ( state == queue ( i )% state )) then idx = i exit end if end do if ( idx /= - 1 ) call cache % put ( cache_idx , state , idx ) end if end function index_in_queue subroutine add_to_queue ( state , idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ), intent ( out ) :: idx !! index of the element in the queue if ( allocated ( queue )) then call expand_queue ( queue , queue_size , item ( state = state )) idx = queue_size else queue = [ item ( state = state )] queue_size = 1 idx = 1 end if end subroutine add_to_queue !**************************************************************** !> !  Add elements to the integer vector in chunks. pure subroutine expand_queue ( vec , n , val , finished ) integer ( ip ), parameter :: chunk_size = 1000 type ( item ), dimension (:), allocatable , intent ( inout ) :: vec integer ( ip ), intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call type ( item ), intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) type ( item ), dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_queue !**************************************************************** end program problem_17","tags":"","loc":"program/problem_17.html"},{"title":"problem_6 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_6~~UsesGraph program~problem_6 problem_6 iso_fortran_env iso_fortran_env program~problem_6->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_6->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_6~~CallsGraph program~problem_6 problem_6 proc~clock_end aoc_utilities::clock%clock_end program~problem_6->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_6->proc~clock_start proc~go~8 problem_6::go program~problem_6->proc~go~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer(kind=ip), parameter,               dimension(*) :: time_a = [60, 94, 78, 82] integer(kind=ip), parameter,               dimension(*) :: distance_a = [475, 2138, 1015, 1650] integer(kind=ip), parameter,               dimension(*) :: time_b = [60947882_ip] integer(kind=ip), parameter,               dimension(*) :: distance_b = [475213810151650_ip] Functions function go (time, distance) result(iproduct) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: time integer(kind=ip), intent(in), dimension(:) :: distance Return Value integer(kind=ip) Source Code program problem_6 use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none ! just copy and paste the inputs here: ! a integer ( ip ), dimension ( * ), parameter :: time_a = [ 60 , 94 , 78 , 82 ] integer ( ip ), dimension ( * ), parameter :: distance_a = [ 475 , 2138 , 1015 , 1650 ] ! b integer ( ip ), dimension ( * ), parameter :: time_b = [ 60947882_ip ] integer ( ip ), dimension ( * ), parameter :: distance_b = [ 475213810151650_ip ] call clk % tic () print * , '6a: ways to win:' , go ( time_a , distance_a ) print * , '6b: ways to win:' , go ( time_b , distance_b ) call clk % toc ( '6' ) contains function go ( time , distance ) result ( iproduct ) integer ( ip ), dimension (:), intent ( in ) :: time integer ( ip ), dimension (:), intent ( in ) :: distance integer ( ip ) :: iproduct integer ( ip ) :: i , ihold , iways , idistance iproduct = 1 do i = 1 , size ( time ) iways = 0 do ihold = 1 , time ( i ) ! time to hold the button idistance = ihold * ( time ( i ) - ihold ) if ( idistance > distance ( i )) iways = iways + 1 end do iproduct = iproduct * iways end do end function go end program problem_6","tags":"","loc":"program/problem_6.html"},{"title":"problem_17 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_17~2~~UsesGraph program~problem_17~2 problem_17 iso_fortran_env iso_fortran_env program~problem_17~2->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_17~2->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Based on AOC 2021 Day 15: https://github.com/jacobwilliams/AoC-2021/blob/master/test/problem_15.f90\nsee: https://en.wikipedia.org/wiki/Dijkstra's_algorithm#Pseudocode only difference is the constraint that it can move at most three blocks in a single direction Calls program~~problem_17~2~~CallsGraph program~problem_17~2 problem_17 proc~add_to_queue~2 problem_17::add_to_queue program~problem_17~2->proc~add_to_queue~2 proc~check~3 problem_17::check program~problem_17~2->proc~check~3 proc~clock_end aoc_utilities::clock%clock_end program~problem_17~2->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_17~2->proc~clock_start proc~read_file_to_int_array aoc_utilities::read_file_to_int_array program~problem_17~2->proc~read_file_to_int_array proc~check~3->proc~add_to_queue~2 proc~index_in_queue~2 problem_17::index_in_queue proc~check~3->proc~index_in_queue~2 proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_int_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_int_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: NSTATE = 4 number of state dimensions [i,j,direction,moves_in_that_direction] integer, parameter :: N_DIRECTIONS = 4 integer(kind=ip), parameter :: UP = 1 integer(kind=ip), parameter :: DOWN = -1 integer(kind=ip), parameter :: LEFT = 2 integer(kind=ip), parameter :: RIGHT = -2 integer, parameter :: MAX_MOVES_IN_DIR = 3 type( item ), dimension(:), allocatable :: queue will be expanding integer(kind=ip), dimension(1) :: iloc integer(kind=ip) :: idx integer :: i integer :: j integer :: n_rows integer :: n_cols integer, dimension(:,:), allocatable :: map heat map Derived Types type :: item Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(NSTATE) :: state = 0 state: [i, j, direction, and # of moves] integer(kind=ip), public :: dist = huge(1) distance for this one logical, public :: visited = .false. if this one is done integer(kind=ip), public :: iprev = -1 index in the queue of the previous one Functions function index_in_queue (state) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state Return Value integer(kind=ip) index in the queue. -1 if not present Subroutines subroutine check (idx, idirection) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: idx integer(kind=ip), intent(in) :: idirection direction to move from current subroutine add_to_queue (state, idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state integer(kind=ip), intent(out) :: idx index of the element in the queue Source Code program problem_17 use aoc_utilities use iso_fortran_env , ip => int64 !! Based on AOC 2021 Day 15: https://github.com/jacobwilliams/AoC-2021/blob/master/test/problem_15.f90 !! see: https://en.wikipedia.org/wiki/Dijkstra's_algorithm#Pseudocode !! !! only difference is the constraint that it can move at most three blocks in a single direction implicit none integer , parameter :: NSTATE = 4 !! number of state dimensions [i,j,direction,moves_in_that_direction] integer , parameter :: N_DIRECTIONS = 4 ! 1,2,3,4 integer ( ip ), parameter :: UP = 1 ! direction traveling integer ( ip ), parameter :: DOWN = - 1 integer ( ip ), parameter :: LEFT = 2 integer ( ip ), parameter :: RIGHT = - 2 integer , parameter :: MAX_MOVES_IN_DIR = 3 ! queue for the states and distances... rather than constructing the 2d array... ! just create this as we go... type :: item integer ( ip ), dimension ( NSTATE ) :: state = 0 !! state: [i, j, direction, and # of moves] integer ( ip ) :: dist = huge ( 1 ) !! distance for this one logical :: visited = . false . !! if this one is done integer ( ip ) :: iprev = - 1 !! index in the queue of the previous one end type item type ( item ), dimension (:), allocatable :: queue !! will be expanding integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: idx integer :: i , j , n_rows , n_cols integer , dimension (:,:), allocatable :: map !! heat map ! for the CI ! need a faster version ... write ( * , * ) 'it works but takes a few minutes...' stop call clk % tic () ! map = read_file_to_int_array('inputs/day17_test.txt') map = read_file_to_int_array ( 'inputs/day17.txt' ) n_rows = size ( map , 1 ) n_cols = size ( map , 2 ) call add_to_queue ([ 1_ip , 1_ip , 0_ip , 0_ip ], idx ) ! start queue ( idx )% dist = 0 do ! find min distance so far for ones not visited iloc = minloc ( queue % dist , mask = . not . queue % visited ) idx = iloc ( 1 ) ! index in the queue queue ( idx )% visited = . true . !write(*,*) 'visited ', queue(idx)%state(1), queue(idx)%state(2), n_rows, n_cols if ( queue ( idx )% state ( 1 ) == n_rows . and . queue ( idx )% state ( 2 ) == n_cols ) exit ! destination: we are done ! process ajacent ones: call check ( idx , UP ) call check ( idx , DOWN ) call check ( idx , LEFT ) call check ( idx , RIGHT ) end do write ( * , * ) '15a: ' , queue ( idx )% dist ! ...draw the path ! block !     character(len=1),dimension(:,:),allocatable :: char_map !     char_map = int_array_to_char_array(map) !     do !         char_map(queue(idx)%state(1),queue(idx)%state(2)) = '#' !         if (queue(idx)%state(1)==1) then !             write(*,*) queue(idx)%state !         end if !         if (queue(idx)%state(1)==1 .and. queue(idx)%state(2)==1) exit !         idx = queue(idx)%iprev !     end do !     write(*,*) ' path: ' !     do i = 1, n_rows !         write(*,'(*(A1))') char_map(i,:) !     end do ! end block call clk % toc ( '17' ) contains subroutine check ( idx , idirection ) implicit none integer ( ip ), intent ( in ) :: idx ! current item in the queue to process integer ( ip ), intent ( in ) :: idirection !! direction to move from current integer ( ip ) :: alt integer ( ip ), dimension ( 2 ) :: v ! neighbor to move to integer ( ip ) :: imovesv , idxv , distv integer ( ip ), dimension ( NSTATE ) :: istate logical :: in_queue associate ( i => queue ( idx )% state ( 1 ), & j => queue ( idx )% state ( 2 ), & direction => queue ( idx )% state ( 3 ), & n_moves => queue ( idx )% state ( 4 )) if ( direction ==- idirection ) return ! can't reverse ! the one to go to: if ( direction == idirection ) then if ( n_moves == MAX_MOVES_IN_DIR ) return ! can't move in this direction anymore imovesv = n_moves + 1 else imovesv = 1 ! reset on change of direction end if select case ( idirection ) case ( UP ); v = [ i - 1 , j ] case ( DOWN ); v = [ i + 1 , j ] case ( LEFT ); v = [ i , j - 1 ] case ( RIGHT ); v = [ i , j + 1 ] end select if ( v ( 1 ) < 1 . or . v ( 2 ) < 1 . or . v ( 1 ) > n_rows . or . v ( 2 ) > n_cols ) return ! can't go off the board istate = [ v ( 1 ), v ( 2 ), idirection , imovesv ] ! new state idxv = index_in_queue ( istate ) ! is it already in the queue in_queue = idxv > 0 ! if this one is already part of another path if ( in_queue ) then if ( queue ( idxv )% visited ) return ! already visited this one distv = queue ( idxv )% dist ! distance in the queue else !call add_to_queue(istate, idxv) ! add this to the queue for processing ! always add it ?? distv = huge ( 1_ip ) ! not processed yet, so huge number end if !alt = queue(idx)%dist + map(queue(idxv)%state(1), queue(idxv)%state(2)) alt = queue ( idx )% dist + map ( v ( 1 ), v ( 2 )) ! new distance if ( alt < distv ) then ! the new one is better, so replace values in the queue if (. not . in_queue ) call add_to_queue ( istate , idxv ) ! only add it if we accept it ???? ! accept this step queue ( idxv )% dist = alt ! new best dist queue ( idxv )% iprev = idx ! previous end if end associate end subroutine check ! .. need a faster queue... function index_in_queue ( state ) result ( idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ) :: idx !! index in the queue. -1 if not present integer :: i idx = - 1 if (. not . allocated ( queue )) error stop 'error: queue not allocated' do i = 1 , size ( queue ) if ( all ( state == queue ( i )% state )) then idx = i return end if end do end function index_in_queue subroutine add_to_queue ( state , idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ), intent ( out ) :: idx !! index of the element in the queue if ( allocated ( queue )) then queue = [ queue , item ( state = state )] idx = size ( queue ) else queue = [ item ( state = state )] idx = 1 end if end subroutine add_to_queue end program problem_17","tags":"","loc":"program/problem_17~2.html"},{"title":"aoc_utilities.f90 – AoC-2023","text":"Files dependent on this one sourcefile~~aoc_utilities.f90~~AfferentGraph sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_01.f90 problem_01.f90 sourcefile~problem_01.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_02.f90 problem_02.f90 sourcefile~problem_02.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_03.f90 problem_03.f90 sourcefile~problem_03.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_04.f90 problem_04.f90 sourcefile~problem_04.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_05.f90 problem_05.f90 sourcefile~problem_05.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_06.f90 problem_06.f90 sourcefile~problem_06.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_07.f90 problem_07.f90 sourcefile~problem_07.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_08.f90 problem_08.f90 sourcefile~problem_08.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_09.f90 problem_09.f90 sourcefile~problem_09.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_10.f90 problem_10.f90 sourcefile~problem_10.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_11.f90 problem_11.f90 sourcefile~problem_11.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_12.f90 problem_12.f90 sourcefile~problem_12.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_12b.f90 problem_12b.f90 sourcefile~problem_12b.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_13.f90 problem_13.f90 sourcefile~problem_13.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_15.f90 problem_15.f90 sourcefile~problem_15.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_16.f90 problem_16.f90 sourcefile~problem_16.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_17.f90 problem_17.f90 sourcefile~problem_17.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_17b.f90 problem_17b.f90 sourcefile~problem_17b.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_18.f90 problem_18.f90 sourcefile~problem_18.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_19.f90 problem_19.f90 sourcefile~problem_19.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_19b.f90 problem_19b.f90 sourcefile~problem_19b.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_21.f90 problem_21.f90 sourcefile~problem_21.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_23.f90 problem_23.f90 sourcefile~problem_23.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_24.f90 problem_24.f90 sourcefile~problem_24.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !************************************************************************************************ !> !  Helper classes and routines for Advent of Code ! !### Author !  * Jacob Williams module aoc_utilities use iso_fortran_env , wp => real64 implicit none private integer , parameter :: chunk_size = 100 !! for dynamic allocations type , public :: clock private integer ( int64 ) :: begin , end , rate contains procedure , public :: tic => clock_start procedure , public :: toc => clock_end end type clock type ( clock ), public :: clk !! a public clock to use for timing in the problems type , public :: string !! a type containing an allocatable character string. !! so we can have an array of strings of different lengths. character ( len = :), allocatable :: str contains procedure , public :: to_int => string_to_int !! convert to integer procedure , public :: to_int_64 => string_to_int_64 end type string type , public :: int64_vec !! an type that contains an allocatable int64 array. !! so we can have an array of these. integer ( int64 ), dimension (:), allocatable :: vals end type int64_vec public :: read_file_to_integer_array , & read_file_to_integer64_array , & read_file_to_char_array , & read_file_to_int_array public :: number_of_lines_in_file public :: read_line public :: parse_ints , parse_ints64 public :: is_number , is_not_number public :: str_to_array public :: lcm public :: reverse public :: diff public :: locpt , parea public :: str_to_int_array_with_mapping , str_to_int64_array_with_mapping public :: int_array_to_char_array public :: hex2int public :: inverse interface sort procedure :: sort_ascending , sort_ascending_64 end interface sort public :: sort interface parse procedure :: parse_nums64 end interface parse public :: parse interface split procedure :: split1 , split2 end interface split public :: split interface int procedure :: string_to_int , & char_to_int , char_to_int64 , & char_array_to_int end interface int public :: int interface unique procedure :: unique32 , unique64 end interface unique public :: unique interface startswith !! test if a string starts with a specified substring procedure :: startswith_cc , startswith_ss , startswith_sc , startswith_cs end interface startswith public :: startswith interface swap procedure :: swap32 , swap64 , swap_str end interface swap public :: swap interface manhatten_distance procedure :: manhatten_distance_64 end interface manhatten_distance public :: manhatten_distance contains !************************************************************************************************ !**************************************************************** !> !  Start the clock subroutine clock_start ( me ) class ( clock ), intent ( inout ) :: me call system_clock ( me % begin , me % rate ) end subroutine clock_start !**************************************************************** !**************************************************************** !> !  Print runtime in milliseconds form the start of the clock. subroutine clock_end ( me , case_str ) class ( clock ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: case_str !! description of the case integer :: itime !! time in integer milliseconds call system_clock ( me % end ) itime = int ( 1000 * ( me % end - me % begin ) / real ( me % rate , wp )) write ( * , '(a,I4,a)' ) trim ( case_str ) // ' runtime: ' , itime , ' ms' write ( * , '(a)' ) '---------------------------' write ( * , * ) '' end subroutine clock_end !**************************************************************** !**************************************************************** !> !  Basic string to integer routine pure function char_to_int ( str ) result ( i ) character ( len =* ), intent ( in ) :: str integer :: i read ( str , * ) i end function char_to_int !**************************************************************** !**************************************************************** !> !  Basic string to integer routine pure elemental function string_to_int ( me ) result ( i ) class ( string ), intent ( in ) :: me integer :: i i = int ( me % str ) end function string_to_int !**************************************************************** !**************************************************************** !> !  Basic string to integer routine pure elemental function string_to_int_64 ( me ) result ( i ) class ( string ), intent ( in ) :: me integer ( int64 ) :: i i = int ( me % str , int64 ) end function string_to_int_64 !**************************************************************** !**************************************************************** !> !  Basic string to integer(ip) routine. !  Hacky hack just so we can overload as int() pure function char_to_int64 ( str , kind ) result ( i ) character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: kind integer ( int64 ) :: i if ( kind /= int64 ) error stop 'error' read ( str , * ) i end function char_to_int64 !**************************************************************** !**************************************************************** !> !  Character array to integer routine pure function char_array_to_int ( str_array ) result ( i ) character ( len = 1 ), dimension (:), intent ( in ) :: str_array !! example ['1','3'] --> 13 integer :: i character ( len = :), allocatable :: str integer :: k str = '' do k = 1 , size ( str_array ) str = str // str_array ( k ) end do i = char_to_int ( str ) end function char_array_to_int !**************************************************************** !**************************************************************** !> !  integer array to Character array pure function int_array_to_char_array ( iarray ) result ( carray ) integer , dimension (:,:), intent ( in ) :: iarray character ( len = 1 ), dimension (:,:), allocatable :: carray integer :: i , j allocate ( carray ( size ( iarray , 1 ), size ( iarray , 2 ))) do i = 1 , size ( iarray , 1 ) do j = 1 , size ( iarray , 2 ) write ( carray ( i , j ), '(I1)' ) iarray ( i , j ) end do end do end function int_array_to_char_array !**************************************************************** !**************************************************************** !> !  Read a file into a 2d character array. function read_file_to_char_array ( filename , border ) result ( array ) character ( len =* ), intent ( in ) :: filename character ( len = 1 ), intent ( in ), optional :: border !! if true, extra border is added with this char character ( len = 1 ), dimension (:,:), allocatable :: array integer :: i , j , iunit , n_lines , n_cols character ( len = :), allocatable :: line open ( newunit = iunit , file = filename , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) line = read_line ( iunit ); n_cols = len ( line ) rewind ( iunit ) if ( present ( border )) then allocate ( array ( 0 : n_lines + 1 , 0 : n_cols + 1 )) ! padding with border array = border else allocate ( array ( n_lines , n_cols )) end if do i = 1 , n_lines line = read_line ( iunit ) do j = 1 , n_cols array ( i , j ) = line ( j : j ) end do end do close ( iunit ) end function read_file_to_char_array !**************************************************************** !**************************************************************** !> !  Read a file into a 2d character array. function read_file_to_int_array ( filename ) result ( array ) character ( len =* ), intent ( in ) :: filename integer , dimension (:,:), allocatable :: array integer :: i , iunit , n_lines , n_cols character ( len = :), allocatable :: line open ( newunit = iunit , file = filename , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) line = read_line ( iunit ) n_cols = len ( line ) rewind ( iunit ) allocate ( array ( n_lines , n_cols )) do i = 1 , n_lines line = read_line ( iunit ) read ( line , '(*(I1))' ) array ( i , 1 : n_cols ) end do close ( iunit ) end function read_file_to_int_array !**************************************************************** !**************************************************************** !> !  Read a file into an integer array (one element per line) function read_file_to_integer_array ( filename ) result ( iarray ) character ( len =* ), intent ( in ) :: filename integer , dimension (:), allocatable :: iarray integer :: i , iunit , n_lines , istat open ( newunit = iunit , file = filename , iostat = istat ) if ( istat /= 0 ) error stop ' error reading file' n_lines = number_of_lines_in_file ( iunit ) allocate ( iarray ( n_lines )) do i = 1 , n_lines read ( iunit , '(I10)' ) iarray ( i ) end do close ( iunit ) end function read_file_to_integer_array !**************************************************************** !**************************************************************** !> !  Read a file into an int64 integer array (one element per line) function read_file_to_integer64_array ( filename ) result ( iarray ) character ( len =* ), intent ( in ) :: filename integer ( int64 ), dimension (:), allocatable :: iarray integer :: i , iunit , n_lines , istat open ( newunit = iunit , file = filename , iostat = istat ) if ( istat /= 0 ) error stop ' error reading file' n_lines = number_of_lines_in_file ( iunit ) allocate ( iarray ( n_lines )) do i = 1 , n_lines read ( iunit , * ) iarray ( i ) end do close ( iunit ) end function read_file_to_integer64_array !**************************************************************** !**************************************************************** !> !  Returns the number of lines in a file (assumed to be open) function number_of_lines_in_file ( iunit ) result ( n_lines ) integer , intent ( in ) :: iunit !! the file unit number !! (assumed to be open) integer :: n_lines !! the number of lines in the file character ( len = 1 ) :: tmp integer :: istat rewind ( iunit ) n_lines = 0 do read ( iunit , fmt = '(A1)' , iostat = istat ) tmp if ( is_iostat_end ( istat )) exit n_lines = n_lines + 1 end do rewind ( iunit ) end function number_of_lines_in_file !**************************************************************** !**************************************************************** !> !  Sorts an integer array `ivec` in increasing order. !  Uses a basic recursive quicksort !  (with insertion sort for partitions with \\le 20 elements). subroutine sort_ascending ( ivec ) integer , dimension (:), intent ( inout ) :: ivec integer , parameter :: max_size_for_insertion_sort = 20 !! max size for using insertion sort. call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending !**************************************************************** !**************************************************************** !> subroutine sort_ascending_64 ( ivec ) integer ( int64 ), dimension (:), intent ( inout ) :: ivec integer ( int64 ), parameter :: max_size_for_insertion_sort = 20 !! max size for using insertion sort. call quicksort ( 1_int64 , size ( ivec , kind = int64 )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array integer ( int64 ), intent ( in ) :: ilow integer ( int64 ), intent ( in ) :: ihigh integer ( int64 ) :: ipivot !! pivot element integer ( int64 ) :: i !! counter integer ( int64 ) :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap64 ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer ( int64 ), intent ( in ) :: ilow integer ( int64 ), intent ( in ) :: ihigh integer ( int64 ), intent ( out ) :: ipivot integer ( int64 ) :: i , ip call swap64 ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap64 ( ivec ( ip ), ivec ( i )) end if end do call swap64 ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending_64 !**************************************************************** !**************************************************************** !> !  Swap two integer values. pure elemental subroutine swap32 ( i1 , i2 ) integer , intent ( inout ) :: i1 integer , intent ( inout ) :: i2 integer :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap32 !**************************************************************** !**************************************************************** !> !  Swap two integer values. pure elemental subroutine swap64 ( i1 , i2 ) integer ( int64 ), intent ( inout ) :: i1 integer ( int64 ), intent ( inout ) :: i2 integer ( int64 ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap64 !**************************************************************** !**************************************************************** !> !  Swap two character string values pure elemental subroutine swap_str ( i1 , i2 ) character ( len =* ), intent ( inout ) :: i1 character ( len =* ), intent ( inout ) :: i2 character ( len = len ( i1 )) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_str !**************************************************************** !**************************************************************** !> !  Split a `string`, given a token. pure function split2 ( s , token ) result ( vals ) implicit none type ( string ), intent ( in ) :: s character ( len =* ), intent ( in ) :: token type ( string ), dimension (:), allocatable :: vals if ( allocated ( s % str )) then vals = split1 ( s % str , token ) else error stop 'error: string not allocated' end if end function split2 !**************************************************************** !**************************************************************** !> !  Split a character string using a token. !  This routine is inspired by the Python split function. ! !### Example !````Fortran !   character(len=:),allocatable :: s !   type(string),dimension(:),allocatable :: vals !   s = '1,2,3,4,5' !   call split(s,',',vals) !```` pure function split1 ( str , token ) result ( vals ) implicit none character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ) :: token type ( string ), dimension (:), allocatable :: vals integer :: i !! counter integer :: len_str !! significant length of `str` integer :: len_token !! length of the token integer :: n_tokens !! number of tokens integer :: i1 !! index integer :: i2 !! index integer :: j !! counters integer , dimension (:), allocatable :: itokens !! start indices of the !! token locations in `str` len_token = len ( token ) ! length of the token n_tokens = 0 ! initialize the token counter j = 0 ! index to start looking for the next token ! first, count the number of times the token ! appears in the string, and get the token indices. ! ! Examples: !  ',         '    --> 1 !  '1234,67,90'    --> 5,8 !  '123,      '    --> 4 ! length of the string if ( token == ' ' ) then ! in this case, we can't ignore trailing space len_str = len ( str ) else ! safe to ignore trailing space when looking for tokens len_str = len_trim ( str ) end if j = 1 n_tokens = 0 do if ( j > len_str ) exit ! end of string, finished i = index ( str ( j :), token ) ! index of next token in remaining string if ( i <= 0 ) exit ! no more tokens found call expand_vector ( itokens , n_tokens , i + j - 1 ) ! save the token location j = j + i + ( len_token - 1 ) end do call expand_vector ( itokens , n_tokens , finished = . true .) ! resize the vector allocate ( vals ( n_tokens + 1 )) if ( n_tokens > 0 ) then len_str = len ( str ) i1 = 1 i2 = itokens ( 1 ) - 1 if ( i2 >= i1 ) then vals ( 1 )% str = str ( i1 : i2 ) else vals ( 1 )% str = '' !the first character is a token end if !      1 2 3 !    'a,b,c,d' do i = 2 , n_tokens i1 = itokens ( i - 1 ) + len_token i2 = itokens ( i ) - 1 if ( i2 >= i1 ) then vals ( i )% str = str ( i1 : i2 ) else vals ( i )% str = '' !empty element (e.g., 'abc,,def') end if end do i1 = itokens ( n_tokens ) + len_token i2 = len_str if ( itokens ( n_tokens ) + len_token <= len_str ) then vals ( n_tokens + 1 )% str = str ( i1 : i2 ) else vals ( n_tokens + 1 )% str = '' !the last character was a token end if else !no tokens present, so just return the original string: vals ( 1 )% str = str end if end function split1 !**************************************************************** !**************************************************************** !> !  Add elements to the integer vector in chunks. pure subroutine expand_vector ( vec , n , val , finished ) integer , dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) integer , dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector !**************************************************************** !**************************************************************** !> !  Reads the next line from a file. function read_line ( iunit , status_ok ) result ( line ) integer , intent ( in ) :: iunit character ( len = :), allocatable :: line logical , intent ( out ), optional :: status_ok !! true if no problems integer :: nread !! character count specifier for read statement integer :: istat !! file read io status flag character ( len = chunk_size ) :: buffer !! the file read buffer nread = 0 buffer = '' line = '' if ( present ( status_ok )) status_ok = . true . do ! read in the next block of text from the line: read ( iunit , fmt = '(A)' , advance = 'NO' , size = nread , iostat = istat ) buffer if ( IS_IOSTAT_END ( istat ) . or . IS_IOSTAT_EOR ( istat )) then ! add the last block of text before the end of record if ( nread > 0 ) line = line // buffer ( 1 : nread ) exit else if ( istat == 0 ) then ! all the characters were read line = line // buffer ! add this block of text to the string else ! some kind of error if ( present ( status_ok )) then status_ok = . false . exit else error stop 'Read error' end if end if end do end function read_line !**************************************************************** !**************************************************************** !> !  Return only the unique values from vec. function unique32 ( vec ) result ( vec_unique ) integer , dimension (:), intent ( in ) :: vec integer , dimension (:), allocatable :: vec_unique integer :: i , num logical , dimension ( size ( vec )) :: mask mask = . false . do i = 1 , size ( vec ) !count the number of occurrences of this element: num = count ( vec ( i ) == vec ) if ( num == 1 ) then !there is only one, flag it: mask ( i ) = . true . else !flag this value only if it hasn't already been flagged: if (. not . any ( vec ( i ) == vec . and . mask ) ) mask ( i ) = . true . end if end do !return only flagged elements: allocate ( vec_unique ( count ( mask )) ) vec_unique = pack ( vec , mask ) ! also sort it: call sort ( vec_unique ) end function unique32 !**************************************************************** !**************************************************************** !> !  Return only the unique values from vec. function unique64 ( vec ) result ( vec_unique ) integer ( int64 ), dimension (:), intent ( in ) :: vec integer ( int64 ), dimension (:), allocatable :: vec_unique integer ( int64 ) :: i , num logical , dimension ( size ( vec )) :: mask mask = . false . do i = 1 , size ( vec ) !count the number of occurrences of this element: num = count ( vec ( i ) == vec ) if ( num == 1 ) then !there is only one, flag it: mask ( i ) = . true . else !flag this value only if it hasn't already been flagged: if (. not . any ( vec ( i ) == vec . and . mask ) ) mask ( i ) = . true . end if end do !return only flagged elements: allocate ( vec_unique ( count ( mask )) ) vec_unique = pack ( vec , mask ) ! also sort it: call sort ( vec_unique ) end function unique64 !**************************************************************** !**************************************************************** !> !  parse positive ints from a string that also includes text function parse_ints ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer , dimension (:), allocatable :: ints ! array of integers integer :: i , j , n integer :: istart character ( len =* ), parameter :: tokens = '0123456789' n = len ( line ) istart = 0 allocate ( ints ( 0 )) do i = 1 , n if ( index ( tokens , line ( i : i )) > 0 ) then if ( istart == 0 ) istart = i else if ( istart /= 0 ) ints = [ ints , int ( line ( istart : i - 1 ))] ! get previous int istart = 0 end if end do if ( istart /= 0 ) ints = [ ints , int ( line ( istart : n ))] ! get last int end function parse_ints !**************************************************************** !**************************************************************** !> !  Parse positive ints from a string that also includes text function parse_ints64 ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer ( int64 ), dimension (:), allocatable :: ints ! array of integers integer ( int64 ) :: i , j , n integer ( int64 ) :: istart character ( len =* ), parameter :: tokens = '0123456789' n = len ( line ) istart = 0 allocate ( ints ( 0 )) do i = 1 , n if ( index ( tokens , line ( i : i )) > 0 ) then if ( istart == 0 ) istart = i else if ( istart /= 0 ) ints = [ ints , int ( line ( istart : i - 1 ), kind = int64 )] ! get previous int istart = 0 end if end do if ( istart /= 0 ) ints = [ ints , int ( line ( istart : n ), kind = int64 )] ! get last int end function parse_ints64 !**************************************************************** !**************************************************************** !> !  parse space-deliminated int64 sequence (positive or negative) function parse_nums64 ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer ( int64 ), dimension (:), allocatable :: ints ! array of integers ints = int ( split ( line , ' ' )) end function parse_nums64 !**************************************************************** !> !  starts with function for strings pure logical function startswith_cc ( str , substring ) character ( len =* ), intent ( in ) :: str , substring startswith_cc = index ( str , substring ) == 1 end function startswith_cc pure logical function startswith_ss ( str , substring ) type ( string ), intent ( in ) :: str , substring startswith_ss = startswith ( str % str , substring % str ) end function startswith_ss pure logical function startswith_sc ( str , substring ) type ( string ), intent ( in ) :: str character ( len =* ), intent ( in ) :: substring startswith_sc = startswith ( str % str , substring ) end function startswith_sc pure logical function startswith_cs ( str , substring ) character ( len =* ), intent ( in ) :: str type ( string ), intent ( in ) :: substring startswith_cs = startswith ( str , substring % str ) end function startswith_cs !**************************************************************** !**************************************************************** !> !  returns true if the character is a number from 0 to 9. logical function is_number ( c ) character ( len = 1 ), intent ( in ) :: c is_number = c >= '0' . and . c <= '9' end function is_number !**************************************************************** !**************************************************************** !> !  returns true if the character is not a number. logical function is_not_number ( c ) character ( len = 1 ), intent ( in ) :: c is_not_number = . not . is_number ( c ) end function is_not_number !**************************************************************** !**************************************************************** !> !  convert the character string to an array of characters function str_to_array ( s ) result ( a ) character ( len =* ), intent ( in ) :: s character ( len = 1 ), dimension ( len ( s )) :: a integer :: i do i = 1 , len ( s ) ! transfer a ( i ) = s ( i : i ) end do end function str_to_array !**************************************************************** !**************************************************************** !> !  LCM. based on code from NCAR Command Language pure integer ( int64 ) function lcm ( i , j ) integer ( int64 ), intent ( in ) :: i , j integer ( int64 ) :: rem , m , n m = abs ( i ) n = abs ( j ) lcm = 0 if ( m <= 0 . or . n <= 0 ) return do rem = mod ( m , n ) if ( rem <= 0 ) exit m = n n = rem end do lcm = abs ( i * j / n ) end function lcm !**************************************************************** !**************************************************************** !> !  Reverse an int64 vector pure function reverse ( ivals ) result ( ireverse ) integer ( int64 ), dimension (:), intent ( in ) :: ivals integer ( int64 ), dimension ( size ( ivals )) :: ireverse integer :: i ireverse = [( ivals ( i ), i = size ( ivals ), 1 , - 1 )] end function reverse !**************************************************************** !**************************************************************** !> !  Difference int64 vector pure function diff ( ivals ) result ( idiff ) integer ( int64 ), dimension (:), intent ( in ) :: ivals integer ( int64 ), dimension (:), allocatable :: idiff integer :: i !! counter idiff = [( ivals ( i + 1 ) - ivals ( i ), i = 1 , size ( ivals ) - 1 )] end function diff !**************************************************************** ! the following routine is from the Fortran Astrodynamics Toolkit !***************************************************************************************** !> !  given a polygonal line connecting the vertices (x(i),y(i)) !  (i = 1,...,n) taken in this order. it is assumed that the !  polygonal path is a loop, where (x(n),y(n)) = (x(1),y(1)) !  or there is an arc from (x(n),y(n)) to (x(1),y(1)). ! !  (x0,y0) is an arbitrary point and l and m are variables. !  l and m are assigned the following values: ! !     l = -1   if (x0,y0) is outside the polygonal path !     l =  0   if (x0,y0) lies on the polygonal path !     l =  1   if (x0,y0) is inside the polygonal path ! !  m = 0 if (x0,y0) is on or outside the path. if (x0,y0) !  is inside the path then m is the winding number of the !  path around the point (x0,y0). ! !# History !  * Original version from the NSWC Library !  * Modified by J. Williams : 08/04/2012 : refactored to modern Fortran pure subroutine locpt ( x0 , y0 , x , y , n , l , m ) implicit none !arguments: integer , intent ( in ) :: n real ( wp ), intent ( in ) :: x0 real ( wp ), intent ( in ) :: y0 real ( wp ), dimension ( n ), intent ( in ) :: x real ( wp ), dimension ( n ), intent ( in ) :: y integer , intent ( out ) :: l integer , intent ( out ) :: m !constants: real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) real ( wp ), parameter :: pi = atan2 ( 0.0_wp , - 1.0_wp ) real ( wp ), parameter :: pi2 = 2.0_wp * pi real ( wp ), parameter :: tol = 4.0_wp * eps * pi !local variables: integer :: i , n0 real ( wp ) :: u , v , theta1 , sum , theta , angle , thetai n0 = n if ( x ( 1 ) == x ( n ) . and . y ( 1 ) == y ( n )) n0 = n - 1 l = - 1 m = 0 u = x ( 1 ) - x0 v = y ( 1 ) - y0 if ( u == 0.0_wp . and . v == 0.0_wp ) then l = 0 !(x0, y0) is on the boundary of the path else if ( n0 >= 2 ) then theta1 = atan2 ( v , u ) sum = 0.0_wp theta = theta1 do i = 2 , n0 u = x ( i ) - x0 v = y ( i ) - y0 if ( u == 0.0_wp . and . v == 0.0_wp ) then l = 0 !(x0, y0) is on the boundary of the path exit end if thetai = atan2 ( v , u ) angle = abs ( thetai - theta ) if ( abs ( angle - pi ) < tol ) then l = 0 !(x0, y0) is on the boundary of the path exit end if if ( angle > pi ) angle = angle - pi2 if ( theta > thetai ) angle = - angle sum = sum + angle theta = thetai end do if ( l /= 0 ) then angle = abs ( theta1 - theta ) if ( abs ( angle - pi ) < tol ) then l = 0 !(x0, y0) is on the boundary of the path else if ( angle > pi ) angle = angle - pi2 if ( theta > theta1 ) angle = - angle sum = sum + angle !sum = 2*pi*m where m is the winding number m = abs ( sum ) / pi2 + 0.2_wp if ( m /= 0 ) then l = 1 if ( sum < 0.0_wp ) m = - m end if end if end if end if end if end subroutine locpt !***************************************************************************************** !***************************************************************************************** !> !  given a sequence of nb points (x(i),y(i)). parea computes !  the area bounded by the closed polygonal curve which passes !  through the points in the order that they are indexed. the !  final point of the curve is assumed to be the first point !  given. therefore, it need not be listed at the end of x and !  y. the curve is not required to be simple. ! !  * Original version from the NSWC Library real ( wp ) function parea ( x , y , nb ) real ( wp ), intent ( in ) :: x ( nb ), y ( nb ) integer , intent ( in ) :: nb real ( wp ) :: a integer :: n , nm1 , i n = nb if ( x ( 1 ) == x ( n ) . and . y ( 1 ) == y ( n )) n = n - 1 if ( n - 3 < 0 ) then parea = 0.0_wp else if ( n - 3 == 0 ) then parea = 0.5_wp * (( x ( 2 ) - x ( 1 )) * ( y ( 3 ) - y ( 1 )) - ( x ( 3 ) - x ( 1 )) * ( y ( 2 ) - y ( 1 ))) else nm1 = n - 1 a = x ( 1 ) * ( y ( 2 ) - y ( n )) + x ( n ) * ( y ( 1 ) - y ( nm1 )) do i = 2 , nm1 a = a + x ( i ) * ( y ( i + 1 ) - y ( i - 1 )) end do parea = 0.5_wp * a end if end function parea !***************************************************************************************** !***************************************************************************************** !> !  Manhattan distance between two `int64` points. pure integer ( int64 ) function manhatten_distance_64 ( x1 , y1 , x2 , y2 ) integer ( int64 ), intent ( in ) :: x1 , y1 , x2 , y2 manhatten_distance_64 = abs ( x1 - x2 ) + abs ( y1 - y2 ) end function manhatten_distance_64 !***************************************************************************************** !***************************************************************************************** !> !  Convert a string to a numeric array by mapping characters to integers (user-specified) pure function str_to_int_array_with_mapping ( str , ichars , iints ) result ( array ) character ( len =* ), intent ( in ) :: str character ( len = 1 ), dimension (:), intent ( in ) :: ichars !! characters to process integer , dimension (:), intent ( in ) :: iints !! int values of the chars integer , dimension (:), allocatable :: array integer :: i integer , dimension ( 1 ) :: iloc allocate ( array ( len ( str ))) do i = 1 , len ( str ) iloc = findloc ( ichars , str ( i : i )) if ( iloc ( 1 ) > 0 ) then array ( i ) = iints ( iloc ( 1 )) else error stop 'error: could not map character: ' // str ( i : i ) end if end do end function str_to_int_array_with_mapping !***************************************************************************************** !***************************************************************************************** !> !  Convert a string to a numeric array by mapping characters to integers (user-specified) pure function str_to_int64_array_with_mapping ( str , ichars , iints ) result ( array ) character ( len =* ), intent ( in ) :: str character ( len = 1 ), dimension (:), intent ( in ) :: ichars !! characters to process integer ( int64 ), dimension (:), intent ( in ) :: iints !! int values of the chars integer ( int64 ), dimension (:), allocatable :: array integer :: i integer , dimension ( 1 ) :: iloc allocate ( array ( len ( str ))) do i = 1 , len ( str ) iloc = findloc ( ichars , str ( i : i )) if ( iloc ( 1 ) > 0 ) then array ( i ) = iints ( iloc ( 1 )) else error stop 'error: could not map character: ' // str ( i : i ) end if end do end function str_to_int64_array_with_mapping !***************************************************************************************** !***************************************************************************************** !> !!  hex string to int value. lowercase letters assumed! !!  no error checking here! pure integer function hex2int ( hex ) character ( len =* ), intent ( in ) :: hex integer :: i , n , ipower ! 70c71 -> 461937 n = len ( hex ) hex2int = 0 !base 16 (0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f) ipower = - 1 do i = n , 1 , - 1 ipower = ipower + 1 associate ( c => hex ( i : i )) if ( c >= 'a' . and . c <= 'f' ) then hex2int = hex2int + ( 10 + iachar ( c ) - iachar ( 'a' )) * ( 16 ** ipower ) else hex2int = hex2int + ( iachar ( c ) - iachar ( '0' )) * ( 16 ** ipower ) end if end associate end do end function hex2int !***************************************************************************************** !***************************************************************************************** !> !  inverse of a 2x2 matrix. ! !  See: https://caps.gsfc.nasa.gov/simpson/software/m22inv_f90.txt subroutine inverse ( a , ainv , status_ok ) real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: a real ( wp ), dimension ( 2 , 2 ), intent ( out ) :: ainv logical , intent ( out ) :: status_ok real ( wp ), parameter :: eps = 1.0e-10_wp real ( wp ), dimension ( 2 , 2 ) :: cofactor associate ( det => a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 2 , 1 ) ) if ( abs ( det ) <= eps ) then ainv = 0.0_wp status_ok = . false . else cofactor ( 1 , 1 ) = + a ( 2 , 2 ) cofactor ( 1 , 2 ) = - a ( 2 , 1 ) cofactor ( 2 , 1 ) = - a ( 1 , 2 ) cofactor ( 2 , 2 ) = + a ( 1 , 1 ) ainv = transpose ( cofactor ) / det status_ok = . true . end if end associate end subroutine inverse !************************************************************************************************ !************************************************************************************************ end module aoc_utilities !************************************************************************************************","tags":"","loc":"sourcefile/aoc_utilities.f90.html"},{"title":"problem_24.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_24.f90~~EfferentGraph sourcefile~problem_24.f90 problem_24.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_24.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_24 use iso_fortran_env , only : wp => real64 , ip => int64 ! use long ints use aoc_utilities implicit none integer :: iunit , n_lines , i , j character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals , rvals , vvals integer ( ip ), dimension (:), allocatable :: xvec , yvec , zvec , vxvec , vyvec , vzvec integer ( ip ) :: n_intersections real ( wp ), dimension ( 2 ) :: tvec real ( wp ), dimension ( 2 ) :: xy_inter integer ( ip ) :: min_val , max_val call clk % tic () ! read the data: ! open(newunit=iunit, file='inputs/day24_test.txt', status='OLD'); min_val=7_ip; max_val = 27_ip open ( newunit = iunit , file = 'inputs/day24.txt' , status = 'OLD' ); min_val = 20000000000000 0.0_wp ; max_val = 40000000000000 0.0_wp n_lines = number_of_lines_in_file ( iunit ) allocate ( xvec ( 0 ), yvec ( 0 ), zvec ( 0 ), vxvec ( 0 ), vyvec ( 0 ), vzvec ( 0 )) do i = 1 , n_lines line = read_line ( iunit ) vals = split ( line , '@' ) rvals = split ( trim ( vals ( 1 )% str ), ',' ) xvec = [ xvec , rvals ( 1 )% to_int_64 ()] yvec = [ yvec , rvals ( 2 )% to_int_64 ()] zvec = [ zvec , rvals ( 3 )% to_int_64 ()] vvals = split ( trim ( vals ( 2 )% str ), ',' ) vxvec = [ vxvec , vvals ( 1 )% to_int_64 ()] vyvec = [ vyvec , vvals ( 2 )% to_int_64 ()] vzvec = [ vzvec , vvals ( 3 )% to_int_64 ()] end do close ( iunit ) n_intersections = 0 do i = 1 , n_lines do j = 1 , i - 1 associate ( x => xvec ( i ), y => yvec ( i ), & dx => vxvec ( i ), dy => vyvec ( i ), & u => xvec ( j ), v => yvec ( j ), & du => vxvec ( j ), dv => vyvec ( j ) ) if ( dy * du /= dv * dx ) then tvec = [( dv * ( x - u ) - du * ( y - v )) / ( dy * du - dx * dv ), & ( dy * ( u - x ) - dx * ( v - y )) / ( dv * dx - du * dy ) ] xy_inter = [ x + tvec ( 1 ) * dx , y + tvec ( 1 ) * dy ] if ( all ( tvec > 0.0_wp ) . and . & all ([ xy_inter >= min_val . and . xy_inter <= max_val ])) then n_intersections = n_intersections + 1 end if end if end associate end do end do write ( * , * ) '21a : ' , n_intersections call clk % toc ( '24' ) end program problem_24","tags":"","loc":"sourcefile/problem_24.f90.html"},{"title":"problem_21.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_21.f90~~EfferentGraph sourcefile~problem_21.f90 problem_21.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_21.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_21 use aoc_utilities use iso_fortran_env , only : wp => real64 , ip => int64 implicit none character ( len = 1 ), dimension (:,:), allocatable :: array integer :: nrows , ncols , i , j integer , dimension ( 2 ) :: iloc integer , dimension (:,:), allocatable :: icount call clk % tic () ! array = read_file_to_char_array('inputs/day21_test.txt', border='#') array = read_file_to_char_array ( 'inputs/day21.txt' , border = '.' ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) allocate ( icount ( nrows , ncols )); icount = 0 iloc = findloc ( array , 'S' ) ! find starting point i = iloc ( 1 ) j = iloc ( 2 ) array ( i , j ) = 'O' ! starting here do i = 1 , 64 call step ( array ) end do write ( * , * ) '21a: ' , count ( array == 'O' ) call clk % toc ( '21' ) contains recursive subroutine step ( array ) !! take all valid steps from any # elements in array character ( len = 1 ), dimension (:,:), intent ( inout ), allocatable :: array integer :: i , j logical :: steped character ( len = 1 ), dimension (:,:), allocatable :: tmp tmp = array do i = 1 , nrows do j = 1 , ncols if ( array ( i , j ) == 'O' ) then steped = . false . ! try a step in each direction: if ( array ( i - 1 , j ) == '.' ) then tmp ( i - 1 , j ) = 'O' ; steped = . true . end if if ( array ( i + 1 , j ) == '.' ) then tmp ( i + 1 , j ) = 'O' ; steped = . true . end if if ( array ( i , j - 1 ) == '.' ) then tmp ( i , j - 1 ) = 'O' ; steped = . true . end if if ( array ( i , j + 1 ) == '.' ) then tmp ( i , j + 1 ) = 'O' ; steped = . true . end if if ( steped ) tmp ( i , j ) = '.' end if end do end do call move_alloc ( tmp , array ) end subroutine step end program problem_21","tags":"","loc":"sourcefile/problem_21.f90.html"},{"title":"problem_15.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_15.f90~~EfferentGraph sourcefile~problem_15.f90 problem_15.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_15.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !********************************************************************************* !> !  A module for problem 15, part 2. module problem_15_module use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none type :: lens character ( len = :), allocatable :: label integer ( ip ) :: focal_length = 0 end type lens type :: box type ( lens ), dimension (:), allocatable :: lenses !! the lenses in the box contains procedure :: add_lens procedure :: remove_lens end type box contains subroutine add_lens ( me , l ) ! = class ( box ), intent ( inout ) :: me type ( lens ), intent ( in ) :: l !! lense to add integer :: i !! counter if ( allocated ( me % lenses )) then do i = 1 , size ( me % lenses ) if ( me % lenses ( i )% label == l % label ) then me % lenses ( i ) = l ! replace with this one return end if end do me % lenses = [ me % lenses , l ] ! if not found, add to end else me % lenses = [ l ] ! first one in the box end if end subroutine add_lens subroutine remove_lens ( me , label ) ! - !! remove the lens with the label (if present) class ( box ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: label integer :: i type ( lens ), dimension (:), allocatable :: tmp if ( allocated ( me % lenses )) then allocate ( tmp ( 0 )) do i = 1 , size ( me % lenses ) if ( me % lenses ( i )% label /= label ) tmp = [ tmp , me % lenses ( i )] end do call move_alloc ( tmp , me % lenses ) end if end subroutine remove_lens end module problem_15_module !********************************************************************************* program problem_15 use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities use problem_15_module implicit none integer :: i , iunit , j type ( string ), dimension (:), allocatable :: vals , vals2 integer ( ip ), dimension (:), allocatable :: ivals type ( box ), dimension ( 0 : 255 ) :: boxes ! for part 2 integer ( ip ) :: ibox ! 0-255 character ( len = :), allocatable :: label integer ( ip ) :: ival , focusing_power , lens_focusing_power call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day15_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day15.txt' , status = 'OLD' ) vals = split ( read_line ( iunit ), ',' ) close ( iunit ) allocate ( ivals ( size ( vals ))) do i = 1 , size ( vals ) ! part 1: ivals ( i ) = hash ( vals ( i )% str ) ! part 2: if ( index ( vals ( i )% str , '=' ) > 0 ) then vals2 = split ( vals ( i )% str , '=' ) label = vals2 ( 1 )% str ibox = hash ( label ) ival = int ( vals2 ( 2 )% str ) ! focal length call boxes ( ibox )% add_lens ( lens ( label , ival )) else if ( index ( vals ( i )% str , '-' ) > 0 ) then vals2 = split ( vals ( i )% str , '-' ) label = vals2 ( 1 )% str ibox = hash ( label ) call boxes ( ibox )% remove_lens ( label ) end if end do write ( * , * ) '15a: ' , sum ( ivals ) focusing_power = 0 do i = 0 , 255 ! all the boxes if ( allocated ( boxes ( i )% lenses )) then do j = 1 , size ( boxes ( i )% lenses ) ! all the lenses in the box lens_focusing_power = ( i + 1 ) * ( j ) * ( boxes ( i )% lenses ( j )% focal_length ) focusing_power = focusing_power + lens_focusing_power end do end if end do write ( * , * ) '15b: ' , focusing_power call clk % toc ( '15' ) contains pure elemental integer ( ip ) function hash ( s ) !! Determine the ASCII code for the current character of the string. character ( len =* ), intent ( in ) :: s integer :: i hash = 0 do i = 1 , len ( s ) hash = modulo ( 17_ip * ( hash + iachar ( s ( i : i ))), 256_ip ) end do end function hash end program problem_15","tags":"","loc":"sourcefile/problem_15.f90.html"},{"title":"problem_19b.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_19b.f90~~EfferentGraph sourcefile~problem_19b.f90 problem_19b.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_19b.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_19b !! reformulated to operate on ranges of the x,m,a,s ratings use aoc_utilities use iso_fortran_env , only : wp => real64 , ip => int64 implicit none integer :: iunit , n_lines , iline , i character ( len = :), allocatable :: line !, name type ( string ), dimension (:), allocatable :: vals logical :: accepted integer ( ip ) :: total_accepted type :: interval integer ( ip ), dimension ( 2 ) :: v !! [start, end] of the interval end type interval type :: part type ( interval ), dimension ( 4 ) :: xmas ! [x,m,a,s] ranges end type part type ( part ) :: parts type :: rule logical :: accept = . false . logical :: reject = . false . integer :: operator = 0 ! 1:<, 2:> integer :: operator_arg = 0 ! 1:x, 2:m, 3:a, 4:s integer :: operator_val = 0 ! value to compare to character ( len = :), allocatable :: goto ! where to next (workflow name) end type rule type :: workflow character ( len = :), allocatable :: name type ( rule ), dimension (:), allocatable :: rules end type workflow type ( workflow ), dimension (:), allocatable :: workflows type ( workflow ), allocatable :: w call clk % tic () ! open(newunit=iunit, file='inputs/day19_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day19.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( workflows ( 0 )) do iline = 1 , n_lines line = read_line ( iunit ) if ( line == '' ) exit ! done - dont need the parts list for part b ! parsing workflows : qqz{s>2770:qs,m<1801:hdj,R} if ( allocated ( w )) deallocate ( w ); allocate ( w ) ! blank one vals = split ( line , '{' ) w % name = vals ( 1 )% str ! workflow name !write(*,*) '--->'//w%name//'<-----' vals ( 2 )% str = vals ( 2 )% str ( 1 : len ( vals ( 2 )% str ) - 1 ) ! remove last bracket vals = split ( vals ( 2 )% str , ',' ) ! workflow rules ! add each rule to the workflow allocate ( w % rules ( 0 )) do i = 1 , size ( vals ) w % rules = [ w % rules , parse_rule ( vals ( i )% str )] end do workflows = [ workflows , w ] end do parts = part ( xmas = [ interval ([ 1 , 4000 ]), & interval ([ 1 , 4000 ]), & interval ([ 1 , 4000 ]),& interval ([ 1 , 4000 ])]) i = workflow_name_to_index ( 'in' ) ! start at the first workflow total_accepted = process ( i , 1 , parts ) write ( * , * ) '19b: ' , total_accepted call clk % toc ( '19b' ) contains recursive function process ( iworkflow , irule , p ) result ( iaccepted ) !! process this part range starting with irule integer , intent ( in ) :: iworkflow integer , intent ( in ) :: irule type ( part ), intent ( in ) :: p integer ( ip ) :: iaccepted integer ( ip ), dimension (:), allocatable :: itmp , itmp_t , itmp_f integer ( ip ) :: i type ( part ) :: pt , pf iaccepted = 0 associate ( r => workflows ( iworkflow )% rules ( irule ) ) ! check if we are done if ( r % accept ) then iaccepted = get_accepted ( p ) return else if ( r % reject ) then iaccepted = 0 return end if ! process recursively, by splitting up the intervals when necessary if ( r % operator > 0 ) then ! process the operator select case ( r % operator ) case ( 1 ) ! < ! always create the two sets and process the two cases below ! [note that some sets maybe empty] ! ! example: ![1,200]   < 10   ==> [1,9]    TRUE !                     [10,200] FALSE itmp = [( i , i = p % xmas ( r % operator_arg )% v ( 1 ), p % xmas ( r % operator_arg )% v ( 2 ))] itmp_t = pack ( itmp , mask = itmp < r % operator_val ) !true itmp_f = pack ( itmp , mask = itmp >= r % operator_val ) !false if ( size ( itmp_t ) > 0 ) then ! some are true pt = p pt % xmas ( r % operator_arg )% v = [ itmp_t ( 1 ), itmp_t ( size ( itmp_t ))] if ( r % goto == 'A' ) then iaccepted = iaccepted + get_accepted ( pt ) else if ( r % goto /= 'R' ) then ! go to next workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , pt ) end if end if if ( size ( itmp_f ) > 0 ) then ! some are false pf = p pf % xmas ( r % operator_arg )% v = [ itmp_f ( 1 ), itmp_f ( size ( itmp_f ))] iaccepted = iaccepted + process ( iworkflow , irule + 1 , pf ) ! next rule end if case ( 2 ) ! > itmp = [( i , i = p % xmas ( r % operator_arg )% v ( 1 ), p % xmas ( r % operator_arg )% v ( 2 ))] itmp_t = pack ( itmp , mask = itmp > r % operator_val ) !true itmp_f = pack ( itmp , mask = itmp <= r % operator_val ) !false if ( size ( itmp_t ) > 0 ) then ! some are true pt = p pt % xmas ( r % operator_arg )% v = [ itmp_t ( 1 ), itmp_t ( size ( itmp_t ))] if ( r % goto == 'A' ) then iaccepted = iaccepted + get_accepted ( pt ) else if ( r % goto /= 'R' ) then ! go to next workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , pt ) end if end if if ( size ( itmp_f ) > 0 ) then ! some are false pf = p pf % xmas ( r % operator_arg )% v = [ itmp_f ( 1 ), itmp_f ( size ( itmp_f ))] iaccepted = iaccepted + process ( iworkflow , irule + 1 , pf ) ! next rule end if end select else ! goto another workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , p ) end if end associate !end do end function process integer ( ip ) function get_accepted ( p ) !! count of all the parts in the set type ( part ), intent ( in ) :: p get_accepted = ( 1 + ( p % xmas ( 1 )% v ( 2 ) - p % xmas ( 1 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 2 )% v ( 2 ) - p % xmas ( 2 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 3 )% v ( 2 ) - p % xmas ( 3 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 4 )% v ( 2 ) - p % xmas ( 4 )% v ( 1 ))) end function get_accepted function workflow_name_to_index ( name ) result ( idx ) !! get the index of this workflow in the array character ( len =* ), intent ( in ) :: name integer :: idx do idx = 1 , size ( workflows ) if ( name == workflows ( idx )% name ) return ! found it end do if ( idx > size ( workflows )) error stop 'workflow not found: ' // name end function workflow_name_to_index function parse_rule ( s ) result ( r ) character ( len =* ), intent ( in ) :: s type ( rule ) :: r type ( string ), dimension (:), allocatable :: v character ( len =* ), parameter :: xmas = 'xmas' ! 1,2,3,4 if ( s == 'A' ) then r % accept = . true . else if ( s == 'R' ) then r % reject = . true . else if ( index ( s , '>' ) > 0 ) then v = split ( s ( 3 :), ':' ) ! example: a<2006:qkq r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 2 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else if ( index ( s , '<' ) > 0 ) then v = split ( s ( 3 :), ':' ) r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 1 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else r % goto = s ! it's a workflow name end if end if end function parse_rule end program problem_19b","tags":"","loc":"sourcefile/problem_19b.f90.html"},{"title":"problem_10.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_10.f90~~EfferentGraph sourcefile~problem_10.f90 problem_10.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_10.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_10 use iso_fortran_env , ip => int64 , wp => real64 use aoc_utilities implicit none integer :: i , j , nrows , ncols , imove , l , m logical , dimension (:,:), allocatable :: icounts character ( len = 1 ), dimension (:,:), allocatable :: array integer , dimension (:,:), allocatable :: distance , distance_reverse logical , dimension (:,:), allocatable :: visited real ( wp ), dimension (:), allocatable :: x , y !! path cooidinates integer , dimension ( 2 ) :: Sij !! i,j of the S char in array call clk % tic () array = read_file_to_char_array ( 'inputs/day10.txt' , '.' ) ! pad with . to simplify edge logic nrows = size ( array , 1 ) ncols = size ( array , 2 ) allocate ( distance ( nrows , ncols )); distance = - 1 allocate ( distance_reverse ( nrows , ncols )); distance_reverse = - 1 allocate ( visited ( nrows , ncols )) ! start at the S coordinate: Sij = findloc ( array , 'S' ) x = [ Sij ( 1 )] ! to store the path for part b y = [ Sij ( 2 )] ! traverse the maze: visited = . false .; visited ( Sij ( 1 ), Sij ( 2 )) = . true .; distance ( Sij ( 1 ), Sij ( 2 )) = 0 do imove = 1 , 4 call move ( Sij ( 1 ), Sij ( 2 ), imove , distance , . true .) end do ! traverse the maze again in reverse: visited = . false .; visited ( Sij ( 1 ), Sij ( 2 )) = . true .; distance_reverse ( Sij ( 1 ), Sij ( 2 )) = 0 do imove = 4 , 1 , - 1 call move ( Sij ( 1 ), Sij ( 2 ), imove , distance_reverse , . false .) end do ! where they match is the distance furthest away from the start write ( * , * ) '10a: ' , pack ( distance , mask = ( distance == distance_reverse . and . distance > 0 )) ! for part b, use locpt to test all the points ! allow openmp to be used here to do each row in parallel allocate ( icounts ( nrows , ncols )); icounts = . false . !$OMP PARALLEL DO SHARED(icounts,x,y) PRIVATE(i,j,l,m) do i = 2 , nrows - 1 ! we can skip the padding do j = 2 , ncols - 1 if ( any ( i == x . and . j == y )) cycle ! skip if on path call locpt ( real ( i , wp ), real ( j , wp ), x , y , size ( x ), l , m ) if ( l == 1 ) icounts ( i , j ) = . true . ! if (i,j) is inside the polygonal path end do end do !$OMP END PARALLEL DO write ( * , * ) '10b: ' , count ( icounts ) call clk % toc ( '10' ) contains recursive subroutine move ( i , j , direction , distance , save_path ) integer , intent ( in ) :: i , j , direction integer , dimension (:,:), intent ( inout ) :: distance logical , intent ( in ) :: save_path !! to save the path coordinates integer :: inew , jnew , imove logical :: valid_move select case ( direction ) case ( 1 ); inew = i - 1 ; jnew = j ! north case ( 2 ); inew = i + 1 ; jnew = j ! south case ( 3 ); inew = i ; jnew = j + 1 ! east case ( 4 ); inew = i ; jnew = j - 1 ! west end select if ( visited ( inew , jnew ) . or . array ( inew , jnew ) == '.' ) return ! can we move in this direction? valid_move = . false . associate ( current_pipe => array ( i , j ), & current_distance => distance ( i , j ), & move_to => array ( inew , jnew ) ) select case ( current_pipe ) case ( 'S' ) ! don't know what the first pip is, so have to try them all select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '|' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south end select case ( '-' ) select case ( direction ) case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'L' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select case ( 'J' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '7' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'F' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select end select if ( valid_move ) then distance ( inew , jnew ) = current_distance + 1 visited ( inew , jnew ) = . true . do imove = 1 , 4 call move ( inew , jnew , imove , distance , save_path ) end do if ( save_path ) then x = [ x , real ( inew , wp )] ! save cordinates of point on the path y = [ y , real ( jnew , wp )] end if end if end associate end subroutine move pure character ( len = 2 ) function pipe_info ( p ) character ( len = 1 ), intent ( in ) :: p select case ( p ) case ( '|' ); pipe_info = 'NS' ! | is a vertical pipe connecting north and south. case ( '-' ); pipe_info = 'EW' ! - is a horizontal pipe connecting east and west. case ( 'L' ); pipe_info = 'NE' ! L is a 90-degree bend connecting north and east. case ( 'J' ); pipe_info = 'NW' ! J is a 90-degree bend connecting north and west. case ( '7' ); pipe_info = 'SW' ! 7 is a 90-degree bend connecting south and west. case ( 'F' ); pipe_info = 'SE' ! F is a 90-degree bend connecting south and east. end select end function pipe_info end program problem_10","tags":"","loc":"sourcefile/problem_10.f90.html"},{"title":"problem_07.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_07.f90~~EfferentGraph sourcefile~problem_07.f90 problem_07.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_07.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_7 use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none integer :: i , iunit , n_lines , icase character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals logical :: done type :: hand character ( len = 1 ), dimension ( 5 ) :: cards !! the cards in a hand integer ( ip ) :: bid = 0 ! the bit for the hand integer :: type = 0 ! the hand type end type hand type ( hand ), dimension (:), allocatable :: hands !! array of hands character ( len = 1 ), dimension ( 2 ), parameter :: cases = [ 'a' , 'b' ] character ( len = 1 ), dimension ( * ), parameter :: cards = [ 'A' , 'K' , 'Q' , 'J' , 'T' , & '9' , '8' , '7' , '6' , '5' , & '4' , '3' , '2' ] character ( len = 1 ), dimension ( * ), parameter :: cards_with_joker = [ 'A' , 'K' , 'Q' , 'T' , & '9' , '8' , '7' , '6' , '5' , & '4' , '3' , '2' , 'J' ] integer , parameter :: FIVE_OF_A_KIND = 1 ! the hand types integer , parameter :: FOUR_OF_A_KIND = 2 integer , parameter :: FULL_HOUSE = 3 integer , parameter :: THREE_OF_A_KIND = 4 integer , parameter :: TWO_PAIR = 5 integer , parameter :: ONE_PAIR = 6 integer , parameter :: HIGH_CARD = 7 call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day7_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day7.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( hands ( n_lines )) do i = 1 , n_lines line = read_line ( iunit ); vals = split ( line , ' ' ) hands ( i )% cards = str_to_array ( vals ( 1 )% str ) hands ( i )% bid = int ( vals ( 2 )) end do close ( iunit ) do icase = 1 , 2 ! first time normally, second time processing the jokers ! sort the list from worst to best to determinte the rank of each hand hands % type = 0 ! reinitialize since they need to be recomputed do ! bubble sort ! done = . true . do i = 1 , n_lines - 1 if ( beats ( hands ( i ), hands ( i + 1 ), icase == 2 )) then call swap_hands ( hands ( i ), hands ( i + 1 )); done = . false . end if end do if ( done ) exit end do write ( * , * ) '7' // cases ( icase ) // ':' , sum ( hands % bid * [( i , i = 1 , n_lines )]) end do call clk % toc ( '7' ) contains integer function hand_type ( me , with_jokers ) !! returns the type of hand class ( hand ), intent ( in ) :: me logical , intent ( in ) :: with_jokers !! if considering jokers integer , dimension ( 5 ) :: i integer , dimension (:), allocatable :: u integer :: n_jokers , n_unique character ( len = 1 ), dimension ( 5 ) :: h h = me % cards i = ichar ( h ) ! convert to code u = unique ( i ) ! unique elements n_unique = size ( u ) if ( with_jokers . and . any ( h == 'J' )) then ! have to pick best hand for all jokers ! just do it by inspection n_jokers = count ( h == 'J' ) select case ( n_jokers ) case ( 5 ) hand_type = FIVE_OF_A_KIND !jjjjj case ( 4 ) hand_type = FIVE_OF_A_KIND !jjjja case ( 3 ) ! can always turn to 4 or 5 of a kind if ( n_unique == 2 ) then !jjjaa hand_type = FIVE_OF_A_KIND else ! jjjab hand_type = FOUR_OF_A_KIND end if case ( 2 ) if ( n_unique == 2 ) then !jjaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then !jjaab hand_type = FOUR_OF_A_KIND else !jjabc hand_type = THREE_OF_A_KIND end if case ( 1 ) if ( n_unique == 2 ) then !jaaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then if ( any ([ count ( i == u ( 1 )) == 3 , & count ( i == u ( 2 )) == 3 , & count ( i == u ( 3 )) == 3 ]) ) then !jaaab hand_type = FOUR_OF_A_KIND elseif ( ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 ) . or . & ( count ( i == u ( 2 )) == 2 . and . count ( i == u ( 2 )) == 2 ) ) then !jaabb hand_type = FULL_HOUSE end if else if ( n_unique == 4 ) then !jaabc hand_type = THREE_OF_A_KIND else if ( n_unique == 5 ) then !jabcd hand_type = ONE_PAIR end if end select else !Every hand is exactly one type. From strongest to weakest, they are: select case ( n_unique ) case ( 1 ) ! aaaaa hand_type = FIVE_OF_A_KIND case ( 2 ) ! aaaab, aaabb if (( count ( i == u ( 1 )) == 4 . and . count ( i == u ( 2 )) == 1 ) . or . & ( count ( i == u ( 1 )) == 1 . and . count ( i == u ( 2 )) == 4 ) ) then hand_type = FOUR_OF_A_KIND else if (( count ( i == u ( 1 )) == 3 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 3 ) ) then hand_type = FULL_HOUSE end if case ( 3 ) ! aaabc, aabcc if ( any ([ count ( i == u ( 1 )) == 3 , count ( i == u ( 2 )) == 3 , count ( i == u ( 3 )) == 3 ]) ) then hand_type = THREE_OF_A_KIND else if ( any ([ count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 , & count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 , & count ( i == u ( 2 )) == 2 . and . count ( i == u ( 3 )) == 2 ]) ) then hand_type = TWO_PAIR end if case ( 4 ) !aabcd hand_type = ONE_PAIR case ( 5 ) !abcde hand_type = HIGH_CARD ! High card, where all cards' labels are distinct: 23456 end select end if end function hand_type logical function beats ( hand1 , hand2 , with_jokers ) !! return true if hand1 beats hand2 (has a higher score) class ( hand ), intent ( inout ) :: hand1 , hand2 logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i associate ( h1 => hand1 % cards , h2 => hand2 % cards ) ! recompute type if it hasn't already been computed if ( hand1 % type == 0 ) hand1 % type = hand_type ( hand1 , with_jokers ) if ( hand2 % type == 0 ) hand2 % type = hand_type ( hand2 , with_jokers ) if ( hand1 % type == hand2 % type ) then ! lower index is stronger do i = 1 , 5 if ( h1 ( i ) /= h2 ( i )) then beats = index_in_cards ( h1 ( i ), with_jokers ) < & index_in_cards ( h2 ( i ), with_jokers ) ! lower is stronger return end if end do else ! one hand beat the other beats = hand1 % type < hand2 % type ! lower score is better (1-7) end if end associate end function beats integer function index_in_cards ( c , with_jokers ) character ( len = 1 ), intent ( in ) :: c logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i do i = 1 , size ( cards_with_joker ) if ( with_jokers ) then if ( c == cards_with_joker ( i )) then index_in_cards = i return end if else if ( c == cards ( i )) then index_in_cards = i return end if end if end do error stop 'card not found' end function index_in_cards pure elemental subroutine swap_hands ( i1 , i2 ) !! swap function for hand type type ( hand ), intent ( inout ) :: i1 type ( hand ), intent ( inout ) :: i2 type ( hand ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_hands end program problem_7","tags":"","loc":"sourcefile/problem_07.f90.html"},{"title":"problem_01.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_01.f90~~EfferentGraph sourcefile~problem_01.f90 problem_01.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_01.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_1 use iso_fortran_env use aoc_utilities implicit none integer :: iunit logical :: status_ok character ( len = :), allocatable :: line integer :: n_lines integer :: i , j , k , n , isum , ifirst , ilast , idxfirst , idxlast character ( len =* ), dimension ( 9 ), parameter :: ichars = [ & 'one  ' , & 'two  ' , & 'three' , & 'four ' , & 'five ' , & 'six  ' , & 'seven' , & 'eight' , & 'nine ' ] call clk % tic () isum = 0 open ( newunit = iunit , file = 'inputs/day1.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) do i = 1 , n_lines ! remove all the chars before the first and after the last number line = read_line ( iunit , status_ok ) n = len ( line ) do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) exit ! done line ( j : j ) = ' ' end do do j = n , 1 , - 1 if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) exit ! done line ( j : j ) = ' ' end do line = trim ( adjustl ( line )) n = len ( line ) isum = isum + 10 * int ( line ( 1 : 1 )) + int ( line ( n : n )) end do write ( * , * ) '1a: sum:' , isum close ( iunit ) ! -------- part 2 ----------- open ( newunit = iunit , file = 'inputs/day1.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do i = 1 , n_lines line = read_line ( iunit , status_ok ) n = len ( line ) ! keep track of the index of the first and last number (digit or string) ifirst = huge ( 1 ) idxfirst = huge ( 1 ) do j = 1 , size ( ichars ) k = min ( index ( line , trim ( ichars ( j ))), index ( line , trim ( ichars ( j )), back = . true .) ) ! accounts for duplicates if ( k > 0 . and . k <= idxfirst ) then ifirst = j idxfirst = k end if end do do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) then if ( j <= idxfirst ) then ifirst = int ( line ( j : j )) idxfirst = j end if end if end do ilast = 0 idxlast = 0 do j = 1 , size ( ichars ) k = max ( index ( line , trim ( ichars ( j ))), index ( line , trim ( ichars ( j )), back = . true .) ) ! accounts for duplicates if ( k > 0 . and . k >= idxlast ) then ilast = j idxlast = k end if end do do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) then if ( j >= idxlast ) then ilast = int ( line ( j : j )) idxlast = j end if end if end do isum = isum + 10 * ifirst + ilast end do write ( * , * ) '1b: sum:' , isum call clk % toc ( '1' ) end program problem_1","tags":"","loc":"sourcefile/problem_01.f90.html"},{"title":"problem_18.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_18.f90~~EfferentGraph sourcefile~problem_18.f90 problem_18.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_18.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_18 use aoc_utilities use iso_fortran_env , only : wp => real64 , ip => int64 implicit none integer ( ip ) :: iresult call clk % tic () call go (. false ., iresult ); write ( * , * ) '18a:' , iresult call go (. true ., iresult ); write ( * , * ) '18b:' , iresult call clk % toc ( '18' ) contains subroutine go ( partb , iresult ) logical , intent ( in ) :: partb !! if solving part b integer ( ip ), intent ( out ) :: iresult integer :: iunit , iline , n_lines , n character ( len = :), allocatable :: line , hex type ( string ), dimension (:), allocatable :: vals character ( len = 1 ) :: direction integer ( ip ), dimension ( 2 ) :: iloc , iloc2 integer ( ip ) :: ival , isteps real ( wp ), dimension (:), allocatable :: xvec , yvec character ( len = 1 ), dimension ( 0 : 3 ) :: direction_str = [ 'R' , 'D' , 'L' , 'U' ] ! directions for part b : 0,1,2,3 ! open(newunit=iunit, file='inputs/day18_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day18.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) iloc = [ 0 , 0 ] ! where to start isteps = 0 xvec = [ 0 ]; yvec = [ 0 ] do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ! direction, number, (hex) if ( partb ) then ! values encoded in hex hex = vals ( 3 )% str ival = hex2int ( hex ( 3 : 7 )) direction = direction_str ( int ( hex ( 8 : 8 ))) else direction = vals ( 1 )% str ival = int ( vals ( 2 )% str ) end if isteps = isteps + ival ! keep track of the total perimeter size iloc2 = destination ( iloc , direction , ival ) ! destination oint xvec = [ xvec , real ( iloc2 ( 1 ), wp )] ! save the points of the polygon yvec = [ yvec , real ( iloc2 ( 2 ), wp )] ! iloc = iloc2 ! update for next move end do close ( iunit ) ! the area including the boundary = area + 1/2 the perimeter + 1 ! using NSWC parea function! n = size ( xvec ) iresult = int ( abs ( parea ( yvec , xvec , n )) + real ( isteps , wp ) / 2_ip + 1_ip , ip ) end subroutine go pure function destination ( initial , direction , steps ) result ( final ) !! get destination point integer ( ip ), dimension ( 2 ), intent ( in ) :: initial character ( len = 1 ), intent ( in ) :: direction integer ( ip ), intent ( in ) :: steps integer ( ip ), dimension ( 2 ) :: final !! x,y of desination point select case ( direction ) case ( 'R' ); final = [ initial ( 1 ), initial ( 2 ) + steps ] case ( 'L' ); final = [ initial ( 1 ), initial ( 2 ) - steps ] case ( 'D' ); final = [ initial ( 1 ) + steps , initial ( 2 )] case ( 'U' ); final = [ initial ( 1 ) - steps , initial ( 2 )] end select end function destination end program problem_18","tags":"","loc":"sourcefile/problem_18.f90.html"},{"title":"cache_module.f90 – AoC-2023","text":"Files dependent on this one sourcefile~~cache_module.f90~~AfferentGraph sourcefile~cache_module.f90 cache_module.f90 sourcefile~problem_12b.f90 problem_12b.f90 sourcefile~problem_12b.f90->sourcefile~cache_module.f90 sourcefile~problem_17b.f90 problem_17b.f90 sourcefile~problem_17b.f90->sourcefile~cache_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> author: Jacob Williams ! !  For caching function evaluations. ! !  This is based on the cache module from `NumDiff`. !  It has been modified to cache integers (`int64`) instead of reals. module aoc_cache_module use iso_fortran_env , only : ip => int64 , wp => real64 implicit none private type :: fx !! an [x,f(x)] cached pair. !! x is a vector and f is a scalar value. private integer ( ip ), dimension (:), allocatable :: x !! vector of input values integer ( ip ) :: f !! scalar output function end type fx type , public :: function_cache !! a vector function cache. private type ( fx ), dimension (:), allocatable :: c !! the cache of `f(x)` integer :: chunk_size = 100 !! for resizing vectors !! in the [[unique]] function contains private procedure , public :: initialize => initialize_cache procedure , public :: get => get_from_cache procedure , public :: put => put_in_cache procedure , public :: destroy => destroy_cache end type function_cache contains !******************************************************************************* !******************************************************************************* !> !  Initialize the cache. Must be called first before use. subroutine initialize_cache ( me , isize , chunk_size ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: isize !! the size of the hash table integer , intent ( in ), optional :: chunk_size !! chunk size to speed up reallocation !! of arrays. A good value is a guess for !! the actual number of elements of `f` that !! will be saved per value of `x` [default is 100] call me % destroy () allocate ( me % c ( 0 : isize - 1 )) if ( present ( chunk_size )) then me % chunk_size = chunk_size else me % chunk_size = 100 end if end subroutine initialize_cache !******************************************************************************* !******************************************************************************* !> !  Check if the `x` vector is in the cache, if so return `f`. !  Note that only some of the elements may be present, so it will return !  the ones there are there, and indicate which ones were found. subroutine get_from_cache ( me , x , i , f , found ) implicit none class ( function_cache ), intent ( inout ) :: me integer ( ip ), dimension (:), intent ( in ) :: x !! independant variable vector integer ( ip ), intent ( out ) :: i !! index in the hash table integer ( ip ), intent ( out ) :: f !! `f(x)` from the cache (if it was found) logical , intent ( out ) :: found !! if `x` was found in the cache integer :: j !! counter ! initialize: found = . false . if ( allocated ( me % c )) then ! get index in the hash table: i = mod ( abs ( vector_djb_hash ( x )), int ( size ( me % c ), ip ) ) ! check the table: if ( allocated ( me % c ( i )% x )) then if ( size ( me % c ( i )% x ) == size ( x )) then if ( all ( me % c ( i )% x == x )) then found = . true . f = me % c ( i )% f end if end if end if else error stop 'Error: the cache has not been initialized.' end if end subroutine get_from_cache !******************************************************************************* !******************************************************************************* !> !  Put a value into the cache. subroutine put_in_cache ( me , i , x , f ) implicit none class ( function_cache ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: i !! index in the hash table integer ( ip ), dimension (:), intent ( in ) :: x !! independant variable vector integer ( ip ), intent ( in ) :: f !! function integer ( ip ), parameter :: null = huge ( 1 ) !! an unusual value to initialize arrays if ( allocated ( me % c )) then if ( i <= size ( me % c )) then ! add to the cache me % c ( i )% x = x me % c ( i )% f = f else error stop 'Error: invalid index in hash table.' end if else error stop 'Error: the cache has not been initialized.' end if end subroutine put_in_cache !******************************************************************************* !******************************************************************************* !> !  Destroy a cache. subroutine destroy_cache ( me ) implicit none class ( function_cache ), intent ( out ) :: me end subroutine destroy_cache !******************************************************************************* !******************************************************************************* !> !  DJB hash algorithm for a `integer(ip)` vector. ! !### See also !  * J. Shahbazian, Fortran hashing algorithm, July 6, 2013 !   [Fortran Dev](https://fortrandev.wordpress.com/2013/07/06/fortran-hashing-algorithm/) pure function vector_djb_hash ( r ) result ( hash ) integer ( ip ), dimension (:), intent ( in ) :: r !! the vector integer ( ip ) :: hash !! the hash value integer :: i !! counter hash = 5381_ip do i = 1 , size ( r ) hash = ishft ( hash , 5_ip ) + hash + r ( i ) end do end function vector_djb_hash !******************************************************************************* !******************************************************************************* end module aoc_cache_module !*******************************************************************************","tags":"","loc":"sourcefile/cache_module.f90.html"},{"title":"problem_23.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_23.f90~~EfferentGraph sourcefile~problem_23.f90 problem_23.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_23.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_23 !! alternate one... collapse the maze into a graph ! Process: !   1. locate the start and end nodes (top and bottom) !   2. find all the cells that have 3 or 4 adjacent cells: ! !      1    2    3    4 !     ###  #.#  ###  #.# !-->  #.#  #.#  ...  ... !     #.#  #.#  #.#  #.# ! !     those are the nodes, and the paths between them are the edges !   3. compute the edges between each node combination and construct the graph !   4. DFS all paths to find the longest. use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none type :: node integer ( ip ), dimension (:), allocatable :: inext !! the node connected to this one integer ( ip ), dimension (:), allocatable :: idist !! distance to inext nodes end type node type ( node ), dimension (:), allocatable :: nodes !! the list of nodes logical :: slopes !! a=true, b=false logical , dimension (:,:), allocatable :: visited logical , dimension (:), allocatable :: nodes_visited integer ( ip ), dimension (:), allocatable :: inodes , jnodes !! node coordinates integer ( ip ) :: max_dist , total_nodes , nrows , ncols character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:), allocatable :: node_dist integer ( ip ), dimension (:), allocatable :: node_prev call clk % tic () ! call go('23a', 'inputs/day23_test.txt', .true. ) ! call go('23b', 'inputs/day23_test.txt', .false.) call go ( '23a' , 'inputs/day23.txt' , . true . ) call go ( '23b' , 'inputs/day23.txt' , . false .) call clk % toc ( '23' ) contains subroutine go ( case , filename , parta ) !! solve the case character ( len =* ), intent ( in ) :: case !! case name for printing character ( len =* ), intent ( in ) :: filename !! input file to read logical , intent ( in ) :: parta !! if this is part a, then consider the slopes integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: istart , iend , idist , i , j logical , parameter :: use_dijkstra = . false . !.... doesn't work yet .... don't know why ....... ! initialize: max_dist = 0 slopes = parta if ( allocated ( nodes )) deallocate ( nodes ) if ( allocated ( visited )) deallocate ( visited ) if ( allocated ( nodes_visited )) deallocate ( nodes_visited ) if ( allocated ( inodes )) deallocate ( inodes ) if ( allocated ( jnodes )) deallocate ( jnodes ) if ( allocated ( node_dist )) deallocate ( node_dist ) if ( allocated ( node_prev )) deallocate ( node_prev ) ! read the data file: array = read_file_to_char_array ( filename ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) iloc = findloc ( array ( 1 ,:), '.' ); istart = iloc ( 1 ) ! get start and end columns iloc = findloc ( array ( nrows ,:), '.' ); iend = iloc ( 1 ) ! ! identify the coordinates of all the nodes: inodes = [ 1 ] ! start node jnodes = [ istart ] do i = 1 , nrows do j = 1 , ncols if ( count_adjacent ( i , j ) >= 3 ) then inodes = [ inodes , i ] jnodes = [ jnodes , j ] end if end do end do inodes = [ inodes , nrows ] ! end node jnodes = [ jnodes , iend ] total_nodes = size ( inodes ) ! for each node, find the other nodes they are ! connected to and the distances between them (the edges) allocate ( nodes ( total_nodes )) allocate ( visited ( nrows , ncols )) do i = 1 , total_nodes visited = . false . idist = 0 call build_graph ( i , inodes ( i ), jnodes ( i ), idist , visited ) end do if ( use_dijkstra ) then !write(*,*) 'hello use_dijkstra'         ! ... something wrong here... don't get the right answer ! based on AOC 2021, Problem 15 allocate ( node_dist ( total_nodes )); node_dist = - 1 ; node_dist ( 1 ) = 0 allocate ( node_prev ( total_nodes )); node_prev = - 1 allocate ( nodes_visited ( total_nodes )); nodes_visited = . false . do iloc = maxloc ( node_dist , mask = . not . nodes_visited ) i = iloc ( 1 ) nodes_visited ( i ) = . true . if ( i == total_nodes ) exit ! we are done! !write(*,*) 'visited ', i if ( allocated ( nodes ( i )% inext )) then do j = 1 , size ( nodes ( i )% inext ) ! adjacent nodes to this one call dijkstra ( i , j ) end do end if !if (all(nodes_visited)) exit ! done end do !write(*,*) case, node_dist(size(node_dist)) ! result for this case (last node) !write(*,*) nodes_visited !write(*,*) node_dist else ! start at first, and find the longest that gets to the last. ! recursively traverse the graph. visited = . false . allocate ( nodes_visited ( total_nodes )); nodes_visited = . false . call traverse ( 1_ip , 0_ip , nodes_visited ) write ( * , * ) case , max_dist ! result for this case end if end subroutine go subroutine dijkstra ( u , inext ) integer ( ip ), intent ( in ) :: u ! current integer ( ip ), intent ( in ) :: inext ! index in inext array of the next node integer ( ip ) :: idist associate ( next_node => nodes ( u )% inext ( inext ), & distance_to_next_node => nodes ( u )% idist ( inext )) if ( nodes_visited ( next_node )) return ! already visited this one idist = node_dist ( u ) + distance_to_next_node ! add distance from u to v if ( idist > node_dist ( next_node )) then !write(*,*) 'highest so far: ', idist node_dist ( next_node ) = idist node_prev ( next_node ) = u end if end associate end subroutine dijkstra recursive subroutine build_graph ( node_num , i , j , idist , visited ) integer ( ip ), intent ( in ) :: node_num !! current node number integer ( ip ), intent ( in ) :: i , j !! current position integer ( ip ), intent ( in ) :: idist !! current distance (number of steps) logical , dimension (:,:), intent ( in ) :: visited !! elements visited in this path (not counting this one) logical , dimension (:,:), allocatable :: tmp_visited integer ( ip ) :: child_node_num if ( i < 1 . or . i > nrows . or . j < 1 . or . j > ncols ) return if ( visited ( i , j )) return if ( array ( i , j ) == '#' ) return ! can't continue from here ! go until we hit another node child_node_num = node_number ( i , j ) if ( child_node_num > 0 . and . child_node_num /= node_num ) then ! we have reached another node call add_edge ( node_num , child_node_num , idist ) else ! continue processing this edge tmp_visited = visited !make a copy and mark this one tmp_visited ( i , j ) = . true . ! we are here now associate ( a => get_cell ( i , j )) ! paths (.), forest (#), and steep slopes (&#94;, >, v, and <). select case ( a ) case ( '.' ) ! path call build_graph ( node_num , i - 1 , j , idist + 1 , tmp_visited ) call build_graph ( node_num , i + 1 , j , idist + 1 , tmp_visited ) call build_graph ( node_num , i , j + 1 , idist + 1 , tmp_visited ) call build_graph ( node_num , i , j - 1 , idist + 1 , tmp_visited ) ! these don't have a choice, must go in these directions: case ( '&#94;' ); call build_graph ( node_num , i - 1 , j , idist + 1 , tmp_visited ) case ( 'v' ); call build_graph ( node_num , i + 1 , j , idist + 1 , tmp_visited ) case ( '>' ); call build_graph ( node_num , i , j + 1 , idist + 1 , tmp_visited ) case ( '<' ); call build_graph ( node_num , i , j - 1 , idist + 1 , tmp_visited ) end select end associate end if end subroutine build_graph recursive subroutine traverse ( node_num , idist , nodes_visited ) !! traverse the graph until we get to the end and check the max distance integer ( ip ), intent ( in ) :: node_num !! current node integer ( ip ), intent ( in ) :: idist !! distance to get here logical , dimension (:), intent ( in ) :: nodes_visited logical , dimension (:), allocatable :: tmp_nodes_visited integer :: i if ( nodes_visited ( node_num )) return ! already visited this node if ( node_num == total_nodes ) then ! reached the destination if ( idist > max_dist ) max_dist = idist ! best so far else ! are their child nodes? if ( allocated ( nodes ( node_num )% inext )) then tmp_nodes_visited = nodes_visited tmp_nodes_visited ( node_num ) = . true . ! mark this node do i = 1 , size ( nodes ( node_num )% inext ) call traverse ( nodes ( node_num )% inext ( i ), idist + nodes ( node_num )% idist ( i ), tmp_nodes_visited ) end do end if end if end subroutine traverse pure logical function is_node ( i , j ) !! returns true if a node is at these coordinates integer ( ip ), intent ( in ) :: i , j is_node = any ( inodes == i . and . jnodes == j ) end function is_node subroutine add_edge ( inode , ichild , idist ) !! add an edge to this node (path to another node with the specified distance) integer ( ip ), intent ( in ) :: inode , ichild , idist if (. not . allocated ( nodes ( inode )% inext )) then allocate ( nodes ( inode )% inext ( 0 )) allocate ( nodes ( inode )% idist ( 0 )) end if nodes ( inode )% inext = [ nodes ( inode )% inext , ichild ] nodes ( inode )% idist = [ nodes ( inode )% idist , idist ] end subroutine add_edge pure integer ( ip ) function node_number ( i , j ) !! returns the index of these coordinates in !! the list of nodes (0 if it is not a node) integer ( ip ), intent ( in ) :: i , j integer ( ip ), dimension ( 1 ) :: iloc iloc = findloc ( inodes == i . and . jnodes == j , . true .) node_number = iloc ( 1 ) end function node_number pure function count_adjacent ( i , j ) result ( icount ) !! count the number of adjacent cells not a tree integer ( ip ), intent ( in ) :: i , j integer ( ip ) :: icount icount = 0 if ( i >= 1 ) icount = icount + count ([ not_tree ( i - 1 , j )]) if ( i <= nrows ) icount = icount + count ([ not_tree ( i + 1 , j )]) if ( j <= ncols ) icount = icount + count ([ not_tree ( i , j + 1 )]) if ( j >= 1 ) icount = icount + count ([ not_tree ( i , j - 1 )]) end function count_adjacent pure function get_cell ( i , j ) result ( a ) integer ( ip ), intent ( in ) :: i , j !! coordinates character ( len = 1 ) :: a if ( slopes ) then a = array ( i , j ) else a = '.' ! ignore the slopes for part b end if end function get_cell pure logical function not_tree ( i , j ) !! returns true if the cell isn't a tree integer ( ip ), intent ( in ) :: i , j !! coordinates if ( i < 1 . or . i > nrows . or . j < 1 . or . j > ncols ) then not_tree = . false . ! off the board, call it a tree else not_tree = array ( i , j ) /= '#' end if end function not_tree end program problem_23","tags":"","loc":"sourcefile/problem_23.f90.html"},{"title":"problem_11.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_11.f90~~EfferentGraph sourcefile~problem_11.f90 problem_11.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_11.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_11 use iso_fortran_env , ip => int64 , wp => real64 use aoc_utilities implicit none call clk % tic () write ( * , * ) '11a: ' , go ( 2_ip ) write ( * , * ) '11b: ' , go ( 1000000_ip ) call clk % toc ( '11' ) contains integer ( ip ) function go ( expansion_factor ) integer ( ip ), intent ( in ) :: expansion_factor integer :: i , j , nrows , ncols , n_galaxies , n , k character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:,:), allocatable :: idists integer ( ip ), dimension (:), allocatable :: igal , jgal integer ( ip ), dimension (:,:), allocatable :: ix , iy ! array = read_file_to_char_array('inputs/day11_test.txt') array = read_file_to_char_array ( 'inputs/day11.txt' ) nrows = size ( array , 1 ); ncols = size ( array , 2 ) n_galaxies = count ( array == '#' ) ! track the real indices after expansion ix = transpose ( spread ([( i , i = 1 , ncols )], 1 , nrows )) ! row indices iy = spread ([( i , i = 1 , nrows )], 1 , ncols ) ! col indices igal = pack ( ix , array == '#' ) ! indices of galaxies jgal = pack ( iy , array == '#' ) ! expand the array, keeping track of the new row indices do i = 1 , nrows ! add rows if necessary if ( all ( array ( i ,:) == '.' )) ix ( i :,:) = ix ( i :,:) + expansion_factor - 1 ! new row end do do j = 1 , ncols ! add cols if necessary if ( all ( array (:, j ) == '.' )) iy (:, j :) = iy (:, j :) + expansion_factor - 1 ! new column end do ! now compute all the distances: allocate ( idists ( n_galaxies , n_galaxies )); idists = 0 do i = 1 , n_galaxies do j = 1 , n_galaxies if ( j <= i ) cycle ! only need the lower diagonal idists ( i , j ) = manhatten_distance ( ix ( igal ( i ), jgal ( i )), iy ( igal ( i ), jgal ( i )),& ix ( igal ( j ), jgal ( j )), iy ( igal ( j ), jgal ( j ))) end do end do go = sum ( idists ) end function go end program problem_11","tags":"","loc":"sourcefile/problem_11.f90.html"},{"title":"problem_04.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_04.f90~~EfferentGraph sourcefile~problem_04.f90 problem_04.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_04.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_4 use iso_fortran_env use aoc_utilities implicit none integer :: iunit , n_lines , i , points , j , iwin type ( string ), dimension (:), allocatable :: vals , vals2 integer , dimension (:), allocatable :: iwinning , ihave , n_matches character ( len = :), allocatable :: line integer , dimension (:,:), allocatable :: card_matrix call clk % tic () ! open(newunit=iunit, file='inputs/day4_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day4.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( n_matches ( n_lines )) ! for part 2 allocate ( card_matrix ( 0 : n_lines , n_lines )) ! for part 2 ! Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53 points = 0 do i = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ': ' ) vals2 = split ( vals ( 2 ), ' | ' ) iwinning = parse_ints ( vals2 ( 1 )% str ) ! winning list ihave = parse_ints ( vals2 ( 2 )% str ) ! ones you have ! count the number of ones you have in the winning set: iwin = 0 do j = 1 , size ( ihave ) iwin = iwin + count ( ihave ( j ) == iwinning ) end do n_matches ( i ) = iwin points = points + 2 ** ( iwin - 1 ) end do close ( iunit ) write ( * , * ) '4a : points : ' , points card_matrix = 0 card_matrix ( 0 ,:) = 1 ! start with one card each do i = 1 , n_lines associate ( n => n_matches ( i )) if ( n > 0 ) card_matrix ( i , i + 1 : i + n ) = sum ( card_matrix (:, i )) end associate end do write ( * , * ) '4b : scratchcards :' , sum ( card_matrix ) call clk % toc ( '4' ) end program problem_4","tags":"","loc":"sourcefile/problem_04.f90.html"},{"title":"problem_02.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_02.f90~~EfferentGraph sourcefile~problem_02.f90 problem_02.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_02.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_2 use iso_fortran_env use aoc_utilities implicit none integer :: iunit logical :: status_ok , game_possible character ( len = :), allocatable :: line , color integer :: n_lines , id , j , k , ipossible , inum , min_red , min_green , min_blue , power type ( string ), dimension (:), allocatable :: vals , trys , cubes , num_color integer , parameter :: n_red = 12 integer , parameter :: n_green = 13 integer , parameter :: n_blue = 14 call clk % tic () !example: Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green open ( newunit = iunit , file = 'inputs/day2.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) ! will parse the line with successive splits ipossible = 0 power = 0 main : do id = 1 , n_lines game_possible = . true . min_red = 0 ; min_green = 0 ; min_blue = 0 line = read_line ( iunit , status_ok ) vals = split ( line , ': ' ) trys = split ( vals ( 2 ), '; ' ) do j = 1 , size ( trys ) cubes = split ( trys ( j ), ', ' ) do k = 1 , size ( cubes ) num_color = split ( cubes ( k ), ' ' ) inum = int ( num_color ( 1 )% str ) color = num_color ( 2 )% str select case ( color ) case ( 'red' ) if ( inum > n_red ) game_possible = . false . if ( inum > min_red ) min_red = inum case ( 'green' ) if ( inum > n_green ) game_possible = . false . if ( inum > min_green ) min_green = inum case ( 'blue' ) if ( inum > n_blue ) game_possible = . false . if ( inum > min_blue ) min_blue = inum end select end do end do power = power + ( min_red * min_green * min_blue ) if ( game_possible ) ipossible = ipossible + id end do main write ( * , * ) '2a: result   :' , ipossible write ( * , * ) '2b: power sum:' , power close ( iunit ) call clk % toc ( '2' ) end program problem_2","tags":"","loc":"sourcefile/problem_02.f90.html"},{"title":"problem_16.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_16.f90~~EfferentGraph sourcefile~problem_16.f90 problem_16.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_16.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_16 use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none integer :: i , j , nrows , ncols , max_count , icount , icase character ( len = 1 ), dimension (:,:), allocatable :: array logical , dimension (:,:,:), allocatable :: visited ! top,bottom,left,right integer , parameter :: TOP = 1 ! direction traveling FROM integer , parameter :: BOTTOM = 2 integer , parameter :: LEFT = 3 integer , parameter :: RIGHT = 4 call clk % tic () ! read the data file: ! array = read_file_to_char_array('inputs/day16_test.txt') ! pad with wall around the array array = read_file_to_char_array ( 'inputs/day16.txt' ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) ! track if we have already done this case, to avoid unnecessary duplication, ! otherwise it may loop indefinitly? allocate ( visited ( 4 , nrows , ncols )) ! part 1: visited = . false . call go ( 1 , 1 , LEFT ) write ( * , * ) '16a: ' , count ( visited ( 1 ,:,:) . or . & visited ( 2 ,:,:) . or . & visited ( 3 ,:,:) . or . & visited ( 4 ,:,:)) ! part 2, just do all the cases: max_count = 0 do icase = 1 , 2 ! first and last col do i = 1 , nrows visited = . false . if ( icase == 1 ) then ; call go ( i , 1 , LEFT ) else ; call go ( i , ncols , RIGHT ) end if icount = count ( visited ( 1 ,:,:) . or . & visited ( 2 ,:,:) . or . & visited ( 3 ,:,:) . or . & visited ( 4 ,:,:)) if ( icount > max_count ) max_count = icount end do end do do icase = 1 , 2 ! first and last row do j = 1 , ncols visited = . false . if ( icase == 1 ) then ; call go ( 1 , j , TOP ) else ; call go ( nrows , j , BOTTOM ) end if icount = count ( visited ( 1 ,:,:) . or . & visited ( 2 ,:,:) . or . & visited ( 3 ,:,:) . or . & visited ( 4 ,:,:)) if ( icount > max_count ) max_count = icount end do end do write ( * , * ) '16b: ' , max_count call clk % toc ( '16' ) contains recursive subroutine go ( i , j , direction_from ) integer , intent ( in ) :: i , j !! grid coordinate integer , intent ( in ) :: direction_from !! direction coming from (TOP,BOTTOM,LEFT,RIGHT integer :: k if ( i > nrows . or . i < 1 . or . j > ncols . or . j < 1 ) return ! off the board if ( visited ( direction_from , i , j )) return ! this case has already been done visited ( direction_from , i , j ) = . true . ! mark this one as visited in this direction associate ( c => array ( i , j )) select case ( c ) case ( '.' ) ! continue in same direction k = 1 do ! loop until we hit something else ! (to avoid unnecessary recursion) select case ( direction_from ) case ( TOP ) ! V if (( i + k ) > nrows ) return if ( array ( i + k , j ) /= '.' ) then call go ( i + k , j , direction_from ) return end if visited ( direction_from , i + k , j ) = . true . case ( BOTTOM ) ! &#94; if (( i - k ) < 1 ) return if ( array ( i - k , j ) /= '.' ) then call go ( i - k , j , direction_from ) return end if visited ( direction_from , i - k , j ) = . true . case ( LEFT ) ! --> if (( j + k ) > ncols ) return if ( array ( i , j + k ) /= '.' ) then call go ( i , j + k , direction_from ) return end if visited ( direction_from , i , j + k ) = . true . case ( RIGHT ) ! <-- if (( j - k ) < 1 ) return if ( array ( i , j - k ) /= '.' ) then call go ( i , j - k , direction_from ) return end if visited ( direction_from , i , j - k ) = . true . end select k = k + 1 end do case ( '-' ) select case ( direction_from ) case ( TOP , BOTTOM ) ! V, &#94; call go ( i , j + 1 , LEFT ) ! split call go ( i , j - 1 , RIGHT ) case ( LEFT ) ! --> call go ( i , j + 1 , LEFT ) case ( RIGHT ) ! <-- call go ( i , j - 1 , RIGHT ) end select case ( '|' ) select case ( direction_from ) case ( TOP ) ! V call go ( i + 1 , j , TOP ) case ( BOTTOM ) ! &#94; call go ( i - 1 , j , BOTTOM ) case ( LEFT , RIGHT ) ! -->, <-- call go ( i + 1 , j , TOP ) call go ( i - 1 , j , BOTTOM ) end select case ( '/' ) select case ( direction_from ) case ( TOP ) ! V call go ( i , j - 1 , RIGHT ) case ( BOTTOM ) ! &#94; call go ( i , j + 1 , LEFT ) case ( LEFT ) ! --> call go ( i - 1 , j , BOTTOM ) case ( RIGHT ) ! <-- call go ( i + 1 , j , TOP ) end select case ( '\\' ) select case ( direction_from ) case ( TOP ) ! V call go ( i , j + 1 , LEFT ) case ( BOTTOM ) ! &#94; call go ( i , j - 1 , RIGHT ) case ( LEFT ) ! --> call go ( i + 1 , j , TOP ) case ( RIGHT ) ! <-- call go ( i - 1 , j , BOTTOM ) end select end select end associate end subroutine go end program problem_16","tags":"","loc":"sourcefile/problem_16.f90.html"},{"title":"problem_12b.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_12b.f90~~EfferentGraph sourcefile~problem_12b.f90 problem_12b.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_12b.f90->sourcefile~aoc_utilities.f90 sourcefile~cache_module.f90 cache_module.f90 sourcefile~problem_12b.f90->sourcefile~cache_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_12b !! completely reworked solution from part a !! this one starts with the int list and checks it against the pattern. !! it also employs a function cache to speed it up. use iso_fortran_env , ip => int64 , wp => real64 use aoc_utilities use aoc_cache_module implicit none ! note: these are negative because we are appending ! them to the pattern for the cache integer ( ip ), parameter :: POINT = - 1 ! . integer ( ip ), parameter :: NUMBER = - 2 ! # integer ( ip ), parameter :: QUESTION = - 3 ! ? ! some global variables integer :: iunit , n_lines , iline character ( len = :), allocatable :: line , pattern type ( string ), dimension (:), allocatable :: vals integer ( ip ), dimension (:), allocatable :: ints , ipattern integer ( ip ) :: isum , ival type ( function_cache ) :: cache !! to cache the [[go]] function values call clk % tic () call cache % initialize ( isize = 10000 , chunk_size = 1000 ) ! open(newunit=iunit, file='inputs/day12_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day12.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ints = parse_ints ( vals ( 2 )% str ) ! integer list pattern = vals ( 1 )% str ! the pattern ! will convert the pattern to an array of numbers: ipattern = str_to_int64_array_with_mapping ( pattern ,[ '.' , '#' , '?' ],& [ POINT , NUMBER , QUESTION ]) ! expand the input ipattern = [ ipattern , QUESTION , ipattern , QUESTION , & ipattern , QUESTION , ipattern , QUESTION , & ipattern ] ints = [ ints , ints , ints , ints , ints ] ival = go ( ipattern , ints ) isum = isum + ival end do write ( * , * ) '12b: ' , isum call clk % toc ( '12b' ) contains recursive function go ( ipattern , ints ) result ( ival ) integer ( ip ), dimension (:), intent ( in ) :: ipattern integer ( ip ), dimension (:), intent ( in ) :: ints integer ( ip ) :: ival integer ( ip ) :: idx logical :: found ! first check the cache: call cache % get ([ ipattern , ints ], idx , ival , found ) if (. not . found ) then if ( size ( ints ) == 0 ) then ! no more ints ival = merge ( 0 , 1 , any ( ipattern == NUMBER )) ! if any more numbers, invalid else if ( size ( ipattern ) == 0 ) then ival = 0 ! too many ints else ! process next element in pattern select case ( ipattern ( 1 )) case ( NUMBER ); ival = ipound ( ipattern , ints ) case ( POINT ); ival = ipoint ( ipattern , ints ) case ( QUESTION ); ival = ipoint ( ipattern , ints ) + ipound ( ipattern , ints ) end select end if ! cache this function call: call cache % put ( idx ,[ ipattern , ints ], ival ) end if end function go recursive integer ( ip ) function ipound ( ipattern , ints ) integer ( ip ), dimension (:), intent ( in ) :: ipattern !! first char is a # integer ( ip ), dimension (:), intent ( in ) :: ints integer ( ip ), dimension (:), allocatable :: this_group ! check for the number of # that correspond to the first group if ( size ( ipattern ) >= ints ( 1 )) then this_group = ipattern ( 1 : ints ( 1 )) where ( this_group == QUESTION ) this_group = NUMBER ! replace ? with # if ( any ( this_group /= NUMBER )) then ! can't fit all the #'s so not valid ipound = 0 return else ! so far so good end if else ! not enough room to hold all the #'s ipound = 0 return end if if ( size ( ipattern ) == ints ( 1 )) then ! if this is the last group, then we are done ipound = merge ( 1 , 0 , size ( ints ) == 1 ) else ! the next character after this number must be a ? or . if ( size ( ipattern ) >= ints ( 1 ) + 1 ) then if ( any ( ipattern ( ints ( 1 ) + 1 ) == [ QUESTION , POINT ])) then block integer ( ip ), dimension (:), allocatable :: ipattern_tmp , ints_tmp ! to handle edge cases ! skip it and process the next group if ( size ( ipattern ) >= ints ( 1 ) + 2 ) then ipattern_tmp = ipattern ( ints ( 1 ) + 2 :) else allocate ( ipattern_tmp ( 0 )) end if if ( size ( ints ) >= 2 ) then ints_tmp = ints ( 2 :) else allocate ( ints_tmp ( 0 )) end if ipound = go ( ipattern_tmp , ints_tmp ) return end block end if end if ! not valid at this point ipound = 0 end if end function ipound recursive integer ( ip ) function ipoint ( ipattern , ints ) integer ( ip ), dimension (:), intent ( in ) :: ipattern !! first char is a . integer ( ip ), dimension (:), intent ( in ) :: ints if ( size ( ipattern ) <= 1 ) then ipoint = go ([ integer ( ip ) :: ], ints ) ! done, pass in empty array else ipoint = go ( ipattern ( 2 :), ints ) ! skip it and go to next one end if end function ipoint end program problem_12b","tags":"","loc":"sourcefile/problem_12b.f90.html"},{"title":"problem_05.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_05.f90~~EfferentGraph sourcefile~problem_05.f90 problem_05.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_05.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_5 use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none integer :: i , iunit , n_lines character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals integer ( ip ), dimension (:), allocatable :: seeds_list integer ( ip ) :: ilocation_min , ilocation , iseed integer ( ip ), dimension (:), allocatable :: ilocation_min_parallel type :: mapping ! save the source and destination start and end values integer ( ip ), dimension (:), allocatable :: dest_start , dest_end , src_start , src_end end type mapping integer , parameter :: NSTAGES = 7 type ( mapping ), dimension ( NSTAGES ) :: mappings ! seed_to_soil, soil_to_fertilizer, fertilizer_to_water, water_to_light, ! light_to_temperature, temperature_to_humidity, humidity_to_location integer :: parsing_state ! index in mappings (1 to NSTAGES) call clk % tic () do i = 1 , NSTAGES allocate ( mappings ( i )% dest_start ( 0 ), mappings ( i )% dest_end ( 0 ),& mappings ( i )% src_start ( 0 ), mappings ( i )% src_end ( 0 )) end do ! open(newunit=iunit, file='inputs/day5_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day5.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) parsing_state = 0 do i = 1 , n_lines line = read_line ( iunit ) if ( line == '' ) cycle ! blank line if ( startswith ( line , 'seeds:' )) then ; seeds_list = parse_ints64 ( line ( 7 :)) else if ( index ( line , 'map:' ) > 0 ) then ; parsing_state = parsing_state + 1 ! one of the 7 stages else ! parse the numbers for the given state: call populate ( parse_ints64 ( line ), mappings ( parsing_state )) end if end do close ( iunit ) ! ------------ part 1 ----------------- ilocation_min = huge ( 1 ) do i = 1 , size ( seeds_list ) ilocation = traverse ( seeds_list ( i ),. false .) if ( ilocation < ilocation_min ) ilocation_min = ilocation end do print * , '5a: ' , ilocation_min ! ------------ part 2 ----------------- !  so it doesn't run in the CI !! if (. false .) then ! brute force, openMP version. just run the part a algorithm for all the seeds. ! takes a minute or so on my computer. allocate ( ilocation_min_parallel ( size ( seeds_list ) / 2 )) ilocation_min_parallel = huge ( 1 ) !$OMP PARALLEL DO SHARED(ilocation_min_parallel) PRIVATE(i,iseed,ilocation) do i = 1 , size ( seeds_list ), 2 do iseed = seeds_list ( i ), seeds_list ( i ) + seeds_list ( i + 1 ) - 1 ilocation = traverse ( iseed , . false .) if ( ilocation < ilocation_min_parallel (( i + 1 ) / 2 )) ilocation_min_parallel (( i + 1 ) / 2 ) = ilocation end do end do !$OMP END PARALLEL DO print * , '5b: ' , minval ( ilocation_min_parallel ) end if ! ------------ part 2 ----------------- ! Alternate version, go backwards from the location to the seed ! and see if it is contained in the seed set. ! this one is pretty fast (< 1 sec) do ilocation = minval ( mappings ( 7 )% dest_start ), maxval ( mappings ( 7 )% dest_end ) ! up to the max ilocation value iseed = traverse ( ilocation , reverse = . true .) ! from ilocation to iseed if ( in_seed_list ( iseed )) exit ! found the min end do print * , '5b: ' , ilocation call clk % toc ( '5' ) contains logical function in_seed_list ( iseed ) ! for part b, is the seed in the initial list integer ( ip ), intent ( in ) :: iseed integer :: i do i = 1 , size ( seeds_list ), 2 if ( iseed >= seeds_list ( i ) . and . iseed <= seeds_list ( i ) + seeds_list ( i + 1 ) - 1 ) then in_seed_list = . true . return end if end do in_seed_list = . false . end function in_seed_list subroutine populate ( nums , m ) integer ( ip ), dimension ( 3 ), intent ( in ) :: nums ! the three numbers from the line: ! [dest range start, src range start, range length type ( mapping ), intent ( inout ) :: m ! structure to add this data to associate ( dest => nums ( 1 ), source => nums ( 2 ), range => nums ( 3 ) ) m % dest_start = [ m % dest_start , dest ] m % dest_end = [ m % dest_end , dest + range - 1 ] m % src_start = [ m % src_start , source ] m % src_end = [ m % src_end , source + range - 1 ] end associate end subroutine populate pure function map ( ival , m , reverse ) result ( idest ) integer ( ip ), intent ( in ) :: ival type ( mapping ), intent ( in ) :: m logical , intent ( in ) :: reverse ! if reversed, go from: dest -> src integer ( ip ) :: idest integer :: i if ( reverse ) then do i = 1 , size ( m % src_start ) ! locate ival (dest) in the dest start:end range if ( ival >= m % dest_start ( i ) . and . ival <= m % dest_end ( i )) then ! found it, map to dest idest = m % src_start ( i ) + ( ival - m % dest_start ( i )) ! this is the resultant isource return end if end do else do i = 1 , size ( m % src_start ) ! locate ival (source) in the source start:end range if ( ival >= m % src_start ( i ) . and . ival <= m % src_end ( i )) then ! found it, map to dest idest = m % dest_start ( i ) + ( ival - m % src_start ( i )) return end if end do end if idest = ival ! if not found in any of the sets end function map pure function traverse ( iseed , reverse ) result ( ilocation ) integer ( ip ), intent ( in ) :: iseed logical , intent ( in ) :: reverse !! if reverse, then ilocation -> iseed integer ( ip ) :: ilocation integer :: i ilocation = iseed ! initialize if ( reverse ) then do i = NSTAGES , 1 , - 1 ilocation = map ( ilocation , mappings ( i ), reverse ) ! this is really iseed end do else do i = 1 , NSTAGES ilocation = map ( ilocation , mappings ( i ), reverse ) end do end if end function traverse end program problem_5","tags":"","loc":"sourcefile/problem_05.f90.html"},{"title":"problem_09.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_09.f90~~EfferentGraph sourcefile~problem_09.f90 problem_09.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_09.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_9 use iso_fortran_env , ip => int64 ! use long ints use aoc_utilities implicit none integer :: i , iunit , n_lines integer ( ip ) :: isum call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day9_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day9.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = sum ([( extrapolate ( parse ( read_line ( iunit ))), i = 1 , n_lines )]) close ( iunit ) write ( * , * ) '9a: sum: ' , isum open ( newunit = iunit , file = 'inputs/day9.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = sum ([( extrapolate ( reverse ( parse ( read_line ( iunit )))), i = 1 , n_lines )]) close ( iunit ) write ( * , * ) '9b: sum: ' , isum call clk % toc ( '9' ) contains pure function extrapolate ( ivals ) result ( iextrap ) !! extrapolate the next value in the sequence using !! a difference table. Straightfoward implemention: !! create the full table, and then evaluate it. integer ( ip ), dimension (:), intent ( in ) :: ivals integer ( ip ) :: iextrap integer :: i , n type ( int64_vec ), dimension (:), allocatable :: diff_table !! difference table (vector of vectors) ! create the difference table: diff_table = [ int64_vec ( ivals )]; n = 1 do n = n + 1 diff_table = [ diff_table , int64_vec ( diff ( diff_table ( n - 1 )% vals ))] ! next line is diff of previous line if ( all ( diff_table ( n )% vals == 0 )) exit end do ! extrapolate iextrap = 0 do i = n - 1 , 1 , - 1 associate ( ilast => diff_table ( i )% vals ( size ( diff_table ( i )% vals )) ) iextrap = iextrap + ilast end associate end do end function extrapolate end program problem_9","tags":"","loc":"sourcefile/problem_09.f90.html"},{"title":"problem_12.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_12.f90~~EfferentGraph sourcefile~problem_12.f90 problem_12.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_12.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_12 use iso_fortran_env , ip => int64 , wp => real64 use aoc_utilities implicit none integer , parameter :: POINT = 0 integer , parameter :: NUMBER = 1 integer , parameter :: QUESTION = 2 ! some global variables integer , dimension (:), allocatable :: a , ints , ipattern , ipattern_tmp integer ( ip ) :: n_valid integer ( ip ) :: isum integer :: iline call clk % tic () call go (. false ., isum ); write ( * , * ) '12a: ' , isum ! call go(.true., isum); write(*,*) '12b: ', isum call clk % toc ( '12' ) contains subroutine go ( expand , isum ) logical , intent ( in ) :: expand integer ( ip ), intent ( out ) :: isum integer :: iunit , n_lines , n_unknowns integer ( ip ) :: n_perms character ( len = :), allocatable :: line , pattern type ( string ), dimension (:), allocatable :: vals ! open(newunit=iunit, file='inputs/day12_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day12.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ints = parse_ints ( vals ( 2 )% str ) ! integer list  1,1,3 pattern = vals ( 1 )% str ! the pattern   #.#.### ! will convert the pattern to an array of numbers: ipattern = str_to_int_array_with_mapping ( pattern ,[ '.' , '#' , '?' ],& [ POINT , NUMBER , QUESTION ]) ! 1010111 if ( expand ) then ! brute force it ipattern = [ ipattern , QUESTION , ipattern , QUESTION , & ipattern , QUESTION , ipattern , QUESTION , & ipattern ] ints = [ ints , ints , ints , ints , ints ] end if n_unknowns = count ( ipattern == 2 ) n_valid = 0 ! number of valid permutations n_perms = 2 ** n_unknowns ! number of permutations ipattern_tmp = ipattern ! recursively test all the permutations if ( allocated ( a )) deallocate ( a ) allocate ( a ( n_unknowns )) call test ( 1 , n_unknowns ) isum = isum + n_valid ! write(*,*) iline, 'n_valid = ', n_valid end do end subroutine go recursive subroutine test ( i , n ) !! each ? can be either a . or a # !! check pattern to match the int list integer , intent ( in ) :: i , n integer :: ix integer , dimension ( * ), parameter :: icoeffs = [ POINT , NUMBER ] !! set of coefficients ['.', '#'] ! what we are not doing here is accounting for permutations ! that we know do not match, because the begin with a sequence ! that doesn't match. those need to be skipped... if ( i > n ) then ! so we have an array of 0s and 1s -> replace the 2s in the ipattern with these !     ipattern: 2220111  -> ???.### !            a: 011      -> .## !       result: 0110111  -> .##.### !write(*,'(a,1x,i5,1x, *(I1))') 'test:', iline, ipattern_tmp ipattern_tmp = unpack ( a , mask = ipattern == QUESTION , field = ipattern ) if ( match ( ipattern_tmp , ints )) n_valid = n_valid + 1 else do ix = 1 , 2 a ( i ) = icoeffs ( ix ) call test ( i + 1 , n ) end do end if end subroutine test logical function match ( ipattern , ints ) !! returns true if the pattern is valid for the int list. integer , dimension (:), intent ( in ) :: ipattern integer , dimension (:), intent ( in ) :: ints integer :: i , iacc , int_checked integer , dimension ( 1 ) :: ifirst , iend logical :: accumulating ! .##..###... -> 2,3 ! start and end indices (ignoring leading and trailing spaces) ifirst = findloc ( ipattern , 1 ) iend = findloc ( ipattern , 1 , back = . true .) if ( ifirst ( 1 ) == 0 . or . iend ( 1 ) == 0 ) then ! all blank match = . false .; return end if ! step through the pattern and stop once we find it invalid accumulating = . true . iacc = 0 int_checked = 0 ! the count of ints that have been checked match = . true . ! initialize do i = ifirst ( 1 ), iend ( 1 ) select case ( ipattern ( i )) case ( POINT ) if ( accumulating ) then int_checked = int_checked + 1 ! check the next one if ( int_checked > size ( ints )) then ! too many ints match = . false . return else if ( ints ( int_checked ) /= iacc ) then ! doesn't match match = . false . return end if accumulating = . false . iacc = 0 end if case ( NUMBER ) if ( accumulating ) then iacc = iacc + 1 else ! start of a new number accumulating = . true . iacc = 1 end if if ( i == iend ( 1 )) then ! last number int_checked = int_checked + 1 ! check the next one if ( int_checked /= size ( ints )) then ! not enough ints match = . false . return else if ( ints ( int_checked ) /= iacc ) then ! doesn't match match = . false . return end if end if end select end do end function match end program problem_12","tags":"","loc":"sourcefile/problem_12.f90.html"},{"title":"problem_13.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_13.f90~~EfferentGraph sourcefile~problem_13.f90 problem_13.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_13.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_13 use iso_fortran_env , ip => int64 , wp => real64 use aoc_utilities implicit none integer :: i , iunit , iline , n_lines , ival , isum , ival2 , isum2 , & m , n , nrows , ncols , ileft , iabove , ileft2 , iabove2 type ( string ), dimension (:), allocatable :: lines integer , dimension (:,:), allocatable :: puzzle , puzzle2 character ( len = :), allocatable :: line integer , parameter :: ASH = 0 !! . integer , parameter :: ROCK = 1 !! # call clk % tic () ! open(newunit=iunit, file='inputs/day13_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day13.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 isum2 = 0 do iline = 1 , n_lines line = read_line ( iunit ) if ( line == '' . or . iline == n_lines ) then ! process this puzzle ! convert the puzzle to a numeric matrix: if ( allocated ( puzzle )) deallocate ( puzzle ) nrows = size ( lines ) ncols = len ( lines ( 1 )% str ) allocate ( puzzle ( nrows , ncols )) do i = 1 , nrows puzzle ( i ,:) = str_to_int_array_with_mapping ( lines ( i )% str , [ '.' , '#' ], [ ASH , ROCK ]) end do ! part 1 call go ( puzzle , ileft ) call go ( transpose ( puzzle ), iabove ) ival = ileft + 100 * iabove isum = isum + ival ! part 2 main : do m = 1 , nrows do n = 1 , ncols ! permute each with a smudge and find the different non-zero value puzzle2 = puzzle if ( puzzle ( m , n ) == ASH ) then puzzle2 ( m , n ) = ROCK else puzzle2 ( m , n ) = ASH end if ! don't consider the one from part a (since that one still may be valid) call go ( puzzle2 , ileft2 , iskip = ileft ) call go ( transpose ( puzzle2 ), iabove2 , iskip = iabove ) if (( ileft2 /= ileft . or . iabove2 /= iabove ) . and . ( ileft2 /= 0 . or . iabove2 /= 0 )) then ival = ileft2 + 100 * iabove2 ! found it exit main end if end do end do main isum2 = isum2 + ival deallocate ( lines ) else ! accumulate this line in the current puzzle if (. not . allocated ( lines )) allocate ( lines ( 0 )) lines = [ lines , string ( line )] end if end do write ( * , * ) '13a: ' , isum write ( * , * ) '13b: ' , isum2 call clk % toc ( '13' ) contains subroutine go ( puzzle , ileft , iskip ) !! compute the number of cols to left of mirror (0 if none) !! call with transpose(puzzle) to get number of rows above. integer , dimension (:,:), intent ( in ) :: puzzle integer , intent ( out ) :: ileft integer , intent ( in ), optional :: iskip !! don't consider this column integer :: nrows , ncols , i , j logical :: mirror nrows = size ( puzzle , 1 ) ncols = size ( puzzle , 2 ) ileft = 0 do i = 1 , ncols - 1 if ( present ( iskip )) then if ( i == iskip ) cycle end if mirror = . true . do j = 1 , min ( i , ncols - i ) if ( any ( puzzle (:, i - j + 1 ) /= puzzle (:, i + j )) ) then mirror = . false . ! no mirror on this line exit end if end do if ( mirror ) then ileft = i exit end if end do end subroutine go end program problem_13","tags":"","loc":"sourcefile/problem_13.f90.html"},{"title":"problem_19.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_19.f90~~EfferentGraph sourcefile~problem_19.f90 problem_19.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_19.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_19 use aoc_utilities use iso_fortran_env , only : wp => real64 , ip => int64 implicit none integer :: iunit , n_lines , iline , i character ( len = :), allocatable :: line !, name type ( string ), dimension (:), allocatable :: vals logical :: accepted integer ( ip ) :: total_accepted type :: part integer ( ip ), dimension ( 4 ) :: xmas ! [x,m,a,s] end type part type ( part ), dimension (:), allocatable :: parts type :: rule logical :: accept = . false . logical :: reject = . false . integer :: operator = 0 ! 1:<, 2:> integer :: operator_arg = 0 ! 1:x, 2:m, 3:a, 4:s integer :: operator_val = 0 ! value to compare to character ( len = :), allocatable :: goto ! where to next (workflow name) end type rule type :: workflow character ( len = :), allocatable :: name type ( rule ), dimension (:), allocatable :: rules end type workflow type ( workflow ), dimension (:), allocatable :: workflows type ( workflow ), allocatable :: w call clk % tic () ! open(newunit=iunit, file='inputs/day19_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day19.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( workflows ( 0 )) do iline = 1 , n_lines line = read_line ( iunit ) if ( line == '' ) then !now parse part ratings allocate ( parts ( 0 )) end if if ( allocated ( parts )) then ! parsing parts if ( line == '' ) cycle ! {x=787,m=2655,a=1222,s=2876} vals = split ( line , ',' ) parts = [ parts , part ( xmas = [ int ( vals ( 1 )% str ( 4 :)), & int ( vals ( 2 )% str ( 3 :)), & int ( vals ( 3 )% str ( 3 :)), & int ( vals ( 4 )% str ( 3 : len ( vals ( 4 )% str ) - 1 ))])] else ! parsing workflows : qqz{s>2770:qs,m<1801:hdj,R} if ( allocated ( w )) deallocate ( w ); allocate ( w ) ! blank one vals = split ( line , '{' ) w % name = vals ( 1 )% str ! workflow name !write(*,*) '--->'//w%name//'<-----' vals ( 2 )% str = vals ( 2 )% str ( 1 : len ( vals ( 2 )% str ) - 1 ) ! remove last bracket vals = split ( vals ( 2 )% str , ',' ) ! workflow rules ! add each rule to the workflow allocate ( w % rules ( 0 )) do i = 1 , size ( vals ) w % rules = [ w % rules , parse_rule ( vals ( i )% str )] end do workflows = [ workflows , w ] end if end do total_accepted = 0 do i = 1 , size ( parts ) accepted = process ( parts ( i )) !write(*,*) parts(i), accepted if ( accepted ) then total_accepted = total_accepted + rating ( parts ( i )) end if end do write ( * , * ) '19a: ' , total_accepted call clk % toc ( '19' ) contains pure integer ( ip ) function rating ( p ) type ( part ), intent ( in ) :: p rating = sum ( p % xmas ) end function rating function process ( p ) result ( accepted ) !! process this part through all the workflows. type ( part ), intent ( in ) :: p logical :: accepted integer :: i , irule i = workflow_name_to_index ( 'in' ) ! start at the first workflow irule = 1 ! first rule do associate ( r => workflows ( i )% rules ( irule ) ) ! check if we are done if ( r % accept ) then ; accepted = . true .; return ; end if if ( r % reject ) then ; accepted = . false .; return ; end if if ( r % operator > 0 ) then ! process the operator select case ( r % operator ) case ( 1 ) ! < if ( p % xmas ( r % operator_arg ) < r % operator_val ) then ! check if done if ( r % goto == 'A' ) then ; accepted = . true .; return ; end if if ( r % goto == 'R' ) then ; accepted = . false .; return ; end if ! go to next workflow: i = workflow_name_to_index ( r % goto ) !write(*,*) 'goto '//r%goto irule = 1 ! start at first rule of new workflow else irule = irule + 1 ! next rule end if case ( 2 ) ! > if ( p % xmas ( r % operator_arg ) > r % operator_val ) then ! check if done if ( r % goto == 'A' ) then ; accepted = . true .; return ; end if if ( r % goto == 'R' ) then ; accepted = . false .; return ; end if ! go to next workflow: i = workflow_name_to_index ( r % goto ) irule = 1 ! start at first rule of new workflow else irule = irule + 1 ! next rule end if end select else ! goto another workflow i = workflow_name_to_index ( r % goto ) irule = 1 ! start at first rule of new workflow end if end associate end do end function process function workflow_name_to_index ( name ) result ( idx ) !! get the index of this workflow in the array character ( len =* ), intent ( in ) :: name integer :: idx do idx = 1 , size ( workflows ) if ( name == workflows ( idx )% name ) return ! found it end do if ( idx > size ( workflows )) error stop 'workflow not found: ' // name end function workflow_name_to_index function parse_rule ( s ) result ( r ) character ( len =* ), intent ( in ) :: s type ( rule ) :: r type ( string ), dimension (:), allocatable :: v character ( len =* ), parameter :: xmas = 'xmas' ! 1,2,3,4 if ( s == 'A' ) then r % accept = . true . else if ( s == 'R' ) then r % reject = . true . else if ( index ( s , '>' ) > 0 ) then v = split ( s ( 3 :), ':' ) ! example: a<2006:qkq r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 2 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else if ( index ( s , '<' ) > 0 ) then v = split ( s ( 3 :), ':' ) r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 1 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else r % goto = s ! it's a workflow name end if end if end function parse_rule end program problem_19","tags":"","loc":"sourcefile/problem_19.f90.html"},{"title":"problem_03.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_03.f90~~EfferentGraph sourcefile~problem_03.f90 problem_03.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_03.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_3 use iso_fortran_env use aoc_utilities implicit none integer :: n_lines , i , j , n_cols , jstart , jend logical :: adjacent , tmp integer ( int64 ) :: isum character ( len = 1 ), dimension (:,:), allocatable :: array integer ( int64 ), dimension (:), allocatable :: ivals call clk % tic () ! read file: ! pad around with blanks to simplify logic below array = read_file_to_char_array ( 'inputs/day3.txt' , border = '.' ) n_lines = size ( array , 1 ) n_cols = size ( array , 2 ) !----------------- part 1 ----------------- isum = 0 do i = 1 , n_lines ! is this character adjacent to a symbol? jend = 0 do j = 1 , n_cols if ( is_not_number ( array ( i , j ))) cycle if ( j <= jend ) cycle ! skip the cols that we already have jend = 0 adjacent = is_symbol ( array ( i - 1 , j ) ) . or . & is_symbol ( array ( i - 1 , j - 1 )) . or . & is_symbol ( array ( i - 1 , j + 1 )) . or . & is_symbol ( array ( i , j - 1 ) ) . or . & is_symbol ( array ( i , j + 1 ) ) . or . & is_symbol ( array ( i + 1 , j ) ) . or . & is_symbol ( array ( i + 1 , j - 1 )) . or . & is_symbol ( array ( i + 1 , j + 1 )) if ( adjacent ) isum = isum + get_number ( i , j ) ! note: this sets jend end do end do write ( * , * ) '3a: sum :' , isum !----------------- part 2 ----------------- ! now look for '*' and find adjacent numbers .... isum = 0 do i = 1 , n_lines do j = 1 , n_cols if ( array ( i , j ) == '*' ) then ! look for 2 adjacent numbers. if ( allocated ( ivals )) deallocate ( ivals ); allocate ( ivals ( 0 )) ! above tmp = check ( i - 1 , j ) ! if only one on top if (. not . tmp ) then tmp = check ( i - 1 , j - 1 ) tmp = check ( i - 1 , j + 1 ) end if tmp = check ( i , j - 1 ) ! left and right tmp = check ( i , j + 1 ) ! below tmp = check ( i + 1 , j ) ! if only one below if (. not . tmp ) then tmp = check ( i + 1 , j - 1 ) tmp = check ( i + 1 , j + 1 ) end if if ( size ( ivals ) == 2 ) isum = isum + product ( ivals ) ! sum gear ratio end if end do end do write ( * , * ) '3b: result :' , isum call clk % toc ( '3' ) contains logical function check ( i , j ) !! if the char is part of a number, then get it and append to ivals integer , intent ( in ) :: i , j check = is_number ( array ( i , j )) if ( check ) ivals = [ ivals , get_number ( i , j )] end function check logical function is_symbol ( c ) character ( len = 1 ), intent ( in ) :: c is_symbol = is_not_number ( c ) . and . c /= '.' end function is_symbol integer ( int64 ) function get_number ( i , j ) !! get the full number contining the character at i,j integer , intent ( in ) :: i , j jstart = j jend = j do if ( array ( i , jstart - 1 ) == '.' . or . is_symbol ( array ( i , jstart - 1 ))) exit jstart = jstart - 1 end do do if ( array ( i , jend + 1 ) == '.' . or . is_symbol ( array ( i , jend + 1 ))) exit jend = jend + 1 end do get_number = int ( array ( i , jstart : jend )) end function get_number end program problem_3","tags":"","loc":"sourcefile/problem_03.f90.html"},{"title":"problem_08.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_08.f90~~EfferentGraph sourcefile~problem_08.f90 problem_08.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_08.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_8 use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none integer :: iunit , n_lines character ( len = :), allocatable :: line , instructions type ( string ), dimension (:), allocatable :: vals integer ( ip ) :: i , j , idx , idx_zzz , imoves , ias , izs integer ( ip ), dimension (:), allocatable :: instructions_ints integer ( ip ), dimension (:), allocatable :: idx_vec , idx_zzz_vec integer ( ip ), dimension (:), allocatable :: imoves_vec type :: node character ( len = 3 ) :: name = '' character ( len = 3 ), dimension ( 2 ) :: lr integer , dimension ( 2 ) :: lr_idx ! the indices in the nodes array of the l,r nodes end type node type ( node ), dimension (:), allocatable :: nodes call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day8_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day8.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( nodes ( n_lines - 2 )) instructions = read_line ( iunit ) allocate ( instructions_ints ( len ( instructions ))) do i = 1 , len ( instructions ) select case ( instructions ( i : i )) ! make an int array for easier access case ( 'L' ); instructions_ints ( i ) = 1 case ( 'R' ); instructions_ints ( i ) = 2 end select end do do i = 0 , n_lines - 1 line = read_line ( iunit ) if ( line == '' ) cycle read ( line , \"(A3,1X,1X,1X,1X,A3,1X,1X,A3,1X)\" ) nodes ( i )% name , nodes ( i )% lr ( 1 ), nodes ( i )% lr ( 2 ) end do close ( iunit ) ! compute all the lr indices: do i = 1 , size ( nodes ) nodes ( i )% lr_idx ( 1 ) = find_node ( nodes ( i )% lr ( 1 )) nodes ( i )% lr_idx ( 2 ) = find_node ( nodes ( i )% lr ( 2 )) end do !******************************************** imoves = moves ( find_node ( 'AAA' ), find_node ( 'ZZZ' )) write ( * , * ) '8a : number of moves:' , imoves !******************************************** ! get indices of the ones that end in A and Z: allocate ( idx_vec ( 0 ), idx_zzz_vec ( 0 )) do i = 1 , size ( nodes ) if ( nodes ( i )% name ( 3 : 3 ) == 'A' ) idx_vec = [ idx_vec , i ] if ( nodes ( i )% name ( 3 : 3 ) == 'Z' ) idx_zzz_vec = [ idx_zzz_vec , i ] end do if ( size ( idx_vec ) /= size ( idx_zzz_vec )) error stop 'error: they need to be the same size?' allocate ( imoves_vec ( size ( idx_vec ))) ! for EACH start, find the number of moves that it takes to get to ONE of the ends. do i = 1 , size ( idx_vec ) imoves_vec ( i ) = moves_any_z ( idx_vec ( i ), idx_zzz_vec ) end do ! don't know why this works ¯\\_(ツ)_/¯ ! I think it's a feature of the specific data given ! (it's a repeating cycle once it gets to the end) write ( * , * ) '8b : number of moves: ' , lcm ( lcm ( lcm ( lcm ( lcm ( imoves_vec ( 1 ),& imoves_vec ( 2 )),& imoves_vec ( 3 )),& imoves_vec ( 4 )),& imoves_vec ( 5 )),& imoves_vec ( 6 )) ! ! ! ! brute force. run all the moves in parallel until they are all done. ! ! ! i = 0 ! imoves = 0 ! do !     if (all_in_set(idx_vec, idx_zzz_vec)) exit !     imoves = imoves + 1 ! another move !     i = i + 1 !     if (i>len(instructions)) i = 1 !     do concurrent (j = 1 : size(idx_vec)) !         idx_vec(j) = nodes(idx_vec(j))%lr_idx(instructions_ints(i)) !     end do ! end do ! write(*,*) '8b : number of moves:', imoves call clk % toc ( '8' ) contains pure function moves ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart , iend !! indices for start and end nodes integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( idx == iend ) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves pure function moves_any_z ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart !! indices for start and end nodes integer ( ip ), dimension (:), intent ( in ) :: iend integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( any ( idx == iend )) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves_any_z pure logical function all_in_set ( ivals , iset ) !! returns true if all the elements of ivals are in the set iset integer ( ip ), dimension (:), intent ( in ) :: ivals , iset integer :: i all_in_set = . true . do i = 1 , size ( ivals ) if (. not . any ( ivals ( i ) == iset )) then all_in_set = . false . exit end if end do end function all_in_set pure integer ( ip ) function find_node ( name ) character ( len =* ), intent ( in ) :: name integer ( ip ) :: i do i = 1 , size ( nodes ) if ( name == nodes ( i )% name ) then find_node = i return end if end do error stop 'could not find node' end function find_node end program problem_8","tags":"","loc":"sourcefile/problem_08.f90.html"},{"title":"problem_17b.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_17b.f90~~EfferentGraph sourcefile~problem_17b.f90 problem_17b.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_17b.f90->sourcefile~aoc_utilities.f90 sourcefile~cache_module.f90 cache_module.f90 sourcefile~problem_17b.f90->sourcefile~cache_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_17 !! part b use aoc_utilities use iso_fortran_env , ip => int64 use aoc_cache_module implicit none integer , parameter :: NSTATE = 4 !! number of state dimensions [i,j,direction,moves_in_that_direction] integer , parameter :: N_DIRECTIONS = 4 ! 1,2,3,4 integer ( ip ), parameter :: UP = 1 ! direction traveling integer ( ip ), parameter :: DOWN = - 1 integer ( ip ), parameter :: LEFT = 2 integer ( ip ), parameter :: RIGHT = - 2 integer , parameter :: MAX_MOVES_IN_DIR = 10 !3 type ( function_cache ) :: cache !! to cache the queue access ... to try to speed things up !!! ! queue for the states and distances... rather than constructing the 2d array... ! just create this as we go... type :: item integer ( ip ), dimension ( NSTATE ) :: state = 0 !! state: [i, j, direction, and # of moves] integer ( ip ) :: dist = huge ( 1 ) !! distance for this one logical :: visited = . false . !! if this one is done integer ( ip ) :: iprev = - 1 !! index in the queue of the previous one end type item type ( item ), dimension (:), allocatable :: queue !! will be expanding integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: idx integer :: i , j , n_rows , n_cols integer , dimension (:,:), allocatable :: map !! heat map integer ( ip ) :: queue_size ! for the CI ! need a faster version ... write ( * , * ) 'it works but takes a few minutes...' stop call clk % tic () call cache % initialize ( isize = 10000 , chunk_size = 1000 ) ! map = read_file_to_int_array('inputs/day17_test.txt') map = read_file_to_int_array ( 'inputs/day17.txt' ) n_rows = size ( map , 1 ) n_cols = size ( map , 2 ) queue_size = 0 call add_to_queue ([ 1_ip , 1_ip , 0_ip , 0_ip ], idx ) ! start queue ( idx )% dist = 0 do ! find min distance so far for ones not visited iloc = minloc ( queue ( 1 : queue_size )% dist , mask = . not . queue ( 1 : queue_size )% visited ) idx = iloc ( 1 ) ! index in the queue queue ( idx )% visited = . true . if ( queue ( idx )% state ( 1 ) == n_rows . and . queue ( idx )% state ( 2 ) == n_cols ) exit ! destination: we are done ! process ajacent ones: call check ( idx , UP ) call check ( idx , DOWN ) call check ( idx , LEFT ) call check ( idx , RIGHT ) end do write ( * , * ) '17b: ' , queue ( idx )% dist call clk % toc ( '17' ) contains subroutine check ( idx , idirection ) implicit none integer ( ip ), intent ( in ) :: idx ! current item in the queue to process integer ( ip ), intent ( in ) :: idirection !! direction to move from current integer ( ip ) :: alt integer ( ip ), dimension ( 2 ) :: v ! neighbor to move to integer ( ip ) :: imovesv , idxv , distv integer ( ip ), dimension ( NSTATE ) :: istate logical :: in_queue associate ( i => queue ( idx )% state ( 1 ), & j => queue ( idx )% state ( 2 ), & direction => queue ( idx )% state ( 3 ), & n_moves => queue ( idx )% state ( 4 )) if ( direction ==- idirection ) return ! can't reverse ! the one to go to: if ( direction == idirection ) then if ( n_moves == MAX_MOVES_IN_DIR ) return ! can't move in this direction anymore imovesv = n_moves + 1 else if ( n_moves /= 0 . and . n_moves < 4 ) return ! must move at last 4 before a turn! imovesv = 1 ! reset on change of direction end if select case ( idirection ) case ( UP ); v = [ i - 1 , j ] case ( DOWN ); v = [ i + 1 , j ] case ( LEFT ); v = [ i , j - 1 ] case ( RIGHT ); v = [ i , j + 1 ] end select if ( v ( 1 ) < 1 . or . v ( 2 ) < 1 . or . v ( 1 ) > n_rows . or . v ( 2 ) > n_cols ) return ! can't go off the board if ( v ( 1 ) == n_rows . and . v ( 2 ) == n_cols . and . imovesv < 4 ) return ! require at least 4 to end istate = [ v ( 1 ), v ( 2 ), idirection , imovesv ] ! new state idxv = index_in_queue ( istate ) ! is it already in the queue in_queue = idxv > 0 ! if this one is already part of another path if ( in_queue ) then if ( queue ( idxv )% visited ) return ! already visited this one distv = queue ( idxv )% dist ! distance in the queue else !call add_to_queue(istate, idxv) ! add this to the queue for processing ! always add it ?? distv = huge ( 1_ip ) ! not processed yet, so huge number end if !alt = queue(idx)%dist + map(queue(idxv)%state(1), queue(idxv)%state(2)) alt = queue ( idx )% dist + map ( v ( 1 ), v ( 2 )) ! new distance if ( alt < distv ) then ! the new one is better, so replace values in the queue if (. not . in_queue ) call add_to_queue ( istate , idxv ) ! only add it if we accept it ???? ! accept this step queue ( idxv )% dist = alt ! new best dist queue ( idxv )% iprev = idx ! previous end if end associate end subroutine check ! .. need a faster queue... function index_in_queue ( state ) result ( idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ) :: idx !! index in the queue. -1 if not present integer ( ip ) :: i logical :: found integer ( ip ) :: cache_idx , cache_ival call cache % get ( state , cache_idx , cache_ival , found ) if ( found ) then idx = cache_ival else idx = - 1 if (. not . allocated ( queue )) error stop 'error: queue not allocated' do i = 1 , queue_size if ( all ( state == queue ( i )% state )) then idx = i exit end if end do if ( idx /= - 1 ) call cache % put ( cache_idx , state , idx ) end if end function index_in_queue subroutine add_to_queue ( state , idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ), intent ( out ) :: idx !! index of the element in the queue if ( allocated ( queue )) then call expand_queue ( queue , queue_size , item ( state = state )) idx = queue_size else queue = [ item ( state = state )] queue_size = 1 idx = 1 end if end subroutine add_to_queue !**************************************************************** !> !  Add elements to the integer vector in chunks. pure subroutine expand_queue ( vec , n , val , finished ) integer ( ip ), parameter :: chunk_size = 1000 type ( item ), dimension (:), allocatable , intent ( inout ) :: vec integer ( ip ), intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call type ( item ), intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) type ( item ), dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_queue !**************************************************************** end program problem_17","tags":"","loc":"sourcefile/problem_17b.f90.html"},{"title":"problem_06.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_06.f90~~EfferentGraph sourcefile~problem_06.f90 problem_06.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_06.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_6 use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none ! just copy and paste the inputs here: ! a integer ( ip ), dimension ( * ), parameter :: time_a = [ 60 , 94 , 78 , 82 ] integer ( ip ), dimension ( * ), parameter :: distance_a = [ 475 , 2138 , 1015 , 1650 ] ! b integer ( ip ), dimension ( * ), parameter :: time_b = [ 60947882_ip ] integer ( ip ), dimension ( * ), parameter :: distance_b = [ 475213810151650_ip ] call clk % tic () print * , '6a: ways to win:' , go ( time_a , distance_a ) print * , '6b: ways to win:' , go ( time_b , distance_b ) call clk % toc ( '6' ) contains function go ( time , distance ) result ( iproduct ) integer ( ip ), dimension (:), intent ( in ) :: time integer ( ip ), dimension (:), intent ( in ) :: distance integer ( ip ) :: iproduct integer ( ip ) :: i , ihold , iways , idistance iproduct = 1 do i = 1 , size ( time ) iways = 0 do ihold = 1 , time ( i ) ! time to hold the button idistance = ihold * ( time ( i ) - ihold ) if ( idistance > distance ( i )) iways = iways + 1 end do iproduct = iproduct * iways end do end function go end program problem_6","tags":"","loc":"sourcefile/problem_06.f90.html"},{"title":"problem_17.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_17.f90~~EfferentGraph sourcefile~problem_17.f90 problem_17.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_17.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_17 use aoc_utilities use iso_fortran_env , ip => int64 !! Based on AOC 2021 Day 15: https://github.com/jacobwilliams/AoC-2021/blob/master/test/problem_15.f90 !! see: https://en.wikipedia.org/wiki/Dijkstra's_algorithm#Pseudocode !! !! only difference is the constraint that it can move at most three blocks in a single direction implicit none integer , parameter :: NSTATE = 4 !! number of state dimensions [i,j,direction,moves_in_that_direction] integer , parameter :: N_DIRECTIONS = 4 ! 1,2,3,4 integer ( ip ), parameter :: UP = 1 ! direction traveling integer ( ip ), parameter :: DOWN = - 1 integer ( ip ), parameter :: LEFT = 2 integer ( ip ), parameter :: RIGHT = - 2 integer , parameter :: MAX_MOVES_IN_DIR = 3 ! queue for the states and distances... rather than constructing the 2d array... ! just create this as we go... type :: item integer ( ip ), dimension ( NSTATE ) :: state = 0 !! state: [i, j, direction, and # of moves] integer ( ip ) :: dist = huge ( 1 ) !! distance for this one logical :: visited = . false . !! if this one is done integer ( ip ) :: iprev = - 1 !! index in the queue of the previous one end type item type ( item ), dimension (:), allocatable :: queue !! will be expanding integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: idx integer :: i , j , n_rows , n_cols integer , dimension (:,:), allocatable :: map !! heat map ! for the CI ! need a faster version ... write ( * , * ) 'it works but takes a few minutes...' stop call clk % tic () ! map = read_file_to_int_array('inputs/day17_test.txt') map = read_file_to_int_array ( 'inputs/day17.txt' ) n_rows = size ( map , 1 ) n_cols = size ( map , 2 ) call add_to_queue ([ 1_ip , 1_ip , 0_ip , 0_ip ], idx ) ! start queue ( idx )% dist = 0 do ! find min distance so far for ones not visited iloc = minloc ( queue % dist , mask = . not . queue % visited ) idx = iloc ( 1 ) ! index in the queue queue ( idx )% visited = . true . !write(*,*) 'visited ', queue(idx)%state(1), queue(idx)%state(2), n_rows, n_cols if ( queue ( idx )% state ( 1 ) == n_rows . and . queue ( idx )% state ( 2 ) == n_cols ) exit ! destination: we are done ! process ajacent ones: call check ( idx , UP ) call check ( idx , DOWN ) call check ( idx , LEFT ) call check ( idx , RIGHT ) end do write ( * , * ) '15a: ' , queue ( idx )% dist ! ...draw the path ! block !     character(len=1),dimension(:,:),allocatable :: char_map !     char_map = int_array_to_char_array(map) !     do !         char_map(queue(idx)%state(1),queue(idx)%state(2)) = '#' !         if (queue(idx)%state(1)==1) then !             write(*,*) queue(idx)%state !         end if !         if (queue(idx)%state(1)==1 .and. queue(idx)%state(2)==1) exit !         idx = queue(idx)%iprev !     end do !     write(*,*) ' path: ' !     do i = 1, n_rows !         write(*,'(*(A1))') char_map(i,:) !     end do ! end block call clk % toc ( '17' ) contains subroutine check ( idx , idirection ) implicit none integer ( ip ), intent ( in ) :: idx ! current item in the queue to process integer ( ip ), intent ( in ) :: idirection !! direction to move from current integer ( ip ) :: alt integer ( ip ), dimension ( 2 ) :: v ! neighbor to move to integer ( ip ) :: imovesv , idxv , distv integer ( ip ), dimension ( NSTATE ) :: istate logical :: in_queue associate ( i => queue ( idx )% state ( 1 ), & j => queue ( idx )% state ( 2 ), & direction => queue ( idx )% state ( 3 ), & n_moves => queue ( idx )% state ( 4 )) if ( direction ==- idirection ) return ! can't reverse ! the one to go to: if ( direction == idirection ) then if ( n_moves == MAX_MOVES_IN_DIR ) return ! can't move in this direction anymore imovesv = n_moves + 1 else imovesv = 1 ! reset on change of direction end if select case ( idirection ) case ( UP ); v = [ i - 1 , j ] case ( DOWN ); v = [ i + 1 , j ] case ( LEFT ); v = [ i , j - 1 ] case ( RIGHT ); v = [ i , j + 1 ] end select if ( v ( 1 ) < 1 . or . v ( 2 ) < 1 . or . v ( 1 ) > n_rows . or . v ( 2 ) > n_cols ) return ! can't go off the board istate = [ v ( 1 ), v ( 2 ), idirection , imovesv ] ! new state idxv = index_in_queue ( istate ) ! is it already in the queue in_queue = idxv > 0 ! if this one is already part of another path if ( in_queue ) then if ( queue ( idxv )% visited ) return ! already visited this one distv = queue ( idxv )% dist ! distance in the queue else !call add_to_queue(istate, idxv) ! add this to the queue for processing ! always add it ?? distv = huge ( 1_ip ) ! not processed yet, so huge number end if !alt = queue(idx)%dist + map(queue(idxv)%state(1), queue(idxv)%state(2)) alt = queue ( idx )% dist + map ( v ( 1 ), v ( 2 )) ! new distance if ( alt < distv ) then ! the new one is better, so replace values in the queue if (. not . in_queue ) call add_to_queue ( istate , idxv ) ! only add it if we accept it ???? ! accept this step queue ( idxv )% dist = alt ! new best dist queue ( idxv )% iprev = idx ! previous end if end associate end subroutine check ! .. need a faster queue... function index_in_queue ( state ) result ( idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ) :: idx !! index in the queue. -1 if not present integer :: i idx = - 1 if (. not . allocated ( queue )) error stop 'error: queue not allocated' do i = 1 , size ( queue ) if ( all ( state == queue ( i )% state )) then idx = i return end if end do end function index_in_queue subroutine add_to_queue ( state , idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ), intent ( out ) :: idx !! index of the element in the queue if ( allocated ( queue )) then queue = [ queue , item ( state = state )] idx = size ( queue ) else queue = [ item ( state = state )] idx = 1 end if end subroutine add_to_queue end program problem_17","tags":"","loc":"sourcefile/problem_17.f90.html"}]}