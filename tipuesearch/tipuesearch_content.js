var tipuesearch = {"pages":[{"title":" AoC-2023 ","text":"AoC-2023 Advent of Code 2023 with Modern Fortran. Compiling All the cases can be compiled and run using the Fortran Package Manager . to run individual cases: fpm run --profile release problem_01 to run them all: fpm run --profile release --all Current status Problem Stars Solution Runtime 1 ⭐⭐ problem_01.f90 12 ms 2 ⭐⭐ problem_02.f90 4 ms 3 ⭐⭐ problem_03.f90 2 ms 4 ⭐⭐ problem_04.f90 5 ms 5 ⭐⭐ problem_05.f90 622 ms 6 ⭐⭐ problem_06.f90 45 ms 7 ⭐⭐ problem_07.f90 17 ms 8 ⭐⭐ problem_08.f90 11 ms 9 ⭐⭐ problem_09.f90 23 ms 10 ⭐⭐ problem_10.f90 708 ms † 11 ⭐⭐ problem_11.f90 1 ms 12 ⭐⭐ problem_12.f90 + problem_12b.f90 754 ms + 232 ms 13 ⭐⭐ problem_13.f90 3 ms 14 ⭐⭐ problem_14.f90 257 ms 15 ⭐⭐ problem_15.f90 3 ms 16 ⭐⭐ problem_16.f90 27 ms 17 ⭐⭐ problem_17.f90 + problem_17b.f90 minutes 18 ⭐⭐ problem_18.f90 2 ms 19 ⭐⭐ problem_19.f90 + problem_19b.f90 44 ms + 47 ms 20 ☆☆ problem_20.f90 21 ⭐☆ problem_21.f90 1 ms 22 ☆☆ problem_22.f90 23 ⭐⭐ problem_23.f90 3689 ms 24 ☆☆ problem_24.f90 25 ☆☆ problem_25.f90 † With OpenMP enabled (i.e, add --flag \"-fopenmp\" to the FPM call). Previous Years AoC-2020 AoC-2021 AoC-2022 AoC-2023 ## Documentation The API documentation for the current master branch can be found here .  This is generated by processing the source files with FORD . Developer Info Jacob Williams","tags":"home","loc":"index.html"},{"title":"finite_diff_method – AoC-2023 ","text":"type, public :: finite_diff_method defines the finite difference method\nused to compute the Jacobian. See: get_finite_difference_method for the different methods. Inherited by type~~finite_diff_method~~InheritedByGraph type~finite_diff_method finite_diff_method type~meth_array meth_array type~meth_array->type~finite_diff_method meth type~numdiff_type numdiff_type type~numdiff_type->type~finite_diff_method meth type~numdiff_type->type~meth_array class_meths Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, private :: id = 0 unique ID for the method character(len=:), private, allocatable :: name the name of the method integer, private :: class = 0 2=backward diffs, 3=central diffs, etc... real(kind=wp), private, dimension(:), allocatable :: dx_factors multiplicative factors for dx perturbation real(kind=wp), private, dimension(:), allocatable :: df_factors multiplicative factors for accumulating function evaluations real(kind=wp), private :: df_den_factor = zero denominator factor for finite difference equation (times dx ) Constructor public        interface finite_diff_method constructor private  function initialize_finite_difference_method (id, name, class, dx_factors, df_factors, df_den_factor) result(me) Constructor for a finite_diff_method . Note factors are input as integers for convenience, but are converted\n      to reals for the actual computations. (note: this means we can't\n      currently define methods that have non-integer factors). Arguments Type Intent Optional Attributes Name integer, intent(in) :: id unique ID for the method character(len=*), intent(in) :: name the name of the method integer, intent(in) :: class 2=backward diffs, 3=central diffs, etc... integer, intent(in), dimension(:) :: dx_factors multiplicative factors for dx perturbation integer, intent(in), dimension(:) :: df_factors multiplicative factors for accumulating function evaluations integer, intent(in) :: df_den_factor denominator factor for finite difference equation (times dx) Return Value type( finite_diff_method ) Type-Bound Procedures procedure, public :: get_formula private  subroutine get_formula (me, formula) Return a string with the finite difference formula. Read more… Arguments Type Intent Optional Attributes Name class( finite_diff_method ), intent(in) :: me character(len=:), intent(out), allocatable :: formula procedure, public :: print => print_finite_difference_method private  subroutine print_finite_difference_method (me, iunit) Print the contents of a finite_diff_method . Used for debugging. Arguments Type Intent Optional Attributes Name class( finite_diff_method ), intent(in) :: me integer, intent(in) :: iunit file unit for printing\n(assumed to be opened) Source Code type , public :: finite_diff_method !! defines the finite difference method !! used to compute the Jacobian. !! !! See: [[get_finite_difference_method]] !! for the different methods. private integer :: id = 0 !! unique ID for the method character ( len = :), allocatable :: name !! the name of the method integer :: class = 0 !! 2=backward diffs, 3=central diffs, etc... real ( wp ), dimension (:), allocatable :: dx_factors !! multiplicative factors for `dx` perturbation real ( wp ), dimension (:), allocatable :: df_factors !! multiplicative factors for accumulating function evaluations real ( wp ) :: df_den_factor = zero !! denominator factor for finite difference equation (times `dx`) contains private procedure , public :: get_formula procedure , public :: print => print_finite_difference_method end type finite_diff_method","tags":"","loc":"type/finite_diff_method.html"},{"title":"meth_array – AoC-2023 ","text":"type, public :: meth_array to store an array of finite_diff_method types\nthis is used when the mode=2 option is used\nin numdiff_type Inherits type~~meth_array~~InheritsGraph type~meth_array meth_array type~finite_diff_method finite_diff_method type~meth_array->type~finite_diff_method meth Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~meth_array~~InheritedByGraph type~meth_array meth_array type~numdiff_type numdiff_type type~numdiff_type->type~meth_array class_meths Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( finite_diff_method ), private, dimension(:), allocatable :: meth Source Code type , public :: meth_array !! to store an array of [[finite_diff_method]] types !! this is used when the `mode=2` option is used !! in [[numdiff_type]] private type ( finite_diff_method ), dimension (:), allocatable :: meth end type meth_array","tags":"","loc":"type/meth_array.html"},{"title":"sparsity_pattern – AoC-2023 ","text":"type, public :: sparsity_pattern A sparsity pattern Inherited by type~~sparsity_pattern~~InheritedByGraph type~sparsity_pattern sparsity_pattern type~numdiff_type numdiff_type type~numdiff_type->type~sparsity_pattern sparsity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, private :: sparsity_computed = .false. has the sparsity pattern already been computed? integer, private :: num_nonzero_elements = 0 number of nonzero elements in the jacobian\n(will be the dimension of irow and icol ) integer, private, dimension(:), allocatable :: irow sparsity pattern - rows of non-zero elements integer, private, dimension(:), allocatable :: icol sparsity pattern - columns of non-zero elements logical, private :: linear_sparsity_computed = .false. if the linear pattern has been populated integer, private :: num_nonzero_linear_elements = 0 number of constant elements in the jacobian integer, private, dimension(:), allocatable :: linear_irow linear sparsity pattern - rows of non-zero elements integer, private, dimension(:), allocatable :: linear_icol linear sparsity pattern - columns of non-zero elements real(kind=wp), private, dimension(:), allocatable :: linear_vals linear elements of the jacobian integer, private, dimension(:), allocatable :: indices index vector [1,2,...,num_nonzero_elements] for putting df into jac integer, private :: maxgrp = 0 the number of groups in the partition\nof the columns of a . integer, private, dimension(:), allocatable :: ngrp specifies the partition of the columns of a .\ncolumn jcol belongs to group ngrp(jcol) . size(n) Type-Bound Procedures procedure, private :: dsm_wrapper private  subroutine dsm_wrapper (me, n, m, info) Wrapper for dsm to compute the sparsity pattern partition. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(inout) :: me integer, intent(in) :: n number of columns of jacobian matrix integer, intent(in) :: m number of rows of jacobian matrix integer, intent(out) :: info status output from dsm procedure, private :: compute_indices private  subroutine compute_indices (me) Computes the indices vector in the class. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(inout) :: me procedure, public :: destroy => destroy_sparsity private  subroutine destroy_sparsity (me) destroy a sparsity_pattern type. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(out) :: me procedure, public :: print => print_sparsity private  subroutine print_sparsity (me, n, m, iunit, dense) Print the sparsity pattern. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(in) :: me integer, intent(in) :: n number of variables (columns of jacobian) integer, intent(in) :: m number of functions (rows of jacobian) integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) logical, intent(in), optional :: dense if present and true, the matrix form\nof the sparsity pattern is printed\n(default is vector form) procedure, public :: columns_in_partition_group private  subroutine columns_in_partition_group (me, igroup, n_cols, cols, nonzero_rows, indices, status_ok) Returns the columns in a sparsity partition group. Read more… Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(in) :: me integer, intent(in) :: igroup group number. Should be >0 and <=me%mxgrp integer, intent(out) :: n_cols number of columns in the igroup group. integer, intent(out), dimension(:), allocatable :: cols the column numbers in the igroup group.\n(if none, then it is not allocated) integer, intent(out), dimension(:), allocatable :: nonzero_rows the row numbers of all the nonzero\nJacobian elements in this group integer, intent(out), dimension(:), allocatable :: indices nonzero indices in jac for a group logical, intent(out) :: status_ok true if the partition is valid Source Code type , public :: sparsity_pattern !! A sparsity pattern private logical :: sparsity_computed = . false . !! has the sparsity pattern already been computed? integer :: num_nonzero_elements = 0 !! number of nonzero elements in the jacobian !! (will be the dimension of `irow` and `icol`) integer , dimension (:), allocatable :: irow !! sparsity pattern - rows of non-zero elements integer , dimension (:), allocatable :: icol !! sparsity pattern - columns of non-zero elements logical :: linear_sparsity_computed = . false . !! if the linear pattern has been populated integer :: num_nonzero_linear_elements = 0 !! number of constant elements in the jacobian integer , dimension (:), allocatable :: linear_irow !! linear sparsity pattern - rows of non-zero elements integer , dimension (:), allocatable :: linear_icol !! linear sparsity pattern - columns of non-zero elements real ( wp ), dimension (:), allocatable :: linear_vals !! linear elements of the jacobian integer , dimension (:), allocatable :: indices !! index vector !! `[1,2,...,num_nonzero_elements]` !! for putting `df` into `jac` integer :: maxgrp = 0 !! the number of groups in the partition !! of the columns of `a`. integer , dimension (:), allocatable :: ngrp !! specifies the partition of the columns of `a`. !! column `jcol` belongs to group `ngrp(jcol)`. !! `size(n)` contains private procedure :: dsm_wrapper procedure :: compute_indices procedure , public :: destroy => destroy_sparsity procedure , public :: print => print_sparsity procedure , public :: columns_in_partition_group end type sparsity_pattern","tags":"","loc":"type/sparsity_pattern.html"},{"title":"numdiff_type – AoC-2023 ","text":"type, public :: numdiff_type base type for sparsity and Jacobian computations. Inherits type~~numdiff_type~~InheritsGraph type~numdiff_type numdiff_type type~finite_diff_method finite_diff_method type~numdiff_type->type~finite_diff_method meth type~function_cache~2 function_cache type~numdiff_type->type~function_cache~2 cache type~meth_array meth_array type~numdiff_type->type~meth_array class_meths type~sparsity_pattern sparsity_pattern type~numdiff_type->type~sparsity_pattern sparsity type~fx~2 fx type~function_cache~2->type~fx~2 c type~meth_array->type~finite_diff_method meth Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, private :: exception_raised = .false. if true, an exception has been raised integer, private :: istat = 0 a non-zero value will cause all routine to exit.\nthis can be set to -1 by calling terminate . character(len=:), private, allocatable :: error_msg error message (if istat/=0 ) integer, private :: n = 0 number of x variables integer, private :: m = 0 number of f functions real(kind=wp), private, dimension(:), allocatable :: xlow lower bounds on x real(kind=wp), private, dimension(:), allocatable :: xhigh upper bounds on x logical, private :: print_messages = .true. if true, warning messages are printed\nto the error_unit for any errors. integer, private :: chunk_size = 100 chuck size for allocating the arrays (>0) integer, private :: perturb_mode = 1 perturbation mode: 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), private, dimension(:), allocatable :: dpert perturbation vector for x logical, private :: partition_sparsity_pattern = .false. to partition the sparsity pattern using dsm type( sparsity_pattern ), private :: sparsity the sparsity pattern real(kind=wp), private, dimension(:), allocatable :: xlow_for_sparsity lower bounds on x for computing sparsity (optional) real(kind=wp), private, dimension(:), allocatable :: xhigh_for_sparsity upper bounds on x for computing sparsity (optional) real(kind=wp), private, dimension(:), allocatable :: dpert_for_sparsity perturbation vector for x when computing\nsparsity for sparsity_mode=4 integer, private :: num_sparsity_points = 3 for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern.\nSee compute_sparsity_random_2 integer, private :: sparsity_perturb_mode = 1 perturbation mode (if sparsity_mode=4 ): 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) logical, private :: compute_linear_sparsity_pattern = .false. to also compute the linear sparsity pattern real(kind=wp), private :: linear_sparsity_tol = epsilon(1.0_wp) the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), private :: function_precision_tol = epsilon(1.0_wp) the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, private :: mode = 1 1 = use meth (specified methods), 2 = use class (specified class, method is selected on-the-fly). type( finite_diff_method ), private, dimension(:), allocatable :: meth the finite difference method to use\ncompute the n th column of the Jacobian size(n) .  Either this or class is used integer, private, dimension(:), allocatable :: class the class of method to use to\ncompute the n th column of the Jacobian size(n) . Either this or meth is used type( meth_array ), private, dimension(:), allocatable :: class_meths array of methods for the specified classes.\nused with class when mode=2 real(kind=wp), private :: eps = 1.0e-9_wp tolerance parameter for diff real(kind=wp), private :: acc = 0.0_wp tolerance parameter for diff type( function_cache ), private :: cache if using the function cache logical, private :: use_diff = .false. if we are using the Neville's process method,\nrather than finite differences procedure( func ), private, pointer :: problem_func => null() the user-defined function procedure( func ), private, pointer :: compute_function => null() compute the user-defined function\nthis can point to the problem_func or, if using\nthe cache, it points to compute_function_with_cache . procedure( spars_f ), private, pointer :: compute_sparsity => null() for computing the sparsity pattern procedure( info_f ), private, pointer :: info_function => null() an optional function the user can define\nwhich is called when each column of the jacobian is computed.\nIt can be used to perform any setup operations. procedure( jacobian_f ), private, pointer :: jacobian_function => null() the low-level function called by compute_jacobian that actually computes the jacobian. Type-Bound Procedures procedure, public :: initialize => initialize_numdiff initialize the class private  subroutine initialize_numdiff (me, n, m, xlow, xhigh, perturb_mode, dpert, problem_func, sparsity_mode, jacobian_method, jacobian_methods, class, classes, info, chunk_size, partition_sparsity_pattern, cache_size, xlow_for_sparsity, xhigh_for_sparsity, dpert_for_sparsity, sparsity_perturb_mode, linear_sparsity_tol, function_precision_tol, num_sparsity_points) Initialize a numdiff_type class. This must be called first. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: n number of x variables integer, intent(in) :: m number of f functions real(kind=wp), intent(in), dimension(n) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(n) :: xhigh upper bounds on x integer, intent(in) :: perturb_mode perturbation mode: 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), dimension(n) :: dpert perturbation vector for x procedure( func ) :: problem_func the user function that defines the problem\n(returns m functions) integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. integer, intent(in), optional :: jacobian_method id code for the finite difference method\nto use for all n variables.\nsee get_finite_difference_method integer, intent(in), optional, dimension(n) :: jacobian_methods id codes for the finite difference method\nto use for each variable.\nsee get_finite_difference_method integer, intent(in), optional :: class method class for the finite difference method\nto use for all n variables.\nsee get_finite_difference_method integer, intent(in), optional, dimension(n) :: classes method class for the finite difference methods\nto use for each variable.\nsee get_finite_difference_method procedure( info_f ), optional :: info a function the user can define\nwhich is called when each column\nof the jacobian is computed.\nIt can be used to perform any\nsetup operations. integer, intent(in), optional :: chunk_size chunk size for allocating the arrays\n(must be >0) [default is 100] logical, intent(in), optional :: partition_sparsity_pattern if the sparisty pattern is to\nbe partitioned using DSM [default is False] integer, intent(in), optional :: cache_size if present, this is the cache size\nfor the function cache\n(default is not to enable cache) real(kind=wp), intent(in), optional, dimension(n) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(n) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. real(kind=wp), intent(in), optional, dimension(n) :: dpert_for_sparsity for sparsity_mode=4 , the perturbation integer, intent(in), optional :: sparsity_perturb_mode perturbation mode (required if sparsity_mode=4 ): 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), optional :: linear_sparsity_tol the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), intent(in), optional :: function_precision_tol the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, intent(in), optional :: num_sparsity_points for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern. procedure, public :: diff_initialize => initialize_numdiff_for_diff initialize the class private  subroutine initialize_numdiff_for_diff (me, n, m, xlow, xhigh, problem_func, sparsity_mode, info, chunk_size, eps, acc, cache_size, xlow_for_sparsity, xhigh_for_sparsity, dpert_for_sparsity, sparsity_perturb_mode, linear_sparsity_tol, function_precision_tol, num_sparsity_points, print_messages) Alternate version of initialize_numdiff routine when\nusing diff to compute the Jacobian. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: n number of x variables integer, intent(in) :: m number of f functions real(kind=wp), intent(in), dimension(n) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(n) :: xhigh upper bounds on x procedure( func ) :: problem_func the user function that defines the problem\n(returns m functions) integer, intent(in) :: sparsity_mode the sparsity computation method: Read more… procedure( info_f ), optional :: info a function the user can define\nwhich is called when each column\nof the jacobian is computed.\nIt can be used to perform any\nsetup operations. integer, intent(in), optional :: chunk_size chunk size for allocating the arrays\n(must be >0) [default is 100] real(kind=wp), intent(in), optional :: eps tolerance parameter for diff if not present, default is 1.0e-9_wp real(kind=wp), intent(in), optional :: acc tolerance parameter for diff if not present, default is 0.0_wp integer, intent(in), optional :: cache_size if present, this is the cache size\nfor the function cache\n(default is not to enable cache) real(kind=wp), intent(in), optional, dimension(n) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(n) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. real(kind=wp), intent(in), optional, dimension(n) :: dpert_for_sparsity required if sparsity_mode=4 integer, intent(in), optional :: sparsity_perturb_mode perturbation mode (required if sparsity_mode=4 ): Read more… real(kind=wp), intent(in), optional :: linear_sparsity_tol the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), intent(in), optional :: function_precision_tol the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, intent(in), optional :: num_sparsity_points for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern. logical, intent(in), optional :: print_messages if true, print error messages to error_unit .\ndefault is True. procedure, public :: compute_jacobian main routine to compute the Jacobian\nusing the selected options. It\nreturns the sparse (vector) form. private  subroutine compute_jacobian (me, x, jac) Compute the Jacobian. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:), allocatable :: jac sparse jacobian vector procedure, public :: compute_jacobian_dense return the dense size(m,n) matrix form of the Jacobian. private  subroutine compute_jacobian_dense (me, x, jac) just a wrapper for compute_jacobian , that returns a dense ( m x n ) matrix. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:,:), allocatable :: jac the jacobian matrix procedure, public :: compute_jacobian_times_vector returns the product of the Jacobian\nmatrix and an input vector private  subroutine compute_jacobian_times_vector (me, x, v, z) Returns the product J*v , where J is the m x n Jacobian matrix\n  and v is an n x 1 vector. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(:) :: v vector (size n ) real(kind=wp), intent(out), dimension(:) :: z The product J*v (size m ) procedure, public :: destroy => destroy_numdiff_type destroy the class private  subroutine destroy_numdiff_type (me) destroy the numdiff_type class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(out) :: me procedure, public :: print_sparsity_pattern print the sparsity pattern in vector form to a file private  subroutine print_sparsity_pattern (me, iunit) Print the sparsity pattern in vector form ( irow , icol ). Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) procedure, public :: print_sparsity_matrix print the sparsity pattern in matrix form to a file private  subroutine print_sparsity_matrix (me, iunit) Print the sparsity pattern in matrix form. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) procedure, public :: set_sparsity_pattern manually set the sparsity pattern private  subroutine set_sparsity_pattern (me, irow, icol, linear_irow, linear_icol, linear_vals, maxgrp, ngrp) To specify the sparsity pattern directly if it is already known. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in), dimension(:) :: irow sparsity pattern nonzero elements row indices integer, intent(in), dimension(:) :: icol sparsity pattern nonzero elements column indices integer, intent(in), optional, dimension(:) :: linear_irow linear sparsity pattern nonzero elements row indices integer, intent(in), optional, dimension(:) :: linear_icol linear sparsity pattern nonzero elements column indices real(kind=wp), intent(in), optional, dimension(:) :: linear_vals linear sparsity values (constant elements of the Jacobian) integer, intent(in), optional :: maxgrp DSM sparsity partition\n[only used if me%partition_sparsity_pattern=True ] integer, intent(in), optional, dimension(:) :: ngrp DSM sparsity partition (size n )\n[only used if me%partition_sparsity_pattern=True ] procedure, public :: select_finite_diff_method select a method in a specified class so\nthat the variable bounds are not violated\nwhen by the perturbations. private  subroutine select_finite_diff_method (me, x, xlow, xhigh, dx, list_of_methods, fd, status_ok) Select a finite diff method of a given class so that the perturbations\nof x will not violate the variable bounds. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in) :: x the variable value real(kind=wp), intent(in) :: xlow the variable lower bound real(kind=wp), intent(in) :: xhigh the variable upper bound real(kind=wp), intent(in) :: dx the perturbation value (>0) type( meth_array ), intent(in) :: list_of_methods list of available methods to choose from type( finite_diff_method ), intent(out) :: fd this method can be used logical, intent(out) :: status_ok true if it really doesn't violate the bounds\n(say, the bounds are very close to each other)\nif status_ok=False , then the first method in\nthe given class is returned in fd . procedure, public :: select_finite_diff_method_for_partition_group version of select_finite_diff_method for partitioned sparsity pattern. private  subroutine select_finite_diff_method_for_partition_group (me, x, xlow, xhigh, dx, list_of_methods, fd, status_ok) Select a finite diff method of a given class so that the perturbations\nof x will not violate the variable bounds for any variable in the group. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x the variable values real(kind=wp), intent(in), dimension(:) :: xlow the variable lower bounds real(kind=wp), intent(in), dimension(:) :: xhigh the variable upper bounds real(kind=wp), intent(in), dimension(:) :: dx the perturbation values (>0) type( meth_array ), intent(in) :: list_of_methods list of available methods to choose from type( finite_diff_method ), intent(out) :: fd this method can be used logical, intent(out) :: status_ok true if it really doesn't violate the bounds\n(say, the bounds are very close to each other)\nif status_ok=False , then the first method in\nthe given class is returned in fd . procedure, public :: set_numdiff_bounds can be called to change the variable bounds. private  subroutine set_numdiff_bounds (me, xlow, xhigh) Change the variable bounds in a numdiff_type . Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(:) :: xhigh upper bounds on x procedure, public :: compute_sparsity_pattern if the user needs to compute the sparsity pattern manually.\n(otherwise it will be done the first time the Jacobian is computed) private  subroutine compute_sparsity_pattern (me, x, irow, icol, linear_irow, linear_icol, linear_vals) Computes the sparsity pattern and return it.\nUses the settings currently in the class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) integer, intent(out), dimension(:), allocatable :: irow sparsity pattern nonzero elements row indices integer, intent(out), dimension(:), allocatable :: icol sparsity pattern nonzero elements column indices integer, intent(out), optional, dimension(:), allocatable :: linear_irow linear sparsity pattern\nnonzero elements row indices integer, intent(out), optional, dimension(:), allocatable :: linear_icol linear sparsity pattern nonzero\nelements column indices real(kind=wp), intent(out), optional, dimension(:), allocatable :: linear_vals linear sparsity values (constant\nelements of the Jacobian) procedure, public :: get_sparsity_pattern returns the sparsity pattern (if it is allocated) private  subroutine get_sparsity_pattern (me, irow, icol, linear_irow, linear_icol, linear_vals, maxgrp, ngrp) Returns the sparsity pattern from the class.\nIf it hasn't been computed, the output arrays will not be allocated. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: irow sparsity pattern nonzero elements row indices integer, intent(out), dimension(:), allocatable :: icol sparsity pattern nonzero elements column indices integer, intent(out), optional, dimension(:), allocatable :: linear_irow linear sparsity pattern\nnonzero elements row indices integer, intent(out), optional, dimension(:), allocatable :: linear_icol linear sparsity pattern nonzero\nelements column indices real(kind=wp), intent(out), optional, dimension(:), allocatable :: linear_vals linear sparsity values (constant\nelements of the Jacobian) integer, intent(out), optional :: maxgrp DSM sparsity partition integer, intent(out), optional, dimension(:), allocatable :: ngrp DSM sparsity partition procedure, public :: terminate can be called by user to stop the computation private  subroutine terminate (me) A user-callable routine. When called, it will terminate\nall computations and return. The istat return code will be\nset to -1 . This can be called in the function or the info function. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me procedure, public :: failed to check if an exception was raised. private pure function failed (me) Returns True if an exception has been raised. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(in) :: me Return Value logical procedure, public :: get_error_status the status of error condition private  subroutine get_error_status (me, istat, error_msg) Returns the current error code and message. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(in) :: me integer, intent(out), optional :: istat error code ( istat=0 means no errors). character(len=:), intent(out), optional, allocatable :: error_msg error message string. procedure, private :: destroy_sparsity_pattern destroy the sparsity pattern private  subroutine destroy_sparsity_pattern (me) Destroy the sparsity pattern in the class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me procedure, private :: compute_perturb_vector private  subroutine compute_perturb_vector (me, x, dpert, perturb_mode, dx) Compute dx , the perturbation vector for x Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dpert integer, intent(in) :: perturb_mode real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable procedure, private :: compute_perturbation_vector computes the variable perturbation factor private  subroutine compute_perturbation_vector (me, x, dx) Compute dx , the perturbation vector for x used\nwhen computing the gradients. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable procedure, private :: compute_sparsity_perturbation_vector private  subroutine compute_sparsity_perturbation_vector (me, x, dx) Compute dx , the perturbation vector for x used\nwhen computing the sparsity pattern. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable procedure, private :: perturb_x_and_compute_f private  subroutine perturb_x_and_compute_f (me, x, dx_factor, dx, df_factor, column, idx, df) Perturb the specified optimization variable, and compute the function.\nThis routine is designed so that df is accumulated as each function\nevaluation is done, to avoid having to allocate more temporary storage. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x nominal variable vector real(kind=wp), intent(in) :: dx_factor factor to multiply dx real(kind=wp), intent(in), dimension(:) :: dx the perturbation value for this column real(kind=wp), intent(in) :: df_factor factor to multiply function value integer, intent(in) :: column the variable to perturb integer, intent(in), dimension(:) :: idx the elements in this\ncolumn of the Jacobian\nto compute (passed to function) real(kind=wp), intent(inout), dimension(me%m) :: df the accumulated function value\nnote: for the first call, this\nshould be set to zero procedure, private :: perturb_x_and_compute_f_partitioned private  subroutine perturb_x_and_compute_f_partitioned (me, x, dx_factor, dx, df_factor, columns, idx, df) Perturb the specified optimization variable, and compute the function.\nThis routine is designed so that df is accumulated as each function\nevaluation is done, to avoid having to allocate more temporary storage. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x nominal variable vector real(kind=wp), intent(in) :: dx_factor factor to multiply dx real(kind=wp), intent(in), dimension(:) :: dx the perturbation value for this column real(kind=wp), intent(in) :: df_factor factor to multiply function value integer, intent(in), dimension(:) :: columns the variables to perturb integer, intent(in), dimension(:) :: idx the elements in this\ncolumn of the Jacobian\nto compute (passed to function) real(kind=wp), intent(inout), dimension(me%m) :: df the accumulated function value\nnote: for the first call, this\nshould be set to zero procedure, private :: set_numdiff_sparsity_bounds private  subroutine set_numdiff_sparsity_bounds (me, xlow, xhigh) Sets the variable bounds for sparsity in a numdiff_type .\n  These are only used for sparsity_mode=2 . Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), optional, dimension(:) :: xlow lower bounds on x to be used for\nsparsity computation. If not present,\nthen then xlow values in the class are used. real(kind=wp), intent(in), optional, dimension(:) :: xhigh upper bounds on x to be used for\nsparsity computation. If not present,\nthen then xhigh values in the class are used. procedure, private :: set_sparsity_mode private  subroutine set_sparsity_mode (me, sparsity_mode, xlow_for_sparsity, xhigh_for_sparsity) Set sparsity mode. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. real(kind=wp), intent(in), optional, dimension(:) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(:) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. procedure, private :: generate_dense_sparsity_partition private  subroutine generate_dense_sparsity_partition (me) Generate a \"dense\" sparsity partition. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me procedure, private :: compute_jacobian_for_sparsity private  subroutine compute_jacobian_for_sparsity (me, i, class_meths, x, jac) A separate version of compute_jacobian to be used only when\n  computing the sparsity pattern in compute_sparsity_random_2 .\n  It uses class_meths and the sparsity dperts and bounds. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: i the column being computed type( meth_array ), intent(in) :: class_meths set of finite diff methods to use real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:), allocatable :: jac sparse jacobian vector procedure, private :: resize_sparsity_vectors private  subroutine resize_sparsity_vectors (me, n_icol, n_irow, n_linear_icol, n_linear_irow, n_linear_vals) Resize the sparsity arrays after accumulating them. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(inout) :: n_icol integer, intent(inout) :: n_irow integer, intent(inout) :: n_linear_icol integer, intent(inout) :: n_linear_irow integer, intent(inout) :: n_linear_vals procedure, private :: raise_exception private  subroutine raise_exception (me, istat, routine, error_msg) Raise an exception. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: istat error code. character(len=*), intent(in) :: routine the routine where the error was raised. character(len=*), intent(in) :: error_msg error message string. procedure, private :: clear_exceptions private  subroutine clear_exceptions (me) Clear all exceptions. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me Source Code type , public :: numdiff_type !! base type for sparsity and Jacobian computations. private logical :: exception_raised = . false . !! if true, an exception has been raised integer :: istat = 0 !! a non-zero value will cause all routine to exit. !! this can be set to `-1` by calling [[terminate]]. character ( len = :), allocatable :: error_msg !! error message (if `istat/=0`) integer :: n = 0 !! number of `x` variables integer :: m = 0 !! number of `f` functions real ( wp ), dimension (:), allocatable :: xlow !! lower bounds on `x` real ( wp ), dimension (:), allocatable :: xhigh !! upper bounds on `x` logical :: print_messages = . true . !! if true, warning messages are printed !! to the `error_unit` for any errors. integer :: chunk_size = 100 !! chuck size for allocating the arrays (>0) integer :: perturb_mode = 1 !! perturbation mode: !! !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` real ( wp ), dimension (:), allocatable :: dpert !! perturbation vector for `x` logical :: partition_sparsity_pattern = . false . !! to partition the sparsity pattern using [[dsm]] type ( sparsity_pattern ) :: sparsity !! the sparsity pattern real ( wp ), dimension (:), allocatable :: xlow_for_sparsity !! lower bounds on `x` for computing sparsity (optional) real ( wp ), dimension (:), allocatable :: xhigh_for_sparsity !! upper bounds on `x` for computing sparsity (optional) real ( wp ), dimension (:), allocatable :: dpert_for_sparsity !! perturbation vector for `x` when computing !! sparsity for `sparsity_mode=4` integer :: num_sparsity_points = 3 !! for `sparsity_mode=4`, the number of jacobian !! evaluations used to estimate the sparsity pattern. !! See [[compute_sparsity_random_2]] integer :: sparsity_perturb_mode = 1 !! perturbation mode (if `sparsity_mode=4`): !! !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` ! if computing the sparsity pattern, we also have an option to ! compute the linear pattern, which indicates constant elements ! of the jacobian. these elements don't need to be computed again. logical :: compute_linear_sparsity_pattern = . false . !! to also compute the linear sparsity pattern real ( wp ) :: linear_sparsity_tol = epsilon ( 1.0_wp ) !! the equality tolerance for derivatives to !! indicate a constant jacobian element (linear sparsity) real ( wp ) :: function_precision_tol = epsilon ( 1.0_wp ) !! the function precision. two functions values !! that are the within this tolerance are !! considered the same value. This is used !! when estimating the sparsity pattern when !! `sparsity_mode=2` in [[compute_sparsity_random]] integer :: mode = 1 !! **1** = use `meth` (specified methods), !! **2** = use `class` (specified class, method is selected on-the-fly). type ( finite_diff_method ), dimension (:), allocatable :: meth !! the finite difference method to use !! compute the `n`th column of the Jacobian !! `size(n)`.  Either this or `class` is used integer , dimension (:), allocatable :: class !! the class of method to use to !! compute the `n`th column of the Jacobian !! `size(n)`. Either this or `meth` is used type ( meth_array ), dimension (:), allocatable :: class_meths !! array of methods for the specified classes. !! used with `class` when `mode=2` ! parameters when using diff: real ( wp ) :: eps = 1.0e-9_wp !! tolerance parameter for [[diff]] real ( wp ) :: acc = 0.0_wp !! tolerance parameter for [[diff]] type ( function_cache ) :: cache !! if using the function cache logical :: use_diff = . false . !! if we are using the Neville's process method, !! rather than finite differences procedure ( func ), pointer :: problem_func => null () !! the user-defined function ! these are required to be defined by the user: procedure ( func ), pointer :: compute_function => null () !! compute the user-defined function !! this can point to the `problem_func` or, if using !! the cache, it points to [[compute_function_with_cache]]. procedure ( spars_f ), pointer :: compute_sparsity => null () !! for computing the sparsity pattern procedure ( info_f ), pointer :: info_function => null () !! an optional function the user can define !! which is called when each column of the jacobian is computed. !! It can be used to perform any setup operations. procedure ( jacobian_f ), pointer :: jacobian_function => null () !! the low-level function called by [[compute_jacobian]] !! that actually computes the jacobian. contains private procedure , public :: initialize => initialize_numdiff !! initialize the class procedure , public :: diff_initialize => initialize_numdiff_for_diff !! initialize the class procedure , public :: compute_jacobian !! main routine to compute the Jacobian !! using the selected options. It !! returns the sparse (vector) form. procedure , public :: compute_jacobian_dense !! return the dense `size(m,n)` !! matrix form of the Jacobian. procedure , public :: compute_jacobian_times_vector !! returns the product of the Jacobian !! matrix and an input vector procedure , public :: destroy => destroy_numdiff_type !! destroy the class procedure , public :: print_sparsity_pattern !! print the sparsity pattern in vector form to a file procedure , public :: print_sparsity_matrix !! print the sparsity pattern in matrix form to a file procedure , public :: set_sparsity_pattern !! manually set the sparsity pattern procedure , public :: select_finite_diff_method !! select a method in a specified class so !! that the variable bounds are not violated !! when by the perturbations. procedure , public :: select_finite_diff_method_for_partition_group !! version of [[select_finite_diff_method]] !! for partitioned sparsity pattern. procedure , public :: set_numdiff_bounds !! can be called to change the variable bounds. procedure , public :: compute_sparsity_pattern !! if the user needs to compute the sparsity pattern manually. !! (otherwise it will be done the first time the Jacobian is computed) procedure , public :: get_sparsity_pattern !! returns the sparsity pattern (if it is allocated) procedure , public :: terminate !! can be called by user to stop the computation procedure , public :: failed !! to check if an exception was raised. procedure , public :: get_error_status !! the status of error condition ! internal routines: procedure :: destroy_sparsity_pattern !! destroy the sparsity pattern procedure :: compute_perturb_vector procedure :: compute_perturbation_vector !! computes the variable perturbation factor procedure :: compute_sparsity_perturbation_vector procedure :: perturb_x_and_compute_f procedure :: perturb_x_and_compute_f_partitioned procedure :: set_numdiff_sparsity_bounds procedure :: set_sparsity_mode procedure :: generate_dense_sparsity_partition procedure :: compute_jacobian_for_sparsity procedure :: resize_sparsity_vectors procedure :: raise_exception procedure :: clear_exceptions end type numdiff_type","tags":"","loc":"type/numdiff_type.html"},{"title":"lens – AoC-2023 ","text":"type, public :: lens Inherited by type~~lens~~InheritedByGraph type~lens lens type~box box type~box->type~lens lenses Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: label integer(kind=ip), public :: focal_length = 0 Source Code type :: lens character ( len = :), allocatable :: label integer ( ip ) :: focal_length = 0 end type lens","tags":"","loc":"type/lens.html"},{"title":"box – AoC-2023 ","text":"type, public :: box Inherits type~~box~~InheritsGraph type~box box type~lens lens type~box->type~lens lenses Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( lens ), public, dimension(:), allocatable :: lenses the lenses in the box Type-Bound Procedures procedure, public :: add_lens public  subroutine add_lens (me, l) Arguments Type Intent Optional Attributes Name class( box ), intent(inout) :: me type( lens ), intent(in) :: l lense to add procedure, public :: remove_lens public  subroutine remove_lens (me, label) remove the lens with the label (if present) Arguments Type Intent Optional Attributes Name class( box ), intent(inout) :: me character(len=*), intent(in) :: label Source Code type :: box type ( lens ), dimension (:), allocatable :: lenses !! the lenses in the box contains procedure :: add_lens procedure :: remove_lens end type box","tags":"","loc":"type/box.html"},{"title":"diff_func – AoC-2023 ","text":"type, public :: diff_func class to define the function for diff Components Type Visibility Attributes Name Initial logical, private :: stop = .false. procedure( func ), private, pointer :: f => null() Type-Bound Procedures procedure, private :: faccur private  subroutine faccur (me, h0, h1, facc, x0, twoinf, f0, f1, ifail) This procedure attempts to estimate the level of rounding errors in\nthe calculated function values near the point x0+h0 by fitting a\nleast-squares straight-line approximation to the function at the\nsix points x0+h0-j*h1 , ( j = 0,1,3,5,7,9 ), and then setting facc to\ntwice the largest deviation of the function values from this line. hi is adjusted if necessary so that it is approximately 8 times the\nsmallest spacing at which the function values are unequal near x0+h0 . Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me real(kind=wp), intent(inout) :: h0 real(kind=wp), intent(inout) :: h1 real(kind=wp), intent(out) :: facc real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: twoinf real(kind=wp), intent(in) :: f0 real(kind=wp), intent(in) :: f1 integer, intent(out) :: ifail 0 if no error, -1 if user termination. procedure, public :: set_function private  subroutine set_function (me, f) Author Jacob Williams Date 12/27/2015 Set the function in a diff_func .\nMust be called before diff . Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me procedure( func ) :: f procedure, public :: compute_derivative => diff private  subroutine diff (me, iord, x0, xmin, xmax, eps, accr, deriv, error, ifail) the procedure diff calculates the first, second or\nthird order derivative of a function by using neville's process to\nextrapolate from a sequence of simple polynomial approximations based on\ninterpolating points distributed symmetrically about x0 (or lying only on\none side of x0 should this be necessary).  if the specified tolerance is\nnon-zero then the procedure attempts to satisfy this absolute or relative\naccuracy requirement, while if it is unsuccessful or if the tolerance is\nset to zero then the result having the minimum achievable estimated error\nis returned instead. Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me integer, intent(in) :: iord 1, 2 or 3 specifies that the first, second or third order\nderivative,respectively, is required. real(kind=wp), intent(in) :: x0 the point at which the derivative of the function is to be calculated. real(kind=wp), intent(in) :: xmin xmin , xmax restrict the interpolating points to lie in [ xmin , xmax ], which\nshould be the largest interval including x0 in which the function is\ncalculable and continuous. real(kind=wp), intent(in) :: xmax xmin , xmax restrict the interpolating points to lie in [ xmin , xmax ], which\nshould be the largest interval including x0 in which the function is\ncalculable and continuous. real(kind=wp), intent(in) :: eps denotes the tolerance, either absolute or relative. eps=0 specifies that\nthe error is to be minimised, while eps>0 or eps<0 specifies that the\nabsolute or relative error, respectively, must not exceed abs(eps) if\npossible.  the accuracy requirement should not be made stricter than\nnecessary, since the amount of computation tends to increase as\nthe magnitude of eps decreases, and is particularly high when eps=0 . real(kind=wp), intent(in) :: accr denotes that the absolute ( accr>0 ) or relative ( accr<0 ) errors in the\ncomputed values of the function are most unlikely to exceed abs(accr) , which\nshould be as small as possible.  if the user cannot estimate accr with\ncomplete confidence, then it should be set to zero. real(kind=wp), intent(out) :: deriv the calculated value of the derivative real(kind=wp), intent(out) :: error an estimated upper bound on the magnitude of the absolute error in\nthe calculated result.  it should always be examined, since in extreme case\nmay indicate that there are no correct significant digits in the value\nreturned for derivative. integer, intent(out) :: ifail will have one of the following values on exit: 0 the procedure was successful. 1 the estimated error in the result exceeds the (non-zero) requested\n     error, but the most accurate result possible has been returned. 2 input data incorrect (derivative and error will be undefined). 3 the interval [ xmin , xmax ] is too small (derivative and error will be\n     undefined). -1 stopped by the user. procedure, public :: terminate private  subroutine terminate (me) Can be called by the user in the function to terminate the computation.\nThis will set ifail=-1 . Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me Source Code type , public :: diff_func !! class to define the function for [[diff]] private logical :: stop = . false . procedure ( func ), pointer :: f => null () contains private procedure :: faccur procedure , public :: set_function procedure , public :: compute_derivative => diff procedure , public :: terminate end type diff_func","tags":"","loc":"type/diff_func.html"},{"title":"mapping – AoC-2023 ","text":"type :: mapping Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(:), allocatable :: dest_start integer(kind=ip), public, dimension(:), allocatable :: dest_end integer(kind=ip), public, dimension(:), allocatable :: src_start integer(kind=ip), public, dimension(:), allocatable :: src_end Source Code type :: mapping ! save the source and destination start and end values integer ( ip ), dimension (:), allocatable :: dest_start , dest_end , src_start , src_end end type mapping","tags":"","loc":"type/mapping.html"},{"title":"node – AoC-2023 ","text":"type :: node Components Type Visibility Attributes Name Initial character(len=3), public :: name = '' character(len=3), public, dimension(2) :: lr integer, public, dimension(2) :: lr_idx Source Code type :: node character ( len = 3 ) :: name = '' character ( len = 3 ), dimension ( 2 ) :: lr integer , dimension ( 2 ) :: lr_idx ! the indices in the nodes array of the l,r nodes end type node","tags":"","loc":"type/node~2.html"},{"title":"fx – AoC-2023 ","text":"type, private :: fx an [x,f(x)] cached pair. Inherited by type~~fx~2~~InheritedByGraph type~fx~2 fx type~function_cache~2 function_cache type~function_cache~2->type~fx~2 c type~numdiff_type numdiff_type type~numdiff_type->type~function_cache~2 cache Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:), allocatable :: x vector of input values real(kind=wp), private, dimension(:), allocatable :: f vector of output functions f(x) note: only the elements indicated by ifs will have valid values. The others will\nbe dummy values. integer, private, dimension(:), allocatable :: ifs elements of f present in the cache\n(this is just an array of the indices\npresent in f ) Source Code type :: fx !! an [x,f(x)] cached pair. private real ( wp ), dimension (:), allocatable :: x !! vector of input values real ( wp ), dimension (:), allocatable :: f !! vector of output functions `f(x)` !! note: only the elements indicated by `ifs` !! will have valid values. The others will !! be dummy values. integer , dimension (:), allocatable :: ifs !! elements of `f` present in the cache !! (this is just an array of the indices !! present in `f`) end type fx","tags":"","loc":"type/fx~2.html"},{"title":"function_cache – AoC-2023 ","text":"type, public :: function_cache a vector function cache. Inherits type~~function_cache~2~~InheritsGraph type~function_cache~2 function_cache type~fx~2 fx type~function_cache~2->type~fx~2 c Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~function_cache~2~~InheritedByGraph type~function_cache~2 function_cache type~numdiff_type numdiff_type type~numdiff_type->type~function_cache~2 cache Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, private :: n = 0 size of x integer, private :: m = 0 size of f type( fx ), private, dimension(:), allocatable :: c the cache of f(x) integer, private :: chunk_size = 100 for resizing vectors\nin the unique function Type-Bound Procedures procedure, public :: initialize => initialize_cache private  subroutine initialize_cache (me, isize, n, m, chunk_size) Initialize the cache. Must be called first before use. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: isize the size of the hash table integer, intent(in) :: n number of independant variables (x) integer, intent(in) :: m number of functions (f) integer, intent(in), optional :: chunk_size chunk size to speed up reallocation\nof arrays. A good value is a guess for\nthe actual number of elements of f that\nwill be saved per value of x [default is 100] procedure, public :: get => get_from_cache private  subroutine get_from_cache (me, x, ifs, i, f, xfound, ffound) Check if the x vector is in the cache, if so return f .\nNote that only some of the elements may be present, so it will return\nthe ones there are there, and indicate which ones were found. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x independant variable vector integer, intent(in), dimension(:) :: ifs elements of f needed integer, intent(out) :: i index in the hash table real(kind=wp), intent(out), dimension(:) :: f f(x) from the cache (if it was found) logical, intent(out) :: xfound if x was found in the cache logical, intent(out), dimension(size(ifs)) :: ffound which ifs were found in the cache procedure, public :: put => put_in_cache private  subroutine put_in_cache (me, i, x, f, ifs) Put a value into the cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: i index in the hash table real(kind=wp), intent(in), dimension(:) :: x independant variable vector (dimension n ) real(kind=wp), intent(in), dimension(:) :: f function vector f(x) (dimension m ) integer, intent(in), dimension(:) :: ifs elements of f to add (should all be >0, <=m ) procedure, public :: destroy => destroy_cache private  subroutine destroy_cache (me) Destroy a cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(out) :: me procedure, public :: print => print_cache private  subroutine print_cache (me, iunit) Print the contents of the cache. Used for debugging. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: iunit file unit for writing\n(assumed to be opened) Source Code type , public :: function_cache !! a vector function cache. private integer :: n = 0 !! size of `x` integer :: m = 0 !! size of `f` type ( fx ), dimension (:), allocatable :: c !! the cache of `f(x)` integer :: chunk_size = 100 !! for resizing vectors !! in the [[unique]] function contains private procedure , public :: initialize => initialize_cache procedure , public :: get => get_from_cache procedure , public :: put => put_in_cache procedure , public :: destroy => destroy_cache procedure , public :: print => print_cache end type function_cache","tags":"","loc":"type/function_cache~2.html"},{"title":"vertex – AoC-2023 ","text":"type, private :: vertex a vertex of a directed acyclic graph (DAG) Inherited by type~~vertex~~InheritedByGraph type~vertex vertex type~dag dag type~dag->type~vertex vertices Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, private, dimension(:), allocatable :: edges these are the vertices that this vertex depends on integer, private :: ivertex = 0 vertex number logical, private :: checking = .false. used for toposort logical, private :: marked = .false. used for toposort character(len=:), private, allocatable :: label used for diagraph character(len=:), private, allocatable :: attributes used for diagraph Type-Bound Procedures generic, public :: set_edges => set_edge_vector , add_edge private  subroutine set_edge_vector (me, edges) specify the edge indices for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in), dimension(:) :: edges private  subroutine add_edge (me, edge) add an edge index for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in) :: edge procedure, public :: set_edge_vector private  subroutine set_edge_vector (me, edges) specify the edge indices for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in), dimension(:) :: edges procedure, public :: add_edge private  subroutine add_edge (me, edge) add an edge index for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in) :: edge Source Code type :: vertex !! a vertex of a directed acyclic graph (DAG) private integer , dimension (:), allocatable :: edges !! these are the vertices that this vertex depends on integer :: ivertex = 0 !! vertex number logical :: checking = . false . !! used for toposort logical :: marked = . false . !! used for toposort character ( len = :), allocatable :: label !! used for diagraph character ( len = :), allocatable :: attributes !! used for diagraph contains generic :: set_edges => set_edge_vector , add_edge procedure :: set_edge_vector procedure :: add_edge end type vertex","tags":"","loc":"type/vertex.html"},{"title":"dag – AoC-2023 ","text":"type, public :: dag a directed acyclic graph (DAG) Inherits type~~dag~~InheritsGraph type~dag dag type~vertex vertex type~dag->type~vertex vertices Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, private :: n = 0 number of vertices type( vertex ), private, dimension(:), allocatable :: vertices the vertices in the DAG. Type-Bound Procedures procedure, public :: set_vertices => dag_set_vertices private  subroutine dag_set_vertices (me, nvertices) set the number of vertices in the dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: nvertices number of vertices procedure, public :: set_edges => dag_set_edges private  subroutine dag_set_edges (me, ivertex, edges) set the edges for a vertex in a dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: ivertex vertex number integer, intent(in), dimension(:) :: edges procedure, public :: set_vertex_info => dag_set_vertex_info private  subroutine dag_set_vertex_info (me, ivertex, label, attributes) set info about a vertex in a dag. Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: ivertex vertex number character(len=*), intent(in), optional :: label if a label is not set,\nthen the integer vertex\nnumber is used. character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. procedure, public :: toposort => dag_toposort private  subroutine dag_toposort (me, order, istat) Main toposort routine Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: order the toposort order integer, intent(out) :: istat Status flag: Read more… procedure, public :: generate_digraph => dag_generate_digraph private  function dag_generate_digraph (me, rankdir, dpi) result(str) Generate a Graphviz digraph structure for the DAG. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer, intent(in), optional :: dpi resolution (e.g. 300) Return Value character(len=:), allocatable procedure, public :: generate_dependency_matrix => dag_generate_dependency_matrix private  subroutine dag_generate_dependency_matrix (me, mat) Generate the dependency matrix for the DAG. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me logical, intent(out), dimension(:,:), allocatable :: mat dependency matrix procedure, public :: save_digraph => dag_save_digraph private  subroutine dag_save_digraph (me, filename, rankdir, dpi) Generate a Graphviz digraph structure for the DAG and write it to a file. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: filename file name for diagraph character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer, intent(in), optional :: dpi resolution (e.g. 300) procedure, public :: get_edges => dag_get_edges private pure function dag_get_edges (me, ivertex) result(edges) get the edges for the vertex (all the the vertices\nthat this vertex depends on). Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer, intent(in) :: ivertex Return Value integer, dimension(:), allocatable procedure, public :: get_dependencies => dag_get_dependencies private pure function dag_get_dependencies (me, ivertex) result(dep) get all the vertices that depend on this vertex. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer, intent(in) :: ivertex Return Value integer, dimension(:), allocatable the set of all vertices\nthan depend on ivertex procedure, public :: destroy => dag_destroy private  subroutine dag_destroy (me) Destroy the dag . Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me Source Code type , public :: dag !! a directed acyclic graph (DAG) private integer :: n = 0 !! number of `vertices` type ( vertex ), dimension (:), allocatable :: vertices !! the vertices in the DAG. contains procedure , public :: set_vertices => dag_set_vertices procedure , public :: set_edges => dag_set_edges procedure , public :: set_vertex_info => dag_set_vertex_info procedure , public :: toposort => dag_toposort procedure , public :: generate_digraph => dag_generate_digraph procedure , public :: generate_dependency_matrix => dag_generate_dependency_matrix procedure , public :: save_digraph => dag_save_digraph procedure , public :: get_edges => dag_get_edges procedure , public :: get_dependencies => dag_get_dependencies procedure , public :: destroy => dag_destroy end type dag","tags":"","loc":"type/dag.html"},{"title":"item – AoC-2023 ","text":"type :: item Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(NSTATE) :: state = 0 state: [i, j, direction, and # of moves] integer(kind=ip), public :: dist = huge(1) distance for this one logical, public :: visited = .false. if this one is done integer(kind=ip), public :: iprev = -1 index in the queue of the previous one Source Code type :: item integer ( ip ), dimension ( NSTATE ) :: state = 0 !! state: [i, j, direction, and # of moves] integer ( ip ) :: dist = huge ( 1 ) !! distance for this one logical :: visited = . false . !! if this one is done integer ( ip ) :: iprev = - 1 !! index in the queue of the previous one end type item","tags":"","loc":"type/item.html"},{"title":"node_t – AoC-2023 ","text":"type :: node_t Components Type Visibility Attributes Name Initial integer, public, dimension(:), allocatable :: connections the ones connected to this one Source Code type :: node_t !character(len=3) :: name = '' integer , dimension (:), allocatable :: connections !! the ones connected to this one end type node_t","tags":"","loc":"type/node_t.html"},{"title":"hand – AoC-2023 ","text":"type :: hand Components Type Visibility Attributes Name Initial character(len=1), public, dimension(5) :: cards the cards in a hand integer(kind=ip), public :: bid = 0 integer, public :: type = 0 Source Code type :: hand character ( len = 1 ), dimension ( 5 ) :: cards !! the cards in a hand integer ( ip ) :: bid = 0 ! the bit for the hand integer :: type = 0 ! the hand type end type hand","tags":"","loc":"type/hand.html"},{"title":"nlesolver_type – AoC-2023 ","text":"type, public :: nlesolver_type Nonlinear equations solver class. Components Type Visibility Attributes Name Initial integer, private :: n = 0 number of opt vars integer, private :: m = 0 number of constraints integer, private :: max_iter = 100 maximum number of iterations real(kind=wp), private :: tol = 1.0e-6_wp convergence tolerance for function values real(kind=wp), private :: alpha = 1.0_wp step length (when specified constant) real(kind=wp), private :: alpha_min = 0.1_wp minimum step length (when allowed to vary) real(kind=wp), private :: alpha_max = 1.0_wp maximum step length (when allowed to vary) real(kind=wp), private :: tolx = 1.0e-8_wp convergence tolerance for x real(kind=wp), private :: c = 0.5_wp backtracking linesearch parameter (0,1) real(kind=wp), private :: tau = 0.5_wp backtracking linesearch parameter (0,1) real(kind=wp), private :: fmin_tol = 1.0e-5_wp tolerance for \"exact\" linesearch integer, private :: n_intervals = 2 number of intervals for fixed point linesearch logical, private :: use_broyden = .false. if true, a Broyden update is used\nrather than computing the Jacobian\nat every step. The grad function is\nonly called for the initial evaluation. integer, private :: broyden_update_n = 4 if this value is >0 , the Broyden update\nis computed at most this many times before\nthe full Jacobian is recomputed. integer, private :: n_uphill_max = 5 maximum number of consecutive steps\nto allow where the value of f increases logical, private :: verbose = .false. verbose output printing integer, private :: iunit = output_unit output unit for printing (assumed to be open). character(len=:), private, allocatable :: message latest status message integer, private :: istat = -999 latest status message procedure( func_func ), private, pointer :: func => null() user-supplied routine to compute the function procedure( grad_func ), private, pointer :: grad => null() user-supplied routine tocompute the gradient of the function procedure( export_func ), private, pointer :: export_iteration => null() user-supplied routine to export iterations procedure( wait_func ), private, pointer :: user_input_check => null() user-supplied routine to enable user to stop iterations procedure( linesearch_func ), private, pointer :: linesearch => null() line search method (determined by step_mode user input in initialize ) Type-Bound Procedures procedure, public :: initialize => initialize_nlesolver_variables private  subroutine initialize_nlesolver_variables (me, n, m, max_iter, tol, alpha, alpha_min, alpha_max, tolx, fmin_tol, backtrack_c, backtrack_tau, use_broyden, broyden_update_n, step_mode, func, grad, export_iteration, user_input_check, verbose, iunit, n_uphill_max, n_intervals) Constructor for the class. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me integer, intent(in) :: n number of optimization variables integer, intent(in) :: m number of constraints integer, intent(in) :: max_iter maximum number of iterations real(kind=wp), intent(in) :: tol function convergence tolerance real(kind=wp), intent(in), optional :: alpha constant step length for step_mode=1 (0,1] real(kind=wp), intent(in), optional :: alpha_min minimum step length (0,1] real(kind=wp), intent(in), optional :: alpha_max maximum step length (0,1] real(kind=wp), intent(in), optional :: tolx convergence tolerance for changes in x real(kind=wp), intent(in), optional :: fmin_tol convergence tolerance for fmin (used when step_mode=3 ) real(kind=wp), intent(in), optional :: backtrack_c backtracking linesearch parameter (0,1) real(kind=wp), intent(in), optional :: backtrack_tau backtracking linesearch parameter (0,1) logical, intent(in), optional :: use_broyden use a Broyden update (default is False) integer, intent(in), optional :: broyden_update_n For Broyden mode, update the full Jacobian\nat most every this many iterations (must be >1)\nIf <=1 then Jacobian is only computed on the\nfirst iteration. integer, intent(in), optional :: step_mode step mode: Read more… procedure( func_func ) :: func computes the function vector procedure( grad_func ) :: grad computes the jacobian procedure( export_func ), optional :: export_iteration function to export each iteration procedure( wait_func ), optional :: user_input_check check for user input (to stop solver if necessary) logical, intent(in), optional :: verbose for verbose status printing integer, intent(in), optional :: iunit unit for verbose printing (assumed to be open).\nby default this is output_unit . integer, intent(in), optional :: n_uphill_max maximum number of consecutive steps\nto allow where the value of f increases integer, intent(in), optional :: n_intervals number of intervals for fixed point linesearch procedure, public :: solve => nlesolver_solver private  subroutine nlesolver_solver (me, x) Main solver. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x procedure, public :: destroy => destroy_nlesolver_variables private  subroutine destroy_nlesolver_variables (me) Destructor Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(out) :: me procedure, public :: status => get_status private  subroutine get_status (me, istat, message) Return the status code and message from the nlesolver_type class. Read more… Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me integer, intent(out), optional :: istat Integer status code. character(len=:), intent(out), optional, allocatable :: message Text status message procedure, private :: set_status private  subroutine set_status (me, istat, string, i, r) Set status flag and message. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me integer, intent(in) :: istat status code character(len=*), intent(in) :: string status message integer, intent(in), optional :: i an integer value to append real(kind=wp), intent(in), optional :: r a real value to append Source Code type , public :: nlesolver_type !! Nonlinear equations solver class. private integer :: n = 0 !! number of opt vars integer :: m = 0 !! number of constraints integer :: max_iter = 100 !! maximum number of iterations real ( wp ) :: tol = 1.0e-6_wp !! convergence tolerance for function values real ( wp ) :: alpha = 1.0_wp !! step length (when specified constant) real ( wp ) :: alpha_min = 0.1_wp !! minimum step length (when allowed to vary) real ( wp ) :: alpha_max = 1.0_wp !! maximum step length (when allowed to vary) real ( wp ) :: tolx = 1.0e-8_wp !! convergence tolerance for `x` real ( wp ) :: c = 0.5_wp !! backtracking linesearch parameter (0,1) real ( wp ) :: tau = 0.5_wp !! backtracking linesearch parameter (0,1) real ( wp ) :: fmin_tol = 1.0e-5_wp !! tolerance for \"exact\" linesearch integer :: n_intervals = 2 !! number of intervals for fixed point linesearch logical :: use_broyden = . false . !! if true, a Broyden update is used !! rather than computing the Jacobian !! at every step. The `grad` function is !! only called for the initial evaluation. integer :: broyden_update_n = 4 !! if this value is `>0`, the Broyden update !! is computed at most this many times before !! the full Jacobian is recomputed. integer :: n_uphill_max = 5 !! maximum number of consecutive steps !! to allow where the value of `f` increases logical :: verbose = . false . !! verbose output printing integer :: iunit = output_unit !! output unit for printing (assumed to be open). character ( len = :), allocatable :: message !! latest status message integer :: istat = - 999 !! latest status message procedure ( func_func ), pointer :: func => null () !! user-supplied routine to compute the function procedure ( grad_func ), pointer :: grad => null () !! user-supplied routine tocompute the gradient of the function procedure ( export_func ), pointer :: export_iteration => null () !! user-supplied routine to export iterations procedure ( wait_func ), pointer :: user_input_check => null () !! user-supplied routine to enable user to stop iterations procedure ( linesearch_func ), pointer :: linesearch => null () !! line search method (determined by `step_mode` user input in [[nlesolver_type:initialize]]) contains private procedure , public :: initialize => initialize_nlesolver_variables procedure , public :: solve => nlesolver_solver procedure , public :: destroy => destroy_nlesolver_variables procedure , public :: status => get_status procedure :: set_status end type nlesolver_type","tags":"","loc":"type/nlesolver_type.html"},{"title":"node – AoC-2023 ","text":"type :: node Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(:), allocatable :: inext the node connected to this one integer(kind=ip), public, dimension(:), allocatable :: idist distance to inext nodes Source Code type :: node integer ( ip ), dimension (:), allocatable :: inext !! the node connected to this one integer ( ip ), dimension (:), allocatable :: idist !! distance to inext nodes end type node","tags":"","loc":"type/node.html"},{"title":"clock – AoC-2023 ","text":"type, public :: clock Components Type Visibility Attributes Name Initial integer(kind=ip), private :: begin integer(kind=ip), private :: end integer(kind=ip), private :: rate Type-Bound Procedures procedure, public :: tic => clock_start private  subroutine clock_start (me) Start the clock Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me procedure, public :: toc => clock_end private  subroutine clock_end (me, case_str) Print runtime in milliseconds form the start of the clock. Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me character(len=*), intent(in) :: case_str description of the case Source Code type , public :: clock private integer ( ip ) :: begin , end , rate contains procedure , public :: tic => clock_start procedure , public :: toc => clock_end end type clock","tags":"","loc":"type/clock.html"},{"title":"string – AoC-2023 ","text":"type, public :: string a type containing an allocatable character string.\nso we can have an array of strings of different lengths. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: str Type-Bound Procedures procedure, public :: to_int => string_to_int convert to integer private pure elemental function string_to_int (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer procedure, public :: to_int_64 => string_to_int_64 private pure elemental function string_to_int_64 (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer(kind=ip) Source Code type , public :: string !! a type containing an allocatable character string. !! so we can have an array of strings of different lengths. character ( len = :), allocatable :: str contains procedure , public :: to_int => string_to_int !! convert to integer procedure , public :: to_int_64 => string_to_int_64 end type string","tags":"","loc":"type/string.html"},{"title":"int64_vec – AoC-2023 ","text":"type, public :: int64_vec an type that contains an allocatable ip array.\nso we can have an array of these. Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(:), allocatable :: vals Source Code type , public :: int64_vec !! an type that contains an allocatable ip array. !! so we can have an array of these. integer ( ip ), dimension (:), allocatable :: vals end type int64_vec","tags":"","loc":"type/int64_vec.html"},{"title":"item – AoC-2023 ","text":"type :: item Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(NSTATE) :: state = 0 state: [i, j, direction, and # of moves] integer(kind=ip), public :: dist = huge(1) distance for this one logical, public :: visited = .false. if this one is done integer(kind=ip), public :: iprev = -1 index in the queue of the previous one Source Code type :: item integer ( ip ), dimension ( NSTATE ) :: state = 0 !! state: [i, j, direction, and # of moves] integer ( ip ) :: dist = huge ( 1 ) !! distance for this one logical :: visited = . false . !! if this one is done integer ( ip ) :: iprev = - 1 !! index in the queue of the previous one end type item","tags":"","loc":"type/item~2.html"},{"title":"fx – AoC-2023 ","text":"type, private :: fx an [x,f(x)] cached pair.\nx is a vector and f is a vector. Inherited by type~~fx~~InheritedByGraph type~fx fx type~function_cache function_cache type~function_cache->type~fx c Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer(kind=ip), private, dimension(:), allocatable :: x vector of input values integer(kind=ip), private, dimension(:), allocatable :: f output functions Source Code type :: fx !! an [x,f(x)] cached pair. !! x is a vector and f is a vector. private integer ( ip ), dimension (:), allocatable :: x !! vector of input values integer ( ip ), dimension (:), allocatable :: f !! output functions end type fx","tags":"","loc":"type/fx.html"},{"title":"function_cache – AoC-2023 ","text":"type, public :: function_cache a vector function cache. Inherits type~~function_cache~~InheritsGraph type~function_cache function_cache type~fx fx type~function_cache->type~fx c Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( fx ), private, dimension(:), allocatable :: c the cache of f(x) integer, private :: chunk_size = 100 for resizing vectors\nin the unique function Type-Bound Procedures procedure, public :: initialize => initialize_cache private  subroutine initialize_cache (me, isize, chunk_size) Initialize the cache. Must be called first before use. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: isize the size of the hash table integer, intent(in), optional :: chunk_size chunk size to speed up reallocation\nof arrays. A good value is a guess for\nthe actual number of elements of f that\nwill be saved per value of x [default is 100] procedure, public :: get => get_from_cache private  subroutine get_from_cache (me, x, i, f, found) Check if the x vector is in the cache, if so return f .\nNote that only some of the elements may be present, so it will return\nthe ones there are there, and indicate which ones were found. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer(kind=ip), intent(in), dimension(:) :: x independant variable vector integer(kind=ip), intent(out) :: i index in the hash table integer(kind=ip), intent(out), dimension(:), allocatable :: f f(x) from the cache (if it was found) logical, intent(out) :: found if x was found in the cache procedure, public :: put => put_in_cache private  subroutine put_in_cache (me, i, x, f) Put a value into the cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer(kind=ip), intent(in) :: i index in the hash table integer(kind=ip), intent(in), dimension(:) :: x independant variable vector integer(kind=ip), intent(in), dimension(:) :: f function procedure, public :: destroy => destroy_cache private  subroutine destroy_cache (me) Destroy a cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(out) :: me Source Code type , public :: function_cache !! a vector function cache. private type ( fx ), dimension (:), allocatable :: c !! the cache of `f(x)` integer :: chunk_size = 100 !! for resizing vectors !! in the [[unique]] function contains private procedure , public :: initialize => initialize_cache procedure , public :: get => get_from_cache procedure , public :: put => put_in_cache procedure , public :: destroy => destroy_cache end type function_cache","tags":"","loc":"type/function_cache.html"},{"title":"part – AoC-2023 ","text":"type :: part Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(4) :: xmas Source Code type :: part integer ( ip ), dimension ( 4 ) :: xmas ! [x,m,a,s] end type part","tags":"","loc":"type/part.html"},{"title":"rule – AoC-2023 ","text":"type :: rule Inherited by type~~rule~~InheritedByGraph type~rule rule type~workflow workflow type~workflow->type~rule rules Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, public :: accept = .false. logical, public :: reject = .false. integer, public :: operator = 0 integer, public :: operator_arg = 0 integer, public :: operator_val = 0 character(len=:), public, allocatable :: goto Source Code type :: rule logical :: accept = . false . logical :: reject = . false . integer :: operator = 0 ! 1:<, 2:> integer :: operator_arg = 0 ! 1:x, 2:m, 3:a, 4:s integer :: operator_val = 0 ! value to compare to character ( len = :), allocatable :: goto ! where to next (workflow name) end type rule","tags":"","loc":"type/rule.html"},{"title":"workflow – AoC-2023 ","text":"type :: workflow Inherits type~~workflow~~InheritsGraph type~workflow workflow type~rule rule type~workflow->type~rule rules Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name type( rule ), public, dimension(:), allocatable :: rules Source Code type :: workflow character ( len = :), allocatable :: name type ( rule ), dimension (:), allocatable :: rules end type workflow","tags":"","loc":"type/workflow.html"},{"title":"interval – AoC-2023 ","text":"type :: interval Inherited by type~~interval~~InheritedByGraph type~interval interval type~part~2 part type~part~2->type~interval xmas Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(2) :: v [start, end] of the interval Source Code type :: interval integer ( ip ), dimension ( 2 ) :: v !! [start, end] of the interval end type interval","tags":"","loc":"type/interval.html"},{"title":"part – AoC-2023 ","text":"type :: part Inherits type~~part~2~~InheritsGraph type~part~2 part type~interval interval type~part~2->type~interval xmas Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( interval ), public, dimension(4) :: xmas Source Code type :: part type ( interval ), dimension ( 4 ) :: xmas ! [x,m,a,s] ranges end type part","tags":"","loc":"type/part~2.html"},{"title":"rule – AoC-2023 ","text":"type :: rule Inherited by type~~rule~2~~InheritedByGraph type~rule~2 rule type~workflow~2 workflow type~workflow~2->type~rule~2 rules Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, public :: accept = .false. logical, public :: reject = .false. integer, public :: operator = 0 integer, public :: operator_arg = 0 integer, public :: operator_val = 0 character(len=:), public, allocatable :: goto Source Code type :: rule logical :: accept = . false . logical :: reject = . false . integer :: operator = 0 ! 1:<, 2:> integer :: operator_arg = 0 ! 1:x, 2:m, 3:a, 4:s integer :: operator_val = 0 ! value to compare to character ( len = :), allocatable :: goto ! where to next (workflow name) end type rule","tags":"","loc":"type/rule~2.html"},{"title":"workflow – AoC-2023 ","text":"type :: workflow Inherits type~~workflow~2~~InheritsGraph type~workflow~2 workflow type~rule~2 rule type~workflow~2->type~rule~2 rules Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name type( rule ), public, dimension(:), allocatable :: rules Source Code type :: workflow character ( len = :), allocatable :: name type ( rule ), dimension (:), allocatable :: rules end type workflow","tags":"","loc":"type/workflow~2.html"},{"title":"func – AoC-2023","text":"interface private  subroutine func(me, x, f, funcs_to_compute) Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x array of variables (size n ) real(kind=wp), intent(out), dimension(:) :: f array of functions (size m ) integer, intent(in), dimension(:) :: funcs_to_compute the elements of the\nfunction vector that need\nto be computed (the other\nare ignored) Description The function (vector array of output functions f , computed\nfrom a vector of input variables x ).\nThis must be defined for all computations.","tags":"","loc":"interface/func.html"},{"title":"spars_f – AoC-2023","text":"interface private  subroutine spars_f(me, x) Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) Description The function to compute the sparsity pattern.\nIt populates the irow and icol variables in the class.","tags":"","loc":"interface/spars_f.html"},{"title":"info_f – AoC-2023","text":"interface private  subroutine info_f(me, column, i, x) Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in), dimension(:) :: column the columns being computed. integer, intent(in) :: i perturbing these columns for the i th time (1,2,...) real(kind=wp), intent(in), dimension(:) :: x the nominal variable vector Description User-defined info function (optional).\nInforms user what is being done during Jacobian computation.\nIt can be used to perform any setup operations that need to\ndone on the user's end.","tags":"","loc":"interface/info_f.html"},{"title":"jacobian_f – AoC-2023","text":"interface private  subroutine jacobian_f(me, x, dx, jac) Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0) for each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector (size num_nonzero_elements ) Description Actual function for computing the Jacobian\ncalled by compute_jacobian .","tags":"","loc":"interface/jacobian_f.html"},{"title":"func – AoC-2023","text":"interface private  function func(me, x) result(fx) Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me real(kind=wp), intent(in) :: x Return Value real(kind=wp) Description interface to function for diff","tags":"","loc":"interface/func~2.html"},{"title":"func – AoC-2023","text":"interface private  function func(x) result(f) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x indep. variable Return Value real(kind=wp) function value f(x) Description interface for user function","tags":"","loc":"interface/func~3.html"},{"title":"func_func – AoC-2023","text":"interface private  subroutine func_func(me, x, f) Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: f Description compute the function","tags":"","loc":"interface/func_func.html"},{"title":"grad_func – AoC-2023","text":"interface private  subroutine grad_func(me, x, g) Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:,:) :: g Description compute the gradient of the function (Jacobian):","tags":"","loc":"interface/grad_func.html"},{"title":"export_func – AoC-2023","text":"interface private  subroutine export_func(me, x, f, iter) Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: f integer, intent(in) :: iter iteration number Description export an iteration:","tags":"","loc":"interface/export_func.html"},{"title":"wait_func – AoC-2023","text":"interface private  subroutine wait_func(me, user_stop) Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me logical, intent(out) :: user_stop Description enable a user-triggered stop of the iterations:","tags":"","loc":"interface/wait_func.html"},{"title":"linesearch_func – AoC-2023","text":"interface private  subroutine linesearch_func(me, xold, p, fjac, x, f, fvec) Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: xold previous value of x real(kind=wp), intent(in), dimension(me%n) :: p search direction real(kind=wp), intent(in), dimension(me%m,me%n) :: fjac jacobian matrix real(kind=wp), intent(out), dimension(me%n) :: x new x real(kind=wp), intent(inout) :: f real(kind=wp), intent(inout), dimension(me%m) :: fvec Description line search method. Note that not all inputs/outputs are\nused by all methods.","tags":"","loc":"interface/linesearch_func.html"},{"title":"pipe_info – AoC-2023","text":"pure function pipe_info(p) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: p Return Value character(len=2) Called by proc~~pipe_info~~CalledByGraph proc~pipe_info problem_10::pipe_info proc~move problem_10::move proc~move->proc~pipe_info proc~move->proc~move program~problem_10 problem_10 program~problem_10->proc~move Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/pipe_info.html"},{"title":"move – AoC-2023","text":"recursive subroutine move(i, j, direction, distance, save_path) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: direction integer, intent(inout), dimension(:,:) :: distance logical, intent(in) :: save_path to save the path coordinates Calls proc~~move~~CallsGraph proc~move problem_10::move proc~move->proc~move proc~pipe_info problem_10::pipe_info proc~move->proc~pipe_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~move~~CalledByGraph proc~move problem_10::move proc~move->proc~move program~problem_10 problem_10 program~problem_10->proc~move Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine move ( i , j , direction , distance , save_path ) integer , intent ( in ) :: i , j , direction integer , dimension (:,:), intent ( inout ) :: distance logical , intent ( in ) :: save_path !! to save the path coordinates integer :: inew , jnew , imove logical :: valid_move select case ( direction ) case ( 1 ); inew = i - 1 ; jnew = j ! north case ( 2 ); inew = i + 1 ; jnew = j ! south case ( 3 ); inew = i ; jnew = j + 1 ! east case ( 4 ); inew = i ; jnew = j - 1 ! west end select if ( visited ( inew , jnew ) . or . array ( inew , jnew ) == '.' ) return ! can we move in this direction? valid_move = . false . associate ( current_pipe => array ( i , j ), & current_distance => distance ( i , j ), & move_to => array ( inew , jnew ) ) select case ( current_pipe ) case ( 'S' ) ! don't know what the first pip is, so have to try them all select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '|' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south end select case ( '-' ) select case ( direction ) case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'L' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select case ( 'J' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '7' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'F' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select end select if ( valid_move ) then distance ( inew , jnew ) = current_distance + 1 visited ( inew , jnew ) = . true . do imove = 1 , 4 call move ( inew , jnew , imove , distance , save_path ) end do if ( save_path ) then x = [ x , real ( inew , wp )] ! save cordinates of point on the path y = [ y , real ( jnew , wp )] end if end if end associate end subroutine move","tags":"","loc":"proc/move.html"},{"title":"initialize_finite_difference_method – AoC-2023","text":"private  function initialize_finite_difference_method(id, name, class, dx_factors, df_factors, df_den_factor) result(me) Constructor for a finite_diff_method . Note factors are input as integers for convenience, but are converted\n      to reals for the actual computations. (note: this means we can't\n      currently define methods that have non-integer factors). Arguments Type Intent Optional Attributes Name integer, intent(in) :: id unique ID for the method character(len=*), intent(in) :: name the name of the method integer, intent(in) :: class 2=backward diffs, 3=central diffs, etc... integer, intent(in), dimension(:) :: dx_factors multiplicative factors for dx perturbation integer, intent(in), dimension(:) :: df_factors multiplicative factors for accumulating function evaluations integer, intent(in) :: df_den_factor denominator factor for finite difference equation (times dx) Return Value type( finite_diff_method ) Called by proc~~initialize_finite_difference_method~~CalledByGraph proc~initialize_finite_difference_method numerical_differentiation_module::initialize_finite_difference_method interface~finite_diff_method numerical_differentiation_module::finite_diff_method interface~finite_diff_method->proc~initialize_finite_difference_method Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function initialize_finite_difference_method ( id , name , class , dx_factors ,& df_factors , df_den_factor ) result ( me ) implicit none type ( finite_diff_method ) :: me integer , intent ( in ) :: id !! unique ID for the method character ( len =* ), intent ( in ) :: name !! the name of the method integer , intent ( in ) :: class !! 2=backward diffs, 3=central diffs, etc... integer , dimension (:), intent ( in ) :: dx_factors !! multiplicative factors for dx perturbation integer , dimension (:), intent ( in ) :: df_factors !! multiplicative factors for accumulating function evaluations integer , intent ( in ) :: df_den_factor !! denominator factor for finite difference equation (times dx) if ( size ( dx_factors ) /= size ( df_factors )) then error stop 'Error in initialize_finite_difference_method: ' // & 'dx_factors and df_factors arrays must be the same size.' else me % id = id me % name = trim ( name ) me % class = class ! the following is not strictly necessary if the ! compiler fully supports auto-LHS allocation: allocate ( me % dx_factors ( size ( dx_factors ))) allocate ( me % df_factors ( size ( df_factors ))) me % dx_factors = real ( dx_factors , wp ) me % df_factors = real ( df_factors , wp ) me % df_den_factor = real ( df_den_factor , wp ) end if end function initialize_finite_difference_method","tags":"","loc":"proc/initialize_finite_difference_method.html"},{"title":"get_all_methods_in_class – AoC-2023","text":"public  function get_all_methods_in_class(class) result(list_of_methods) Returns all the methods with the given class (i.e., number of points in the formula). Arguments Type Intent Optional Attributes Name integer, intent(in) :: class the class is the number of points in the\nfinite different computation Return Value type( meth_array ) all the methods with the specified class Calls proc~~get_all_methods_in_class~~CallsGraph proc~get_all_methods_in_class numerical_differentiation_module::get_all_methods_in_class proc~get_finite_difference_method numerical_differentiation_module::get_finite_difference_method proc~get_all_methods_in_class->proc~get_finite_difference_method Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_all_methods_in_class~~CalledByGraph proc~get_all_methods_in_class numerical_differentiation_module::get_all_methods_in_class proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~get_all_methods_in_class proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~get_all_methods_in_class program~test1 test1 program~test1->proc~get_all_methods_in_class program~test1->proc~initialize_numdiff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function get_all_methods_in_class ( class ) result ( list_of_methods ) implicit none integer , intent ( in ) :: class !! the `class` is the number of points in the !! finite different computation type ( meth_array ) :: list_of_methods !! all the methods with the specified `class` type ( finite_diff_method ) :: fd !! temp variable for getting a !! method from [[get_finite_difference_method]] integer :: id !! method id counter logical :: found !! status flag integer :: n !! temp size variable type ( finite_diff_method ), dimension (:), allocatable :: tmp !! for resizing `meth` array ! currently, the only way to do this is to call the ! get_finite_difference_method routine and see if there ! is one available. id = 0 do id = id + 1 call get_finite_difference_method ( id , fd , found ) if ( found ) then if ( fd % class == class ) then if ( allocated ( list_of_methods % meth )) then ! add to the list n = size ( list_of_methods % meth ) allocate ( tmp ( n + 1 )) tmp ( 1 : n ) = list_of_methods % meth tmp ( n + 1 ) = fd call move_alloc ( tmp , list_of_methods % meth ) ! ... this doesn't appear to work on Intel compiler ... !list_of_methods%meth = [list_of_methods%meth,fd]  ! add to the list else ! first element: allocate ( list_of_methods % meth ( 1 )) list_of_methods % meth = fd end if elseif ( fd % class > class ) then ! we assume they are in increasing order exit end if else exit ! done end if end do end function get_all_methods_in_class","tags":"","loc":"proc/get_all_methods_in_class.html"},{"title":"failed – AoC-2023","text":"private pure function failed(me) Returns True if an exception has been raised. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(in) :: me Return Value logical Called by proc~~failed~~CalledByGraph proc~failed numerical_differentiation_module::numdiff_type%failed program~test1 test1 program~test1->proc~failed program~test2 test2 program~test2->proc~failed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function failed ( me ) implicit none class ( numdiff_type ), intent ( in ) :: me failed = me % exception_raised end function failed","tags":"","loc":"proc/failed.html"},{"title":"integer_to_string – AoC-2023","text":"private  function integer_to_string(i, with_sign) result(str) Convert an integer to a string. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i the integer logical, intent(in), optional :: with_sign also include the sign (default is False) Return Value character(len=:), allocatable integer converted to a string Called by proc~~integer_to_string~~CalledByGraph proc~integer_to_string numerical_differentiation_module::integer_to_string proc~get_formula numerical_differentiation_module::finite_diff_method%get_formula proc~get_formula->proc~integer_to_string proc~set_numdiff_bounds numerical_differentiation_module::numdiff_type%set_numdiff_bounds proc~set_numdiff_bounds->proc~integer_to_string proc~get_finite_diff_formula numerical_differentiation_module::get_finite_diff_formula proc~get_finite_diff_formula->proc~get_formula proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~set_numdiff_bounds proc~initialize_numdiff_for_diff numerical_differentiation_module::numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~set_numdiff_bounds program~test1 test1 program~test1->proc~get_formula program~test1->proc~get_finite_diff_formula program~test1->proc~initialize_numdiff program~test1->proc~initialize_numdiff_for_diff program~test2 test2 program~test2->proc~get_finite_diff_formula Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function integer_to_string ( i , with_sign ) result ( str ) implicit none integer , intent ( in ) :: i !! the integer logical , intent ( in ), optional :: with_sign !! also include the sign (default is False) character ( len = :), allocatable :: str !! integer converted to a string integer :: istat !! `iostat` code for write statement character ( len = 100 ) :: tmp !! logical :: sgn !! local copy of `with_sign` if ( present ( with_sign )) then sgn = with_sign else sgn = . false . end if if ( sgn ) then write ( tmp , '(SP,I100)' , iostat = istat ) i else write ( tmp , '(I100)' , iostat = istat ) i end if if ( istat == 0 ) then str = trim ( adjustl ( tmp )) else str = '****' end if end function integer_to_string","tags":"","loc":"proc/integer_to_string.html"},{"title":"print_finite_difference_method – AoC-2023","text":"private  subroutine print_finite_difference_method(me, iunit) Print the contents of a finite_diff_method . Used for debugging. Type Bound finite_diff_method Arguments Type Intent Optional Attributes Name class( finite_diff_method ), intent(in) :: me integer, intent(in) :: iunit file unit for printing\n(assumed to be opened) Source Code subroutine print_finite_difference_method ( me , iunit ) implicit none class ( finite_diff_method ), intent ( in ) :: me integer , intent ( in ) :: iunit !! file unit for printing !! (assumed to be opened) write ( iunit , '(A,1X,I5)' ) 'id            :' , me % id write ( iunit , '(A,1X,A)' ) 'name          :' , me % name write ( iunit , '(A,1X,I5)' ) 'class         :' , me % class write ( iunit , '(A,1X,*(I5,\",\"))' ) 'dx_factors    :' , int ( me % dx_factors ) write ( iunit , '(A,1X,*(I5,\",\"))' ) 'df_factors    :' , int ( me % df_factors ) write ( iunit , '(A,1X,I5)' ) 'df_den_factor :' , int ( me % df_den_factor ) end subroutine print_finite_difference_method","tags":"","loc":"proc/print_finite_difference_method.html"},{"title":"compute_function_with_cache – AoC-2023","text":"private  subroutine compute_function_with_cache(me, x, f, funcs_to_compute) Wrapper for computing the function, using the cache. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x array of variables (size n ) real(kind=wp), intent(out), dimension(:) :: f array of functions (size m ) integer, intent(in), dimension(:) :: funcs_to_compute the elements of the\nfunction vector that need\nto be computed (the other\nare ignored) Calls proc~~compute_function_with_cache~~CallsGraph proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~get_from_cache numdiff_cache_module::function_cache%get_from_cache proc~compute_function_with_cache->proc~get_from_cache proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~compute_function_with_cache->proc~put_in_cache proc~vector_djb_hash numdiff_cache_module::vector_djb_hash proc~get_from_cache->proc~vector_djb_hash interface~unique numdiff_utilities_module::unique proc~put_in_cache->interface~unique proc~unique_int numdiff_utilities_module::unique_int interface~unique->proc~unique_int proc~unique_real numdiff_utilities_module::unique_real interface~unique->proc~unique_real interface~expand_vector numdiff_utilities_module::expand_vector proc~unique_int->interface~expand_vector interface~sort_ascending numdiff_utilities_module::sort_ascending proc~unique_int->interface~sort_ascending proc~unique_real->interface~expand_vector proc~unique_real->interface~sort_ascending proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector->proc~expand_vector_real proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap numdiff_utilities_module::swap proc~sort_ascending_int->interface~swap proc~sort_ascending_real->interface~swap proc~swap_int numdiff_utilities_module::swap_int interface~swap->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_function_with_cache ( me , x , f , funcs_to_compute ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! array of variables (size `n`) real ( wp ), dimension (:), intent ( out ) :: f !! array of functions (size `m`) integer , dimension (:), intent ( in ) :: funcs_to_compute !! the elements of the !! function vector that need !! to be computed (the other !! are ignored) integer :: i !! index in the cache logical , dimension ( size ( funcs_to_compute )) :: ffound !! functions found in the cache logical :: xfound !! if `x` was found in the cache if ( me % exception_raised ) return ! check for exceptions call me % cache % get ( x , funcs_to_compute , i , f , xfound , ffound ) if ( xfound . and . any ( ffound )) then ! at least one of the functions was found if ( all ( ffound )) return ! all were found ! compute the ones that weren't found, ! and add them to the cache: call me % problem_func ( x , f , pack ( funcs_to_compute , mask = (. not . ffound ))) call me % cache % put ( i , x , f , pack ( funcs_to_compute , mask = (. not . ffound ))) else ! compute the function and add it to the cache: call me % problem_func ( x , f , funcs_to_compute ) call me % cache % put ( i , x , f , funcs_to_compute ) end if end subroutine compute_function_with_cache","tags":"","loc":"proc/compute_function_with_cache.html"},{"title":"get_formula – AoC-2023","text":"private  subroutine get_formula(me, formula) Return a string with the finite difference formula. Example For 3-point backward: dfdx = (f(x-2h)-4f(x-h)+3f(x)) / (2h) Type Bound finite_diff_method Arguments Type Intent Optional Attributes Name class( finite_diff_method ), intent(in) :: me character(len=:), intent(out), allocatable :: formula Calls proc~~get_formula~~CallsGraph proc~get_formula numerical_differentiation_module::finite_diff_method%get_formula proc~integer_to_string numerical_differentiation_module::integer_to_string proc~get_formula->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_formula~~CalledByGraph proc~get_formula numerical_differentiation_module::finite_diff_method%get_formula proc~get_finite_diff_formula numerical_differentiation_module::get_finite_diff_formula proc~get_finite_diff_formula->proc~get_formula program~test1 test1 program~test1->proc~get_formula program~test1->proc~get_finite_diff_formula program~test2 test2 program~test2->proc~get_finite_diff_formula Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_formula ( me , formula ) class ( finite_diff_method ), intent ( in ) :: me character ( len = :), allocatable , intent ( out ) :: formula integer :: i !! counter character ( len = :), allocatable :: x !! temp variable for integer to string conversion character ( len = :), allocatable :: f !! temp variable for integer to string conversion if ( allocated ( me % dx_factors ) . and . allocated ( me % df_factors )) then formula = 'dfdx = (' do i = 1 , size ( me % dx_factors ) if ( int ( me % df_factors ( i )) == 1 ) then if ( i == 1 ) then formula = formula // 'f(' else formula = formula // '+f(' end if elseif ( int ( me % df_factors ( i )) ==- 1 ) then formula = formula // '-f(' else if ( i == 1 ) then f = integer_to_string ( int ( me % df_factors ( i ))) else f = integer_to_string ( int ( me % df_factors ( i )), with_sign = . true .) end if formula = formula // trim ( adjustl ( f )) // 'f(' end if if ( int ( me % dx_factors ( i )) == 0 ) then formula = formula // 'x' elseif ( int ( me % dx_factors ( i )) == 1 ) then formula = formula // 'x+h' elseif ( int ( me % dx_factors ( i )) ==- 1 ) then formula = formula // 'x-h' else x = integer_to_string ( int ( me % dx_factors ( i )), with_sign = . true .) formula = formula // 'x' // trim ( adjustl ( x )) // 'h' end if formula = formula // ')' end do f = integer_to_string ( int ( me % df_den_factor )) if ( int ( me % df_den_factor ) == 1 ) then formula = formula // ') / h' else formula = formula // ') / (' // trim ( adjustl ( f )) // 'h)' end if else formula = '' end if end subroutine get_formula","tags":"","loc":"proc/get_formula.html"},{"title":"get_finite_diff_formula – AoC-2023","text":"public  subroutine get_finite_diff_formula(id, formula, name) Return a string with the finite difference formula.\n  Input is the method id code. See also: get_formula Arguments Type Intent Optional Attributes Name integer, intent(in) :: id the id code for the method character(len=:), intent(out), allocatable :: formula the formula string character(len=:), intent(out), optional, allocatable :: name Calls proc~~get_finite_diff_formula~~CallsGraph proc~get_finite_diff_formula numerical_differentiation_module::get_finite_diff_formula proc~get_finite_difference_method numerical_differentiation_module::get_finite_difference_method proc~get_finite_diff_formula->proc~get_finite_difference_method proc~get_formula numerical_differentiation_module::finite_diff_method%get_formula proc~get_finite_diff_formula->proc~get_formula proc~integer_to_string numerical_differentiation_module::integer_to_string proc~get_formula->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_finite_diff_formula~~CalledByGraph proc~get_finite_diff_formula numerical_differentiation_module::get_finite_diff_formula program~test1 test1 program~test1->proc~get_finite_diff_formula program~test2 test2 program~test2->proc~get_finite_diff_formula Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_finite_diff_formula ( id , formula , name ) implicit none integer , intent ( in ) :: id !! the id code for the method character ( len = :), allocatable , intent ( out ) :: formula !! the formula string character ( len = :), allocatable , intent ( out ), optional :: name type ( finite_diff_method ) :: fd logical :: found call get_finite_difference_method ( id , fd , found ) if ( found . and . fd % id /= 0 ) then call get_formula ( fd , formula ) if ( present ( name )) name = fd % name else formula = '' if ( present ( name )) name = '' end if end subroutine get_finite_diff_formula","tags":"","loc":"proc/get_finite_diff_formula.html"},{"title":"get_finite_difference_method – AoC-2023","text":"private  subroutine get_finite_difference_method(id, fd, found) Return a finite_diff_method given the id code.\n  (the id codes begin at 1, are sequential, and uniquely define the method). Available methods Where is the user-defined function of and is a \"small\" perturbation. References G. E. Mullges, F. Uhlig, \"Numerical Algorithms with Fortran\", Springer, 1996. G. W. Griffiths, \"Numerical Analysis Using R\", Cambridge University Press, 2016. Note This is the only routine that has to be changed if a new\n      finite difference method is added. Note The order within a class is assumed to be the order that we would prefer\n      to use them (e.g., central diffs are first, etc.) This is used in\n      the select_finite_diff_method routine. Arguments Type Intent Optional Attributes Name integer, intent(in) :: id the id code for the method type( finite_diff_method ), intent(out) :: fd this method (can be used\nin compute_jacobian ) logical, intent(out) :: found true if it was found Called by proc~~get_finite_difference_method~~CalledByGraph proc~get_finite_difference_method numerical_differentiation_module::get_finite_difference_method proc~get_all_methods_in_class numerical_differentiation_module::get_all_methods_in_class proc~get_all_methods_in_class->proc~get_finite_difference_method proc~get_finite_diff_formula numerical_differentiation_module::get_finite_diff_formula proc~get_finite_diff_formula->proc~get_finite_difference_method proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~get_finite_difference_method proc~initialize_numdiff->proc~get_all_methods_in_class proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~get_all_methods_in_class program~test1 test1 program~test1->proc~get_all_methods_in_class program~test1->proc~get_finite_diff_formula program~test1->proc~initialize_numdiff program~test2 test2 program~test2->proc~get_finite_diff_formula Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_finite_difference_method ( id , fd , found ) implicit none integer , intent ( in ) :: id !! the id code for the method type ( finite_diff_method ), intent ( out ) :: fd !! this method (can be used !! in [[compute_jacobian]]) logical , intent ( out ) :: found !! true if it was found found = . true . select case ( id ) ! 2 point methods case ( 1 ) ! (f(x+h)-f(x)) / h fd = finite_diff_method ( id , '2-point forward 1' , 2 ,[ 1 , 0 ],[ 1 , - 1 ], 1 ) case ( 2 ) ! (f(x)-f(x-h)) / h fd = finite_diff_method ( id , '2-point backward 1' , 2 ,[ 0 , - 1 ],[ 1 , - 1 ], 1 ) ! 3 point methods case ( 3 ) ! (f(x+h)-f(x-h)) / (2h) fd = finite_diff_method ( id , '3-point central' , 3 ,[ 1 , - 1 ],[ 1 , - 1 ], 2 ) case ( 4 ) ! (-3f(x)+4f(x+h)-f(x+2h)) / (2h) fd = finite_diff_method ( id , '3-point forward 2' , 3 ,[ 0 , 1 , 2 ],[ - 3 , 4 , - 1 ], 2 ) case ( 5 ) ! (f(x-2h)-4f(x-h)+3f(x)) / (2h) fd = finite_diff_method ( id , '3-point backward 2' , 3 ,[ - 2 , - 1 , 0 ],[ 1 , - 4 , 3 ], 2 ) ! 4 point methods case ( 6 ) ! (-2f(x-h)-3f(x)+6f(x+h)-f(x+2h)) / (6h) fd = finite_diff_method ( id , '4-point forward 2' , 4 ,[ - 1 , 0 , 1 , 2 ],[ - 2 , - 3 , 6 , - 1 ], 6 ) case ( 7 ) ! (f(x-2h)-6f(x-h)+3f(x)+2f(x+h)) / (6h) fd = finite_diff_method ( id , '4-point backward 2' , 4 ,[ - 2 , - 1 , 0 , 1 ],[ 1 , - 6 , 3 , 2 ], 6 ) case ( 8 ) ! (-11f(x)+18f(x+h)-9f(x+2h)+2f(x+3h)) / (6h) fd = finite_diff_method ( id , '4-point forward 3' , 4 ,[ 0 , 1 , 2 , 3 ],[ - 11 , 18 , - 9 , 2 ], 6 ) case ( 9 ) ! (-2f(x-3h)+9f(x-2h)-18f(x-h)+11f(x)) / (6h) fd = finite_diff_method ( id , '4-point backward 3' , 4 ,[ - 3 , - 2 , - 1 , 0 ],[ - 2 , 9 , - 18 , 11 ], 6 ) ! 5 point methods case ( 10 ) ! (f(x-2h)-8f(x-h)+8f(x+h)-f(x+2h)) / (12h) fd = finite_diff_method ( id , '5-point central' , 5 ,[ - 2 , - 1 , 1 , 2 ],[ 1 , - 8 , 8 , - 1 ], 12 ) case ( 11 ) ! (-3f(x-h)-10f(x)+18f(x+h)-6f(x+2h)+f(x+3h)) / (12h) fd = finite_diff_method ( id , '5-point forward 3' , 5 ,[ - 1 , 0 , 1 , 2 , 3 ],[ - 3 , - 10 , 18 , - 6 , 1 ], 12 ) case ( 12 ) ! (-f(x-3h)+6f(x-2h)-18f(x-h)+10f(x)+3f(x+h)) / (12h) fd = finite_diff_method ( id , '5-point backward 3' , 5 ,[ - 3 , - 2 , - 1 , 0 , 1 ],[ - 1 , 6 , - 18 , 10 , 3 ], 12 ) case ( 13 ) ! (-25f(x)+48f(x+h)-36f(x+2h)+16f(x+3h)-3f(x+4h)) / (12h) fd = finite_diff_method ( id , '5-point forward 4' , 5 ,[ 0 , 1 , 2 , 3 , 4 ],[ - 25 , 48 , - 36 , 16 , - 3 ], 12 ) case ( 14 ) ! (3f(x-4h)-16f(x-3h)+36f(x-2h)-48f(x-h)+25f(x)) / (12h) fd = finite_diff_method ( id , '5-point backward 4' , 5 ,[ - 4 , - 3 , - 2 , - 1 , 0 ],[ 3 , - 16 , 36 , - 48 , 25 ], 12 ) ! 6 point methods case ( 15 ) ! (3f(x-2h)-30f(x-h)-20f(x)+60f(x+h)-15f(x+2h)+2f(x+3h)) / (60h) fd = finite_diff_method ( id , '6-point forward 3' , 6 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 ],[ 3 , - 30 , - 20 , 60 , - 15 , 2 ], 60 ) case ( 16 ) ! (-2f(x-3h)+15f(x-2h)-60f(x-h)+20f(x)+30f(x+h)-3f(x+2h)) / (60h) fd = finite_diff_method ( id , '6-point backward 3' , 6 ,[ - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ - 2 , 15 , - 60 , 20 , 30 , - 3 ], 60 ) case ( 17 ) ! (-12f(x-h)-65f(x)+120f(x+h)-60f(x+2h)+20f(x+3h)-3f(x+4h)) / (60h) fd = finite_diff_method ( id , '6-point forward 4' , 6 ,[ - 1 , 0 , 1 , 2 , 3 , 4 ],[ - 12 , - 65 , 120 , - 60 , 20 , - 3 ], 60 ) case ( 18 ) ! (3f(x-4h)-20f(x-3h)+60f(x-2h)-120f(x-h)+65f(x)+12f(x+h)) / (60h) fd = finite_diff_method ( id , '6-point backward 4' , 6 ,[ - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ 3 , - 20 , 60 , - 120 , 65 , 12 ], 60 ) case ( 19 ) ! (-137f(x)+300f(x+h)-300f(x+2h)+200f(x+3h)-75f(x+4h)+12f(x+5h)) / (60h) fd = finite_diff_method ( id , '6-point forward 5' , 6 ,[ 0 , 1 , 2 , 3 , 4 , 5 ],[ - 137 , 300 , - 300 , 200 , - 75 , 12 ], 60 ) case ( 20 ) ! (-12f(x-5h)+75f(x-4h)-200f(x-3h)+300f(x-2h)-300f(x-h)+137f(x)) / (60h) fd = finite_diff_method ( id , '6-point backward 5' , 6 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ - 12 , 75 , - 200 , 300 , - 300 , 137 ], 60 ) ! 7 point methods case ( 21 ) ! (-f(x-3h)+9f(x-2h)-45f(x-h)+45f(x+h)-9f(x+2h)+f(x+3h)) / (60h) fd = finite_diff_method ( id , '7-point central' , 7 ,[ - 3 , - 2 , - 1 , 1 , 2 , 3 ],[ - 1 , 9 , - 45 , 45 , - 9 , 1 ], 60 ) case ( 22 ) ! (2f(x-2h)-24f(x-h)-35f(x)+80f(x+h)-30f(x+2h)+8f(x+3h)-f(x+4h)) / (60h) fd = finite_diff_method ( id , '7-point forward 4' , 7 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 , 4 ],[ 2 , - 24 , - 35 , 80 , - 30 , 8 , - 1 ], 60 ) case ( 23 ) ! (f(x-4h)-8f(x-3h)+30f(x-2h)-80f(x-h)+35f(x)+24f(x+h)-2f(x+2h)) / (60h) fd = finite_diff_method ( id , '7-point backward 4' , 7 ,[ - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ 1 , - 8 , 30 , - 80 , 35 , 24 , - 2 ], 60 ) case ( 24 ) ! (-10f(x-h)-77f(x)+150f(x+h)-100f(x+2h)+50f(x+3h)-15f(x+4h)+2f(x+5h)) / (60h) fd = finite_diff_method ( id , '7-point forward 5' , 7 ,[ - 1 , 0 , 1 , 2 , 3 , 4 , 5 ],[ - 10 , - 77 , 150 , - 100 , 50 , - 15 , 2 ], 60 ) case ( 25 ) ! (-2f(x-5h)+15f(x-4h)-50f(x-3h)+100f(x-2h)-150f(x-h)+77f(x)+10f(x+h)) / (60h) fd = finite_diff_method ( id , '7-point backward 5' , 7 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ - 2 , 15 , - 50 , 100 , - 150 , 77 , 10 ], 60 ) case ( 26 ) ! (-147f(x)+360f(x+h)-450f(x+2h)+400f(x+3h)-225f(x+4h)+72f(x+5h)-10f(x+6h)) / (60h) fd = finite_diff_method ( id , '7-point forward 6' , 7 ,[ 0 , 1 , 2 , 3 , 4 , 5 , 6 ],[ - 147 , 360 , - 450 , 400 , - 225 , 72 , - 10 ], 60 ) case ( 27 ) ! (10f(x-6h)-72f(x-5h)+225f(x-4h)-400f(x-3h)+450f(x-2h)-360f(x-h)+147f(x)) / (60h) fd = finite_diff_method ( id , '7-point backward 6' , 7 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ 10 , - 72 , 225 , - 400 , 450 , - 360 , 147 ], 60 ) ! 8 point methods case ( 28 ) ! (-4f(x-3h)+42f(x-2h)-252f(x-h)-105f(x)+420f(x+h)-126f(x+2h)+28f(x+3h)-3f(x+4h)) / (420h) fd = finite_diff_method ( id , '8-point forward 4' , 8 ,[ - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 , 4 ],[ - 4 , 42 , - 252 , - 105 , 420 , - 126 , 28 , - 3 ], 420 ) case ( 29 ) ! (3f(x-4h)-28f(x-3h)+126f(x-2h)-420f(x-h)+105f(x)+252f(x+h)-42f(x+2h)+4f(x+3h)) / (420h) fd = finite_diff_method ( id , '8-point backward 4' , 8 ,[ - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 ],[ 3 , - 28 , 126 , - 420 , 105 , 252 , - 42 , 4 ], 420 ) case ( 30 ) ! (10f(x-2h)-140f(x-h)-329f(x)+700f(x+h)-350f(x+2h)+140f(x+3h)-35f(x+4h)+4f(x+5h)) / (420h) fd = finite_diff_method ( id , '8-point forward 5' , 8 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 ],[ 10 , - 140 , - 329 , 700 , - 350 , 140 , - 35 , 4 ], 420 ) case ( 31 ) ! (-4f(x-5h)+35f(x-4h)-140f(x-3h)+350f(x-2h)-700f(x-h)+329f(x)+140f(x+h)-10f(x+2h)) / (420h) fd = finite_diff_method ( id , '8-point backward 5' , 8 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ - 4 , 35 , - 140 , 350 , - 700 , 329 , 140 , - 10 ], 420 ) case ( 32 ) ! (-60f(x-h)-609f(x)+1260f(x+h)-1050f(x+2h)+700f(x+3h)-315f(x+4h)+84f(x+5h)-10f(x+6h)) / (420h) fd = finite_diff_method ( id , '8-point forward 6' , 8 ,[ - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 ],[ - 60 , - 609 , 1260 , - 1050 , 700 , - 315 , 84 , - 10 ], 420 ) case ( 33 ) ! (10f(x-6h)-84f(x-5h)+315f(x-4h)-700f(x-3h)+1050f(x-2h)-1260f(x-h)+609f(x)+60f(x+h)) / (420h) fd = finite_diff_method ( id , '8-point backward 6' , 8 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ 10 , - 84 , 315 , - 700 , 1050 , - 1260 , 609 , 60 ], 420 ) case ( 34 ) ! (-1089f(x)+2940f(x+h)-4410f(x+2h)+4900f(x+3h)-3675f(x+4h)+1764f(x+5h)-490f(x+6h)+60f(x+7h)) / (420h) fd = finite_diff_method ( id , '8-point forward 7' , 8 ,[ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ],[ - 1089 , 2940 , - 4410 , 4900 , - 3675 , 1764 , - 490 , 60 ], 420 ) case ( 35 ) ! (-60f(x-7h)+490f(x-6h)-1764f(x-5h)+3675f(x-4h)-4900f(x-3h)+4410f(x-2h)-2940f(x-h)+1089f(x)) / (420h) fd = finite_diff_method ( id , '8-point backward 7' , 8 ,[ - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ - 60 , 490 , - 1764 , 3675 , - 4900 , 4410 , - 2940 , 1089 ], 420 ) ! 9 point methods case ( 36 ) ! (3f(x-4h)-32f(x-3h)+168f(x-2h)-672f(x-h)+672f(x+h)-168f(x+2h)+32f(x+3h)-3f(x+4h)) / (840h) fd = finite_diff_method ( id , '9-point central' , & 9 ,[ - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 ],[ 3 , - 32 , 168 , - 672 , 672 , - 168 , 32 , - 3 ], 840 ) case ( 37 ) ! (-5f(x-3h)+60f(x-2h)-420f(x-h)-378f(x)+1050f(x+h)-420f(x+2h)+140f(x+3h)-30f(x+4h)+3f(x+5h)) / (840h) fd = finite_diff_method ( id , '9-point forward 5' , & 9 ,[ - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 ],[ - 5 , 60 , - 420 , - 378 , 1050 , - 420 , 140 , - 30 , 3 ], 840 ) case ( 38 ) ! (-3f(x-5h)+30f(x-4h)-140f(x-3h)+420f(x-2h)-1050f(x-h)+378f(x)+420f(x+h)-60f(x+2h)+5f(x+3h)) / (840h) fd = finite_diff_method ( id , '9-point backward 5' , & 9 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 ],[ - 3 , 30 , - 140 , 420 , - 1050 , 378 , 420 , - 60 , 5 ], 840 ) case ( 39 ) ! (15f(x-2h)-240f(x-h)-798f(x)+1680f(x+h)-1050f(x+2h)+560f(x+3h)-210f(x+4h)+48f(x+5h)-5f(x+6h)) / (840h) fd = finite_diff_method ( id , '9-point forward 6' , & 9 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 ],[ 15 , - 240 , - 798 , 1680 , - 1050 , 560 , - 210 , 48 , - 5 ], 840 ) case ( 40 ) ! (5f(x-6h)-48f(x-5h)+210f(x-4h)-560f(x-3h)+1050f(x-2h)-1680f(x-h)+798f(x)+240f(x+h)-15f(x+2h)) / (840h) fd = finite_diff_method ( id , '9-point backward 6' , & 9 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ 5 , - 48 , 210 , - 560 , 1050 , - 1680 , 798 , 240 , - 15 ], 840 ) case ( 41 ) ! (-105f(x-h)-1338f(x)+2940f(x+h)-2940f(x+2h)+2450f(x+3h)-1470f(x+4h)+588f(x+5h)-140f(x+6h)+15f(x+7h)) / (840h) fd = finite_diff_method ( id , '9-point forward 7' , & 9 ,[ - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ],[ - 105 , - 1338 , 2940 , - 2940 , 2450 , - 1470 , 588 , - 140 , 15 ], 840 ) case ( 42 ) ! (-15f(x-7h)+140f(x-6h)-588f(x-5h)+1470f(x-4h)-2450f(x-3h)+2940f(x-2h)-2940f(x-h)+1338f(x)+105f(x+h)) / (840h) fd = finite_diff_method ( id , '9-point backward 7' , & 9 ,[ - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ - 15 , 140 , - 588 , 1470 , - 2450 , 2940 , - 2940 , 1338 , 105 ], 840 ) case ( 43 ) ! (-2283f(x)+6720f(x+h)-11760f(x+2h)+15680f(x+3h)-14700f(x+4h)+9408f(x+5h)-3920f(x+6h)+960f(x+7h)-105f(x+8h)) / (840h) fd = finite_diff_method ( id , '9-point forward 8' , & 9 ,[ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ],[ - 2283 , 6720 , - 11760 , 15680 , - 14700 , 9408 , - 3920 , 960 , - 105 ], 840 ) case ( 44 ) ! (105f(x-8h)-960f(x-7h)+3920f(x-6h)-9408f(x-5h)+14700f(x-4h)-15680f(x-3h)+11760f(x-2h)-6720f(x-h)+2283f(x)) / (840h) fd = finite_diff_method ( id , '9-point backward 8' , & 9 ,[ - 8 , - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ 105 , - 960 , 3920 , - 9408 , 14700 , - 15680 , 11760 , - 6720 , 2283 ], 840 ) ! 11 point methods case ( 500 ) ! (-2f(x-5h)+25f(x-4h)-150f(x-3h)+600f(x-2h)-2100f(x-h)+2100f(x+h)-600f(x+2h)+150f(x+3h)-25f(x+4h)+2f(x+5h)) / (2520h) fd = finite_diff_method ( id , '11-point central' , & 11 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 ],[ - 2 , 25 , - 150 , 600 , - 2100 , 2100 , - 600 , 150 , - 25 , 2 ], 2520 ) ! 13 point methods case ( 600 ) ! (5f(x-6h)-72f(x-5h)+495f(x-4h)-2200f(x-3h)+7425f(x-2h)-23760f(x-h)+23760f(x+h)-7425f(x+2h)+2200f(x+3h)-495f(x+4h)+72f(x+5h)-5f(x+6h)) / (27720h) fd = finite_diff_method ( id , '13-point central' , & 13 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 , 6 ],& [ 5 , - 72 , 495 , - 2200 , 7425 , - 23760 , 23760 , - 7425 , 2200 , - 495 , 72 , - 5 ], 27720 ) ! 15 point methods case ( 700 ) ! (-15f(x-7h)+245f(x-6h)-1911f(x-5h)+9555f(x-4h)-35035f(x-3h)+105105f(x-2h)-315315f(x-h)+315315f(x+h)-105105f(x+2h)+35035f(x+3h)-9555f(x+4h)+1911f(x+5h)-245f(x+6h)+15f(x+7h)) / (360360h) fd = finite_diff_method ( id , '15-point central' , & 15 ,[ - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ],& [ - 15 , 245 , - 1911 , 9555 , - 35035 , 105105 , - 315315 , 315315 , - 105105 , 35035 , - 9555 , 1911 , - 245 , 15 ], 360360 ) ! 17 point methods case ( 800 ) ! (7f(x-8h)-128f(x-7h)+1120f(x-6h)-6272f(x-5h)+25480f(x-4h)-81536f(x-3h)+224224f(x-2h)-640640f(x-h)+640640f(x+h)-224224f(x+2h)+81536f(x+3h)-25480f(x+4h)+6272f(x+5h)-1120f(x+6h)+128f(x+7h)-7f(x+8h)) / (720720h) fd = finite_diff_method ( id , '17-point central' , & 17 ,[ - 8 , - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ],& [ 7 , - 128 , 1120 , - 6272 , 25480 , - 81536 , 224224 , - 640640 , 640640 , - 224224 , 81536 , - 25480 , 6272 , - 1120 , 128 , - 7 ], 720720 ) case default found = . false . end select end subroutine get_finite_difference_method","tags":"","loc":"proc/get_finite_difference_method.html"},{"title":"select_finite_diff_method – AoC-2023","text":"private  subroutine select_finite_diff_method(me, x, xlow, xhigh, dx, list_of_methods, fd, status_ok) Select a finite diff method of a given class so that the perturbations\nof x will not violate the variable bounds. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in) :: x the variable value real(kind=wp), intent(in) :: xlow the variable lower bound real(kind=wp), intent(in) :: xhigh the variable upper bound real(kind=wp), intent(in) :: dx the perturbation value (>0) type( meth_array ), intent(in) :: list_of_methods list of available methods to choose from type( finite_diff_method ), intent(out) :: fd this method can be used logical, intent(out) :: status_ok true if it really doesn't violate the bounds\n(say, the bounds are very close to each other)\nif status_ok=False , then the first method in\nthe given class is returned in fd . Called by proc~~select_finite_diff_method~~CalledByGraph proc~select_finite_diff_method numerical_differentiation_module::numdiff_type%select_finite_diff_method proc~compute_jacobian_for_sparsity numerical_differentiation_module::numdiff_type%compute_jacobian_for_sparsity proc~compute_jacobian_for_sparsity->proc~select_finite_diff_method proc~compute_jacobian_standard numerical_differentiation_module::compute_jacobian_standard proc~compute_jacobian_standard->proc~select_finite_diff_method program~test1 test1 program~test1->proc~select_finite_diff_method proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine select_finite_diff_method ( me , x , xlow , xhigh , dx , list_of_methods , fd , status_ok ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x !! the variable value real ( wp ), intent ( in ) :: xlow !! the variable lower bound real ( wp ), intent ( in ) :: xhigh !! the variable upper bound real ( wp ), intent ( in ) :: dx !! the perturbation value (>0) type ( meth_array ), intent ( in ) :: list_of_methods !! list of available methods to choose from type ( finite_diff_method ), intent ( out ) :: fd !! this method can be used logical , intent ( out ) :: status_ok !! true if it really doesn't violate the bounds !! (say, the bounds are very close to each other) !! if `status_ok=False`, then the first method in !! the given class is returned in `fd`. integer :: i !! counter integer :: j !! counter real ( wp ) :: xs !! if `x` is outside the bounds, this is the value !! on the nearest bound. otherwise equal to `x`. real ( wp ) :: xp !! perturbed `x` value ! initialize: status_ok = . false . if ( me % exception_raised ) return ! check for exceptions ! make sure it is within the bounds xs = min ( xhigh , max ( xlow , x )) ! try all the methods in the class: do i = 1 , size ( list_of_methods % meth ) status_ok = . true . ! will be set to false if any ! perturbation violates the bounds ! check each of the perturbations: do j = 1 , size ( list_of_methods % meth ( i )% dx_factors ) xp = xs + list_of_methods % meth ( i )% dx_factors ( j ) * dx if ( xp < xlow . or . xp > xhigh ) then status_ok = . false . exit end if end do if ( status_ok ) then ! this one is OK to use fd = list_of_methods % meth ( i ) exit end if end do if (. not . status_ok ) then ! no method was found that doesn't violate the bounds, ! so just return the first one in the list. fd = list_of_methods % meth ( 1 ) end if end subroutine select_finite_diff_method","tags":"","loc":"proc/select_finite_diff_method.html"},{"title":"select_finite_diff_method_for_partition_group – AoC-2023","text":"private  subroutine select_finite_diff_method_for_partition_group(me, x, xlow, xhigh, dx, list_of_methods, fd, status_ok) Select a finite diff method of a given class so that the perturbations\nof x will not violate the variable bounds for any variable in the group. The x vector are only the variables in a group (not the full variable vector) Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x the variable values real(kind=wp), intent(in), dimension(:) :: xlow the variable lower bounds real(kind=wp), intent(in), dimension(:) :: xhigh the variable upper bounds real(kind=wp), intent(in), dimension(:) :: dx the perturbation values (>0) type( meth_array ), intent(in) :: list_of_methods list of available methods to choose from type( finite_diff_method ), intent(out) :: fd this method can be used logical, intent(out) :: status_ok true if it really doesn't violate the bounds\n(say, the bounds are very close to each other)\nif status_ok=False , then the first method in\nthe given class is returned in fd . Called by proc~~select_finite_diff_method_for_partition_group~~CalledByGraph proc~select_finite_diff_method_for_partition_group numerical_differentiation_module::numdiff_type%select_finite_diff_method_for_partition_group proc~compute_jacobian_partitioned numerical_differentiation_module::compute_jacobian_partitioned proc~compute_jacobian_partitioned->proc~select_finite_diff_method_for_partition_group Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine select_finite_diff_method_for_partition_group ( me , x , xlow , xhigh , dx ,& list_of_methods , fd , status_ok ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! the variable values real ( wp ), dimension (:), intent ( in ) :: xlow !! the variable lower bounds real ( wp ), dimension (:), intent ( in ) :: xhigh !! the variable upper bounds real ( wp ), dimension (:), intent ( in ) :: dx !! the perturbation values (>0) type ( meth_array ), intent ( in ) :: list_of_methods !! list of available methods to choose from type ( finite_diff_method ), intent ( out ) :: fd !! this method can be used logical , intent ( out ) :: status_ok !! true if it really doesn't violate the bounds !! (say, the bounds are very close to each other) !! if `status_ok=False`, then the first method in !! the given class is returned in `fd`. integer :: i !! counter integer :: j !! counter real ( wp ), dimension ( size ( x )) :: xp !! perturbed `x` values real ( wp ), dimension ( size ( x )) :: xs !! if `x` is outside the bounds, this is the value !! on the nearest bound. otherwise equal to `x`. ! initialize: status_ok = . false . if ( me % exception_raised ) return ! check for exceptions ! make sure they are within the bounds xs = min ( xhigh , max ( xlow , x )) ! try all the methods in the class: do i = 1 , size ( list_of_methods % meth ) status_ok = . true . ! will be set to false if any ! perturbation violates the bounds ! check each of the perturbations: do j = 1 , size ( list_of_methods % meth ( i )% dx_factors ) xp = xs + list_of_methods % meth ( i )% dx_factors ( j ) * dx if ( any ( xp < xlow ) . or . any ( xp > xhigh )) then status_ok = . false . exit end if end do if ( status_ok ) then ! this one is OK to use fd = list_of_methods % meth ( i ) exit end if end do if (. not . status_ok ) then ! no method was found that doesn't violate the bounds, ! so just return the first one in the list. fd = list_of_methods % meth ( 1 ) end if end subroutine select_finite_diff_method_for_partition_group","tags":"","loc":"proc/select_finite_diff_method_for_partition_group.html"},{"title":"initialize_numdiff_for_diff – AoC-2023","text":"private  subroutine initialize_numdiff_for_diff(me, n, m, xlow, xhigh, problem_func, sparsity_mode, info, chunk_size, eps, acc, cache_size, xlow_for_sparsity, xhigh_for_sparsity, dpert_for_sparsity, sparsity_perturb_mode, linear_sparsity_tol, function_precision_tol, num_sparsity_points, print_messages) Alternate version of initialize_numdiff routine when\nusing diff to compute the Jacobian. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: n number of x variables integer, intent(in) :: m number of f functions real(kind=wp), intent(in), dimension(n) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(n) :: xhigh upper bounds on x procedure( func ) :: problem_func the user function that defines the problem\n(returns m functions) integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. procedure( info_f ), optional :: info a function the user can define\nwhich is called when each column\nof the jacobian is computed.\nIt can be used to perform any\nsetup operations. integer, intent(in), optional :: chunk_size chunk size for allocating the arrays\n(must be >0) [default is 100] real(kind=wp), intent(in), optional :: eps tolerance parameter for diff if not present, default is 1.0e-9_wp real(kind=wp), intent(in), optional :: acc tolerance parameter for diff if not present, default is 0.0_wp integer, intent(in), optional :: cache_size if present, this is the cache size\nfor the function cache\n(default is not to enable cache) real(kind=wp), intent(in), optional, dimension(n) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(n) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. real(kind=wp), intent(in), optional, dimension(n) :: dpert_for_sparsity required if sparsity_mode=4 integer, intent(in), optional :: sparsity_perturb_mode perturbation mode (required if sparsity_mode=4 ): 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), optional :: linear_sparsity_tol the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), intent(in), optional :: function_precision_tol the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, intent(in), optional :: num_sparsity_points for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern. logical, intent(in), optional :: print_messages if true, print error messages to error_unit .\ndefault is True. Calls proc~~initialize_numdiff_for_diff~~CallsGraph proc~initialize_numdiff_for_diff numerical_differentiation_module::numdiff_type%initialize_numdiff_for_diff proc~destroy_cache numdiff_cache_module::function_cache%destroy_cache proc~initialize_numdiff_for_diff->proc~destroy_cache proc~initialize_cache numdiff_cache_module::function_cache%initialize_cache proc~initialize_numdiff_for_diff->proc~initialize_cache proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~initialize_numdiff_for_diff->proc~raise_exception proc~set_numdiff_bounds numerical_differentiation_module::numdiff_type%set_numdiff_bounds proc~initialize_numdiff_for_diff->proc~set_numdiff_bounds proc~set_sparsity_mode numerical_differentiation_module::numdiff_type%set_sparsity_mode proc~initialize_numdiff_for_diff->proc~set_sparsity_mode proc~initialize_cache->proc~destroy_cache proc~set_numdiff_bounds->proc~raise_exception proc~integer_to_string numerical_differentiation_module::integer_to_string proc~set_numdiff_bounds->proc~integer_to_string proc~set_sparsity_mode->proc~raise_exception proc~set_numdiff_sparsity_bounds numerical_differentiation_module::numdiff_type%set_numdiff_sparsity_bounds proc~set_sparsity_mode->proc~set_numdiff_sparsity_bounds proc~set_numdiff_sparsity_bounds->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~initialize_numdiff_for_diff~~CalledByGraph proc~initialize_numdiff_for_diff numerical_differentiation_module::numdiff_type%initialize_numdiff_for_diff program~test1 test1 program~test1->proc~initialize_numdiff_for_diff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize_numdiff_for_diff ( me , n , m , xlow , xhigh ,& problem_func , sparsity_mode , info ,& chunk_size , eps , acc , cache_size ,& xlow_for_sparsity , xhigh_for_sparsity ,& dpert_for_sparsity , sparsity_perturb_mode ,& linear_sparsity_tol , function_precision_tol ,& num_sparsity_points , print_messages ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of `x` variables integer , intent ( in ) :: m !! number of `f` functions real ( wp ), dimension ( n ), intent ( in ) :: xlow !! lower bounds on `x` real ( wp ), dimension ( n ), intent ( in ) :: xhigh !! upper bounds on `x` procedure ( func ) :: problem_func !! the user function that defines the problem !! (returns `m` functions) integer , intent ( in ) :: sparsity_mode !! the sparsity computation method: !! !! **1** - assume dense, !! **2** - three-point simple method, !! **3** - will be specified by the user in !! a subsequent call to [[set_sparsity_pattern]]. !! **4** - computes a two-point jacobian !! at `num_sparsity_points` points. procedure ( info_f ), optional :: info !! a function the user can define !! which is called when each column !! of the jacobian is computed. !! It can be used to perform any !! setup operations. integer , intent ( in ), optional :: chunk_size !! chunk size for allocating the arrays !! (must be >0) [default is 100] real ( wp ), intent ( in ), optional :: eps !! tolerance parameter for [[diff]] !! if not present, default is `1.0e-9_wp` real ( wp ), intent ( in ), optional :: acc !! tolerance parameter for [[diff]] !! if not present, default is `0.0_wp` integer , intent ( in ), optional :: cache_size !! if present, this is the cache size !! for the function cache !! (default is not to enable cache) real ( wp ), dimension ( n ), intent ( in ), optional :: xlow_for_sparsity !! lower bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xlow` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: xhigh_for_sparsity !! upper bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xhigh` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: dpert_for_sparsity !! required if `sparsity_mode=4` integer , intent ( in ), optional :: sparsity_perturb_mode !! perturbation mode (required if `sparsity_mode=4`): !! !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` integer , intent ( in ), optional :: num_sparsity_points !! for `sparsity_mode=4`, the number of jacobian !! evaluations used to estimate the sparsity pattern. real ( wp ), intent ( in ), optional :: linear_sparsity_tol !! the equality tolerance for derivatives to !! indicate a constant jacobian element (linear sparsity) real ( wp ), intent ( in ), optional :: function_precision_tol !! the function precision. two functions values !! that are the within this tolerance are !! considered the same value. This is used !! when estimating the sparsity pattern when !! `sparsity_mode=2` in [[compute_sparsity_random]] logical , intent ( in ), optional :: print_messages !! if true, print error messages to `error_unit`. !! default is True. logical :: cache !! if the cache is to be used me % use_diff = . true . ! cache: cache = present ( cache_size ) if ( cache ) cache = cache_size > 0 if ( cache ) then me % compute_function => compute_function_with_cache call me % cache % initialize ( cache_size , n , m ) else me % compute_function => problem_func call me % cache % destroy () end if ! functions: me % problem_func => problem_func me % jacobian_function => compute_jacobian_with_diff ! size of the problem: me % n = n me % m = m ! input variable bounds: call me % set_numdiff_bounds ( xlow , xhigh ) ! set the sparsity function call me % set_sparsity_mode ( sparsity_mode , xlow_for_sparsity , xhigh_for_sparsity ) if ( sparsity_mode == 4 ) then ! these must be present, since we don't have a dpert and perturb mode for the gradients: if ( present ( dpert_for_sparsity ) . and . present ( sparsity_perturb_mode )) then me % dpert_for_sparsity = abs ( dpert_for_sparsity ) ! perturbation options: select case ( sparsity_perturb_mode ) case ( 1 : 3 ) me % sparsity_perturb_mode = sparsity_perturb_mode case default call me % raise_exception ( 1 , 'initialize_numdiff_for_diff' ,& 'sparsity_perturb_mode must be 1, 2, or 3.' ) return end select else call me % raise_exception ( 2 , 'initialize_numdiff_for_diff' ,& 'missing required inputs for sparsity mode 4' ) return end if end if ! if these aren't present, they will just keep the defaults: if ( present ( linear_sparsity_tol )) me % linear_sparsity_tol = linear_sparsity_tol if ( present ( function_precision_tol )) me % function_precision_tol = function_precision_tol if ( present ( num_sparsity_points )) me % num_sparsity_points = num_sparsity_points ! optional: if ( present ( chunk_size )) me % chunk_size = abs ( chunk_size ) if ( present ( eps )) me % eps = eps if ( present ( acc )) me % acc = acc if ( present ( info )) me % info_function => info if ( present ( print_messages )) me % print_messages = print_messages end subroutine initialize_numdiff_for_diff","tags":"","loc":"proc/initialize_numdiff_for_diff.html"},{"title":"set_numdiff_bounds – AoC-2023","text":"private  subroutine set_numdiff_bounds(me, xlow, xhigh) Change the variable bounds in a numdiff_type . See also set_numdiff_sparsity_bounds Note The bounds must be set when the class is initialized,\n      but this routine can be used to change them later if required. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(:) :: xhigh upper bounds on x Calls proc~~set_numdiff_bounds~~CallsGraph proc~set_numdiff_bounds numerical_differentiation_module::numdiff_type%set_numdiff_bounds proc~integer_to_string numerical_differentiation_module::integer_to_string proc~set_numdiff_bounds->proc~integer_to_string proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~set_numdiff_bounds->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_numdiff_bounds~~CalledByGraph proc~set_numdiff_bounds numerical_differentiation_module::numdiff_type%set_numdiff_bounds proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~set_numdiff_bounds proc~initialize_numdiff_for_diff numerical_differentiation_module::numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~set_numdiff_bounds program~test1 test1 program~test1->proc~initialize_numdiff program~test1->proc~initialize_numdiff_for_diff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_numdiff_bounds ( me , xlow , xhigh ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: xlow !! lower bounds on `x` real ( wp ), dimension (:), intent ( in ) :: xhigh !! upper bounds on `x` integer :: i !! counter for error print character ( len = :), allocatable :: error_info !! error message info character ( len = :), allocatable :: istr !! for integer to string character ( len = 30 ) :: xlow_str , xhigh_str !! for real to string if ( me % exception_raised ) return ! check for exceptions if ( allocated ( me % xlow )) deallocate ( me % xlow ) if ( allocated ( me % xhigh )) deallocate ( me % xhigh ) if ( size ( xlow ) /= me % n . or . size ( xhigh ) /= me % n ) then call me % raise_exception ( 3 , 'set_numdiff_bounds' ,& 'invalid size of xlow or xhigh' ) return else if ( any ( xlow >= xhigh )) then error_info = 'all xlow must be < xhigh' do i = 1 , size ( xlow ) if ( xlow ( i ) >= xhigh ( i )) then istr = integer_to_string ( i ) write ( xlow_str , '(F30.16)' ) xlow ( i ) write ( xhigh_str , '(F30.16)' ) xhigh ( i ) error_info = error_info // new_line ( '' ) // '  Error for optimization variable ' // trim ( adjustl ( istr )) // & ': xlow=' // trim ( adjustl ( xlow_str )) // & ' >= xhigh=' // trim ( adjustl ( xhigh_str )) end if end do call me % raise_exception ( 4 , 'set_numdiff_bounds' , error_info ) return else allocate ( me % xlow ( me % n )) allocate ( me % xhigh ( me % n )) me % xlow = xlow me % xhigh = xhigh end if end subroutine set_numdiff_bounds","tags":"","loc":"proc/set_numdiff_bounds.html"},{"title":"set_sparsity_mode – AoC-2023","text":"private  subroutine set_sparsity_mode(me, sparsity_mode, xlow_for_sparsity, xhigh_for_sparsity) Set sparsity mode. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. real(kind=wp), intent(in), optional, dimension(:) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(:) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. Calls proc~~set_sparsity_mode~~CallsGraph proc~set_sparsity_mode numerical_differentiation_module::numdiff_type%set_sparsity_mode proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~set_sparsity_mode->proc~raise_exception proc~set_numdiff_sparsity_bounds numerical_differentiation_module::numdiff_type%set_numdiff_sparsity_bounds proc~set_sparsity_mode->proc~set_numdiff_sparsity_bounds proc~set_numdiff_sparsity_bounds->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_sparsity_mode~~CalledByGraph proc~set_sparsity_mode numerical_differentiation_module::numdiff_type%set_sparsity_mode proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~set_sparsity_mode proc~initialize_numdiff_for_diff numerical_differentiation_module::numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~set_sparsity_mode program~test1 test1 program~test1->proc~initialize_numdiff program~test1->proc~initialize_numdiff_for_diff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_sparsity_mode ( me , sparsity_mode , xlow_for_sparsity , xhigh_for_sparsity ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: sparsity_mode !! the sparsity computation method: !! **1** - assume dense, !! **2** - three-point simple method, !! **3** - will be specified by the user in !! a subsequent call to [[set_sparsity_pattern]]. !! **4** - computes a two-point jacobian !! at `num_sparsity_points` points. real ( wp ), dimension (:), intent ( in ), optional :: xlow_for_sparsity !! lower bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xlow` is used. real ( wp ), dimension (:), intent ( in ), optional :: xhigh_for_sparsity !! upper bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xhigh` is used. if ( me % exception_raised ) return ! check for exceptions ! set the sparsity function select case ( sparsity_mode ) case ( 1 ) ! dense me % compute_sparsity => compute_sparsity_dense case ( 3 ) ! user defined me % compute_sparsity => null () case ( 2 ) ! three-point simple method me % compute_sparsity => compute_sparsity_random ! in this case, we have the option of specifying ! separate bounds for computing the sparsity: call me % set_numdiff_sparsity_bounds ( xlow_for_sparsity , xhigh_for_sparsity ) case ( 4 ) ! compute 2-point jacobian in specified number of points me % compute_sparsity => compute_sparsity_random_2 ! in this case, we have the option of specifying ! separate bounds for computing the sparsity: call me % set_numdiff_sparsity_bounds ( xlow_for_sparsity , xhigh_for_sparsity ) case default call me % raise_exception ( 5 , 'set_sparsity_mode' ,& 'sparsity_mode must be 1, 2, 3, or 4.' ) return end select end subroutine set_sparsity_mode","tags":"","loc":"proc/set_sparsity_mode.html"},{"title":"set_numdiff_sparsity_bounds – AoC-2023","text":"private  subroutine set_numdiff_sparsity_bounds(me, xlow, xhigh) Sets the variable bounds for sparsity in a numdiff_type .\n  These are only used for sparsity_mode=2 . See also set_numdiff_bounds Note This routine assumes that xlow and xhigh have already\n      been set in the class. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), optional, dimension(:) :: xlow lower bounds on x to be used for\nsparsity computation. If not present,\nthen then xlow values in the class are used. real(kind=wp), intent(in), optional, dimension(:) :: xhigh upper bounds on x to be used for\nsparsity computation. If not present,\nthen then xhigh values in the class are used. Calls proc~~set_numdiff_sparsity_bounds~~CallsGraph proc~set_numdiff_sparsity_bounds numerical_differentiation_module::numdiff_type%set_numdiff_sparsity_bounds proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~set_numdiff_sparsity_bounds->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_numdiff_sparsity_bounds~~CalledByGraph proc~set_numdiff_sparsity_bounds numerical_differentiation_module::numdiff_type%set_numdiff_sparsity_bounds proc~set_sparsity_mode numerical_differentiation_module::numdiff_type%set_sparsity_mode proc~set_sparsity_mode->proc~set_numdiff_sparsity_bounds proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~set_sparsity_mode proc~initialize_numdiff_for_diff numerical_differentiation_module::numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~set_sparsity_mode program~test1 test1 program~test1->proc~initialize_numdiff program~test1->proc~initialize_numdiff_for_diff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_numdiff_sparsity_bounds ( me , xlow , xhigh ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ), optional :: xlow !! lower bounds on `x` to be used for !! sparsity computation. If not present, !! then then `xlow` values in the class are used. real ( wp ), dimension (:), intent ( in ), optional :: xhigh !! upper bounds on `x` to be used for !! sparsity computation. If not present, !! then then `xhigh` values in the class are used. if ( me % exception_raised ) return ! check for exceptions if ( allocated ( me % xlow_for_sparsity )) deallocate ( me % xlow_for_sparsity ) if ( allocated ( me % xhigh_for_sparsity )) deallocate ( me % xhigh_for_sparsity ) if (. not . present ( xlow )) then allocate ( me % xlow_for_sparsity ( size ( me % xlow ))) me % xlow_for_sparsity = me % xlow else allocate ( me % xlow_for_sparsity ( size ( xlow ))) me % xlow_for_sparsity = xlow end if if (. not . present ( xhigh )) then allocate ( me % xhigh_for_sparsity ( size ( me % xhigh ))) me % xhigh_for_sparsity = me % xhigh else allocate ( me % xhigh_for_sparsity ( size ( xhigh ))) me % xhigh_for_sparsity = xhigh end if ! error checks: if ( size ( me % xlow_for_sparsity ) /= me % n . or . size ( me % xhigh_for_sparsity ) /= me % n ) then call me % raise_exception ( 6 , 'set_numdiff_sparsity_bounds' ,& 'invalid size of xlow or xhigh' ) else if ( any ( me % xlow_for_sparsity >= me % xhigh_for_sparsity )) then call me % raise_exception ( 7 , 'set_numdiff_sparsity_bounds' ,& 'all xlow must be < xhigh' ) end if end subroutine set_numdiff_sparsity_bounds","tags":"","loc":"proc/set_numdiff_sparsity_bounds.html"},{"title":"initialize_numdiff – AoC-2023","text":"private  subroutine initialize_numdiff(me, n, m, xlow, xhigh, perturb_mode, dpert, problem_func, sparsity_mode, jacobian_method, jacobian_methods, class, classes, info, chunk_size, partition_sparsity_pattern, cache_size, xlow_for_sparsity, xhigh_for_sparsity, dpert_for_sparsity, sparsity_perturb_mode, linear_sparsity_tol, function_precision_tol, num_sparsity_points) Initialize a numdiff_type class. This must be called first. Note Only one of the following inputs can be used: jacobian_method , jacobian_methods , class , or classes . Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: n number of x variables integer, intent(in) :: m number of f functions real(kind=wp), intent(in), dimension(n) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(n) :: xhigh upper bounds on x integer, intent(in) :: perturb_mode perturbation mode: 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), dimension(n) :: dpert perturbation vector for x procedure( func ) :: problem_func the user function that defines the problem\n(returns m functions) integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. integer, intent(in), optional :: jacobian_method id code for the finite difference method\nto use for all n variables.\nsee get_finite_difference_method integer, intent(in), optional, dimension(n) :: jacobian_methods id codes for the finite difference method\nto use for each variable.\nsee get_finite_difference_method integer, intent(in), optional :: class method class for the finite difference method\nto use for all n variables.\nsee get_finite_difference_method integer, intent(in), optional, dimension(n) :: classes method class for the finite difference methods\nto use for each variable.\nsee get_finite_difference_method procedure( info_f ), optional :: info a function the user can define\nwhich is called when each column\nof the jacobian is computed.\nIt can be used to perform any\nsetup operations. integer, intent(in), optional :: chunk_size chunk size for allocating the arrays\n(must be >0) [default is 100] logical, intent(in), optional :: partition_sparsity_pattern if the sparisty pattern is to\nbe partitioned using DSM [default is False] integer, intent(in), optional :: cache_size if present, this is the cache size\nfor the function cache\n(default is not to enable cache) real(kind=wp), intent(in), optional, dimension(n) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(n) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. real(kind=wp), intent(in), optional, dimension(n) :: dpert_for_sparsity for sparsity_mode=4 , the perturbation integer, intent(in), optional :: sparsity_perturb_mode perturbation mode (required if sparsity_mode=4 ): 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), optional :: linear_sparsity_tol the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), intent(in), optional :: function_precision_tol the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, intent(in), optional :: num_sparsity_points for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern. Calls proc~~initialize_numdiff~~CallsGraph proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff proc~destroy_cache numdiff_cache_module::function_cache%destroy_cache proc~initialize_numdiff->proc~destroy_cache proc~get_all_methods_in_class numerical_differentiation_module::get_all_methods_in_class proc~initialize_numdiff->proc~get_all_methods_in_class proc~get_finite_difference_method numerical_differentiation_module::get_finite_difference_method proc~initialize_numdiff->proc~get_finite_difference_method proc~initialize_cache numdiff_cache_module::function_cache%initialize_cache proc~initialize_numdiff->proc~initialize_cache proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~initialize_numdiff->proc~raise_exception proc~set_numdiff_bounds numerical_differentiation_module::numdiff_type%set_numdiff_bounds proc~initialize_numdiff->proc~set_numdiff_bounds proc~set_sparsity_mode numerical_differentiation_module::numdiff_type%set_sparsity_mode proc~initialize_numdiff->proc~set_sparsity_mode proc~get_all_methods_in_class->proc~get_finite_difference_method proc~initialize_cache->proc~destroy_cache proc~set_numdiff_bounds->proc~raise_exception proc~integer_to_string numerical_differentiation_module::integer_to_string proc~set_numdiff_bounds->proc~integer_to_string proc~set_sparsity_mode->proc~raise_exception proc~set_numdiff_sparsity_bounds numerical_differentiation_module::numdiff_type%set_numdiff_sparsity_bounds proc~set_sparsity_mode->proc~set_numdiff_sparsity_bounds proc~set_numdiff_sparsity_bounds->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~initialize_numdiff~~CalledByGraph proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff program~test1 test1 program~test1->proc~initialize_numdiff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize_numdiff ( me , n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func , sparsity_mode , jacobian_method , jacobian_methods ,& class , classes , info , chunk_size , partition_sparsity_pattern ,& cache_size , xlow_for_sparsity , xhigh_for_sparsity ,& dpert_for_sparsity , sparsity_perturb_mode ,& linear_sparsity_tol , function_precision_tol ,& num_sparsity_points ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of `x` variables integer , intent ( in ) :: m !! number of `f` functions real ( wp ), dimension ( n ), intent ( in ) :: xlow !! lower bounds on `x` real ( wp ), dimension ( n ), intent ( in ) :: xhigh !! upper bounds on `x` integer , intent ( in ) :: perturb_mode !! perturbation mode: !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` real ( wp ), dimension ( n ), intent ( in ) :: dpert !! perturbation vector for `x` procedure ( func ) :: problem_func !! the user function that defines the problem !! (returns `m` functions) integer , intent ( in ) :: sparsity_mode !! the sparsity computation method: !! **1** - assume dense, !! **2** - three-point simple method, !! **3** - will be specified by the user in !! a subsequent call to [[set_sparsity_pattern]]. !! **4** - computes a two-point jacobian !! at `num_sparsity_points` points. integer , intent ( in ), optional :: jacobian_method !! `id` code for the finite difference method !! to use for all `n` variables. !! see [[get_finite_difference_method]] integer , dimension ( n ), intent ( in ), optional :: jacobian_methods !! `id` codes for the finite difference method !! to use for each variable. !! see [[get_finite_difference_method]] integer , intent ( in ), optional :: class !! method class for the finite difference method !! to use for all `n` variables. !! see [[get_finite_difference_method]] integer , dimension ( n ), intent ( in ), optional :: classes !! method class for the finite difference methods !! to use for each variable. !! see [[get_finite_difference_method]] procedure ( info_f ), optional :: info !! a function the user can define !! which is called when each column !! of the jacobian is computed. !! It can be used to perform any !! setup operations. integer , intent ( in ), optional :: chunk_size !! chunk size for allocating the arrays !! (must be >0) [default is 100] logical , intent ( in ), optional :: partition_sparsity_pattern !! if the sparisty pattern is to !! be partitioned using [[DSM]] !! [default is False] integer , intent ( in ), optional :: cache_size !! if present, this is the cache size !! for the function cache !! (default is not to enable cache) real ( wp ), dimension ( n ), intent ( in ), optional :: xlow_for_sparsity !! lower bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xlow` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: xhigh_for_sparsity !! upper bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xhigh` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: dpert_for_sparsity !! for `sparsity_mode=4`, the perturbation integer , intent ( in ), optional :: sparsity_perturb_mode !! perturbation mode (required if `sparsity_mode=4`): !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` real ( wp ), intent ( in ), optional :: linear_sparsity_tol !! the equality tolerance for derivatives to !! indicate a constant jacobian element (linear sparsity) real ( wp ), intent ( in ), optional :: function_precision_tol !! the function precision. two functions values !! that are the within this tolerance are !! considered the same value. This is used !! when estimating the sparsity pattern when !! `sparsity_mode=2` in [[compute_sparsity_random]] integer , intent ( in ), optional :: num_sparsity_points !! for `sparsity_mode=4`, the number of jacobian !! evaluations used to estimate the sparsity pattern. integer :: i !! counter logical :: found !! flag for [[get_finite_difference_method]] logical :: cache !! if the cache is to be used me % use_diff = . false . ! cache: cache = present ( cache_size ) if ( cache ) cache = cache_size > 0 if ( cache ) then me % compute_function => compute_function_with_cache call me % cache % initialize ( cache_size , n , m ) else me % compute_function => problem_func call me % cache % destroy () end if ! functions: me % problem_func => problem_func if ( present ( partition_sparsity_pattern )) then me % partition_sparsity_pattern = partition_sparsity_pattern else me % partition_sparsity_pattern = . false . end if ! method: if ( allocated ( me % meth )) deallocate ( me % meth ) if ( allocated ( me % class )) deallocate ( me % class ) if ( allocated ( me % class_meths )) deallocate ( me % class_meths ) if ( present ( jacobian_method ) . and . . not . present ( jacobian_methods ) . and . & . not . present ( class ) . and . . not . present ( classes )) then ! use the same for all variable me % mode = 1 allocate ( me % meth ( n )) do i = 1 , n call get_finite_difference_method ( jacobian_method , me % meth ( i ), found ) if (. not . found ) then call me % raise_exception ( 8 , 'initialize_numdiff' ,& 'invalid jacobian_method' ) return end if end do elseif (. not . present ( jacobian_method ) . and . present ( jacobian_methods ) . and . & . not . present ( class ) . and . . not . present ( classes )) then ! specify a separate method for each variable me % mode = 1 allocate ( me % meth ( n )) do i = 1 , n call get_finite_difference_method ( jacobian_methods ( i ), me % meth ( i ), found ) if (. not . found ) then call me % raise_exception ( 9 , 'initialize_numdiff' ,& 'invalid jacobian_methods' ) return end if end do if ( me % partition_sparsity_pattern ) then call me % raise_exception ( 10 , 'initialize_numdiff' ,& 'when using partitioned sparsity pattern, ' // & 'all columns must use the same ' // & 'finite diff method.' ) return end if elseif (. not . present ( jacobian_method ) . and . . not . present ( jacobian_methods ) . and . & present ( class ) . and . . not . present ( classes )) then ! use the class for all variables me % mode = 2 allocate ( me % class ( n )) me % class = class allocate ( me % class_meths ( n )) me % class_meths ( 1 ) = get_all_methods_in_class ( class ) if ( n > 1 ) me % class_meths ( 2 : n ) = me % class_meths ( 1 ) ! just copy them over elseif (. not . present ( jacobian_method ) . and . . not . present ( jacobian_methods ) . and . & . not . present ( class ) . and . present ( classes )) then ! specify a separate class for each variable me % mode = 2 me % class = classes allocate ( me % class_meths ( n )) do i = 1 , n me % class_meths ( i ) = get_all_methods_in_class ( me % class ( i )) end do if ( me % partition_sparsity_pattern ) then call me % raise_exception ( 11 , 'initialize_numdiff' ,& 'when using partitioned sparsity pattern, ' // & 'all columns must use the same ' // & 'finite diff method.' ) end if else call me % raise_exception ( 12 , 'initialize_numdiff' ,& 'must specify one of either ' // & 'jacobian_method, jacobian_methods, class, or classes.' ) end if ! size of the problem: me % n = n me % m = m ! input variable bounds: call me % set_numdiff_bounds ( xlow , xhigh ) ! perturbation options: select case ( perturb_mode ) case ( 1 : 3 ) me % perturb_mode = perturb_mode case default call me % raise_exception ( 13 , 'initialize_numdiff' ,& 'perturb_mode must be 1, 2, or 3.' ) return end select if ( allocated ( me % dpert )) deallocate ( me % dpert ) allocate ( me % dpert ( n )) me % dpert = abs ( dpert ) ! optional: if ( present ( info )) me % info_function => info if ( present ( chunk_size )) me % chunk_size = abs ( chunk_size ) ! set the jacobian function, depending on the options: if ( me % partition_sparsity_pattern ) then me % jacobian_function => compute_jacobian_partitioned else me % jacobian_function => compute_jacobian_standard end if ! set the sparsity function call me % set_sparsity_mode ( sparsity_mode , xlow_for_sparsity , xhigh_for_sparsity ) if ( present ( linear_sparsity_tol )) me % linear_sparsity_tol = linear_sparsity_tol if ( present ( function_precision_tol )) me % function_precision_tol = function_precision_tol if ( present ( num_sparsity_points )) me % num_sparsity_points = num_sparsity_points if ( present ( dpert_for_sparsity )) then me % dpert_for_sparsity = abs ( dpert_for_sparsity ) else me % dpert_for_sparsity = dpert ! use the same dpert as the jacobian end if if ( present ( sparsity_perturb_mode )) then select case ( sparsity_perturb_mode ) case ( 1 : 3 ) me % sparsity_perturb_mode = sparsity_perturb_mode case default call me % raise_exception ( 14 , 'initialize_numdiff' ,& 'sparsity_perturb_mode must be 1, 2, or 3.' ) return end select else me % sparsity_perturb_mode = perturb_mode ! use the same perturb mode as the jacobian end if end subroutine initialize_numdiff","tags":"","loc":"proc/initialize_numdiff.html"},{"title":"destroy_numdiff_type – AoC-2023","text":"private  subroutine destroy_numdiff_type(me) destroy the numdiff_type class. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(out) :: me Called by proc~~destroy_numdiff_type~~CalledByGraph proc~destroy_numdiff_type numerical_differentiation_module::numdiff_type%destroy_numdiff_type program~test1 test1 program~test1->proc~destroy_numdiff_type program~test2 test2 program~test2->proc~destroy_numdiff_type Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy_numdiff_type ( me ) implicit none class ( numdiff_type ), intent ( out ) :: me end subroutine destroy_numdiff_type","tags":"","loc":"proc/destroy_numdiff_type.html"},{"title":"destroy_sparsity – AoC-2023","text":"private  subroutine destroy_sparsity(me) destroy a sparsity_pattern type. Type Bound sparsity_pattern Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(out) :: me Called by proc~~destroy_sparsity~~CalledByGraph proc~destroy_sparsity numerical_differentiation_module::sparsity_pattern%destroy_sparsity proc~destroy_sparsity_pattern numerical_differentiation_module::numdiff_type%destroy_sparsity_pattern proc~destroy_sparsity_pattern->proc~destroy_sparsity proc~compute_sparsity_dense numerical_differentiation_module::compute_sparsity_dense proc~compute_sparsity_dense->proc~destroy_sparsity_pattern proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~destroy_sparsity_pattern proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~destroy_sparsity_pattern proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~destroy_sparsity_pattern Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy_sparsity ( me ) implicit none class ( sparsity_pattern ), intent ( out ) :: me end subroutine destroy_sparsity","tags":"","loc":"proc/destroy_sparsity.html"},{"title":"dsm_wrapper – AoC-2023","text":"private  subroutine dsm_wrapper(me, n, m, info) Wrapper for dsm to compute the sparsity pattern partition. Type Bound sparsity_pattern Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(inout) :: me integer, intent(in) :: n number of columns of jacobian matrix integer, intent(in) :: m number of rows of jacobian matrix integer, intent(out) :: info status output from dsm Calls proc~~dsm_wrapper~~CallsGraph proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~dsm dsm_module::dsm proc~dsm_wrapper->proc~dsm proc~degr dsm_module::degr proc~dsm->proc~degr proc~ido dsm_module::ido proc~dsm->proc~ido proc~numsrt dsm_module::numsrt proc~dsm->proc~numsrt proc~seq dsm_module::seq proc~dsm->proc~seq proc~setr dsm_module::setr proc~dsm->proc~setr proc~slo dsm_module::slo proc~dsm->proc~slo proc~srtdat dsm_module::srtdat proc~dsm->proc~srtdat proc~ido->proc~numsrt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dsm_wrapper~~CalledByGraph proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dsm_wrapper ( me , n , m , info ) implicit none class ( sparsity_pattern ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of columns of jacobian matrix integer , intent ( in ) :: m !! number of rows of jacobian matrix integer , intent ( out ) :: info !! status output from [[dsm]] integer :: mingrp !! for call to [[dsm]] integer , dimension (:), allocatable :: ipntr !! for call to [[dsm]] integer , dimension (:), allocatable :: jpntr !! for call to [[dsm]] integer , dimension (:), allocatable :: irow !! for call to [[dsm]] !! (temp copy since [[dsm]] !! will modify it) integer , dimension (:), allocatable :: icol !! for call to [[dsm]] !! (temp copy since [[dsm]] !! will modify it) allocate ( ipntr ( m + 1 )) allocate ( jpntr ( n + 1 )) allocate ( me % ngrp ( n )) irow = me % irow icol = me % icol call dsm ( m , n , me % num_nonzero_elements ,& irow , icol ,& me % ngrp , me % maxgrp ,& mingrp , info , ipntr , jpntr ) end subroutine dsm_wrapper","tags":"","loc":"proc/dsm_wrapper.html"},{"title":"columns_in_partition_group – AoC-2023","text":"private  subroutine columns_in_partition_group(me, igroup, n_cols, cols, nonzero_rows, indices, status_ok) Returns the columns in a sparsity partition group. Note This is just a wrapper to get data from ngrp . Type Bound sparsity_pattern Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(in) :: me integer, intent(in) :: igroup group number. Should be >0 and <=me%mxgrp integer, intent(out) :: n_cols number of columns in the igroup group. integer, intent(out), dimension(:), allocatable :: cols the column numbers in the igroup group.\n(if none, then it is not allocated) integer, intent(out), dimension(:), allocatable :: nonzero_rows the row numbers of all the nonzero\nJacobian elements in this group integer, intent(out), dimension(:), allocatable :: indices nonzero indices in jac for a group logical, intent(out) :: status_ok true if the partition is valid Called by proc~~columns_in_partition_group~~CalledByGraph proc~columns_in_partition_group numerical_differentiation_module::sparsity_pattern%columns_in_partition_group proc~compute_jacobian_partitioned numerical_differentiation_module::compute_jacobian_partitioned proc~compute_jacobian_partitioned->proc~columns_in_partition_group Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine columns_in_partition_group ( me , igroup , n_cols , cols , nonzero_rows , indices , status_ok ) implicit none class ( sparsity_pattern ), intent ( in ) :: me integer , intent ( in ) :: igroup !! group number. Should be `>0` and `<=me%mxgrp` integer , intent ( out ) :: n_cols !! number of columns in the `igroup` group. integer , dimension (:), allocatable , intent ( out ) :: cols !! the column numbers in the `igroup` group. !! (if none, then it is not allocated) integer , dimension (:), allocatable , intent ( out ) :: nonzero_rows !! the row numbers of all the nonzero !! Jacobian elements in this group integer , dimension (:), allocatable , intent ( out ) :: indices !! nonzero indices in `jac` for a group logical , intent ( out ) :: status_ok !! true if the partition is valid integer :: i !! counter integer :: num_nonzero_elements_in_col !! number of nonzero elements in a column integer :: num_nonzero_elements_in_group !! number of nonzero elements in a group integer , dimension (:), allocatable :: col_indices !! nonzero indices in `jac` for a column if ( me % maxgrp > 0 . and . allocated ( me % ngrp )) then status_ok = . true . n_cols = count ( me % ngrp == igroup ) if ( n_cols > 0 ) then allocate ( cols ( n_cols )) cols = pack ([( i , i = 1 , size ( me % ngrp ))], mask = me % ngrp == igroup ) end if ! get all the non-zero elements in each column: num_nonzero_elements_in_group = 0 ! initialize do i = 1 , n_cols num_nonzero_elements_in_col = count ( me % icol == cols ( i )) if ( num_nonzero_elements_in_col /= 0 ) then ! there are functions to ! compute in this column num_nonzero_elements_in_group = num_nonzero_elements_in_group + & num_nonzero_elements_in_col if ( allocated ( col_indices )) deallocate ( col_indices ) allocate ( col_indices ( num_nonzero_elements_in_col )) col_indices = pack ( me % indices , mask = me % icol == cols ( i )) if ( allocated ( nonzero_rows )) then nonzero_rows = [ nonzero_rows , me % irow ( col_indices )] indices = [ indices , col_indices ] else nonzero_rows = me % irow ( col_indices ) indices = col_indices end if end if end do else status_ok = . false . end if end subroutine columns_in_partition_group","tags":"","loc":"proc/columns_in_partition_group.html"},{"title":"destroy_sparsity_pattern – AoC-2023","text":"private  subroutine destroy_sparsity_pattern(me) Destroy the sparsity pattern in the class. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me Calls proc~~destroy_sparsity_pattern~~CallsGraph proc~destroy_sparsity_pattern numerical_differentiation_module::numdiff_type%destroy_sparsity_pattern proc~destroy_sparsity numerical_differentiation_module::sparsity_pattern%destroy_sparsity proc~destroy_sparsity_pattern->proc~destroy_sparsity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~destroy_sparsity_pattern~~CalledByGraph proc~destroy_sparsity_pattern numerical_differentiation_module::numdiff_type%destroy_sparsity_pattern proc~compute_sparsity_dense numerical_differentiation_module::compute_sparsity_dense proc~compute_sparsity_dense->proc~destroy_sparsity_pattern proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~destroy_sparsity_pattern proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~destroy_sparsity_pattern proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~destroy_sparsity_pattern Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy_sparsity_pattern ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me call me % sparsity % destroy () end subroutine destroy_sparsity_pattern","tags":"","loc":"proc/destroy_sparsity_pattern.html"},{"title":"compute_indices – AoC-2023","text":"private  subroutine compute_indices(me) Computes the indices vector in the class. Type Bound sparsity_pattern Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(inout) :: me Called by proc~~compute_indices~~CalledByGraph proc~compute_indices numerical_differentiation_module::sparsity_pattern%compute_indices proc~compute_sparsity_dense numerical_differentiation_module::compute_sparsity_dense proc~compute_sparsity_dense->proc~compute_indices proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~compute_indices proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~compute_indices proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~compute_indices Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_indices ( me ) implicit none class ( sparsity_pattern ), intent ( inout ) :: me integer :: i !! counter allocate ( me % indices ( me % num_nonzero_elements )) me % indices = [( i , i = 1 , me % num_nonzero_elements )] end subroutine compute_indices","tags":"","loc":"proc/compute_indices.html"},{"title":"set_sparsity_pattern – AoC-2023","text":"private  subroutine set_sparsity_pattern(me, irow, icol, linear_irow, linear_icol, linear_vals, maxgrp, ngrp) To specify the sparsity pattern directly if it is already known. Note If specifying the linear pattern, all three optional arguments\n      must be present. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in), dimension(:) :: irow sparsity pattern nonzero elements row indices integer, intent(in), dimension(:) :: icol sparsity pattern nonzero elements column indices integer, intent(in), optional, dimension(:) :: linear_irow linear sparsity pattern nonzero elements row indices integer, intent(in), optional, dimension(:) :: linear_icol linear sparsity pattern nonzero elements column indices real(kind=wp), intent(in), optional, dimension(:) :: linear_vals linear sparsity values (constant elements of the Jacobian) integer, intent(in), optional :: maxgrp DSM sparsity partition\n[only used if me%partition_sparsity_pattern=True ] integer, intent(in), optional, dimension(:) :: ngrp DSM sparsity partition (size n )\n[only used if me%partition_sparsity_pattern=True ] Calls proc~~set_sparsity_pattern~~CallsGraph proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~compute_indices numerical_differentiation_module::sparsity_pattern%compute_indices proc~set_sparsity_pattern->proc~compute_indices proc~destroy_sparsity_pattern numerical_differentiation_module::numdiff_type%destroy_sparsity_pattern proc~set_sparsity_pattern->proc~destroy_sparsity_pattern proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~set_sparsity_pattern->proc~dsm_wrapper proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~set_sparsity_pattern->proc~raise_exception proc~destroy_sparsity numerical_differentiation_module::sparsity_pattern%destroy_sparsity proc~destroy_sparsity_pattern->proc~destroy_sparsity proc~dsm dsm_module::dsm proc~dsm_wrapper->proc~dsm proc~degr dsm_module::degr proc~dsm->proc~degr proc~ido dsm_module::ido proc~dsm->proc~ido proc~numsrt dsm_module::numsrt proc~dsm->proc~numsrt proc~seq dsm_module::seq proc~dsm->proc~seq proc~setr dsm_module::setr proc~dsm->proc~setr proc~slo dsm_module::slo proc~dsm->proc~slo proc~srtdat dsm_module::srtdat proc~dsm->proc~srtdat proc~ido->proc~numsrt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_sparsity_pattern ( me , irow , icol , linear_irow , linear_icol , linear_vals , maxgrp , ngrp ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , dimension (:), intent ( in ) :: irow !! sparsity pattern nonzero elements row indices integer , dimension (:), intent ( in ) :: icol !! sparsity pattern nonzero elements column indices integer , dimension (:), intent ( in ), optional :: linear_irow !! linear sparsity pattern nonzero elements row indices integer , dimension (:), intent ( in ), optional :: linear_icol !! linear sparsity pattern nonzero elements column indices real ( wp ), dimension (:), intent ( in ), optional :: linear_vals !! linear sparsity values (constant elements of the Jacobian) integer , intent ( in ), optional :: maxgrp !! DSM sparsity partition !! [only used if `me%partition_sparsity_pattern=True`] integer , dimension (:), intent ( in ), optional :: ngrp !! DSM sparsity partition (size `n`) !! [only used if `me%partition_sparsity_pattern=True`] integer :: info !! status output form [[dsm]] call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions if ( size ( irow ) /= size ( icol ) . or . any ( irow > me % m ) . or . any ( icol > me % n )) then call me % raise_exception ( 15 , 'set_sparsity_pattern' ,& 'invalid inputs' ) return else me % sparsity % sparsity_computed = . true . me % sparsity % num_nonzero_elements = size ( irow ) me % sparsity % irow = irow me % sparsity % icol = icol call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) then if ( present ( maxgrp ) . and . present ( ngrp )) then ! use the user-input partition: if ( maxgrp > 0 . and . all ( ngrp >= 1 . and . ngrp <= maxgrp ) . and . size ( ngrp ) == me % n ) then me % sparsity % maxgrp = maxgrp me % sparsity % ngrp = ngrp else call me % raise_exception ( 28 , 'set_sparsity_pattern' ,& 'invalid sparsity partition inputs.' ) return end if else call me % sparsity % dsm_wrapper ( me % n , me % m , info ) if ( info /= 1 ) then call me % raise_exception ( 16 , 'set_sparsity_pattern' ,& 'error partitioning sparsity pattern.' ) return end if end if end if end if ! linear pattern: if ( present ( linear_irow ) . and . present ( linear_icol ) . and . present ( linear_vals )) then if ( size ( linear_irow ) /= size ( linear_icol ) . or . & size ( linear_vals ) /= size ( linear_icol ) . or . & any ( linear_irow > me % m ) . or . & any ( linear_icol > me % n )) then call me % raise_exception ( 17 , 'set_sparsity_pattern' ,& 'invalid linear sparsity pattern' ) return else me % sparsity % linear_irow = linear_irow me % sparsity % linear_icol = linear_icol me % sparsity % linear_vals = linear_vals me % sparsity % linear_sparsity_computed = . true . me % sparsity % num_nonzero_linear_elements = size ( linear_irow ) end if end if end subroutine set_sparsity_pattern","tags":"","loc":"proc/set_sparsity_pattern.html"},{"title":"compute_sparsity_dense – AoC-2023","text":"private  subroutine compute_sparsity_dense(me, x) assume all elements of Jacobian are non-zero. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) Calls proc~~compute_sparsity_dense~~CallsGraph proc~compute_sparsity_dense numerical_differentiation_module::compute_sparsity_dense proc~compute_indices numerical_differentiation_module::sparsity_pattern%compute_indices proc~compute_sparsity_dense->proc~compute_indices proc~destroy_sparsity_pattern numerical_differentiation_module::numdiff_type%destroy_sparsity_pattern proc~compute_sparsity_dense->proc~destroy_sparsity_pattern proc~generate_dense_sparsity_partition numerical_differentiation_module::numdiff_type%generate_dense_sparsity_partition proc~compute_sparsity_dense->proc~generate_dense_sparsity_partition proc~destroy_sparsity numerical_differentiation_module::sparsity_pattern%destroy_sparsity proc~destroy_sparsity_pattern->proc~destroy_sparsity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_sparsity_dense ( me , x ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) integer :: i !! counter integer :: r !! row counter integer :: c !! column counter call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions me % sparsity % num_nonzero_elements = me % m * me % n allocate ( me % sparsity % irow ( me % sparsity % num_nonzero_elements )) allocate ( me % sparsity % icol ( me % sparsity % num_nonzero_elements )) call me % sparsity % compute_indices () ! create the dense matrix: i = 0 do c = 1 , me % n do r = 1 , me % m i = i + 1 me % sparsity % irow ( i ) = r me % sparsity % icol ( i ) = c end do end do ! No real need for this, since it can't be partitioned (all elements are true) if ( me % partition_sparsity_pattern ) call me % generate_dense_sparsity_partition () me % sparsity % sparsity_computed = . true . end subroutine compute_sparsity_dense","tags":"","loc":"proc/compute_sparsity_dense.html"},{"title":"generate_dense_sparsity_partition – AoC-2023","text":"private  subroutine generate_dense_sparsity_partition(me) Generate a \"dense\" sparsity partition. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me Called by proc~~generate_dense_sparsity_partition~~CalledByGraph proc~generate_dense_sparsity_partition numerical_differentiation_module::numdiff_type%generate_dense_sparsity_partition proc~compute_sparsity_dense numerical_differentiation_module::compute_sparsity_dense proc~compute_sparsity_dense->proc~generate_dense_sparsity_partition proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~generate_dense_sparsity_partition Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine generate_dense_sparsity_partition ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer :: i !! counter if ( me % exception_raised ) return ! check for exceptions me % sparsity % maxgrp = me % n allocate ( me % sparsity % ngrp ( me % n )) me % sparsity % ngrp = [( i , i = 1 , me % n )] end subroutine generate_dense_sparsity_partition","tags":"","loc":"proc/generate_dense_sparsity_partition.html"},{"title":"compute_sparsity_random – AoC-2023","text":"private  subroutine compute_sparsity_random(me, x) Compute the sparsity pattern by computing the function at three\n\"random\" points in the [ xlow_for_sparsity , xhigh_for_sparsity ] interval\nand checking if the function values are the same. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n )\n(not used here) Calls proc~~compute_sparsity_random~~CallsGraph proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random interface~expand_vector numdiff_utilities_module::expand_vector proc~compute_sparsity_random->interface~expand_vector proc~compute_indices numerical_differentiation_module::sparsity_pattern%compute_indices proc~compute_sparsity_random->proc~compute_indices proc~destroy_sparsity_pattern numerical_differentiation_module::numdiff_type%destroy_sparsity_pattern proc~compute_sparsity_random->proc~destroy_sparsity_pattern proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~compute_sparsity_random->proc~dsm_wrapper proc~equal_within_tol numdiff_utilities_module::equal_within_tol proc~compute_sparsity_random->proc~equal_within_tol proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_sparsity_random->proc~raise_exception proc~resize_sparsity_vectors numerical_differentiation_module::numdiff_type%resize_sparsity_vectors proc~compute_sparsity_random->proc~resize_sparsity_vectors proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector->proc~expand_vector_real proc~destroy_sparsity numerical_differentiation_module::sparsity_pattern%destroy_sparsity proc~destroy_sparsity_pattern->proc~destroy_sparsity proc~dsm dsm_module::dsm proc~dsm_wrapper->proc~dsm proc~resize_sparsity_vectors->interface~expand_vector proc~degr dsm_module::degr proc~dsm->proc~degr proc~ido dsm_module::ido proc~dsm->proc~ido proc~numsrt dsm_module::numsrt proc~dsm->proc~numsrt proc~seq dsm_module::seq proc~dsm->proc~seq proc~setr dsm_module::setr proc~dsm->proc~setr proc~slo dsm_module::slo proc~dsm->proc~slo proc~srtdat dsm_module::srtdat proc~dsm->proc~srtdat proc~ido->proc~numsrt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_sparsity_random ( me , x ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) !! (not used here) integer :: i !! column counter integer :: j !! row counter integer :: n_icol !! `icol` size counter integer :: n_irow !! `irow` size counter integer :: n_linear_icol !! `linear_icol` size counter integer :: n_linear_irow !! `linear_irow` size counter integer :: n_linear_vals !! `linear_vals` size counter integer , dimension ( me % m ) :: idx !! indices to compute `[1,2,...,m]` real ( wp ), dimension ( me % n ) :: x1 !! perturbed variable vector real ( wp ), dimension ( me % n ) :: x2 !! perturbed variable vector real ( wp ), dimension ( me % n ) :: x3 !! perturbed variable vector real ( wp ), dimension ( me % n ) :: x4 !! perturbed variable vector real ( wp ), dimension ( me % m ) :: f1 !! function evaluation real ( wp ), dimension ( me % m ) :: f2 !! function evaluation real ( wp ), dimension ( me % m ) :: f3 !! function evaluation real ( wp ), dimension ( me % m ) :: f4 !! function evaluation real ( wp ) :: dfdx1 !! for linear sparsity estimation real ( wp ) :: dfdx2 !! for linear sparsity estimation real ( wp ) :: dfdx3 !! for linear sparsity estimation real ( wp ) :: dfdx !! for linear sparsity estimation integer :: info !! status output form [[dsm]] real ( wp ), dimension ( 4 ), parameter :: coeffs = [ 0.20123456787654321_wp ,& 0.40123456787654321_wp ,& 0.60123456787654321_wp ,& 0.80123456787654321_wp ] !! Pick three pseudo-random points roughly equally spaced. !! (add some noise in attempt to avoid freak zeros) !!```` !! xlow---|----|--x--|---xhigh !!        1    2     3 !!```` !! !! Also using an extra point to estimate the !! constant elements of the Jacobian. ! initialize: call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions ! error check: if (. not . allocated ( me % xlow_for_sparsity ) . or . . not . allocated ( me % xhigh_for_sparsity )) then call me % raise_exception ( 18 , 'compute_sparsity_random' ,& 'the x bounds have not been set.' ) return end if associate ( xlow => me % xlow_for_sparsity , xhigh => me % xhigh_for_sparsity ) ! we will compute all the functions: idx = [( i , i = 1 , me % m )] n_icol = 0 ! initialize vector size counters n_irow = 0 n_linear_icol = 0 n_linear_irow = 0 n_linear_vals = 0 ! define a nominal point roughly in the middle: x2 = xlow + ( xhigh - xlow ) * coeffs ( 2 ) call me % compute_function ( x2 , f2 , idx ) if ( me % exception_raised ) return ! check for exceptions if ( me % compute_linear_sparsity_pattern ) then ! we need another point where we perturb all the variables ! to check to make sure it is linear in only one variable. x4 = xlow + ( xhigh - xlow ) * coeffs ( 4 ) call me % compute_function ( x4 , f4 , idx ) if ( me % exception_raised ) return ! check for exceptions end if do i = 1 , me % n ! columns of Jacobian ! restore nominal: x1 = x2 x3 = x2 x1 ( i ) = xlow ( i ) + ( xhigh ( i ) - xlow ( i )) * coeffs ( 1 ) x3 ( i ) = xlow ( i ) + ( xhigh ( i ) - xlow ( i )) * coeffs ( 3 ) call me % compute_function ( x1 , f1 , idx ) if ( me % exception_raised ) return ! check for exceptions call me % compute_function ( x3 , f3 , idx ) if ( me % exception_raised ) return ! check for exceptions do j = 1 , me % m ! each function (rows of Jacobian) if ( equal_within_tol ([ f1 ( j ), f2 ( j ), f3 ( j )], me % function_precision_tol )) then ! no change in the function, so no sparsity element here. cycle else if ( me % compute_linear_sparsity_pattern ) then ! if computing the linear pattern separately. ! do the three points lie on a line? (x1,f1) -> (x2, f2), -> (x3,f3) ! [check that the slopes are equal within a tolerance] dfdx1 = ( f1 ( j ) - f2 ( j )) / ( x1 ( i ) - x2 ( i )) ! slope of line from 1->2 dfdx2 = ( f1 ( j ) - f3 ( j )) / ( x1 ( i ) - x3 ( i )) ! slope of line from 1->3 dfdx3 = ( f1 ( j ) - f4 ( j )) / ( x1 ( i ) - x4 ( i )) ! slope of line from 1->4 if ( equal_within_tol ([ dfdx1 , dfdx2 , dfdx3 ], me % linear_sparsity_tol )) then ! this is a linear element (constant value) dfdx = ( dfdx1 + dfdx2 + dfdx3 ) / 3.0_wp ! just take the average and use that call expand_vector ( me % sparsity % linear_icol , n_linear_icol , me % chunk_size , val = i ) call expand_vector ( me % sparsity % linear_irow , n_linear_irow , me % chunk_size , val = j ) call expand_vector ( me % sparsity % linear_vals , n_linear_vals , me % chunk_size , val = dfdx ) cycle ! this element will not be added to the nonlinear pattern end if end if ! otherwise, add it to the nonlinear pattern: call expand_vector ( me % sparsity % icol , n_icol , me % chunk_size , val = i ) call expand_vector ( me % sparsity % irow , n_irow , me % chunk_size , val = j ) end if end do end do ! resize to correct size: call me % resize_sparsity_vectors ( n_icol , n_irow , n_linear_icol ,& n_linear_irow , n_linear_vals ) end associate call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) then call me % sparsity % dsm_wrapper ( me % n , me % m , info ) if ( info /= 1 ) then call me % raise_exception ( 19 , 'compute_sparsity_random' ,& 'error partitioning sparsity pattern.' ) return end if end if ! finished: me % sparsity % sparsity_computed = . true . end subroutine compute_sparsity_random","tags":"","loc":"proc/compute_sparsity_random.html"},{"title":"resize_sparsity_vectors – AoC-2023","text":"private  subroutine resize_sparsity_vectors(me, n_icol, n_irow, n_linear_icol, n_linear_irow, n_linear_vals) Resize the sparsity arrays after accumulating them. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(inout) :: n_icol integer, intent(inout) :: n_irow integer, intent(inout) :: n_linear_icol integer, intent(inout) :: n_linear_irow integer, intent(inout) :: n_linear_vals Calls proc~~resize_sparsity_vectors~~CallsGraph proc~resize_sparsity_vectors numerical_differentiation_module::numdiff_type%resize_sparsity_vectors interface~expand_vector numdiff_utilities_module::expand_vector proc~resize_sparsity_vectors->interface~expand_vector proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector->proc~expand_vector_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~resize_sparsity_vectors~~CalledByGraph proc~resize_sparsity_vectors numerical_differentiation_module::numdiff_type%resize_sparsity_vectors proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~resize_sparsity_vectors proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~resize_sparsity_vectors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine resize_sparsity_vectors ( me , n_icol , n_irow , n_linear_icol ,& n_linear_irow , n_linear_vals ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( inout ) :: n_icol integer , intent ( inout ) :: n_irow integer , intent ( inout ) :: n_linear_icol integer , intent ( inout ) :: n_linear_irow integer , intent ( inout ) :: n_linear_vals if ( me % exception_raised ) return ! check for exceptions ! resize to correct size: if ( allocated ( me % sparsity % icol )) then call expand_vector ( me % sparsity % icol , n_icol , me % chunk_size , finished = . true .) call expand_vector ( me % sparsity % irow , n_irow , me % chunk_size , finished = . true .) me % sparsity % num_nonzero_elements = size ( me % sparsity % irow ) else me % sparsity % num_nonzero_elements = 0 end if ! linear pattern (note: there may be no linear elements): me % sparsity % linear_sparsity_computed = me % compute_linear_sparsity_pattern . and . & allocated ( me % sparsity % linear_vals ) if ( me % sparsity % linear_sparsity_computed ) then call expand_vector ( me % sparsity % linear_icol , n_linear_icol , me % chunk_size , finished = . true .) call expand_vector ( me % sparsity % linear_irow , n_linear_irow , me % chunk_size , finished = . true .) call expand_vector ( me % sparsity % linear_vals , n_linear_vals , me % chunk_size , finished = . true .) me % sparsity % num_nonzero_linear_elements = n_linear_vals else me % sparsity % num_nonzero_linear_elements = 0 end if end subroutine resize_sparsity_vectors","tags":"","loc":"proc/resize_sparsity_vectors.html"},{"title":"compute_sparsity_random_2 – AoC-2023","text":"private  subroutine compute_sparsity_random_2(me, x) Compute the sparsity pattern by computing a 2-point jacobian at a specified\nnumber of \"random\" points ( num_sparsity_points ) in the\n[ xlow_for_sparsity , xhigh_for_sparsity ] interval and checking if\nthey are the same. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n )\n(not used here) Calls proc~~compute_sparsity_random_2~~CallsGraph proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 interface~expand_vector numdiff_utilities_module::expand_vector proc~compute_sparsity_random_2->interface~expand_vector proc~compute_indices numerical_differentiation_module::sparsity_pattern%compute_indices proc~compute_sparsity_random_2->proc~compute_indices proc~compute_jacobian_for_sparsity numerical_differentiation_module::numdiff_type%compute_jacobian_for_sparsity proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity proc~destroy_sparsity_pattern numerical_differentiation_module::numdiff_type%destroy_sparsity_pattern proc~compute_sparsity_random_2->proc~destroy_sparsity_pattern proc~divide_interval numdiff_utilities_module::divide_interval proc~compute_sparsity_random_2->proc~divide_interval proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~compute_sparsity_random_2->proc~dsm_wrapper proc~equal_within_tol numdiff_utilities_module::equal_within_tol proc~compute_sparsity_random_2->proc~equal_within_tol proc~generate_dense_sparsity_partition numerical_differentiation_module::numdiff_type%generate_dense_sparsity_partition proc~compute_sparsity_random_2->proc~generate_dense_sparsity_partition proc~get_all_methods_in_class numerical_differentiation_module::get_all_methods_in_class proc~compute_sparsity_random_2->proc~get_all_methods_in_class proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_sparsity_random_2->proc~raise_exception proc~resize_sparsity_vectors numerical_differentiation_module::numdiff_type%resize_sparsity_vectors proc~compute_sparsity_random_2->proc~resize_sparsity_vectors proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector->proc~expand_vector_real proc~compute_sparsity_perturbation_vector numerical_differentiation_module::numdiff_type%compute_sparsity_perturbation_vector proc~compute_jacobian_for_sparsity->proc~compute_sparsity_perturbation_vector proc~perturb_x_and_compute_f numerical_differentiation_module::numdiff_type%perturb_x_and_compute_f proc~compute_jacobian_for_sparsity->proc~perturb_x_and_compute_f proc~select_finite_diff_method numerical_differentiation_module::numdiff_type%select_finite_diff_method proc~compute_jacobian_for_sparsity->proc~select_finite_diff_method proc~destroy_sparsity numerical_differentiation_module::sparsity_pattern%destroy_sparsity proc~destroy_sparsity_pattern->proc~destroy_sparsity interface~unique numdiff_utilities_module::unique proc~divide_interval->interface~unique proc~dsm dsm_module::dsm proc~dsm_wrapper->proc~dsm proc~get_finite_difference_method numerical_differentiation_module::get_finite_difference_method proc~get_all_methods_in_class->proc~get_finite_difference_method proc~resize_sparsity_vectors->interface~expand_vector proc~unique_int numdiff_utilities_module::unique_int interface~unique->proc~unique_int proc~unique_real numdiff_utilities_module::unique_real interface~unique->proc~unique_real proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_sparsity_perturbation_vector->proc~compute_perturb_vector proc~degr dsm_module::degr proc~dsm->proc~degr proc~ido dsm_module::ido proc~dsm->proc~ido proc~numsrt dsm_module::numsrt proc~dsm->proc~numsrt proc~seq dsm_module::seq proc~dsm->proc~seq proc~setr dsm_module::setr proc~dsm->proc~setr proc~slo dsm_module::slo proc~dsm->proc~slo proc~srtdat dsm_module::srtdat proc~dsm->proc~srtdat proc~compute_perturb_vector->proc~raise_exception proc~ido->proc~numsrt proc~unique_int->interface~expand_vector interface~sort_ascending numdiff_utilities_module::sort_ascending proc~unique_int->interface~sort_ascending proc~unique_real->interface~expand_vector proc~unique_real->interface~sort_ascending proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap numdiff_utilities_module::swap proc~sort_ascending_int->interface~swap proc~sort_ascending_real->interface~swap proc~swap_int numdiff_utilities_module::swap_int interface~swap->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_sparsity_random_2 ( me , x ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) !! (not used here) type :: jac_type !! so we can define an array of jacobian columns real ( wp ), dimension (:), allocatable :: jac !! a column of the jacobian end type jac_type real ( wp ), dimension (:), allocatable :: coeffs !! coefficients for computing `xp` real ( wp ), dimension (:,:), allocatable :: xp !! perturbed `x` array (size `n,num_sparsity_points`) type ( jac_type ), dimension (:), allocatable :: jac_array !! array of jacobian columns type ( sparsity_pattern ) :: tmp_sparsity_pattern !! will accumulate the pattern here !! and copy it into the class when !! finished. integer :: i !! counter for the number of points integer :: j !! counter integer :: icol !! column counter integer :: irow !! row counter real ( wp ) :: dfdx !! value of a jacobian element integer :: n_icol !! `icol` size counter integer :: n_irow !! `irow` size counter integer :: n_linear_icol !! `linear_icol` size counter integer :: n_linear_irow !! `linear_irow` size counter integer :: n_linear_vals !! `linear_vals` size counter type ( meth_array ) :: class_meths !! set of finite diff methods to use real ( wp ), dimension (:), allocatable :: jac !! array of jacobian element values integer :: info !! status output form [[dsm]] ! initialize: call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions ! error check: if (. not . allocated ( me % xlow_for_sparsity ) . or . . not . allocated ( me % xhigh_for_sparsity )) then call me % raise_exception ( 20 , 'compute_sparsity_random_2' ,& 'the x bounds have not been set.' ) return end if ! compute the coefficients: coeffs = divide_interval ( me % num_sparsity_points ) ! save the initial settings: tmp_sparsity_pattern = me % sparsity ! we create a provisional sparsity pattern here, ! to compute one row at a time: me % sparsity % irow = [( irow , irow = 1 , me % m )] me % sparsity % sparsity_computed = . true . me % sparsity % num_nonzero_elements = me % m call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) call me % generate_dense_sparsity_partition () n_icol = 0 n_irow = 0 n_linear_icol = 0 n_linear_irow = 0 n_linear_vals = 0 allocate ( jac ( me % num_sparsity_points )) ! the idea here is to compute the (dense) jacobian ! one column at at time, and keep a running track of ! the ones that have changed. ! first precompute the perturbation arrays for each point: allocate ( xp ( me % n , me % num_sparsity_points )) do i = 1 , me % num_sparsity_points xp (:, i ) = me % xlow_for_sparsity + ( me % xhigh_for_sparsity - me % xlow_for_sparsity ) * coeffs ( i ) end do ! we will use 2-point methods (simple differences): class_meths = get_all_methods_in_class ( 2 ) do icol = 1 , me % n ! column loop ! size the array: if ( allocated ( jac_array )) deallocate ( jac_array ) allocate ( jac_array ( me % num_sparsity_points )) ! compute the ith column of the jacobian: me % sparsity % icol = [( icol , j = 1 , me % m )] do i = 1 , me % num_sparsity_points call me % compute_jacobian_for_sparsity ( icol , class_meths , xp (:, i ), jac_array ( i )% jac ) if ( me % exception_raised ) return ! check for exceptions end do ! check each row: do irow = 1 , me % m ! get the jacobian values for this row,col for all the points: do j = 1 , me % num_sparsity_points jac ( j ) = jac_array ( j )% jac ( irow ) end do ! put the results into the tmp_sparsity_pattern if ( equal_within_tol ([ 0.0_wp , jac ], me % linear_sparsity_tol )) then ! they are all zero cycle else if ( me % compute_linear_sparsity_pattern ) then if ( equal_within_tol ( jac , me % linear_sparsity_tol )) then ! this is a linear element (constant value) dfdx = sum ( jac ) / me % num_sparsity_points ! just take the average and use that call expand_vector ( tmp_sparsity_pattern % linear_icol , n_linear_icol , me % chunk_size , val = icol ) call expand_vector ( tmp_sparsity_pattern % linear_irow , n_linear_irow , me % chunk_size , val = irow ) call expand_vector ( tmp_sparsity_pattern % linear_vals , n_linear_vals , me % chunk_size , val = dfdx ) cycle ! this element will not be added to the nonlinear pattern end if end if ! otherwise, add it to the nonlinear pattern: call expand_vector ( tmp_sparsity_pattern % icol , n_icol , me % chunk_size , val = icol ) call expand_vector ( tmp_sparsity_pattern % irow , n_irow , me % chunk_size , val = irow ) end if end do end do ! copy over the computed pattern: me % sparsity = tmp_sparsity_pattern ! resize to correct size: call me % resize_sparsity_vectors ( n_icol , n_irow , n_linear_icol ,& n_linear_irow , n_linear_vals ) call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) then call me % sparsity % dsm_wrapper ( me % n , me % m , info ) if ( info /= 1 ) then call me % raise_exception ( 21 , 'compute_sparsity_random_2' ,& 'error partitioning sparsity pattern.' ) return end if end if me % sparsity % sparsity_computed = . true . end subroutine compute_sparsity_random_2","tags":"","loc":"proc/compute_sparsity_random_2.html"},{"title":"compute_sparsity_pattern – AoC-2023","text":"private  subroutine compute_sparsity_pattern(me, x, irow, icol, linear_irow, linear_icol, linear_vals) Computes the sparsity pattern and return it.\nUses the settings currently in the class. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) integer, intent(out), dimension(:), allocatable :: irow sparsity pattern nonzero elements row indices integer, intent(out), dimension(:), allocatable :: icol sparsity pattern nonzero elements column indices integer, intent(out), optional, dimension(:), allocatable :: linear_irow linear sparsity pattern\nnonzero elements row indices integer, intent(out), optional, dimension(:), allocatable :: linear_icol linear sparsity pattern nonzero\nelements column indices real(kind=wp), intent(out), optional, dimension(:), allocatable :: linear_vals linear sparsity values (constant\nelements of the Jacobian) Calls proc~~compute_sparsity_pattern~~CallsGraph proc~compute_sparsity_pattern numerical_differentiation_module::numdiff_type%compute_sparsity_pattern proc~get_sparsity_pattern numerical_differentiation_module::numdiff_type%get_sparsity_pattern proc~compute_sparsity_pattern->proc~get_sparsity_pattern Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_sparsity_pattern ( me , x , irow , icol , linear_irow , linear_icol , linear_vals ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) integer , dimension (:), allocatable , intent ( out ) :: irow !! sparsity pattern nonzero elements row indices integer , dimension (:), allocatable , intent ( out ) :: icol !! sparsity pattern nonzero elements column indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_irow !! linear sparsity pattern !! nonzero elements row indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_icol !! linear sparsity pattern nonzero !! elements column indices real ( wp ), dimension (:), allocatable , intent ( out ), optional :: linear_vals !! linear sparsity values (constant !! elements of the Jacobian) if ( me % exception_raised ) return ! check for exceptions if ( associated ( me % compute_sparsity )) then call me % compute_sparsity ( x ) if ( me % exception_raised ) return ! check for exceptions call me % get_sparsity_pattern ( irow , icol , linear_irow , linear_icol , linear_vals ) end if end subroutine compute_sparsity_pattern","tags":"","loc":"proc/compute_sparsity_pattern.html"},{"title":"get_sparsity_pattern – AoC-2023","text":"private  subroutine get_sparsity_pattern(me, irow, icol, linear_irow, linear_icol, linear_vals, maxgrp, ngrp) Returns the sparsity pattern from the class.\nIf it hasn't been computed, the output arrays will not be allocated. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: irow sparsity pattern nonzero elements row indices integer, intent(out), dimension(:), allocatable :: icol sparsity pattern nonzero elements column indices integer, intent(out), optional, dimension(:), allocatable :: linear_irow linear sparsity pattern\nnonzero elements row indices integer, intent(out), optional, dimension(:), allocatable :: linear_icol linear sparsity pattern nonzero\nelements column indices real(kind=wp), intent(out), optional, dimension(:), allocatable :: linear_vals linear sparsity values (constant\nelements of the Jacobian) integer, intent(out), optional :: maxgrp DSM sparsity partition integer, intent(out), optional, dimension(:), allocatable :: ngrp DSM sparsity partition Called by proc~~get_sparsity_pattern~~CalledByGraph proc~get_sparsity_pattern numerical_differentiation_module::numdiff_type%get_sparsity_pattern proc~compute_sparsity_pattern numerical_differentiation_module::numdiff_type%compute_sparsity_pattern proc~compute_sparsity_pattern->proc~get_sparsity_pattern Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_sparsity_pattern ( me , irow , icol ,& linear_irow , linear_icol , linear_vals ,& maxgrp , ngrp ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , dimension (:), allocatable , intent ( out ) :: irow !! sparsity pattern nonzero elements row indices integer , dimension (:), allocatable , intent ( out ) :: icol !! sparsity pattern nonzero elements column indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_irow !! linear sparsity pattern !! nonzero elements row indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_icol !! linear sparsity pattern nonzero !! elements column indices real ( wp ), dimension (:), allocatable , intent ( out ), optional :: linear_vals !! linear sparsity values (constant !! elements of the Jacobian) integer , intent ( out ), optional :: maxgrp !! DSM sparsity partition integer , dimension (:), allocatable , intent ( out ), optional :: ngrp !! DSM sparsity partition if ( me % exception_raised ) return ! check for exceptions if ( allocated ( me % sparsity % irow ) . and . allocated ( me % sparsity % icol )) then irow = me % sparsity % irow icol = me % sparsity % icol end if ! optional linear pattern output: if ( present ( linear_irow )) then if ( allocated ( me % sparsity % linear_irow )) linear_irow = me % sparsity % linear_irow end if if ( present ( linear_icol )) then if ( allocated ( me % sparsity % linear_icol )) linear_icol = me % sparsity % linear_icol end if if ( present ( linear_vals )) then if ( allocated ( me % sparsity % linear_vals )) linear_vals = me % sparsity % linear_vals end if ! optional DSM partition: if ( present ( ngrp ) . and . allocated ( me % sparsity % ngrp )) ngrp = me % sparsity % ngrp if ( present ( maxgrp )) maxgrp = me % sparsity % maxgrp end subroutine get_sparsity_pattern","tags":"","loc":"proc/get_sparsity_pattern.html"},{"title":"compute_jacobian_dense – AoC-2023","text":"private  subroutine compute_jacobian_dense(me, x, jac) just a wrapper for compute_jacobian , that returns a dense ( m x n ) matrix. Note This one will include the constant elements if the linear pattern is available. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:,:), allocatable :: jac the jacobian matrix Calls proc~~compute_jacobian_dense~~CallsGraph proc~compute_jacobian_dense numerical_differentiation_module::numdiff_type%compute_jacobian_dense proc~compute_jacobian numerical_differentiation_module::numdiff_type%compute_jacobian proc~compute_jacobian_dense->proc~compute_jacobian proc~compute_perturbation_vector numerical_differentiation_module::numdiff_type%compute_perturbation_vector proc~compute_jacobian->proc~compute_perturbation_vector proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_jacobian->proc~raise_exception proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_perturbation_vector->proc~compute_perturb_vector proc~compute_perturb_vector->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian_dense ( me , x , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:,:), allocatable , intent ( out ) :: jac !! the jacobian matrix real ( wp ), dimension (:), allocatable :: jac_vec !! sparse jacobian representation integer :: i !! counter if ( me % exception_raised ) return ! check for exceptions ! size output matrix: allocate ( jac ( me % m , me % n )) ! convert to dense form: jac = zero ! compute sparse form of jacobian: call me % compute_jacobian ( x , jac_vec ) if ( me % exception_raised ) return ! check for exceptions if ( allocated ( jac_vec )) then ! add the nonlinear elements: do i = 1 , me % sparsity % num_nonzero_elements jac ( me % sparsity % irow ( i ), me % sparsity % icol ( i )) = jac_vec ( i ) end do deallocate ( jac_vec ) end if ! add the constant elements if necessary: do i = 1 , me % sparsity % num_nonzero_linear_elements jac ( me % sparsity % linear_irow ( i ), me % sparsity % linear_icol ( i )) = me % sparsity % linear_vals ( i ) end do end subroutine compute_jacobian_dense","tags":"","loc":"proc/compute_jacobian_dense.html"},{"title":"perturb_x_and_compute_f – AoC-2023","text":"private  subroutine perturb_x_and_compute_f(me, x, dx_factor, dx, df_factor, column, idx, df) Perturb the specified optimization variable, and compute the function.\nThis routine is designed so that df is accumulated as each function\nevaluation is done, to avoid having to allocate more temporary storage. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x nominal variable vector real(kind=wp), intent(in) :: dx_factor factor to multiply dx real(kind=wp), intent(in), dimension(:) :: dx the perturbation value for this column real(kind=wp), intent(in) :: df_factor factor to multiply function value integer, intent(in) :: column the variable to perturb integer, intent(in), dimension(:) :: idx the elements in this\ncolumn of the Jacobian\nto compute (passed to function) real(kind=wp), intent(inout), dimension(me%m) :: df the accumulated function value\nnote: for the first call, this\nshould be set to zero Called by proc~~perturb_x_and_compute_f~~CalledByGraph proc~perturb_x_and_compute_f numerical_differentiation_module::numdiff_type%perturb_x_and_compute_f proc~compute_jacobian_for_sparsity numerical_differentiation_module::numdiff_type%compute_jacobian_for_sparsity proc~compute_jacobian_for_sparsity->proc~perturb_x_and_compute_f proc~compute_jacobian_standard numerical_differentiation_module::compute_jacobian_standard proc~compute_jacobian_standard->proc~perturb_x_and_compute_f proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine perturb_x_and_compute_f ( me , x , dx_factor , dx ,& df_factor , column , idx , df ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! nominal variable vector real ( wp ), intent ( in ) :: dx_factor !! factor to multiply `dx` real ( wp ), dimension (:), intent ( in ) :: dx !! the perturbation value for this column real ( wp ), intent ( in ) :: df_factor !! factor to multiply function value integer , intent ( in ) :: column !! the variable to perturb integer , dimension (:), intent ( in ) :: idx !! the elements in this !! column of the Jacobian !! to compute (passed to function) real ( wp ), dimension ( me % m ), intent ( inout ) :: df !! the accumulated function value !! note: for the first call, this !! should be set to zero real ( wp ), dimension ( me % n ) :: xp !! the perturbed variable vector real ( wp ), dimension ( me % m ) :: f !! function evaluation if ( me % exception_raised ) return ! check for exceptions xp = x if ( dx_factor /= zero ) xp ( column ) = xp ( column ) + dx_factor * dx ( column ) call me % compute_function ( xp , f , idx ) if ( me % exception_raised ) return ! check for exceptions df ( idx ) = df ( idx ) + df_factor * f ( idx ) end subroutine perturb_x_and_compute_f","tags":"","loc":"proc/perturb_x_and_compute_f.html"},{"title":"compute_jacobian_times_vector – AoC-2023","text":"private  subroutine compute_jacobian_times_vector(me, x, v, z) Returns the product J*v , where J is the m x n Jacobian matrix\n  and v is an n x 1 vector. Note This one will include the constant elements if the linear pattern is available. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(:) :: v vector (size n ) real(kind=wp), intent(out), dimension(:) :: z The product J*v (size m ) Calls proc~~compute_jacobian_times_vector~~CallsGraph proc~compute_jacobian_times_vector numerical_differentiation_module::numdiff_type%compute_jacobian_times_vector proc~compute_jacobian numerical_differentiation_module::numdiff_type%compute_jacobian proc~compute_jacobian_times_vector->proc~compute_jacobian proc~compute_perturbation_vector numerical_differentiation_module::numdiff_type%compute_perturbation_vector proc~compute_jacobian->proc~compute_perturbation_vector proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_jacobian->proc~raise_exception proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_perturbation_vector->proc~compute_perturb_vector proc~compute_perturb_vector->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian_times_vector ( me , x , v , z ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:), intent ( in ) :: v !! vector (size `n`) real ( wp ), dimension (:), intent ( out ) :: z !! The product `J*v` (size `m`) real ( wp ), dimension (:), allocatable :: jac !! sparse jacobian vector integer :: i !! counter integer :: r !! row number in full jacobian integer :: c !! column number in full jacobian if ( me % exception_raised ) return ! check for exceptions ! first compute the jacobian in sparse vector form: call me % compute_jacobian ( x , jac ) if ( me % exception_raised ) return ! check for exceptions ! initialize output vector: z = 0.0_wp if ( allocated ( jac )) then !   J    v   z !  ---   -   - !  X0X   X   X !  0X0 * X = X !  00X   X   X !  00X       X ! multiplication by input v: do i = 1 , me % sparsity % num_nonzero_elements r = me % sparsity % irow ( i ) c = me % sparsity % icol ( i ) z ( r ) = z ( r ) + jac ( i ) * v ( c ) end do deallocate ( jac ) end if ! linear elements if available: do i = 1 , me % sparsity % num_nonzero_linear_elements r = me % sparsity % linear_irow ( i ) c = me % sparsity % linear_icol ( i ) z ( r ) = z ( r ) + me % sparsity % linear_vals ( i ) * v ( c ) end do end subroutine compute_jacobian_times_vector","tags":"","loc":"proc/compute_jacobian_times_vector.html"},{"title":"compute_jacobian – AoC-2023","text":"private  subroutine compute_jacobian(me, x, jac) Compute the Jacobian. Note The output jac only includes the elements of the nonlinear Jacobian.\n      If the constant elements are being handled separately (if the linear\n      pattern is available), then those elements can be obtained by\n      calling get_sparsity_pattern if required. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:), allocatable :: jac sparse jacobian vector Calls proc~~compute_jacobian~~CallsGraph proc~compute_jacobian numerical_differentiation_module::numdiff_type%compute_jacobian proc~compute_perturbation_vector numerical_differentiation_module::numdiff_type%compute_perturbation_vector proc~compute_jacobian->proc~compute_perturbation_vector proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_jacobian->proc~raise_exception proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_perturbation_vector->proc~compute_perturb_vector proc~compute_perturb_vector->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_jacobian~~CalledByGraph proc~compute_jacobian numerical_differentiation_module::numdiff_type%compute_jacobian proc~compute_jacobian_dense numerical_differentiation_module::numdiff_type%compute_jacobian_dense proc~compute_jacobian_dense->proc~compute_jacobian proc~compute_jacobian_times_vector numerical_differentiation_module::numdiff_type%compute_jacobian_times_vector proc~compute_jacobian_times_vector->proc~compute_jacobian program~test1 test1 program~test1->proc~compute_jacobian program~test2 test2 program~test2->proc~compute_jacobian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian ( me , x , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:), allocatable , intent ( out ) :: jac !! sparse jacobian vector real ( wp ), dimension ( me % n ) :: dx !! absolute perturbation (>0) for each variable if ( me % exception_raised ) return ! check for exceptions ! if we don't have a sparsity pattern yet then compute it: ! [also computes the indices vector] if (. not . me % sparsity % sparsity_computed ) call me % compute_sparsity ( x ) if ( me % sparsity % num_nonzero_elements == 0 ) return ! size the jacobian vector: allocate ( jac ( me % sparsity % num_nonzero_elements )) ! compute dx vector: if (. not . me % use_diff ) then ! only need this for the finite difference methods (not diff) call me % compute_perturbation_vector ( x , dx ) if ( me % exception_raised ) return ! check for exceptions end if ! compute the jacobian: if ( associated ( me % jacobian_function )) then call me % jacobian_function ( x , dx , jac ) else call me % raise_exception ( 22 , 'compute_jacobian' ,& 'jacobian_function has not been associated.' ) return end if end subroutine compute_jacobian","tags":"","loc":"proc/compute_jacobian.html"},{"title":"compute_jacobian_for_sparsity – AoC-2023","text":"private  subroutine compute_jacobian_for_sparsity(me, i, class_meths, x, jac) A separate version of compute_jacobian to be used only when\n  computing the sparsity pattern in compute_sparsity_random_2 .\n  It uses class_meths and the sparsity dperts and bounds. Note Based on compute_jacobian . The index manipulation here could be\n      greatly simplified, since we realdy know we are computed all the\n      elements in one column. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: i the column being computed type( meth_array ), intent(in) :: class_meths set of finite diff methods to use real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:), allocatable :: jac sparse jacobian vector Calls proc~~compute_jacobian_for_sparsity~~CallsGraph proc~compute_jacobian_for_sparsity numerical_differentiation_module::numdiff_type%compute_jacobian_for_sparsity proc~compute_sparsity_perturbation_vector numerical_differentiation_module::numdiff_type%compute_sparsity_perturbation_vector proc~compute_jacobian_for_sparsity->proc~compute_sparsity_perturbation_vector proc~perturb_x_and_compute_f numerical_differentiation_module::numdiff_type%perturb_x_and_compute_f proc~compute_jacobian_for_sparsity->proc~perturb_x_and_compute_f proc~select_finite_diff_method numerical_differentiation_module::numdiff_type%select_finite_diff_method proc~compute_jacobian_for_sparsity->proc~select_finite_diff_method proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_sparsity_perturbation_vector->proc~compute_perturb_vector proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_perturb_vector->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_jacobian_for_sparsity~~CalledByGraph proc~compute_jacobian_for_sparsity numerical_differentiation_module::numdiff_type%compute_jacobian_for_sparsity proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian_for_sparsity ( me , i , class_meths , x , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: i !! the column being computed type ( meth_array ), intent ( in ) :: class_meths !! set of finite diff methods to use real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:), allocatable , intent ( out ) :: jac !! sparse jacobian vector real ( wp ), dimension ( me % n ) :: dx !! absolute perturbation (>0) for each variable integer , dimension (:), allocatable :: nonzero_elements_in_col !! the indices of the !! nonzero Jacobian !! elements in a column integer :: j !! function evaluation counter real ( wp ), dimension ( me % m ) :: df !! accumulated function type ( finite_diff_method ) :: fd !! a finite different method (when !! specifying class rather than the method) logical :: status_ok !! error flag integer :: num_nonzero_elements_in_col !! number of nonzero elements in a column if ( me % exception_raised ) return ! check for exceptions ! Note that a sparsity pattern has already been set ! size the jacobian vector: allocate ( jac ( me % sparsity % num_nonzero_elements )) ! compute the perturbation vector (really we only need dx(i)): call me % compute_sparsity_perturbation_vector ( x , dx ) if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero ! determine functions to compute for this column: num_nonzero_elements_in_col = count ( me % sparsity % icol == i ) if ( num_nonzero_elements_in_col /= 0 ) then ! there are functions to compute nonzero_elements_in_col = pack ( me % sparsity % irow , mask = me % sparsity % icol == i ) call me % select_finite_diff_method ( x ( i ), me % xlow_for_sparsity ( i ), me % xhigh_for_sparsity ( i ),& dx ( i ), class_meths , fd , status_ok ) if (. not . status_ok ) then if ( me % print_messages ) then write ( error_unit , '(A,1X,I5)' ) & 'Error in compute_jacobian_for_sparsity: variable bounds violated for column: ' , i end if end if ! compute this column of the Jacobian: df = zero do j = 1 , size ( fd % dx_factors ) if ( associated ( me % info_function )) call me % info_function ([ i ], j , x ) call me % perturb_x_and_compute_f ( x , fd % dx_factors ( j ),& dx , fd % df_factors ( j ),& i , nonzero_elements_in_col , df ) if ( me % exception_raised ) return ! check for exceptions end do df ( nonzero_elements_in_col ) = df ( nonzero_elements_in_col ) / & ( fd % df_den_factor * dx ( i )) ! put result into the output vector: jac ( pack ( me % sparsity % indices , mask = me % sparsity % icol == i )) = & df ( nonzero_elements_in_col ) end if end subroutine compute_jacobian_for_sparsity","tags":"","loc":"proc/compute_jacobian_for_sparsity.html"},{"title":"compute_jacobian_standard – AoC-2023","text":"private  subroutine compute_jacobian_standard(me, x, dx, jac) Compute the Jacobian using finite differences.\n(one column at a time) Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector (size num_nonzero_elements ) Calls proc~~compute_jacobian_standard~~CallsGraph proc~compute_jacobian_standard numerical_differentiation_module::compute_jacobian_standard proc~perturb_x_and_compute_f numerical_differentiation_module::numdiff_type%perturb_x_and_compute_f proc~compute_jacobian_standard->proc~perturb_x_and_compute_f proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_jacobian_standard->proc~raise_exception proc~select_finite_diff_method numerical_differentiation_module::numdiff_type%select_finite_diff_method proc~compute_jacobian_standard->proc~select_finite_diff_method Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian_standard ( me , x , dx , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) !! for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector (size !! `num_nonzero_elements`) integer , dimension (:), allocatable :: nonzero_elements_in_col !! the indices of the !! nonzero Jacobian !! elements in a column integer :: i !! column counter integer :: j !! function evaluation counter real ( wp ), dimension ( me % m ) :: df !! accumulated function type ( finite_diff_method ) :: fd !! a finite different method (when !! specifying class rather than the method) logical :: status_ok !! error flag integer :: num_nonzero_elements_in_col !! number of nonzero elements in a column if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero ! compute Jacobian matrix column-by-column: do i = 1 , me % n ! determine functions to compute for this column: num_nonzero_elements_in_col = count ( me % sparsity % icol == i ) if ( num_nonzero_elements_in_col /= 0 ) then ! there are functions to compute nonzero_elements_in_col = pack ( me % sparsity % irow , mask = me % sparsity % icol == i ) select case ( me % mode ) case ( 1 ) ! use the specified methods ! compute this column of the Jacobian: df = zero do j = 1 , size ( me % meth ( i )% dx_factors ) if ( associated ( me % info_function )) call me % info_function ([ i ], j , x ) call me % perturb_x_and_compute_f ( x , me % meth ( i )% dx_factors ( j ),& dx , me % meth ( i )% df_factors ( j ),& i , nonzero_elements_in_col , df ) if ( me % exception_raised ) return ! check for exceptions end do df ( nonzero_elements_in_col ) = df ( nonzero_elements_in_col ) / & ( me % meth ( i )% df_den_factor * dx ( i )) case ( 2 ) ! select the method from the class so as not to violate the bounds call me % select_finite_diff_method ( x ( i ), me % xlow ( i ), me % xhigh ( i ),& dx ( i ), me % class_meths ( i ), fd , status_ok ) if (. not . status_ok ) then if ( me % print_messages ) then write ( error_unit , '(A,1X,I5)' ) & 'Error in compute_jacobian_standard: variable bounds violated for column: ' , i end if end if ! compute this column of the Jacobian: df = zero do j = 1 , size ( fd % dx_factors ) if ( associated ( me % info_function )) call me % info_function ([ i ], j , x ) call me % perturb_x_and_compute_f ( x , fd % dx_factors ( j ),& dx , fd % df_factors ( j ),& i , nonzero_elements_in_col , df ) if ( me % exception_raised ) return ! check for exceptions end do df ( nonzero_elements_in_col ) = df ( nonzero_elements_in_col ) / & ( fd % df_den_factor * dx ( i )) case default call me % raise_exception ( 23 , 'compute_jacobian_standard' ,& 'invalid mode' ) return end select ! put result into the output vector: jac ( pack ( me % sparsity % indices , mask = me % sparsity % icol == i )) = & df ( nonzero_elements_in_col ) end if end do end subroutine compute_jacobian_standard","tags":"","loc":"proc/compute_jacobian_standard.html"},{"title":"compute_jacobian_with_diff – AoC-2023","text":"private  subroutine compute_jacobian_with_diff(me, x, dx, jac) Compute the Jacobian one element at a time using the Neville's process\nalgorithm diff . This takes a very large number of function evaluations,\nbut should give a very accurate answer. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector (size num_nonzero_elements ) Calls proc~~compute_jacobian_with_diff~~CallsGraph proc~compute_jacobian_with_diff numerical_differentiation_module::compute_jacobian_with_diff proc~diff diff_module::diff_func%diff proc~compute_jacobian_with_diff->proc~diff proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_jacobian_with_diff->proc~raise_exception proc~set_function diff_module::diff_func%set_function proc~compute_jacobian_with_diff->proc~set_function proc~faccur diff_module::diff_func%faccur proc~diff->proc~faccur Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian_with_diff ( me , x , dx , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) !! for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector (size !! `num_nonzero_elements`) integer , parameter :: iord = 1 !! tells [[diff]] to compute first derivative integer :: i !! counter for nonzero elements of jacobian type ( diff_func ) :: d !! the [[diff]] class to use real ( wp ) :: x0 !! value of ith variable for [[diff]] real ( wp ) :: xmin !! ith variable lower bound real ( wp ) :: xmax !! ith variable upper bound real ( wp ) :: deriv !! derivative value df/dx from [[diff]] real ( wp ) :: error !! estimated error from [[diff]] integer :: ifail !! [[diff]] error flag real ( wp ), dimension ( me % n ) :: xp !! used by [[dfunc]]. real ( wp ), dimension ( me % m ) :: fvec !! used by [[dfunc]]. integer :: ir !! row index of next non-zero element integer :: ic !! column index of next non-zero element integer :: ic_prev !! previous column perturbed integer :: icount !! count of number of times a column has been perturbed logical :: use_info !! if we are reporting to the user if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero use_info = associated ( me % info_function ) if ( use_info ) ic_prev = - 1 ! set the function for diff: call d % set_function ( dfunc ) ! each element is computed one by one do i = 1 , me % sparsity % num_nonzero_elements ir = me % sparsity % irow ( i ) ic = me % sparsity % icol ( i ) x0 = x ( ic ) xmin = me % xlow ( ic ) xmax = me % xhigh ( ic ) ! if reporting to the user, have to keep track ! of which column is being perturbed, and how ! many times: if ( use_info ) then if ( ic /= ic_prev ) icount = 0 end if call d % compute_derivative ( iord , x0 , xmin , xmax , me % eps , me % acc , deriv , error , ifail ) if ( ifail == 0 . or . ifail == 1 ) then jac ( i ) = deriv else if ( ifail == - 1 ) then ! this indicates an exception was ! already raised, so just return. return else call me % raise_exception ( 24 , 'compute_jacobian_with_diff' ,& 'error computing derivative with DIFF.' ) return end if if ( use_info ) ic_prev = ic end do contains function dfunc ( this , xval ) result ( fx ) !! interface to user function for [[diff]] routine. implicit none class ( diff_func ), intent ( inout ) :: this real ( wp ), intent ( in ) :: xval !! input variable (`ic` variable) real ( wp ) :: fx !! derivative of `ir` function !! w.r.t. `xval` variable if ( use_info ) then icount = icount + 1 call me % info_function ([ ic ], icount , x ) end if xp = x xp ( ic ) = xval call me % compute_function ( xp , fvec , funcs_to_compute = [ ir ]) if ( me % exception_raised ) then ! check for exceptions fx = 0.0_wp call me % terminate () else fx = fvec ( ir ) end if end function dfunc end subroutine compute_jacobian_with_diff","tags":"","loc":"proc/compute_jacobian_with_diff.html"},{"title":"compute_jacobian_partitioned – AoC-2023","text":"private  subroutine compute_jacobian_partitioned(me, x, dx, jac) Compute the Jacobian using finite differences,\n(using the partitioned sparsity pattern to compute multiple columns\nat a time). Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0) for each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector Calls proc~~compute_jacobian_partitioned~~CallsGraph proc~compute_jacobian_partitioned numerical_differentiation_module::compute_jacobian_partitioned proc~columns_in_partition_group numerical_differentiation_module::sparsity_pattern%columns_in_partition_group proc~compute_jacobian_partitioned->proc~columns_in_partition_group proc~perturb_x_and_compute_f_partitioned numerical_differentiation_module::numdiff_type%perturb_x_and_compute_f_partitioned proc~compute_jacobian_partitioned->proc~perturb_x_and_compute_f_partitioned proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_jacobian_partitioned->proc~raise_exception proc~select_finite_diff_method_for_partition_group numerical_differentiation_module::numdiff_type%select_finite_diff_method_for_partition_group proc~compute_jacobian_partitioned->proc~select_finite_diff_method_for_partition_group Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian_partitioned ( me , x , dx , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector integer :: i !! column counter integer :: j !! function evaluation counter integer :: igroup !! group number counter integer :: n_cols !! number of columns in a group integer , dimension (:), allocatable :: cols !! array of column indices in a group integer , dimension (:), allocatable :: nonzero_rows !! the indices of the nonzero Jacobian !! elementes (row numbers) in a group integer , dimension (:), allocatable :: indices !! nonzero indices in `jac` for a group integer , dimension (:), allocatable :: col_indices !! nonzero indices in `jac` for a column real ( wp ), dimension ( me % m ) :: df !! accumulated function type ( finite_diff_method ) :: fd !! a finite different method (when !! specifying class rather than the method) logical :: status_ok !! error flag integer :: num_nonzero_elements_in_col if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero ! compute by group: do igroup = 1 , me % sparsity % maxgrp ! get the columns in this group: call me % sparsity % columns_in_partition_group ( igroup , n_cols , cols ,& nonzero_rows , indices , status_ok ) if (. not . status_ok ) then call me % raise_exception ( 25 , 'compute_jacobian_partitioned' ,& 'the partition has not been computed.' ) return end if if ( n_cols > 0 ) then if ( allocated ( nonzero_rows )) then select case ( me % mode ) case ( 1 ) ! use the specified methods ! note: all the methods must be the same within a group ! compute the columns of the Jacobian in this group: df = zero do j = 1 , size ( me % meth ( 1 )% dx_factors ) if ( associated ( me % info_function )) call me % info_function ( cols , j , x ) call me % perturb_x_and_compute_f_partitioned ( x , me % meth ( 1 )% dx_factors ( j ),& dx , me % meth ( 1 )% df_factors ( j ),& cols , nonzero_rows , df ) if ( me % exception_raised ) return ! check for exceptions end do ! divide by the denominator, which can be different for each column: do i = 1 , n_cols num_nonzero_elements_in_col = count ( me % sparsity % icol == cols ( i )) if ( allocated ( col_indices )) deallocate ( col_indices ) allocate ( col_indices ( num_nonzero_elements_in_col )) col_indices = pack ( me % sparsity % indices , mask = me % sparsity % icol == cols ( i )) df ( me % sparsity % irow ( col_indices )) = df ( me % sparsity % irow ( col_indices )) / & ( me % meth ( 1 )% df_den_factor * dx ( cols ( i ))) end do case ( 2 ) ! select the method from the class so as not to violate ! the bounds on *any* of the variables in the group ! note: all the classes must be the same within a group call me % select_finite_diff_method_for_partition_group ( & x ( cols ), me % xlow ( cols ), me % xhigh ( cols ),& dx ( cols ), me % class_meths ( 1 ), fd , status_ok ) if (. not . status_ok ) then if ( me % print_messages ) then ! will not consider this a fatal error for now: write ( error_unit , '(A,1X,I5,1X,A,1X,*(I5,1X))' ) & 'Error in compute_jacobian_partitioned: ' // & 'variable bounds violated for group: ' ,& igroup , '. columns: ' , cols end if end if ! compute the columns of the Jacobian in this group: df = zero do j = 1 , size ( fd % dx_factors ) if ( associated ( me % info_function )) call me % info_function ( cols , j , x ) call me % perturb_x_and_compute_f_partitioned ( x , fd % dx_factors ( j ),& dx , fd % df_factors ( j ),& cols , nonzero_rows , df ) if ( me % exception_raised ) return ! check for exceptions end do ! divide by the denominator, which can be different for each column: do i = 1 , n_cols num_nonzero_elements_in_col = count ( me % sparsity % icol == cols ( i )) if ( allocated ( col_indices )) deallocate ( col_indices ) allocate ( col_indices ( num_nonzero_elements_in_col )) col_indices = pack ( me % sparsity % indices , mask = me % sparsity % icol == cols ( i )) df ( me % sparsity % irow ( col_indices )) = df ( me % sparsity % irow ( col_indices )) / & ( fd % df_den_factor * dx ( cols ( i ))) end do case default call me % raise_exception ( 26 , 'compute_jacobian_partitioned' , 'invalid mode' ) return end select ! put result into the output vector: jac ( indices ) = df ( nonzero_rows ) end if end if end do end subroutine compute_jacobian_partitioned","tags":"","loc":"proc/compute_jacobian_partitioned.html"},{"title":"perturb_x_and_compute_f_partitioned – AoC-2023","text":"private  subroutine perturb_x_and_compute_f_partitioned(me, x, dx_factor, dx, df_factor, columns, idx, df) Perturb the specified optimization variable, and compute the function.\nThis routine is designed so that df is accumulated as each function\nevaluation is done, to avoid having to allocate more temporary storage. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x nominal variable vector real(kind=wp), intent(in) :: dx_factor factor to multiply dx real(kind=wp), intent(in), dimension(:) :: dx the perturbation value for this column real(kind=wp), intent(in) :: df_factor factor to multiply function value integer, intent(in), dimension(:) :: columns the variables to perturb integer, intent(in), dimension(:) :: idx the elements in this\ncolumn of the Jacobian\nto compute (passed to function) real(kind=wp), intent(inout), dimension(me%m) :: df the accumulated function value\nnote: for the first call, this\nshould be set to zero Called by proc~~perturb_x_and_compute_f_partitioned~~CalledByGraph proc~perturb_x_and_compute_f_partitioned numerical_differentiation_module::numdiff_type%perturb_x_and_compute_f_partitioned proc~compute_jacobian_partitioned numerical_differentiation_module::compute_jacobian_partitioned proc~compute_jacobian_partitioned->proc~perturb_x_and_compute_f_partitioned Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine perturb_x_and_compute_f_partitioned ( me , x , dx_factor , dx ,& df_factor , columns , idx , df ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! nominal variable vector real ( wp ), intent ( in ) :: dx_factor !! factor to multiply `dx` real ( wp ), dimension (:), intent ( in ) :: dx !! the perturbation value for this column real ( wp ), intent ( in ) :: df_factor !! factor to multiply function value integer , dimension (:), intent ( in ) :: columns !! the variables to perturb integer , dimension (:), intent ( in ) :: idx !! the elements in this !! column of the Jacobian !! to compute (passed to function) real ( wp ), dimension ( me % m ), intent ( inout ) :: df !! the accumulated function value !! note: for the first call, this !! should be set to zero real ( wp ), dimension ( me % n ) :: xp !! the perturbed variable vector real ( wp ), dimension ( me % m ) :: f !! function evaluation if ( me % exception_raised ) return ! check for exceptions xp = x if ( dx_factor /= zero ) xp ( columns ) = xp ( columns ) + dx_factor * dx ( columns ) call me % compute_function ( xp , f , idx ) if ( me % exception_raised ) return ! check for exceptions df ( idx ) = df ( idx ) + df_factor * f ( idx ) end subroutine perturb_x_and_compute_f_partitioned","tags":"","loc":"proc/perturb_x_and_compute_f_partitioned.html"},{"title":"compute_perturb_vector – AoC-2023","text":"private  subroutine compute_perturb_vector(me, x, dpert, perturb_mode, dx) Compute dx , the perturbation vector for x Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dpert integer, intent(in) :: perturb_mode real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable Calls proc~~compute_perturb_vector~~CallsGraph proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_perturb_vector->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_perturb_vector~~CalledByGraph proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_perturbation_vector numerical_differentiation_module::numdiff_type%compute_perturbation_vector proc~compute_perturbation_vector->proc~compute_perturb_vector proc~compute_sparsity_perturbation_vector numerical_differentiation_module::numdiff_type%compute_sparsity_perturbation_vector proc~compute_sparsity_perturbation_vector->proc~compute_perturb_vector proc~compute_jacobian numerical_differentiation_module::numdiff_type%compute_jacobian proc~compute_jacobian->proc~compute_perturbation_vector proc~compute_jacobian_for_sparsity numerical_differentiation_module::numdiff_type%compute_jacobian_for_sparsity proc~compute_jacobian_for_sparsity->proc~compute_sparsity_perturbation_vector proc~compute_jacobian_dense numerical_differentiation_module::numdiff_type%compute_jacobian_dense proc~compute_jacobian_dense->proc~compute_jacobian proc~compute_jacobian_times_vector numerical_differentiation_module::numdiff_type%compute_jacobian_times_vector proc~compute_jacobian_times_vector->proc~compute_jacobian proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity program~test1 test1 program~test1->proc~compute_jacobian program~test2 test2 program~test2->proc~compute_jacobian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_perturb_vector ( me , x , dpert , perturb_mode , dx ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dpert integer , intent ( in ) :: perturb_mode real ( wp ), dimension ( me % n ), intent ( out ) :: dx !! absolute perturbation (>0) !! for each variable real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) !! the smallest allowed absolute step if ( me % exception_raised ) return ! check for exceptions select case ( perturb_mode ) case ( 1 ) dx = abs ( dpert ) case ( 2 ) dx = abs ( dpert * x ) case ( 3 ) dx = abs ( dpert ) * ( 1.0_wp + abs ( x )) case default call me % raise_exception ( 27 , 'compute_perturb_vector' ,& 'invalid value for perturb_mode (must be 1, 2, or 3)' ) return end select ! make sure none are too small: where ( dx < eps ) dx = eps end where end subroutine compute_perturb_vector","tags":"","loc":"proc/compute_perturb_vector.html"},{"title":"compute_perturbation_vector – AoC-2023","text":"private  subroutine compute_perturbation_vector(me, x, dx) Compute dx , the perturbation vector for x used\nwhen computing the gradients. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable Calls proc~~compute_perturbation_vector~~CallsGraph proc~compute_perturbation_vector numerical_differentiation_module::numdiff_type%compute_perturbation_vector proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_perturbation_vector->proc~compute_perturb_vector proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_perturb_vector->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_perturbation_vector~~CalledByGraph proc~compute_perturbation_vector numerical_differentiation_module::numdiff_type%compute_perturbation_vector proc~compute_jacobian numerical_differentiation_module::numdiff_type%compute_jacobian proc~compute_jacobian->proc~compute_perturbation_vector proc~compute_jacobian_dense numerical_differentiation_module::numdiff_type%compute_jacobian_dense proc~compute_jacobian_dense->proc~compute_jacobian proc~compute_jacobian_times_vector numerical_differentiation_module::numdiff_type%compute_jacobian_times_vector proc~compute_jacobian_times_vector->proc~compute_jacobian program~test1 test1 program~test1->proc~compute_jacobian program~test2 test2 program~test2->proc~compute_jacobian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_perturbation_vector ( me , x , dx ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( out ) :: dx !! absolute perturbation (>0) !! for each variable if ( me % exception_raised ) return ! check for exceptions call me % compute_perturb_vector ( x , me % dpert , me % perturb_mode , dx ) end subroutine compute_perturbation_vector","tags":"","loc":"proc/compute_perturbation_vector.html"},{"title":"compute_sparsity_perturbation_vector – AoC-2023","text":"private  subroutine compute_sparsity_perturbation_vector(me, x, dx) Compute dx , the perturbation vector for x used\nwhen computing the sparsity pattern. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable Calls proc~~compute_sparsity_perturbation_vector~~CallsGraph proc~compute_sparsity_perturbation_vector numerical_differentiation_module::numdiff_type%compute_sparsity_perturbation_vector proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_sparsity_perturbation_vector->proc~compute_perturb_vector proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_perturb_vector->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_sparsity_perturbation_vector~~CalledByGraph proc~compute_sparsity_perturbation_vector numerical_differentiation_module::numdiff_type%compute_sparsity_perturbation_vector proc~compute_jacobian_for_sparsity numerical_differentiation_module::numdiff_type%compute_jacobian_for_sparsity proc~compute_jacobian_for_sparsity->proc~compute_sparsity_perturbation_vector proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_sparsity_perturbation_vector ( me , x , dx ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( out ) :: dx !! absolute perturbation (>0) !! for each variable if ( me % exception_raised ) return ! check for exceptions call me % compute_perturb_vector ( x , me % dpert_for_sparsity , me % sparsity_perturb_mode , dx ) end subroutine compute_sparsity_perturbation_vector","tags":"","loc":"proc/compute_sparsity_perturbation_vector.html"},{"title":"print_sparsity – AoC-2023","text":"private  subroutine print_sparsity(me, n, m, iunit, dense) Print the sparsity pattern. Type Bound sparsity_pattern Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(in) :: me integer, intent(in) :: n number of variables (columns of jacobian) integer, intent(in) :: m number of functions (rows of jacobian) integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) logical, intent(in), optional :: dense if present and true, the matrix form\nof the sparsity pattern is printed\n(default is vector form) Source Code subroutine print_sparsity ( me , n , m , iunit , dense ) implicit none class ( sparsity_pattern ), intent ( in ) :: me integer , intent ( in ) :: n !! number of variables (columns of jacobian) integer , intent ( in ) :: m !! number of functions (rows of jacobian) integer , intent ( in ) :: iunit !! file unit to write to. !! (assumed to be already opened) logical , intent ( in ), optional :: dense !! if present and true, the matrix form !! of the sparsity pattern is printed !! (default is vector form) logical :: print_matrix !! if the matrix form is to be printed integer :: r !! row counter character ( len = 1 ), dimension ( n ) :: row !! a row of the sparsity matrix if ( present ( dense )) then print_matrix = dense else print_matrix = . false . ! default end if write ( iunit , '(A)' ) '---Sparsity pattern---' if ( allocated ( me % irow ) . and . allocated ( me % icol )) then if ( print_matrix ) then do r = 1 , m ! print by row row = '0' row ( pack ( me % icol , mask = me % irow == r )) = 'X' write ( iunit , '(*(A1))' ) row end do else write ( iunit , '(A,1X,*(I3,\",\"))' ) 'irow:' , me % irow write ( iunit , '(A,1X,*(I3,\",\"))' ) 'icol:' , me % icol end if if ( allocated ( me % ngrp )) then write ( iunit , '(A)' ) '' write ( iunit , '(A)' ) '---Sparsity partition---' write ( iunit , '(A,1x,I5)' ) 'Number of groups:' , me % maxgrp write ( iunit , '(A,1x,*(I5,1X))' ) 'Group array:     ' , me % ngrp end if end if write ( iunit , '(A)' ) '' ! print linear pattern if available if ( me % linear_sparsity_computed ) then write ( iunit , '(A)' ) '---Linear sparsity pattern---' if ( allocated ( me % linear_icol ) . and . allocated ( me % linear_irow )) then if ( print_matrix ) then do r = 1 , m ! print by row row = '0' row ( pack ( me % linear_icol , mask = me % linear_irow == r )) = 'X' write ( iunit , '(*(A1))' ) row end do else write ( iunit , '(A,1X,*(I3,\",\"))' ) 'irow:' , me % linear_irow write ( iunit , '(A,1X,*(I3,\",\"))' ) 'icol:' , me % linear_icol write ( iunit , '(A,1X,*(E30.16,\",\"))' ) 'vals:' , me % linear_vals end if end if write ( iunit , '(A)' ) '' end if end subroutine print_sparsity","tags":"","loc":"proc/print_sparsity.html"},{"title":"print_sparsity_pattern – AoC-2023","text":"private  subroutine print_sparsity_pattern(me, iunit) Print the sparsity pattern in vector form ( irow , icol ). Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) Called by proc~~print_sparsity_pattern~~CalledByGraph proc~print_sparsity_pattern numerical_differentiation_module::numdiff_type%print_sparsity_pattern program~test1 test1 program~test1->proc~print_sparsity_pattern Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine print_sparsity_pattern ( me , iunit ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: iunit !! file unit to write to. !! (assumed to be already opened) call me % sparsity % print ( me % n , me % m , iunit , dense = . false .) end subroutine print_sparsity_pattern","tags":"","loc":"proc/print_sparsity_pattern.html"},{"title":"print_sparsity_matrix – AoC-2023","text":"private  subroutine print_sparsity_matrix(me, iunit) Print the sparsity pattern in matrix form. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) Called by proc~~print_sparsity_matrix~~CalledByGraph proc~print_sparsity_matrix numerical_differentiation_module::numdiff_type%print_sparsity_matrix program~test1 test1 program~test1->proc~print_sparsity_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine print_sparsity_matrix ( me , iunit ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: iunit !! file unit to write to. !! (assumed to be already opened) call me % sparsity % print ( me % n , me % m , iunit , dense = . true .) end subroutine print_sparsity_matrix","tags":"","loc":"proc/print_sparsity_matrix.html"},{"title":"terminate – AoC-2023","text":"private  subroutine terminate(me) A user-callable routine. When called, it will terminate\nall computations and return. The istat return code will be\nset to -1 . This can be called in the function or the info function. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me Source Code subroutine terminate ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me if ( me % exception_raised ) return ! check for existing exceptions me % istat = - 1 me % error_msg = 'Terminated by the user' me % exception_raised = . true . end subroutine terminate","tags":"","loc":"proc/terminate.html"},{"title":"raise_exception – AoC-2023","text":"private  subroutine raise_exception(me, istat, routine, error_msg) Raise an exception. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: istat error code. character(len=*), intent(in) :: routine the routine where the error was raised. character(len=*), intent(in) :: error_msg error message string. Called by proc~~raise_exception~~CalledByGraph proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_jacobian numerical_differentiation_module::numdiff_type%compute_jacobian proc~compute_jacobian->proc~raise_exception proc~compute_perturbation_vector numerical_differentiation_module::numdiff_type%compute_perturbation_vector proc~compute_jacobian->proc~compute_perturbation_vector proc~compute_jacobian_partitioned numerical_differentiation_module::compute_jacobian_partitioned proc~compute_jacobian_partitioned->proc~raise_exception proc~compute_jacobian_standard numerical_differentiation_module::compute_jacobian_standard proc~compute_jacobian_standard->proc~raise_exception proc~compute_jacobian_with_diff numerical_differentiation_module::compute_jacobian_with_diff proc~compute_jacobian_with_diff->proc~raise_exception proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_perturb_vector->proc~raise_exception proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~raise_exception proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~raise_exception proc~compute_jacobian_for_sparsity numerical_differentiation_module::numdiff_type%compute_jacobian_for_sparsity proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~raise_exception proc~set_numdiff_bounds numerical_differentiation_module::numdiff_type%set_numdiff_bounds proc~initialize_numdiff->proc~set_numdiff_bounds proc~set_sparsity_mode numerical_differentiation_module::numdiff_type%set_sparsity_mode proc~initialize_numdiff->proc~set_sparsity_mode proc~initialize_numdiff_for_diff numerical_differentiation_module::numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~raise_exception proc~initialize_numdiff_for_diff->proc~set_numdiff_bounds proc~initialize_numdiff_for_diff->proc~set_sparsity_mode proc~set_numdiff_bounds->proc~raise_exception proc~set_numdiff_sparsity_bounds numerical_differentiation_module::numdiff_type%set_numdiff_sparsity_bounds proc~set_numdiff_sparsity_bounds->proc~raise_exception proc~set_sparsity_mode->proc~raise_exception proc~set_sparsity_mode->proc~set_numdiff_sparsity_bounds proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~raise_exception proc~compute_jacobian_dense numerical_differentiation_module::numdiff_type%compute_jacobian_dense proc~compute_jacobian_dense->proc~compute_jacobian proc~compute_jacobian_times_vector numerical_differentiation_module::numdiff_type%compute_jacobian_times_vector proc~compute_jacobian_times_vector->proc~compute_jacobian proc~compute_perturbation_vector->proc~compute_perturb_vector proc~compute_sparsity_perturbation_vector numerical_differentiation_module::numdiff_type%compute_sparsity_perturbation_vector proc~compute_sparsity_perturbation_vector->proc~compute_perturb_vector program~test1 test1 program~test1->proc~compute_jacobian program~test1->proc~initialize_numdiff program~test1->proc~initialize_numdiff_for_diff program~test2 test2 program~test2->proc~compute_jacobian proc~compute_jacobian_for_sparsity->proc~compute_sparsity_perturbation_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine raise_exception ( me , istat , routine , error_msg ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: istat !! error code. character ( len =* ), intent ( in ) :: routine !! the routine where the error was raised. character ( len =* ), intent ( in ) :: error_msg !! error message string. me % istat = istat me % error_msg = 'Error in ' // trim ( routine ) // ' : ' // trim ( error_msg ) me % exception_raised = . true . end subroutine raise_exception","tags":"","loc":"proc/raise_exception.html"},{"title":"clear_exceptions – AoC-2023","text":"private  subroutine clear_exceptions(me) Clear all exceptions. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me Source Code subroutine clear_exceptions ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me me % istat = 0 if ( allocated ( me % error_msg )) deallocate ( me % error_msg ) me % exception_raised = . false . end subroutine clear_exceptions","tags":"","loc":"proc/clear_exceptions.html"},{"title":"get_error_status – AoC-2023","text":"private  subroutine get_error_status(me, istat, error_msg) Returns the current error code and message. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(in) :: me integer, intent(out), optional :: istat error code ( istat=0 means no errors). character(len=:), intent(out), optional, allocatable :: error_msg error message string. Called by proc~~get_error_status~~CalledByGraph proc~get_error_status numerical_differentiation_module::numdiff_type%get_error_status program~test1 test1 program~test1->proc~get_error_status program~test2 test2 program~test2->proc~get_error_status Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_error_status ( me , istat , error_msg ) implicit none class ( numdiff_type ), intent ( in ) :: me integer , intent ( out ), optional :: istat !! error code (`istat=0` means no errors). character ( len = :), allocatable , intent ( out ), optional :: error_msg !! error message string. if ( present ( istat )) istat = me % istat if ( present ( error_msg )) then if ( allocated ( me % error_msg )) then error_msg = me % error_msg else error_msg = '' end if end if end subroutine get_error_status","tags":"","loc":"proc/get_error_status.html"},{"title":"finite_diff_method – AoC-2023","text":"public interface finite_diff_method constructor Calls interface~~finite_diff_method~~CallsGraph interface~finite_diff_method numerical_differentiation_module::finite_diff_method proc~initialize_finite_difference_method numerical_differentiation_module::initialize_finite_difference_method interface~finite_diff_method->proc~initialize_finite_difference_method Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function initialize_finite_difference_method (id, name, class, dx_factors, df_factors, df_den_factor) result(me) Constructor for a finite_diff_method . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: id unique ID for the method character(len=*), intent(in) :: name the name of the method integer, intent(in) :: class 2=backward diffs, 3=central diffs, etc... integer, intent(in), dimension(:) :: dx_factors multiplicative factors for dx perturbation integer, intent(in), dimension(:) :: df_factors multiplicative factors for accumulating function evaluations integer, intent(in) :: df_den_factor denominator factor for finite difference equation (times dx) Return Value type( finite_diff_method )","tags":"","loc":"interface/finite_diff_method.html"},{"title":"add_lens – AoC-2023","text":"public  subroutine add_lens(me, l) Type Bound box Arguments Type Intent Optional Attributes Name class( box ), intent(inout) :: me type( lens ), intent(in) :: l lense to add Called by proc~~add_lens~~CalledByGraph proc~add_lens problem_15_module::box%add_lens program~problem_15 problem_15 program~problem_15->proc~add_lens Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine add_lens ( me , l ) ! = class ( box ), intent ( inout ) :: me type ( lens ), intent ( in ) :: l !! lense to add integer :: i !! counter if ( allocated ( me % lenses )) then do i = 1 , size ( me % lenses ) if ( me % lenses ( i )% label == l % label ) then me % lenses ( i ) = l ! replace with this one return end if end do me % lenses = [ me % lenses , l ] ! if not found, add to end else me % lenses = [ l ] ! first one in the box end if end subroutine add_lens","tags":"","loc":"proc/add_lens.html"},{"title":"remove_lens – AoC-2023","text":"public  subroutine remove_lens(me, label) remove the lens with the label (if present) Type Bound box Arguments Type Intent Optional Attributes Name class( box ), intent(inout) :: me character(len=*), intent(in) :: label Called by proc~~remove_lens~~CalledByGraph proc~remove_lens problem_15_module::box%remove_lens program~problem_15 problem_15 program~problem_15->proc~remove_lens Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine remove_lens ( me , label ) ! - !! remove the lens with the label (if present) class ( box ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: label integer :: i type ( lens ), dimension (:), allocatable :: tmp if ( allocated ( me % lenses )) then allocate ( tmp ( 0 )) do i = 1 , size ( me % lenses ) if ( me % lenses ( i )% label /= label ) tmp = [ tmp , me % lenses ( i )] end do call move_alloc ( tmp , me % lenses ) end if end subroutine remove_lens","tags":"","loc":"proc/remove_lens.html"},{"title":"hash – AoC-2023","text":"pure elemental function hash(s) Determine the ASCII code for the current character of the string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value integer(kind=ip) Called by proc~~hash~~CalledByGraph proc~hash problem_15::hash program~problem_15 problem_15 program~problem_15->proc~hash Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental integer ( ip ) function hash ( s ) !! Determine the ASCII code for the current character of the string. character ( len =* ), intent ( in ) :: s integer :: i hash = 0 do i = 1 , len ( s ) hash = modulo ( 17_ip * ( hash + iachar ( s ( i : i ))), 256_ip ) end do end function hash","tags":"","loc":"proc/hash.html"},{"title":"set_function – AoC-2023","text":"private  subroutine set_function(me, f) Set the function in a diff_func .\nMust be called before diff . Type Bound diff_func Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me procedure( func ) :: f Called by proc~~set_function~~CalledByGraph proc~set_function diff_module::diff_func%set_function proc~compute_jacobian_with_diff numerical_differentiation_module::compute_jacobian_with_diff proc~compute_jacobian_with_diff->proc~set_function Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_function ( me , f ) implicit none class ( diff_func ), intent ( inout ) :: me procedure ( func ) :: f me % f => f end subroutine set_function","tags":"","loc":"proc/set_function.html"},{"title":"terminate – AoC-2023","text":"private  subroutine terminate(me) Can be called by the user in the function to terminate the computation.\nThis will set ifail=-1 . Type Bound diff_func Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me Source Code subroutine terminate ( me ) implicit none class ( diff_func ), intent ( inout ) :: me me % stop = . true . end subroutine terminate","tags":"","loc":"proc/terminate~2.html"},{"title":"diff – AoC-2023","text":"private  subroutine diff(me, iord, x0, xmin, xmax, eps, accr, deriv, error, ifail) the procedure diff calculates the first, second or\nthird order derivative of a function by using neville's process to\nextrapolate from a sequence of simple polynomial approximations based on\ninterpolating points distributed symmetrically about x0 (or lying only on\none side of x0 should this be necessary).  if the specified tolerance is\nnon-zero then the procedure attempts to satisfy this absolute or relative\naccuracy requirement, while if it is unsuccessful or if the tolerance is\nset to zero then the result having the minimum achievable estimated error\nis returned instead. Type Bound diff_func Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me integer, intent(in) :: iord 1, 2 or 3 specifies that the first, second or third order\nderivative,respectively, is required. real(kind=wp), intent(in) :: x0 the point at which the derivative of the function is to be calculated. real(kind=wp), intent(in) :: xmin xmin , xmax restrict the interpolating points to lie in [ xmin , xmax ], which\nshould be the largest interval including x0 in which the function is\ncalculable and continuous. real(kind=wp), intent(in) :: xmax xmin , xmax restrict the interpolating points to lie in [ xmin , xmax ], which\nshould be the largest interval including x0 in which the function is\ncalculable and continuous. real(kind=wp), intent(in) :: eps denotes the tolerance, either absolute or relative. eps=0 specifies that\nthe error is to be minimised, while eps>0 or eps<0 specifies that the\nabsolute or relative error, respectively, must not exceed abs(eps) if\npossible.  the accuracy requirement should not be made stricter than\nnecessary, since the amount of computation tends to increase as\nthe magnitude of eps decreases, and is particularly high when eps=0 . real(kind=wp), intent(in) :: accr denotes that the absolute ( accr>0 ) or relative ( accr<0 ) errors in the\ncomputed values of the function are most unlikely to exceed abs(accr) , which\nshould be as small as possible.  if the user cannot estimate accr with\ncomplete confidence, then it should be set to zero. real(kind=wp), intent(out) :: deriv the calculated value of the derivative real(kind=wp), intent(out) :: error an estimated upper bound on the magnitude of the absolute error in\nthe calculated result.  it should always be examined, since in extreme case\nmay indicate that there are no correct significant digits in the value\nreturned for derivative. integer, intent(out) :: ifail will have one of the following values on exit: 0 the procedure was successful. 1 the estimated error in the result exceeds the (non-zero) requested\n     error, but the most accurate result possible has been returned. 2 input data incorrect (derivative and error will be undefined). 3 the interval [ xmin , xmax ] is too small (derivative and error will be\n     undefined). -1 stopped by the user. Calls proc~~diff~~CallsGraph proc~diff diff_module::diff_func%diff proc~faccur diff_module::diff_func%faccur proc~diff->proc~faccur Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~diff~~CalledByGraph proc~diff diff_module::diff_func%diff proc~compute_jacobian_with_diff numerical_differentiation_module::compute_jacobian_with_diff proc~compute_jacobian_with_diff->proc~diff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine diff ( me , iord , x0 , xmin , xmax , eps , accr , deriv , error , ifail ) implicit none class ( diff_func ), intent ( inout ) :: me integer , intent ( in ) :: iord !! 1, 2 or 3 specifies that the first, second or third order !! derivative,respectively, is required. real ( wp ), intent ( in ) :: x0 !! the point at which the derivative of the function is to be calculated. real ( wp ), intent ( in ) :: xmin !! `xmin`, `xmax` restrict the interpolating points to lie in [`xmin`, `xmax`], which !! should be the largest interval including `x0` in which the function is !! calculable and continuous. real ( wp ), intent ( in ) :: xmax !! `xmin`, `xmax` restrict the interpolating points to lie in [`xmin`, `xmax`], which !! should be the largest interval including `x0` in which the function is !! calculable and continuous. real ( wp ), intent ( in ) :: eps !! denotes the tolerance, either absolute or relative. `eps=0` specifies that !! the error is to be minimised, while `eps>0` or `eps<0` specifies that the !! absolute or relative error, respectively, must not exceed `abs(eps)` if !! possible.  the accuracy requirement should not be made stricter than !! necessary, since the amount of computation tends to increase as !! the magnitude of `eps` decreases, and is particularly high when `eps=0`. real ( wp ), intent ( in ) :: accr !! denotes that the absolute (`accr>0`) or relative (`accr<0`) errors in the !! computed values of the function are most unlikely to exceed `abs(accr)`, which !! should be as small as possible.  if the user cannot estimate `accr` with !! complete confidence, then it should be set to zero. real ( wp ), intent ( out ) :: deriv !! the calculated value of the derivative real ( wp ), intent ( out ) :: error !! an estimated upper bound on the magnitude of the absolute error in !! the calculated result.  it should always be examined, since in extreme case !! may indicate that there are no correct significant digits in the value !! returned for derivative. integer , intent ( out ) :: ifail !! will have one of the following values on exit: !!  *0* the procedure was successful. !!  *1* the estimated error in the result exceeds the (non-zero) requested !!      error, but the most accurate result possible has been returned. !!  *2* input data incorrect (derivative and error will be undefined). !!  *3* the interval [`xmin`, `xmax`] is too small (derivative and error will be !!      undefined). !!  *-1* stopped by the user. real ( wp ) :: acc , beta , beta4 , h , h0 , h1 , h2 , & newh1 , newh2 , heval , hprev , baseh , hacc1 , hacc2 , nhacc1 , & nhacc2 , minh , maxh , maxh1 , maxh2 , tderiv , f0 , twof0 , f1 , f2 , f3 , f4 , fmax , & maxfun , pmaxf , df1 , deltaf , pdelta , z , zpower , c0f0 , c1 , c2 , c3 , dnew , dprev , & re , te , newerr , temerr , newacc , pacc1 , pacc2 , facc1 , facc2 , acc0 , & acc1 , acc2 , relacc , twoinf , twosup , s , & d ( 10 ), denom ( 10 ), e ( 10 ), minerr ( 10 ), maxf ( 0 : 10 ), save ( 0 : 13 ), storef ( - 45 : 45 ), factor integer :: i , j , k , n , nmax , method , signh , fcount , init logical :: ignore ( 10 ), contin , saved real ( wp ) :: dummy1 , dummy2 integer , parameter :: eta = digits ( 1.0_wp ) - 1 !! minimum number of significant binary digits (apart from the !! sign digit) used to represent the mantissa of real(wp) numbers. it should !! be decreased by one if the computer truncates rather than rounds. integer , parameter :: inf = - minexponent ( 1.0_wp ) - 2 !! the largest possible positive integers subject to !! 2**(-inf) and -2**(-inf) being representable real(wp) numbers. integer , parameter :: sup = maxexponent ( 1.0_wp ) - 1 !! the largest possible positive integers subject to !! 2**sup and -2**sup being representable real(wp) numbers. real ( wp ), parameter :: sqrt2 = sqrt ( 2.0_wp ) !!  \\sqrt(2)  real ( wp ), parameter :: sqrt3 = sqrt ( 3.0_wp ) !!  \\sqrt(3)  me % stop = . false . ! execution commences with examination of input parameters if ( iord < 1 . or . iord > 3 . or . xmax <= xmin . or . & x0 > xmax . or . x0 < xmin . or . . not . associated ( me % f )) then ifail = 2 else acc = accr twoinf = 2.0_wp ** ( - inf ) twosup = 2.0_wp ** sup factor = 2.0_wp ** ( real (( inf + sup ), wp ) / 3 0.0_wp ) if ( factor < 25 6.0_wp ) factor = 25 6.0_wp maxh1 = xmax - x0 signh = 1 if ( x0 - xmin <= maxh1 ) then maxh2 = x0 - xmin else maxh2 = maxh1 maxh1 = x0 - xmin signh = - 1 end if relacc = 2.0_wp ** ( 1.0_wp - eta ) maxh1 = ( 1.0_wp - relacc ) * maxh1 maxh2 = ( 1.0_wp - relacc ) * maxh2 s = 12 8.0_wp * twoinf if ( abs ( x0 ) > 12 8.0_wp * twoinf * 2.0_wp ** eta ) s = abs ( x0 ) * 2.0_wp ** ( - eta ) if ( maxh1 < s ) then ! interval too small ifail = 3 return end if if ( acc < 0.0_wp ) then if ( - acc > relacc ) relacc = - acc acc = 0.0_wp end if ! determine the smallest spacing at which the calculated ! function values are unequal near x0. f0 = me % f ( x0 ) if ( me % stop ) then ifail = - 1 return end if twof0 = f0 + f0 if ( abs ( x0 ) > twoinf * 2.0_wp ** eta ) then h = abs ( x0 ) * 2.0_wp ** ( - eta ) z = 2.0_wp else h = twoinf z = 6 4.0_wp end if df1 = me % f ( x0 + signh * h ) - f0 if ( me % stop ) then ifail = - 1 return end if do if ( df1 /= 0.0_wp . or . z * h > maxh1 ) exit h = z * h df1 = me % f ( x0 + signh * h ) - f0 if ( me % stop ) then ifail = - 1 return end if if ( z /= 2.0_wp ) then if ( df1 /= 0.0_wp ) then h = h / z z = 2.0_wp df1 = 0.0_wp else if ( z * h > maxh1 ) z = 2.0_wp end if end if end do if ( df1 == 0.0_wp ) then ! constant function deriv = 0.0_wp error = 0.0_wp ifail = 0 return end if if ( h > maxh1 / 12 8.0_wp ) then ! minimum h too large ifail = 3 return end if h = 8.0_wp * h h1 = signh * h h0 = h1 h2 = - h1 minh = 2.0_wp ** ( - min ( inf , sup ) / iord ) if ( minh < h ) minh = h select case ( iord ) case ( 1 ) s = 8.0_wp case ( 2 ) s = 9.0_wp * sqrt3 case ( 3 ) s = 2 7.0_wp end select if ( minh > maxh1 / s ) then ifail = 3 return end if if ( minh > maxh2 / s . or . maxh2 < 12 8.0_wp * twoinf ) then method = 1 else method = 2 end if ! method 1 uses 1-sided formulae, and method 2 symmetric. ! now estimate accuracy of calculated function values. if ( method /= 2 . or . iord == 2 ) then if ( x0 /= 0.0_wp ) then dummy1 = 0.0_wp dummy2 = - h1 call me % faccur ( dummy1 , dummy2 , acc0 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return else acc0 = 0.0_wp end if end if if ( abs ( h1 ) > twosup / 12 8.0_wp ) then hacc1 = twosup else hacc1 = 12 8.0_wp * h1 end if if ( abs ( hacc1 ) / 4.0_wp < minh ) then hacc1 = 4.0_wp * signh * minh else if ( abs ( hacc1 ) > maxh1 ) then hacc1 = signh * maxh1 end if f1 = me % f ( x0 + hacc1 ) if ( me % stop ) then ifail = - 1 return end if call me % faccur ( hacc1 , h1 , acc1 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return if ( method == 2 ) then hacc2 = - hacc1 if ( abs ( hacc2 ) > maxh2 ) hacc2 = - signh * maxh2 f1 = me % f ( x0 + hacc2 ) if ( me % stop ) then ifail = - 1 return end if call me % faccur ( hacc2 , h2 , acc2 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return end if nmax = 8 if ( eta > 36 ) nmax = 10 n = - 1 fcount = 0 deriv = 0.0_wp error = twosup init = 3 contin = . true . do n = n + 1 if (. not . contin ) exit if ( init == 3 ) then ! calculate coefficients for differentiation ! formulae and neville extrapolation algorithm if ( iord == 1 ) then beta = 2.0_wp else if ( method == 2 ) then beta = sqrt2 else beta = sqrt3 end if beta4 = beta ** 4 z = beta if ( method == 2 ) z = z ** 2 zpower = 1.0_wp do k = 1 , nmax zpower = z * zpower denom ( k ) = zpower - 1 end do if ( method == 2 . and . iord == 1 ) then e ( 1 ) = 5.0_wp e ( 2 ) = 6.3_wp do i = 3 , nmax e ( i ) = 6.81_wp end do else if (( method /= 2 . and . iord == 1 ) . or . & ( method == 2 . and . iord == 2 )) then e ( 1 ) = 1 0.0_wp e ( 2 ) = 1 6.0_wp e ( 3 ) = 2 0.36_wp e ( 4 ) = 2 3.0_wp e ( 5 ) = 2 4.46_wp do i = 6 , nmax e ( i ) = 2 6.0_wp end do if ( method == 2 . and . iord == 2 ) then do i = 1 , nmax e ( i ) = 2.0_wp * e ( i ) end do end if else if ( method /= 2 . and . iord == 2 ) then e ( 1 ) = 1 7.78_wp e ( 2 ) = 3 0.06_wp e ( 3 ) = 3 9.66_wp e ( 4 ) = 4 6.16_wp e ( 5 ) = 5 0.26_wp do i = 6 , nmax e ( i ) = 5 5.0_wp end do else if ( method == 2 . and . iord == 3 ) then e ( 1 ) = 2 5.97_wp e ( 2 ) = 4 1.22_wp e ( 3 ) = 5 0.95_wp e ( 4 ) = 5 6.4_wp e ( 5 ) = 5 9.3_wp do i = 6 , nmax e ( i ) = 6 2.0_wp end do else e ( 1 ) = 2 4.5_wp e ( 2 ) = 4 0.4_wp e ( 3 ) = 5 2.78_wp e ( 4 ) = 6 1.2_wp e ( 5 ) = 6 6.55_wp do i = 6 , nmax e ( i ) = 7 3.0_wp end do c0f0 = - twof0 / ( 3.0_wp * beta ) c1 = 3.0_wp / ( 3.0_wp * beta - 1.0_wp ) c2 = - 1.0_wp / ( 3.0_wp * ( beta - 1.0_wp )) c3 = 1.0_wp / ( 3.0_wp * beta * ( 5.0_wp - 2.0_wp * beta )) end if end if if ( init >= 2 ) then ! initialization of steplengths, accuracy and other parameters heval = signh * minh h = heval baseh = heval maxh = maxh2 if ( method == 1 ) maxh = maxh1 do k = 1 , nmax minerr ( k ) = twosup ignore ( k ) = . false . end do if ( method == 1 ) newacc = acc1 if ( method == - 1 ) newacc = acc2 if ( method == 2 ) newacc = ( acc1 + acc2 ) / 2.0_wp if ( newacc < acc ) newacc = acc if (( method /= 2 . or . iord == 2 ) . and . newacc < acc0 ) newacc = acc0 if ( method /= - 1 ) then facc1 = acc1 nhacc1 = hacc1 newh1 = h1 end if if ( method /= 1 ) then facc2 = acc2 nhacc2 = hacc2 newh2 = h2 else facc2 = 0.0_wp nhacc2 = 0.0_wp end if init = 1 j = 0 saved = . false . end if ! calculate new or initial function values if ( init == 1 . and . ( n == 0 . or . iord == 1 ) . and . & . not .( method == 2 . and . fcount >= 45 )) then if ( method == 2 ) then fcount = fcount + 1 f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if storef ( fcount ) = f1 f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if storef ( - fcount ) = f2 else j = j + 1 if ( j <= fcount ) then f1 = storef ( j * method ) else f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if end if end if else f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if if ( method == 2 ) then f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if end if end if if ( n == 0 ) then if ( method == 2 . and . iord == 3 ) then pdelta = f1 - f2 pmaxf = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp heval = beta * heval f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if deltaf = f1 - f2 maxfun = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp heval = beta * heval f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if else if ( method /= 2 . and . iord >= 2 ) then if ( iord == 2 ) then f3 = f1 else f4 = f1 heval = beta * heval f3 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if end if heval = beta * heval f2 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if heval = beta * heval f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if end if end if ! evaluate a new approximation dnew to the derivative if ( n > nmax ) then n = nmax do i = 1 , n maxf ( i - 1 ) = maxf ( i ) end do end if if ( method == 2 ) then maxf ( n ) = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp if ( iord == 1 ) then dnew = ( f1 - f2 ) / 2.0_wp else if ( iord == 2 ) then dnew = f1 + f2 - twof0 else dnew = - pdelta pdelta = deltaf deltaf = f1 - f2 dnew = dnew + 0.5_wp * deltaf if ( maxf ( n ) < pmaxf ) maxf ( n ) = pmaxf pmaxf = maxfun maxfun = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp end if else maxf ( n ) = abs ( f1 ) if ( iord == 1 ) then dnew = f1 - f0 else if ( iord == 2 ) then dnew = ( twof0 - 3.0_wp * f3 + f1 ) / 3.0_wp if ( maxf ( n ) < abs ( f3 )) maxf ( n ) = abs ( f3 ) f3 = f2 f2 = f1 else dnew = c3 * f1 + c2 * f2 + c1 * f4 + c0f0 if ( maxf ( n ) < abs ( f2 )) maxf ( n ) = abs ( f2 ) if ( maxf ( n ) < abs ( f4 )) maxf ( n ) = abs ( f4 ) f4 = f3 f3 = f2 f2 = f1 end if end if if ( abs ( h ) > 1 ) then dnew = dnew / h ** iord else if ( 12 8.0_wp * abs ( dnew ) > twosup * abs ( h ) ** iord ) then dnew = twosup / 12 8.0_wp else dnew = dnew / h ** iord end if end if if ( init == 0 ) then ! update estimated accuracy of function values newacc = acc if (( method /= 2 . or . iord == 2 ) . and . newacc < acc0 ) newacc = acc0 if ( method /= - 1 . and . abs ( nhacc1 ) <= 1.125_wp * abs ( heval ) / beta4 ) then nhacc1 = heval pacc1 = facc1 call me % faccur ( nhacc1 , newh1 , facc1 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return if ( facc1 < pacc1 ) facc1 = ( 3.0_wp * facc1 + pacc1 ) / 4.0_wp end if if ( method /= 1 . and . abs ( nhacc2 ) <= 1.125_wp * abs ( heval ) / beta4 ) then if ( method == 2 ) then f1 = f2 nhacc2 = - heval else nhacc2 = heval end if pacc2 = facc2 call me % faccur ( nhacc2 , newh2 , facc2 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return if ( facc2 < pacc2 ) facc2 = ( 3.0_wp * facc2 + pacc2 ) / 4.0_wp end if if ( method == 1 . and . newacc < facc1 ) newacc = facc1 if ( method == - 1 . and . newacc < facc2 ) newacc = facc2 if ( method == 2 . and . newacc < ( facc1 + facc2 ) / 2.0_wp ) & newacc = ( facc1 + facc2 ) / 2.0_wp end if ! evaluate successive elements of the current row in the neville ! array, estimating and examining the truncation and rounding ! errors in each contin = n < nmax hprev = abs ( h ) fmax = maxf ( n ) if (( method /= 2 . or . iord == 2 ) . and . fmax < abs ( f0 )) fmax = abs ( f0 ) do k = 1 , n dprev = d ( k ) d ( k ) = dnew dnew = dprev + ( dprev - dnew ) / denom ( k ) te = abs ( dnew - d ( k )) if ( fmax < maxf ( n - k )) fmax = maxf ( n - k ) hprev = hprev / beta if ( newacc >= relacc * fmax ) then re = newacc * e ( k ) else re = relacc * fmax * e ( k ) end if if ( re /= 0.0_wp ) then if ( hprev > 1 ) then re = re / hprev ** iord else if ( 2.0_wp * re > twosup * hprev ** iord ) then re = twosup / 2.0_wp else re = re / hprev ** iord end if end if newerr = te + re if ( te > re ) newerr = 1.25_wp * newerr if (. not . ignore ( k )) then if (( init == 0 . or . ( k == 2 . and . . not . ignore ( 1 ))) & . and . newerr < error ) then deriv = d ( k ) error = newerr end if if ( init == 1 . and . n == 1 ) then tderiv = d ( 1 ) temerr = newerr end if if ( minerr ( k ) < twosup / 4.0_wp ) then s = 4.0_wp * minerr ( k ) else s = twosup end if if ( te > re . or . newerr > s ) then ignore ( k ) = . true . else contin = . true . end if if ( newerr < minerr ( k )) minerr ( k ) = newerr if ( init == 1 . and . n == 2 . and . k == 1 . and . . not . ignore ( 1 )) then if ( newerr < temerr ) then tderiv = d ( 1 ) temerr = newerr end if if ( temerr < error ) then deriv = tderiv error = temerr end if end if end if end do if ( n < nmax ) d ( n + 1 ) = dnew if ( eps < 0.0_wp ) then s = abs ( eps * deriv ) else s = eps end if if ( error <= s ) then contin = . false . else if ( init == 1 . and . ( n == 2 . or . ignore ( 1 ))) then if (( ignore ( 1 ) . or . ignore ( 2 )) . and . saved ) then saved = . false . n = 2 h = beta * save ( 0 ) heval = beta * save ( 1 ) maxf ( 0 ) = save ( 2 ) maxf ( 1 ) = save ( 3 ) maxf ( 2 ) = save ( 4 ) d ( 1 ) = save ( 5 ) d ( 2 ) = save ( 6 ) d ( 3 ) = save ( 7 ) minerr ( 1 ) = save ( 8 ) minerr ( 2 ) = save ( 9 ) if ( method == 2 . and . iord == 3 ) then pdelta = save ( 10 ) deltaf = save ( 11 ) pmaxf = save ( 12 ) maxfun = save ( 13 ) else if ( method /= 2 . and . iord >= 2 ) then f2 = save ( 10 ) f3 = save ( 11 ) if ( iord == 3 ) f4 = save ( 12 ) end if init = 0 ignore ( 1 ) = . false . ignore ( 2 ) = . false . else if (. not . ( ignore ( 1 ) . or . ignore ( 2 )) . and . n == 2 & . and . beta4 * factor * abs ( heval ) <= maxh ) then ! save all current values in case of return to current point saved = . true . save ( 0 ) = h save ( 1 ) = heval save ( 2 ) = maxf ( 0 ) save ( 3 ) = maxf ( 1 ) save ( 4 ) = maxf ( 2 ) save ( 5 ) = d ( 1 ) save ( 6 ) = d ( 2 ) save ( 7 ) = d ( 3 ) save ( 8 ) = minerr ( 1 ) save ( 9 ) = minerr ( 2 ) if ( method == 2 . and . iord == 3 ) then save ( 10 ) = pdelta save ( 11 ) = deltaf save ( 12 ) = pmaxf save ( 13 ) = maxfun else if ( method /= 2 . and . iord >= 2 ) then save ( 10 ) = f2 save ( 11 ) = f3 if ( iord == 3 ) save ( 12 ) = f4 end if h = factor * baseh heval = h baseh = h n = - 1 else init = 0 h = beta * h heval = beta * heval end if else if ( contin . and . beta * abs ( heval ) <= maxh ) then h = beta * h heval = beta * heval else if ( method /= 1 ) then contin = . true . if ( method == 2 ) then init = 3 method = - 1 if ( iord /= 2 ) then if ( x0 /= 0.0_wp ) then dummy1 = 0.0_wp dummy2 = - h0 call me % faccur ( dummy1 , dummy2 , acc0 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return else acc0 = 0.0_wp end if end if else init = 2 method = 1 end if n = - 1 signh = - signh else contin = . false . end if end do if ( eps < 0.0_wp ) then s = abs ( eps * deriv ) else s = eps end if ifail = 0 if ( eps /= 0.0_wp . and . error > s ) ifail = 1 end if end subroutine diff","tags":"","loc":"proc/diff.html"},{"title":"faccur – AoC-2023","text":"private  subroutine faccur(me, h0, h1, facc, x0, twoinf, f0, f1, ifail) This procedure attempts to estimate the level of rounding errors in\nthe calculated function values near the point x0+h0 by fitting a\nleast-squares straight-line approximation to the function at the\nsix points x0+h0-j*h1 , ( j = 0,1,3,5,7,9 ), and then setting facc to\ntwice the largest deviation of the function values from this line. hi is adjusted if necessary so that it is approximately 8 times the\nsmallest spacing at which the function values are unequal near x0+h0 . Type Bound diff_func Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me real(kind=wp), intent(inout) :: h0 real(kind=wp), intent(inout) :: h1 real(kind=wp), intent(out) :: facc real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: twoinf real(kind=wp), intent(in) :: f0 real(kind=wp), intent(in) :: f1 integer, intent(out) :: ifail 0 if no error, -1 if user termination. Called by proc~~faccur~~CalledByGraph proc~faccur diff_module::diff_func%faccur proc~diff diff_module::diff_func%diff proc~diff->proc~faccur proc~compute_jacobian_with_diff numerical_differentiation_module::compute_jacobian_with_diff proc~compute_jacobian_with_diff->proc~diff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine faccur ( me , h0 , h1 , facc , x0 , twoinf , f0 , f1 , ifail ) implicit none class ( diff_func ), intent ( inout ) :: me real ( wp ), intent ( inout ) :: h0 real ( wp ), intent ( inout ) :: h1 real ( wp ), intent ( out ) :: facc real ( wp ), intent ( in ) :: x0 real ( wp ), intent ( in ) :: twoinf real ( wp ), intent ( in ) :: f0 real ( wp ), intent ( in ) :: f1 integer , intent ( out ) :: ifail !! 0 if no error, -1 if user termination. real ( wp ) :: a0 , a1 , f00 , f001 , f2 , deltaf , t0 , t1 , df ( 5 ) integer :: j ifail = 0 t0 = 0.0_wp t1 = 0.0_wp if ( h0 /= 0.0_wp ) then if ( x0 + h0 /= 0.0_wp ) then f00 = f1 else h0 = 0.875_wp * h0 f00 = me % f ( x0 + h0 ) if ( me % stop ) then ifail = - 1 return end if end if if ( abs ( h1 ) >= 3 2.0_wp * twoinf ) h1 = h1 / 8.0_wp if ( 1 6.0_wp * abs ( h1 ) > abs ( h0 )) h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp f001 = me % f ( x0 + h0 - h1 ) if ( me % stop ) then ifail = - 1 return end if if ( f001 == f00 ) then if ( 25 6.0_wp * abs ( h1 ) <= abs ( h0 )) then h1 = 2.0_wp * h1 do f001 = me % f ( x0 + h0 - h1 ) if ( me % stop ) then ifail = - 1 return end if if ( f001 /= f00 . or . 25 6.0_wp * abs ( h1 ) > abs ( h0 )) exit h1 = 2.0_wp * h1 end do h1 = 8.0_wp * h1 else h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp end if else if ( 25 6.0_wp * twoinf <= abs ( h0 )) then do f001 = me % f ( x0 + h0 - h1 / 2.0_wp ) if ( me % stop ) then ifail = - 1 return end if if ( f001 == f00 . or . abs ( h1 ) < 4.0_wp * twoinf ) exit h1 = h1 / 2.0_wp end do h1 = 8.0_wp * h1 if ( 1 6.0_wp * abs ( h1 ) > abs ( h0 )) h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp else h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp end if end if else f00 = f0 end if do j = 1 , 5 f2 = me % f ( x0 + h0 - real ( 2 * j - 1 , wp ) * h1 ) if ( me % stop ) then ifail = - 1 return end if df ( j ) = f2 - f00 t0 = t0 + df ( j ) t1 = t1 + real ( 2 * j - 1 , wp ) * df ( j ) end do a0 = ( 3 3.0_wp * t0 - 5.0_wp * t1 ) / 7 3.0_wp a1 = ( - 5.0_wp * t0 + 1.2_wp * t1 ) / 7 3.0_wp facc = abs ( a0 ) do j = 1 , 5 deltaf = abs ( df ( j ) - ( a0 + real ( 2 * j - 1 , wp ) * a1 )) if ( facc < deltaf ) facc = deltaf end do facc = 2.0_wp * facc end subroutine faccur","tags":"","loc":"proc/faccur.html"},{"title":"fmin – AoC-2023","text":"public  function fmin(f, ax, bx, tol) result(xmin) An approximation x to the point where f attains a minimum on\n  the interval (ax,bx) is determined. the method used is a combination of golden section search and\n  successive parabolic interpolation. convergence is never much slower\n  than that for a fibonacci search. if f has a continuous second\n  derivative which is positive at the minimum (which is not at ax or bx ), then convergence is superlinear, and usually of the order of\n  about 1.324. the function f is never evaluated at two points closer together\n  than eps*abs(fmin) + (tol/3) , where eps is approximately the square\n  root of the relative machine precision. if f is a unimodal\n  function and the computed values of f are always unimodal when\n  separated by at least eps*abs(x) + (tol/3) , then fmin approximates\n  the abcissa of the global minimum of f on the interval ax,bx with\n  an error less than 3*eps*abs(fmin) + tol . if f is not unimodal,\n  then fmin may approximate a local, but perhaps non-global, minimum to\n  the same accuracy. Reference Richard brent, \"algorithms for minimization without derivatives\",\n    prentice - hall, inc. (1973). See also [fmin from Netlib](http: Arguments Type Intent Optional Attributes Name procedure( func ) :: f the function to minimize real(kind=wp), intent(in) :: ax left endpoint of initial interval real(kind=wp), intent(in) :: bx right endpoint of initial interval real(kind=wp), intent(in) :: tol desired length of the interval of\nuncertainty of the final result (>=0) Return Value real(kind=wp) abcissa approximating the point where\nf attains a minimum Called by proc~~fmin~~CalledByGraph proc~fmin fmin_module::fmin proc~exact_linesearch nlesolver_module::exact_linesearch proc~exact_linesearch->proc~fmin program~test test program~test->proc~fmin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function fmin ( f , ax , bx , tol ) result ( xmin ) implicit none procedure ( func ) :: f !! the function to minimize real ( wp ), intent ( in ) :: ax !! left endpoint of initial interval real ( wp ), intent ( in ) :: bx !! right endpoint of initial interval real ( wp ), intent ( in ) :: tol !! desired length of the interval of !! uncertainty of the final result (>=0) real ( wp ) :: xmin !! abcissa approximating the point where !! f attains a minimum real ( wp ) :: a , b , d , e , xm , p , q , r , tol1 , tol2 , u , v , w real ( wp ) :: fu , fv , fw , fx , x real ( wp ) :: abs , sqrt , sign real ( wp ), parameter :: c = ( 3.0_wp - sqrt ( 5.0_wp )) / 2.0_wp !! squared inverse of golden ratio real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: sqrteps = sqrt ( epsilon ( 1.0_wp )) ! initialization a = ax b = bx v = a + c * ( b - a ) w = v x = v e = 0.0_wp fx = f ( x ) fv = fx fw = fx do !  main loop starts here xm = half * ( a + b ) tol1 = sqrteps * abs ( x ) + tol / 3.0_wp tol2 = 2.0_wp * tol1 !  check stopping criterion if ( abs ( x - xm ) <= ( tol2 - half * ( b - a ))) then ! write(*,*) 'x             = ', x ! write(*,*) 'xm            = ', xm ! write(*,*) 'abs(x - xm)   = ', abs(x - xm) ! write(*,*) 'tol2          = ', tol2 ! write(*,*) 'half*(b - a)  = ', half*(b - a) exit end if ! is golden-section necessary if ( abs ( e ) <= tol1 ) then !  a golden-section step if ( x >= xm ) then e = a - x else e = b - x end if d = c * e else !  fit parabola r = ( x - w ) * ( fx - fv ) q = ( x - v ) * ( fx - fw ) p = ( x - v ) * q - ( x - w ) * r q = 2.0_wp * ( q - r ) if ( q > 0.0_wp ) p = - p q = abs ( q ) r = e e = d !  is parabola acceptable if (( abs ( p ) >= abs ( half * q * r )) . or . ( p <= q * ( a - x )) . or . ( p >= q * ( b - x ))) then !  a golden-section step if ( x >= xm ) then e = a - x else e = b - x end if d = c * e else !  a parabolic interpolation step d = p / q u = x + d !  f must not be evaluated too close to ax or bx if ((( u - a ) < tol2 ) . or . (( b - u ) < tol2 )) d = sign ( tol1 , xm - x ) end if end if !  f must not be evaluated too close to x if ( abs ( d ) >= tol1 ) then u = x + d else u = x + sign ( tol1 , d ) end if fu = f ( u ) !  update a, b, v, w, and x if ( fu <= fx ) then if ( u >= x ) a = x if ( u < x ) b = x v = w fv = fw w = x fw = fx x = u fx = fu else if ( u < x ) a = u if ( u >= x ) b = u if ( fu <= fw . or . w == x ) then v = w fv = fw w = u fw = fu else if ( fu <= fv . or . v == x . or . v == w ) then v = u fv = fu end if end if end do !  end of main loop xmin = x end function fmin","tags":"","loc":"proc/fmin.html"},{"title":"step – AoC-2023","text":"recursive subroutine step(array) take all valid steps from any # elements in array Arguments Type Intent Optional Attributes Name character(len=1), intent(inout), dimension(:,:), allocatable :: array Called by proc~~step~~CalledByGraph proc~step problem_21::step program~problem_21 problem_21 program~problem_21->proc~step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine step ( array ) !! take all valid steps from any # elements in array character ( len = 1 ), dimension (:,:), intent ( inout ), allocatable :: array integer :: i , j logical :: steped character ( len = 1 ), dimension (:,:), allocatable :: tmp tmp = array do i = 1 , nrows do j = 1 , ncols if ( array ( i , j ) == 'O' ) then steped = . false . ! try a step in each direction: if ( array ( i - 1 , j ) == '.' ) then tmp ( i - 1 , j ) = 'O' ; steped = . true . end if if ( array ( i + 1 , j ) == '.' ) then tmp ( i + 1 , j ) = 'O' ; steped = . true . end if if ( array ( i , j - 1 ) == '.' ) then tmp ( i , j - 1 ) = 'O' ; steped = . true . end if if ( array ( i , j + 1 ) == '.' ) then tmp ( i , j + 1 ) = 'O' ; steped = . true . end if if ( steped ) tmp ( i , j ) = '.' end if end do end do call move_alloc ( tmp , array ) end subroutine step","tags":"","loc":"proc/step.html"},{"title":"extrapolate – AoC-2023","text":"pure function extrapolate(ivals) result(iextrap) extrapolate the next value in the sequence using\na difference table. Straightfoward implemention:\ncreate the full table, and then evaluate it. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals Return Value integer(kind=ip) Calls proc~~extrapolate~~CallsGraph proc~extrapolate problem_9::extrapolate proc~diff~2 aoc_utilities::diff proc~extrapolate->proc~diff~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~extrapolate~~CalledByGraph proc~extrapolate problem_9::extrapolate program~problem_9 problem_9 program~problem_9->proc~extrapolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function extrapolate ( ivals ) result ( iextrap ) !! extrapolate the next value in the sequence using !! a difference table. Straightfoward implemention: !! create the full table, and then evaluate it. integer ( ip ), dimension (:), intent ( in ) :: ivals integer ( ip ) :: iextrap integer :: i , n type ( int64_vec ), dimension (:), allocatable :: diff_table !! difference table (vector of vectors) ! create the difference table: diff_table = [ int64_vec ( ivals )]; n = 1 do n = n + 1 diff_table = [ diff_table , int64_vec ( diff ( diff_table ( n - 1 )% vals ))] ! next line is diff of previous line if ( all ( diff_table ( n )% vals == 0 )) exit end do ! extrapolate iextrap = 0 do i = n - 1 , 1 , - 1 associate ( ilast => diff_table ( i )% vals ( size ( diff_table ( i )% vals )) ) iextrap = iextrap + ilast end associate end do end function extrapolate","tags":"","loc":"proc/extrapolate.html"},{"title":"unique_int – AoC-2023","text":"private  function unique_int(vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value integer, dimension(:), allocatable unique elements of ivec Calls proc~~unique_int~~CallsGraph proc~unique_int numdiff_utilities_module::unique_int interface~expand_vector numdiff_utilities_module::expand_vector proc~unique_int->interface~expand_vector interface~sort_ascending numdiff_utilities_module::sort_ascending proc~unique_int->interface~sort_ascending proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector->proc~expand_vector_real proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap numdiff_utilities_module::swap proc~sort_ascending_int->interface~swap proc~sort_ascending_real->interface~swap proc~swap_int numdiff_utilities_module::swap_int interface~swap->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~unique_int~~CalledByGraph proc~unique_int numdiff_utilities_module::unique_int interface~unique numdiff_utilities_module::unique interface~unique->proc~unique_int proc~divide_interval numdiff_utilities_module::divide_interval proc~divide_interval->interface~unique proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function unique_int ( vec , chunk_size ) result ( ivec_unique ) implicit none integer , dimension (:), intent ( in ) :: vec !! a vector of integers integer , intent ( in ) :: chunk_size !! chunk size for adding to arrays integer , dimension (:), allocatable :: ivec_unique !! unique elements of `ivec` integer , dimension ( size ( vec )) :: ivec !! temp copy of vec integer :: i !! counter integer :: n !! number of unique elements ! first we sort it: ivec = vec ! make a copy call sort_ascending ( ivec ) ! add the first element: n = 1 ivec_unique = [ ivec ( 1 )] ! walk through array and get the unique ones: if ( size ( ivec ) > 1 ) then do i = 2 , size ( ivec ) if ( ivec ( i ) /= ivec ( i - 1 )) then call expand_vector ( ivec_unique , n , chunk_size , val = ivec ( i )) end if end do call expand_vector ( ivec_unique , n , chunk_size , finished = . true .) end if end function unique_int","tags":"","loc":"proc/unique_int.html"},{"title":"unique_real – AoC-2023","text":"private  function unique_real(vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value real(kind=wp), dimension(:), allocatable unique elements of ivec Calls proc~~unique_real~~CallsGraph proc~unique_real numdiff_utilities_module::unique_real interface~expand_vector numdiff_utilities_module::expand_vector proc~unique_real->interface~expand_vector interface~sort_ascending numdiff_utilities_module::sort_ascending proc~unique_real->interface~sort_ascending proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector->proc~expand_vector_real proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap numdiff_utilities_module::swap proc~sort_ascending_int->interface~swap proc~sort_ascending_real->interface~swap proc~swap_int numdiff_utilities_module::swap_int interface~swap->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~unique_real~~CalledByGraph proc~unique_real numdiff_utilities_module::unique_real interface~unique numdiff_utilities_module::unique interface~unique->proc~unique_real proc~divide_interval numdiff_utilities_module::divide_interval proc~divide_interval->interface~unique proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function unique_real ( vec , chunk_size ) result ( ivec_unique ) implicit none real ( wp ), dimension (:), intent ( in ) :: vec !! a vector of integers integer , intent ( in ) :: chunk_size !! chunk size for adding to arrays real ( wp ), dimension (:), allocatable :: ivec_unique !! unique elements of `ivec` real ( wp ), dimension ( size ( vec )) :: ivec !! temp copy of vec integer :: i !! counter integer :: n !! number of unique elements ! first we sort it: ivec = vec ! make a copy call sort_ascending ( ivec ) ! add the first element: n = 1 ivec_unique = [ ivec ( 1 )] ! walk through array and get the unique ones: if ( size ( ivec ) > 1 ) then do i = 2 , size ( ivec ) if ( ivec ( i ) /= ivec ( i - 1 )) then call expand_vector ( ivec_unique , n , chunk_size , val = ivec ( i )) end if end do call expand_vector ( ivec_unique , n , chunk_size , finished = . true .) end if end function unique_real","tags":"","loc":"proc/unique_real.html"},{"title":"equal_within_tol – AoC-2023","text":"public pure function equal_within_tol(vals, tol) result(equal) Returns true if the values in the array are the same\n(to within the specified absolute tolerance). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: vals a set of values real(kind=wp), intent(in) :: tol a positive tolerance value Return Value logical true if they are equal\nwithin the tolerance Called by proc~~equal_within_tol~~CalledByGraph proc~equal_within_tol numdiff_utilities_module::equal_within_tol proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~equal_within_tol proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~equal_within_tol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function equal_within_tol ( vals , tol ) result ( equal ) implicit none real ( wp ), dimension (:), intent ( in ) :: vals !! a set of values real ( wp ), intent ( in ) :: tol !! a positive tolerance value logical :: equal !! true if they are equal !! within the tolerance equal = all ( abs ( vals - vals ( 1 )) <= abs ( tol ) ) end function equal_within_tol","tags":"","loc":"proc/equal_within_tol.html"},{"title":"divide_interval – AoC-2023","text":"public  function divide_interval(num_points) result(points) Returns a set of slightly randomized equally-spaced\n  points that divide an interval. Example: for num_points = 3: o---|---|---|---o\n         1   2   3 returns: [0.25308641972530865, 0.5061728394506173, 0.759259259175926] . Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_points the number of points in the interval Return Value real(kind=wp), dimension(:), allocatable the resultant vector Calls proc~~divide_interval~~CallsGraph proc~divide_interval numdiff_utilities_module::divide_interval interface~unique numdiff_utilities_module::unique proc~divide_interval->interface~unique proc~unique_int numdiff_utilities_module::unique_int interface~unique->proc~unique_int proc~unique_real numdiff_utilities_module::unique_real interface~unique->proc~unique_real interface~expand_vector numdiff_utilities_module::expand_vector proc~unique_int->interface~expand_vector interface~sort_ascending numdiff_utilities_module::sort_ascending proc~unique_int->interface~sort_ascending proc~unique_real->interface~expand_vector proc~unique_real->interface~sort_ascending proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector->proc~expand_vector_real proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap numdiff_utilities_module::swap proc~sort_ascending_int->interface~swap proc~sort_ascending_real->interface~swap proc~swap_int numdiff_utilities_module::swap_int interface~swap->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~divide_interval~~CalledByGraph proc~divide_interval numdiff_utilities_module::divide_interval proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function divide_interval ( num_points ) result ( points ) implicit none integer , intent ( in ) :: num_points !! the number of points in the interval real ( wp ), dimension (:), allocatable :: points !! the resultant vector real ( wp ), parameter :: noise = 1.012345678901234567_wp !! a noise value. Not a round number !! so as to avoid freak zeros in the !! jacobian real ( wp ), parameter :: min_val = 1 0.0_wp * epsilon ( 1.0_wp ) !! the minimize distance from the lower bound real ( wp ), parameter :: max_val = 1.0_wp - min_val !! the minimize distance from the upper bound integer :: i !! counter real ( wp ) :: delta !! step size real ( wp ), dimension (:), allocatable :: tmp !! a temp array to hold the values delta = 1.0_wp / ( num_points + 1 ) allocate ( tmp ( num_points )) do i = 1 , num_points tmp ( i ) = min ( max ( min_val , delta * i * noise ), max_val ) end do ! this is to protect for the min/max case if there ! are enough points so that some are duplicated near ! the bounds: points = unique ( tmp , chunk_size = 10 ) end function divide_interval","tags":"","loc":"proc/divide_interval.html"},{"title":"expand_vector_int – AoC-2023","text":"private pure subroutine expand_vector_int(vec, n, chunk_size, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) Called by proc~~expand_vector_int~~CalledByGraph proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector numdiff_utilities_module::expand_vector interface~expand_vector->proc~expand_vector_int proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->interface~expand_vector proc~resize_sparsity_vectors numerical_differentiation_module::numdiff_type%resize_sparsity_vectors proc~compute_sparsity_random->proc~resize_sparsity_vectors proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->interface~expand_vector proc~compute_sparsity_random_2->proc~resize_sparsity_vectors proc~divide_interval numdiff_utilities_module::divide_interval proc~compute_sparsity_random_2->proc~divide_interval proc~resize_sparsity_vectors->interface~expand_vector proc~unique_int numdiff_utilities_module::unique_int proc~unique_int->interface~expand_vector proc~unique_real numdiff_utilities_module::unique_real proc~unique_real->interface~expand_vector interface~unique numdiff_utilities_module::unique interface~unique->proc~unique_int interface~unique->proc~unique_real proc~divide_interval->interface~unique proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine expand_vector_int ( vec , n , chunk_size , val , finished ) implicit none integer , dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ) :: chunk_size !! allocate `vec` in blocks of this size (>0) integer , intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) integer , dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector_int","tags":"","loc":"proc/expand_vector_int.html"},{"title":"expand_vector_real – AoC-2023","text":"private pure subroutine expand_vector_real(vec, n, chunk_size, val, finished) Add elements to the real vector in chunks. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) real(kind=wp), intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) Called by proc~~expand_vector_real~~CalledByGraph proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector numdiff_utilities_module::expand_vector interface~expand_vector->proc~expand_vector_real proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->interface~expand_vector proc~resize_sparsity_vectors numerical_differentiation_module::numdiff_type%resize_sparsity_vectors proc~compute_sparsity_random->proc~resize_sparsity_vectors proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->interface~expand_vector proc~compute_sparsity_random_2->proc~resize_sparsity_vectors proc~divide_interval numdiff_utilities_module::divide_interval proc~compute_sparsity_random_2->proc~divide_interval proc~resize_sparsity_vectors->interface~expand_vector proc~unique_int numdiff_utilities_module::unique_int proc~unique_int->interface~expand_vector proc~unique_real numdiff_utilities_module::unique_real proc~unique_real->interface~expand_vector interface~unique numdiff_utilities_module::unique interface~unique->proc~unique_int interface~unique->proc~unique_real proc~divide_interval->interface~unique proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine expand_vector_real ( vec , n , chunk_size , val , finished ) implicit none real ( wp ), dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ) :: chunk_size !! allocate `vec` in blocks of this size (>0) real ( wp ), intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) real ( wp ), dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector_real","tags":"","loc":"proc/expand_vector_real.html"},{"title":"sort_ascending_int – AoC-2023","text":"private  subroutine sort_ascending_int(ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec Calls proc~~sort_ascending_int~~CallsGraph proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int interface~swap numdiff_utilities_module::swap proc~sort_ascending_int->interface~swap proc~swap_int numdiff_utilities_module::swap_int interface~swap->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sort_ascending_int~~CalledByGraph proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int interface~sort_ascending numdiff_utilities_module::sort_ascending interface~sort_ascending->proc~sort_ascending_int proc~unique_int numdiff_utilities_module::unique_int proc~unique_int->interface~sort_ascending proc~unique_real numdiff_utilities_module::unique_real proc~unique_real->interface~sort_ascending interface~unique numdiff_utilities_module::unique interface~unique->proc~unique_int interface~unique->proc~unique_real proc~divide_interval numdiff_utilities_module::divide_interval proc~divide_interval->interface~unique proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine sort_ascending_int ( ivec ) implicit none integer , dimension (:), intent ( inout ) :: ivec call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending_int","tags":"","loc":"proc/sort_ascending_int.html"},{"title":"sort_ascending_real – AoC-2023","text":"private  subroutine sort_ascending_real(ivec) Sorts a real array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: ivec Calls proc~~sort_ascending_real~~CallsGraph proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real interface~swap numdiff_utilities_module::swap proc~sort_ascending_real->interface~swap proc~swap_int numdiff_utilities_module::swap_int interface~swap->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sort_ascending_real~~CalledByGraph proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real interface~sort_ascending numdiff_utilities_module::sort_ascending interface~sort_ascending->proc~sort_ascending_real proc~unique_int numdiff_utilities_module::unique_int proc~unique_int->interface~sort_ascending proc~unique_real numdiff_utilities_module::unique_real proc~unique_real->interface~sort_ascending interface~unique numdiff_utilities_module::unique interface~unique->proc~unique_int interface~unique->proc~unique_real proc~divide_interval numdiff_utilities_module::divide_interval proc~divide_interval->interface~unique proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine sort_ascending_real ( ivec ) implicit none real ( wp ), dimension (:), intent ( inout ) :: ivec call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending_real","tags":"","loc":"proc/sort_ascending_real.html"},{"title":"swap_int – AoC-2023","text":"private pure elemental subroutine swap_int(i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 Called by proc~~swap_int~~CalledByGraph proc~swap_int numdiff_utilities_module::swap_int interface~swap numdiff_utilities_module::swap interface~swap->proc~swap_int proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int proc~sort_ascending_int->interface~swap proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real proc~sort_ascending_real->interface~swap interface~sort_ascending numdiff_utilities_module::sort_ascending interface~sort_ascending->proc~sort_ascending_int interface~sort_ascending->proc~sort_ascending_real proc~unique_int numdiff_utilities_module::unique_int proc~unique_int->interface~sort_ascending proc~unique_real numdiff_utilities_module::unique_real proc~unique_real->interface~sort_ascending interface~unique numdiff_utilities_module::unique interface~unique->proc~unique_int interface~unique->proc~unique_real proc~divide_interval numdiff_utilities_module::divide_interval proc~divide_interval->interface~unique proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap_int ( i1 , i2 ) implicit none integer , intent ( inout ) :: i1 integer , intent ( inout ) :: i2 integer :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_int","tags":"","loc":"proc/swap_int.html"},{"title":"swap_real – AoC-2023","text":"private pure elemental subroutine swap_real(i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: i1 real(kind=wp), intent(inout) :: i2 Called by proc~~swap_real~~CalledByGraph proc~swap_real numdiff_utilities_module::swap_real interface~swap numdiff_utilities_module::swap interface~swap->proc~swap_real proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int proc~sort_ascending_int->interface~swap proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real proc~sort_ascending_real->interface~swap interface~sort_ascending numdiff_utilities_module::sort_ascending interface~sort_ascending->proc~sort_ascending_int interface~sort_ascending->proc~sort_ascending_real proc~unique_int numdiff_utilities_module::unique_int proc~unique_int->interface~sort_ascending proc~unique_real numdiff_utilities_module::unique_real proc~unique_real->interface~sort_ascending interface~unique numdiff_utilities_module::unique interface~unique->proc~unique_int interface~unique->proc~unique_real proc~divide_interval numdiff_utilities_module::divide_interval proc~divide_interval->interface~unique proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap_real ( i1 , i2 ) implicit none real ( wp ), intent ( inout ) :: i1 real ( wp ), intent ( inout ) :: i2 real ( wp ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_real","tags":"","loc":"proc/swap_real.html"},{"title":"expand_vector – AoC-2023","text":"public interface expand_vector Calls interface~~expand_vector~~CallsGraph interface~expand_vector numdiff_utilities_module::expand_vector proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector->proc~expand_vector_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~expand_vector~~CalledByGraph interface~expand_vector numdiff_utilities_module::expand_vector proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->interface~expand_vector proc~resize_sparsity_vectors numerical_differentiation_module::numdiff_type%resize_sparsity_vectors proc~compute_sparsity_random->proc~resize_sparsity_vectors proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->interface~expand_vector proc~compute_sparsity_random_2->proc~resize_sparsity_vectors proc~divide_interval numdiff_utilities_module::divide_interval proc~compute_sparsity_random_2->proc~divide_interval proc~resize_sparsity_vectors->interface~expand_vector proc~unique_int numdiff_utilities_module::unique_int proc~unique_int->interface~expand_vector proc~unique_real numdiff_utilities_module::unique_real proc~unique_real->interface~expand_vector interface~unique numdiff_utilities_module::unique interface~unique->proc~unique_int interface~unique->proc~unique_real proc~divide_interval->interface~unique proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure subroutine expand_vector_int (vec, n, chunk_size, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) private pure subroutine expand_vector_real (vec, n, chunk_size, val, finished) Add elements to the real vector in chunks. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) real(kind=wp), intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n )","tags":"","loc":"interface/expand_vector.html"},{"title":"unique – AoC-2023","text":"public interface unique Calls interface~~unique~~CallsGraph interface~unique numdiff_utilities_module::unique proc~unique_int numdiff_utilities_module::unique_int interface~unique->proc~unique_int proc~unique_real numdiff_utilities_module::unique_real interface~unique->proc~unique_real interface~expand_vector numdiff_utilities_module::expand_vector proc~unique_int->interface~expand_vector interface~sort_ascending numdiff_utilities_module::sort_ascending proc~unique_int->interface~sort_ascending proc~unique_real->interface~expand_vector proc~unique_real->interface~sort_ascending proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector->proc~expand_vector_real proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap numdiff_utilities_module::swap proc~sort_ascending_int->interface~swap proc~sort_ascending_real->interface~swap proc~swap_int numdiff_utilities_module::swap_int interface~swap->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~unique~~CalledByGraph interface~unique numdiff_utilities_module::unique proc~divide_interval numdiff_utilities_module::divide_interval proc~divide_interval->interface~unique proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function unique_int (vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value integer, dimension(:), allocatable unique elements of ivec private  function unique_real (vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value real(kind=wp), dimension(:), allocatable unique elements of ivec","tags":"","loc":"interface/unique.html"},{"title":"sort_ascending – AoC-2023","text":"public interface sort_ascending Calls interface~~sort_ascending~~CallsGraph interface~sort_ascending numdiff_utilities_module::sort_ascending proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap numdiff_utilities_module::swap proc~sort_ascending_int->interface~swap proc~sort_ascending_real->interface~swap proc~swap_int numdiff_utilities_module::swap_int interface~swap->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~sort_ascending~~CalledByGraph interface~sort_ascending numdiff_utilities_module::sort_ascending proc~unique_int numdiff_utilities_module::unique_int proc~unique_int->interface~sort_ascending proc~unique_real numdiff_utilities_module::unique_real proc~unique_real->interface~sort_ascending interface~unique numdiff_utilities_module::unique interface~unique->proc~unique_int interface~unique->proc~unique_real proc~divide_interval numdiff_utilities_module::divide_interval proc~divide_interval->interface~unique proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine sort_ascending_int (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_real (ivec) Sorts a real array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: ivec","tags":"","loc":"interface/sort_ascending.html"},{"title":"swap – AoC-2023","text":"private interface swap Calls interface~~swap~~CallsGraph interface~swap numdiff_utilities_module::swap proc~swap_int numdiff_utilities_module::swap_int interface~swap->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~swap~~CalledByGraph interface~swap numdiff_utilities_module::swap proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int proc~sort_ascending_int->interface~swap proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real proc~sort_ascending_real->interface~swap interface~sort_ascending numdiff_utilities_module::sort_ascending interface~sort_ascending->proc~sort_ascending_int interface~sort_ascending->proc~sort_ascending_real proc~unique_int numdiff_utilities_module::unique_int proc~unique_int->interface~sort_ascending proc~unique_real numdiff_utilities_module::unique_real proc~unique_real->interface~sort_ascending interface~unique numdiff_utilities_module::unique interface~unique->proc~unique_int interface~unique->proc~unique_real proc~divide_interval numdiff_utilities_module::divide_interval proc~divide_interval->interface~unique proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure elemental subroutine swap_int (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap_real (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: i1 real(kind=wp), intent(inout) :: i2","tags":"","loc":"interface/swap.html"},{"title":"dsm – AoC-2023","text":"public  subroutine dsm(m, n, npairs, indrow, indcol, ngrp, maxgrp, mingrp, info, ipntr, jpntr) The purpose of dsm is to determine an optimal or near-\noptimal consistent partition of the columns of a sparse m by n matrix a . the sparsity pattern of the matrix a is specified by\nthe arrays indrow and indcol . on input the indices\nfor the non-zero elements of a are indrow(k),indcol(k), k = 1,2,...,npairs . the ( indrow , indcol ) pairs may be specified in any order.\nduplicate input pairs are permitted, but the subroutine\neliminates them. the subroutine partitions the columns of a into groups\nsuch that columns in the same group do not have a\nnon-zero in the same row position. a partition of the\ncolumns of a with this property is consistent with the\ndirect determination of a . Arguments Type Intent Optional Attributes Name integer, intent(in) :: m number of rows of a (>0) integer, intent(in) :: n number of columns of a (>0) integer, intent(in) :: npairs number of ( indrow , indcol ) pairs used\nto describe the sparsity pattern of a (>0) integer, intent(inout), dimension(npairs) :: indrow an integer array of length npairs . on input indrow must contain the row indices of the non-zero elements of a .\non output indrow is permuted so that the corresponding\ncolumn indices are in non-decreasing order. the column\nindices can be recovered from the array jpntr . integer, intent(inout), dimension(npairs) :: indcol an integer array of length npairs . on input indcol must contain the column indices of the non-zero elements of a . on output indcol is permuted so that the corresponding\nrow indices are in non-decreasing order. the row indices\ncan be recovered from the array ipntr . integer, intent(out), dimension(n) :: ngrp specifies the partition of the columns of a .\ncolumn jcol belongs to group ngrp(jcol) . integer, intent(out) :: maxgrp the number of groups in the partition\nof the columns of a . integer, intent(out) :: mingrp a lower bound for the number of groups\nin any consistent partition of the\ncolumns of a . integer, intent(out) :: info for normal termination info = 1 .\nif m , n , or npairs is not positive,\nthen info = 0 . if the k-th element of indrow is not an integer between\n1 and m or the k-th element of indcol is not an integer between 1 and n,\nthen info = -k . integer, intent(out), dimension(m+1) :: ipntr an integer output array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 .\nnote that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(out), dimension(n+1) :: jpntr jpntr is an integer output array of length n + 1 which\nspecifies the locations of the row indices in indrow.\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 .\nnote that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . Calls proc~~dsm~~CallsGraph proc~dsm dsm_module::dsm proc~degr dsm_module::degr proc~dsm->proc~degr proc~ido dsm_module::ido proc~dsm->proc~ido proc~numsrt dsm_module::numsrt proc~dsm->proc~numsrt proc~seq dsm_module::seq proc~dsm->proc~seq proc~setr dsm_module::setr proc~dsm->proc~setr proc~slo dsm_module::slo proc~dsm->proc~slo proc~srtdat dsm_module::srtdat proc~dsm->proc~srtdat proc~ido->proc~numsrt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dsm~~CalledByGraph proc~dsm dsm_module::dsm proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm program~dsm_test dsm_test program~dsm_test->proc~dsm proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dsm ( m , n , Npairs , Indrow , Indcol , Ngrp , Maxgrp , Mingrp , Info , Ipntr , Jpntr ) implicit none integer , intent ( in ) :: m !! number of rows of `a` (>0) integer , intent ( in ) :: n !! number of columns of `a` (>0) integer , intent ( in ) :: npairs !! number of (`indrow`,`indcol`) pairs used !! to describe the sparsity pattern of `a` (>0) integer , intent ( out ) :: maxgrp !! the number of groups in the partition !! of the columns of `a`. integer , intent ( out ) :: mingrp !! a lower bound for the number of groups !! in any consistent partition of the !! columns of `a`. integer , intent ( out ) :: info !! for normal termination `info = 1`. !! if `m`, `n`, or `npairs` is not positive, !! then `info = 0`. if the k-th element of !! `indrow` is not an integer between !! 1 and m or the k-th element of `indcol` !! is not an integer between 1 and n, !! then `info = -k`. integer , dimension ( npairs ), intent ( inout ) :: indrow !! an integer array of length `npairs`. on input `indrow` !! must contain the row indices of the non-zero elements of `a`. !! on output `indrow` is permuted so that the corresponding !! column indices are in non-decreasing order. the column !! indices can be recovered from the array `jpntr`. integer , dimension ( npairs ), intent ( inout ) :: indcol !! an integer array of length `npairs`. on input `indcol` !! must contain the column indices of the non-zero elements of !! `a`. on output `indcol` is permuted so that the corresponding !! row indices are in non-decreasing order. the row indices !! can be recovered from the array `ipntr`. integer , dimension ( n ), intent ( out ) :: ngrp !! specifies the partition of the columns of `a`. !! column `jcol` belongs to group `ngrp(jcol)`. integer , dimension ( m + 1 ), intent ( out ) :: ipntr !! an integer output array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! note that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n + 1 ), intent ( out ) :: jpntr !! jpntr is an integer output array of length n + 1 which !! specifies the locations of the row indices in indrow. !! the row indices for column j are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! note that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( max ( m , 6 * n )) :: iwa !! an integer work array integer :: i , ir , j , jp , k , maxclq , nnz , numgrp !  check the input data. Info = 0 if ( m < 1 . or . n < 1 . or . Npairs < 1 ) return do k = 1 , Npairs Info = - k if ( Indrow ( k ) < 1 . or . Indrow ( k ) > m . or . Indcol ( k ) < 1 . or . Indcol ( k ) > n ) return enddo Info = 1 !  sort the data structure by columns. call srtdat ( n , Npairs , Indrow , Indcol , Jpntr , Iwa ) !  compress the data and determine the number of !  non-zero elements of a. do i = 1 , m Iwa ( i ) = 0 enddo nnz = 1 do j = 1 , n k = nnz do jp = Jpntr ( j ) , Jpntr ( j + 1 ) - 1 ir = Indrow ( jp ) if ( Iwa ( ir ) /= j ) then Indrow ( nnz ) = ir nnz = nnz + 1 Iwa ( ir ) = j endif enddo Jpntr ( j ) = k enddo Jpntr ( n + 1 ) = nnz !  extend the data structure to rows. call setr ( m , n , Indrow , Jpntr , Indcol , Ipntr , Iwa ) !  determine a lower bound for the number of groups. Mingrp = 0 do i = 1 , m Mingrp = max ( Mingrp , Ipntr ( i + 1 ) - Ipntr ( i )) enddo !  determine the degree sequence for the intersection !  graph of the columns of a. call degr ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 5 * n + 1 ), Iwa ( n + 1 )) !  color the intersection graph of the columns of a !  with the smallest-last (sl) ordering. call slo ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 5 * n + 1 ), Iwa ( 4 * n + 1 ), maxclq ,& Iwa ( 1 ), Iwa ( n + 1 ), Iwa ( 2 * n + 1 ), Iwa ( 3 * n + 1 )) call seq ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 4 * n + 1 ), Ngrp , Maxgrp , & Iwa ( n + 1 )) Mingrp = max ( Mingrp , maxclq ) !  exit if the smallest-last ordering is optimal. if ( Maxgrp == Mingrp ) return !  color the intersection graph of the columns of a !  with the incidence-degree (id) ordering. call ido ( m , n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 5 * n + 1 ), Iwa ( 4 * n + 1 ), & maxclq , Iwa ( 1 ), Iwa ( n + 1 ), Iwa ( 2 * n + 1 ), Iwa ( 3 * n + 1 )) call seq ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 4 * n + 1 ), Iwa ( 1 ), numgrp , & Iwa ( n + 1 )) Mingrp = max ( Mingrp , maxclq ) !  retain the better of the two orderings so far. if ( numgrp < Maxgrp ) then Maxgrp = numgrp do j = 1 , n Ngrp ( j ) = Iwa ( j ) enddo !  exit if the incidence-degree ordering is optimal. if ( Maxgrp == Mingrp ) return endif !  color the intersection graph of the columns of a !  with the largest-first (lf) ordering. call numsrt ( n , n - 1 , Iwa ( 5 * n + 1 ), - 1 , Iwa ( 4 * n + 1 ), Iwa ( 2 * n + 1 ), Iwa ( n + 1 )) call seq ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 4 * n + 1 ), Iwa ( 1 ), numgrp , & Iwa ( n + 1 )) !  retain the best of the three orderings and exit. if ( numgrp < Maxgrp ) then Maxgrp = numgrp do j = 1 , n Ngrp ( j ) = Iwa ( j ) enddo endif end subroutine dsm","tags":"","loc":"proc/dsm.html"},{"title":"degr – AoC-2023","text":"private  subroutine degr(n, indrow, jpntr, indcol, ipntr, ndeg, iwa) Given the sparsity pattern of an m by n matrix a ,\n  this subroutine determines the degree sequence for\n  the intersection graph of the columns of a . In graph-theory terminology, the intersection graph of\n  the columns of a is the loopless graph g with vertices a(j), j = 1,2,...,n where a(j) is the j -th column of a and with edge (a(i),a(j)) if and only if columns i and j have a non-zero in the same row position. Note The value of m is not needed by degr and is\n      therefore not present in the subroutine statement. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a . integer, intent(in), dimension(*) :: indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, intent(in), dimension(n+1) :: jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(in), dimension(*) :: indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, intent(in), dimension(*) :: ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(out), dimension(n) :: ndeg an integer output array of length n which\nspecifies the degree sequence. the degree of the j -th column of a is ndeg(j) . integer, dimension(n) :: iwa an integer work array of length n Called by proc~~degr~~CalledByGraph proc~degr dsm_module::degr proc~dsm dsm_module::dsm proc~dsm->proc~degr proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm program~dsm_test dsm_test program~dsm_test->proc~dsm proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine degr ( n , Indrow , Jpntr , Indcol , Ipntr , Ndeg , Iwa ) implicit none integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of `a`. integer , dimension ( * ), intent ( in ) :: indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ), intent ( in ) :: jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ), intent ( in ) :: indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( * ), intent ( in ) :: ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ), intent ( out ) :: ndeg !! an integer output array of length `n` which !! specifies the degree sequence. the degree of the !! `j`-th column of `a` is `ndeg(j)`. integer , dimension ( n ) :: iwa !! an integer work array of length `n` integer :: ic , ip , ir , jcol , jp ! initialization block. do jp = 1 , n Ndeg ( jp ) = 0 Iwa ( jp ) = 0 enddo ! compute the degree sequence by determining the contributions ! to the degrees from the current(jcol) column and further ! columns which have not yet been considered. do jcol = 2 , n Iwa ( jcol ) = n ! determine all positions (ir,jcol) which correspond ! to non-zeroes in the matrix. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! for each row ir, determine all positions (ir,ic) ! which correspond to non-zeroes in the matrix. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! array iwa marks columns which have contributed to ! the degree count of column jcol. update the degree ! counts of these columns as well as column jcol. if ( Iwa ( ic ) < jcol ) then Iwa ( ic ) = jcol Ndeg ( ic ) = Ndeg ( ic ) + 1 Ndeg ( jcol ) = Ndeg ( jcol ) + 1 endif enddo enddo enddo end subroutine degr","tags":"","loc":"proc/degr.html"},{"title":"ido – AoC-2023","text":"private  subroutine ido(m, n, Indrow, Jpntr, Indcol, Ipntr, Ndeg, List, Maxclq, Iwa1, Iwa2, Iwa3, Iwa4) given the sparsity pattern of an m by n matrix a , this\nsubroutine determines an incidence-degree ordering of the\ncolumns of a . the incidence-degree ordering is defined for the loopless\ngraph g with vertices a(j), j = 1,2,...,n where a(j) is the j -th column of a and with edge (a(i),a(j)) if and only if\ncolumns i and j have a non-zero in the same row position. the incidence-degree ordering is determined recursively by\nletting list(k), k = 1,...,n be a column with maximal\nincidence to the subgraph spanned by the ordered columns.\namong all the columns of maximal incidence, ido chooses a\ncolumn of maximal degree. Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of a . integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a . integer, intent(in), dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, intent(in), dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(in), dimension(*) :: Indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, intent(in), dimension(m+1) :: Ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(in), dimension(n) :: Ndeg an integer input array of length n which specifies\nthe degree sequence. the degree of the j -th column\nof a is ndeg(j) . integer, intent(out), dimension(n) :: List an integer output array of length n which specifies\nthe incidence-degree ordering of the columns of a . the j -th\ncolumn in this order is list(j) . integer, intent(out) :: Maxclq an integer output variable set to the size\nof the largest clique found during the ordering. integer, dimension(0:n-1) :: Iwa1 integer work array of length n . integer, dimension(n) :: Iwa2 integer work array of length n . integer, dimension(n) :: Iwa3 integer work array of length n . integer, dimension(n) :: Iwa4 integer work array of length n . Calls proc~~ido~~CallsGraph proc~ido dsm_module::ido proc~numsrt dsm_module::numsrt proc~ido->proc~numsrt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ido~~CalledByGraph proc~ido dsm_module::ido proc~dsm dsm_module::dsm proc~dsm->proc~ido proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm program~dsm_test dsm_test program~dsm_test->proc~dsm proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine ido ( m , n , Indrow , Jpntr , Indcol , Ipntr , Ndeg , List , Maxclq , & Iwa1 , Iwa2 , Iwa3 , Iwa4 ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of `a`. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of `a`. integer , intent ( out ) :: Maxclq !! an integer output variable set to the size !! of the largest clique found during the ordering. integer , dimension ( * ), intent ( in ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ), intent ( in ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ), intent ( in ) :: Indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( m + 1 ), intent ( in ) :: Ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ), intent ( in ) :: Ndeg !! an integer input array of length `n` which specifies !! the degree sequence. the degree of the `j`-th column !! of `a` is `ndeg(j)`. integer , dimension ( n ), intent ( out ) :: List !! an integer output array of length `n` which specifies !! the incidence-degree ordering of the columns of `a`. the `j`-th !! column in this order is `list(j)`. integer , dimension ( 0 : n - 1 ) :: Iwa1 !! integer work array of length `n`. integer , dimension ( n ) :: Iwa2 !! integer work array of length `n`. integer , dimension ( n ) :: Iwa3 !! integer work array of length `n`. integer , dimension ( n ) :: Iwa4 !! integer work array of length `n`. integer :: ic , ip , ir , jcol , jp , maxinc , maxlst , ncomp , & numinc , numlst , numord , numwgt ! sort the degree sequence. call numsrt ( n , n - 1 , Ndeg , - 1 , Iwa4 , Iwa2 , Iwa3 ) ! initialization block. ! ! create a doubly-linked list to access the incidences of the ! columns. the pointers for the linked list are as follows. ! ! each un-ordered column ic is in a list (the incidence list) ! of columns with the same incidence. ! ! iwa1(numinc) is the first column in the numinc list ! unless iwa1(numinc) = 0. in this case there are ! no columns in the numinc list. ! ! iwa2(ic) is the column before ic in the incidence list ! unless iwa2(ic) = 0. in this case ic is the first ! column in this incidence list. ! ! iwa3(ic) is the column after ic in the incidence list ! unless iwa3(ic) = 0. in this case ic is the last ! column in this incidence list. ! ! if ic is an un-ordered column, then list(ic) is the ! incidence of ic to the graph induced by the ordered ! columns. if jcol is an ordered column, then list(jcol) ! is the incidence-degree order of column jcol. maxinc = 0 do jp = n , 1 , - 1 ic = Iwa4 ( jp ) Iwa1 ( n - jp ) = 0 Iwa2 ( ic ) = 0 Iwa3 ( ic ) = Iwa1 ( 0 ) if ( Iwa1 ( 0 ) > 0 ) Iwa2 ( Iwa1 ( 0 )) = ic Iwa1 ( 0 ) = ic Iwa4 ( jp ) = 0 List ( jp ) = 0 enddo ! DETERMINE THE MAXIMAL SEARCH LENGTH FOR THE LIST ! OF COLUMNS OF MAXIMAL INCIDENCE. maxlst = 0 do ir = 1 , m maxlst = maxlst + ( Ipntr ( ir + 1 ) - Ipntr ( ir )) ** 2 enddo maxlst = maxlst / n Maxclq = 0 numord = 1 ! BEGINNING OF ITERATION LOOP. ! UPDATE THE SIZE OF THE LARGEST CLIQUE ! FOUND DURING THE ORDERING. 100 if ( maxinc == 0 ) ncomp = 0 ncomp = ncomp + 1 if ( maxinc + 1 == ncomp ) Maxclq = max ( Maxclq , ncomp ) ! CHOOSE A COLUMN JCOL OF MAXIMAL DEGREE AMONG THE ! COLUMNS OF MAXIMAL INCIDENCE MAXINC. 200 jp = Iwa1 ( maxinc ) if ( jp > 0 ) then numwgt = - 1 do numlst = 1 , maxlst if ( Ndeg ( jp ) > numwgt ) then numwgt = Ndeg ( jp ) jcol = jp endif jp = Iwa3 ( jp ) if ( jp <= 0 ) exit enddo List ( jcol ) = numord numord = numord + 1 ! TERMINATION TEST. if ( numord > n ) then ! INVERT THE ARRAY LIST. do jcol = 1 , n Iwa2 ( List ( jcol )) = jcol enddo do jp = 1 , n List ( jp ) = Iwa2 ( jp ) enddo else ! DELETE COLUMN JCOL FROM THE MAXINC LIST. if ( Iwa2 ( jcol ) == 0 ) then Iwa1 ( maxinc ) = Iwa3 ( jcol ) else Iwa3 ( Iwa2 ( jcol )) = Iwa3 ( jcol ) endif if ( Iwa3 ( jcol ) > 0 ) Iwa2 ( Iwa3 ( jcol )) = Iwa2 ( jcol ) ! FIND ALL COLUMNS ADJACENT TO COLUMN JCOL. Iwa4 ( jcol ) = n ! DETERMINE ALL POSITIONS (IR,JCOL) WHICH CORRESPOND ! TO NON-ZEROES IN THE MATRIX. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! FOR EACH ROW IR, DETERMINE ALL POSITIONS (IR,IC) ! WHICH CORRESPOND TO NON-ZEROES IN THE MATRIX. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! ARRAY IWA4 MARKS COLUMNS WHICH ARE ADJACENT TO ! COLUMN JCOL. if ( Iwa4 ( ic ) < numord ) then Iwa4 ( ic ) = numord ! UPDATE THE POINTERS TO THE CURRENT INCIDENCE LISTS. numinc = List ( ic ) List ( ic ) = List ( ic ) + 1 maxinc = max ( maxinc , List ( ic )) ! DELETE COLUMN IC FROM THE NUMINC LIST. if ( Iwa2 ( ic ) == 0 ) then Iwa1 ( numinc ) = Iwa3 ( ic ) else Iwa3 ( Iwa2 ( ic )) = Iwa3 ( ic ) endif if ( Iwa3 ( ic ) > 0 ) Iwa2 ( Iwa3 ( ic )) = Iwa2 ( ic ) ! ADD COLUMN IC TO THE NUMINC+1 LIST. Iwa2 ( ic ) = 0 Iwa3 ( ic ) = Iwa1 ( numinc + 1 ) if ( Iwa1 ( numinc + 1 ) > 0 ) Iwa2 ( Iwa1 ( numinc + 1 )) = ic Iwa1 ( numinc + 1 ) = ic endif enddo enddo ! END OF ITERATION LOOP. goto 100 endif else maxinc = maxinc - 1 goto 200 endif end subroutine ido","tags":"","loc":"proc/ido.html"},{"title":"numsrt – AoC-2023","text":"private  subroutine numsrt(n, Nmax, Num, Mode, Index, Last, Next) Given a sequence of integers, this subroutine groups\n  together those indices with the same sequence value\n  and, optionally, sorts the sequence into either\n  ascending or descending order. The sequence of integers is defined by the array num ,\n  and it is assumed that the integers are each from the set 0,1,...,nmax . on output the indices k such that num(k) = l for any l = 0,1,...,nmax can be obtained from the arrays\n  last and next as follows. k = last ( l ) while ( k /= 0 ) k = next ( k ) Optionally, the subroutine produces an array index so that\n  the sequence num(index(i)), i = 1,2,...,n is sorted. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable. integer :: Nmax a positive integer input variable. integer, dimension(n) :: Num an input array of length n which contains the\nsequence of integers to be grouped and sorted. it\nis assumed that the integers are each from the set 0,1,...,nmax . integer :: Mode an integer input variable. the sequence num is\nsorted in ascending order if mode is positive and in\ndescending order if mode is negative. if mode is 0,\nno sorting is done. integer, dimension(n) :: Index an integer output array of length n set so\nthat the sequence num(index(i)), i = 1,2,...,n is sorted according to the setting of mode.\nif mode is 0, index is not referenced. integer, dimension(0:Nmax) :: Last an integer output array of length nmax + 1 . the\nindex of num for the last occurrence of l is last(l) for any l = 0,1,...,nmax unless last(l) = 0 . in\nthis case l does not appear in num . integer, dimension(n) :: Next an integer output array of length n . if num(k) = l , then the index of num for the previous\noccurrence of l is next(k) for any l = 0,1,...,nmax unless next(k) = 0 . in this case there is no previous\noccurrence of l in num . Called by proc~~numsrt~~CalledByGraph proc~numsrt dsm_module::numsrt proc~dsm dsm_module::dsm proc~dsm->proc~numsrt proc~ido dsm_module::ido proc~dsm->proc~ido proc~ido->proc~numsrt proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm program~dsm_test dsm_test program~dsm_test->proc~dsm proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine numsrt ( n , Nmax , Num , Mode , Index , Last , Next ) implicit none integer , intent ( in ) :: n !! a positive integer input variable. integer :: Nmax !! a positive integer input variable. integer :: Mode !! an integer input variable. the sequence `num` is !! sorted in ascending order if `mode` is positive and in !! descending order if `mode` is negative. if `mode` is 0, !! no sorting is done. integer , dimension ( n ) :: Num !! an input array of length `n` which contains the !! sequence of integers to be grouped and sorted. it !! is assumed that the integers are each from the set !! `0,1,...,nmax`. integer , dimension ( n ) :: Index !! an integer output array of length `n` set so !! that the sequence !! `num(index(i)), i = 1,2,...,n` !! is sorted according to the setting of mode. !! if `mode` is 0, `index` is not referenced. integer , dimension ( 0 : Nmax ) :: Last !! an integer output array of length `nmax + 1`. the !! index of `num` for the last occurrence of `l` is `last(l)` !! for any `l = 0,1,...,nmax` unless `last(l) = 0`. in !! this case `l` does not appear in `num`. integer , dimension ( n ) :: Next !! an integer output array of length `n`. if !! `num(k) = l`, then the index of `num` for the previous !! occurrence of `l` is `next(k)` for any `l = 0,1,...,nmax` !! unless `next(k) = 0`. in this case there is no previous !! occurrence of `l` in `num`. integer :: i , j , jinc , jl , ju , k , l ! determine the arrays next and last. do i = 0 , Nmax Last ( i ) = 0 enddo do k = 1 , n l = Num ( k ) Next ( k ) = Last ( l ) Last ( l ) = k enddo if ( Mode /= 0 ) then ! store the pointers to the sorted array in index. i = 1 if ( Mode > 0 ) then jl = 0 ju = Nmax jinc = 1 else jl = Nmax ju = 0 jinc = - 1 endif do j = jl , ju , jinc k = Last ( j ) do if ( k == 0 ) exit Index ( i ) = k i = i + 1 k = Next ( k ) enddo enddo end if end subroutine numsrt","tags":"","loc":"proc/numsrt.html"},{"title":"seq – AoC-2023","text":"private  subroutine seq(n, Indrow, Jpntr, Indcol, Ipntr, List, Ngrp, Maxgrp, Iwa) given the sparsity pattern of an m by n matrix a , this\nsubroutine determines a consistent partition of the\ncolumns of a by a sequential algorithm. a consistent partition is defined in terms of the loopless\ngraph g with vertices a(j), j = 1,2,...,n where a(j) is the j -th column of a and with edge (a(i),a(j)) if and only if\ncolumns i and j have a non-zero in the same row position. a partition of the columns of a into groups is consistent\nif the columns in any group are not adjacent in the graph g .\nin graph-theory terminology, a consistent partition of the\ncolumns of a corresponds to a coloring of the graph g . the subroutine examines the columns in the order specified\nby the array list, and assigns the current column to the\ngroup with the smallest possible number. note that the value of m is not needed by seq and is\ntherefore not present in the subroutine statement. Arguments Type Intent Optional Attributes Name integer :: n a positive integer input variable set to the number\nof columns of a . integer, dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(*) :: Indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, dimension(*) :: Ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(n) :: List an integer input array of length n which specifies\nthe order to be used by the sequential algorithm.\nthe j -th column in this order is list(j) . integer, dimension(n) :: Ngrp an integer output array of length n which specifies\nthe partition of the columns of a . column jcol belongs\nto group ngrp(jcol) . integer :: Maxgrp an integer output variable which specifies the\nnumber of groups in the partition of the columns of a . integer, dimension(n) :: Iwa an integer work array of length n Called by proc~~seq~~CalledByGraph proc~seq dsm_module::seq proc~dsm dsm_module::dsm proc~dsm->proc~seq proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm program~dsm_test dsm_test program~dsm_test->proc~dsm proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine seq ( n , Indrow , Jpntr , Indcol , Ipntr , List , Ngrp , Maxgrp , Iwa ) implicit none integer :: n !! a positive integer input variable set to the number !! of columns of `a`. integer :: Maxgrp !! an integer output variable which specifies the !! number of groups in the partition of the columns of `a`. integer , dimension ( * ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ) :: Indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( * ) :: Ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ) :: List !! an integer input array of length `n` which specifies !! the order to be used by the sequential algorithm. !! the `j`-th column in this order is `list(j)`. integer , dimension ( n ) :: Ngrp !! an integer output array of length `n` which specifies !! the partition of the columns of `a`. column `jcol` belongs !! to group `ngrp(jcol)`. integer , dimension ( n ) :: Iwa !! an integer work array of length `n` integer :: ic , ip , ir , j , jcol , jp ! initialization block. Maxgrp = 0 do jp = 1 , n Ngrp ( jp ) = n Iwa ( jp ) = 0 enddo ! beginning of iteration loop. do j = 1 , n jcol = List ( j ) ! find all columns adjacent to column jcol. ! ! determine all positions (ir,jcol) which correspond ! to non-zeroes in the matrix. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! for each row ir, determine all positions (ir,ic) ! which correspond to non-zeroes in the matrix. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! array iwa marks the group numbers of the ! columns which are adjacent to column jcol. Iwa ( Ngrp ( ic )) = j enddo enddo ! assign the smallest un-marked group number to jcol. do jp = 1 , Maxgrp if ( Iwa ( jp ) /= j ) then Maxgrp = Maxgrp - 1 exit end if enddo Maxgrp = Maxgrp + 1 Ngrp ( jcol ) = jp enddo ! end of iteration loop. end subroutine seq","tags":"","loc":"proc/seq.html"},{"title":"setr – AoC-2023","text":"private  subroutine setr(m, n, Indrow, Jpntr, Indcol, Ipntr, Iwa) given a column-oriented definition of the sparsity pattern\nof an m by n matrix a , this subroutine determines a\nrow-oriented definition of the sparsity pattern of a . on input the column-oriented definition is specified by\nthe arrays indrow and jpntr . on output the row-oriented\ndefinition is specified by the arrays indcol and ipntr . Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of a . integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a . integer, dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(*) :: Indcol an integer output array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, dimension(m+1) :: Ipntr an integer output array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(1) is set to 1 and that ipntr(m+1)-1 is\nthen the number of non-zero elements of the matrix a . integer, dimension(m) :: Iwa an integer work array of length m . Called by proc~~setr~~CalledByGraph proc~setr dsm_module::setr proc~dsm dsm_module::dsm proc~dsm->proc~setr proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm program~dsm_test dsm_test program~dsm_test->proc~dsm proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine setr ( m , n , Indrow , Jpntr , Indcol , Ipntr , Iwa ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of `a`. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of `a`. integer , dimension ( * ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ) :: Indcol !! an integer output array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( m + 1 ) :: Ipntr !! an integer output array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(1)` is set to 1 and that `ipntr(m+1)-1` is !! then the number of non-zero elements of the matrix `a`. integer , dimension ( m ) :: Iwa !! an integer work array of length `m`. integer :: ir , jcol , jp ! store in array iwa the counts of non-zeroes in the rows. do ir = 1 , m Iwa ( ir ) = 0 enddo do jp = 1 , Jpntr ( n + 1 ) - 1 Iwa ( Indrow ( jp )) = Iwa ( Indrow ( jp )) + 1 enddo ! set pointers to the start of the rows in indcol. Ipntr ( 1 ) = 1 do ir = 1 , m Ipntr ( ir + 1 ) = Ipntr ( ir ) + Iwa ( ir ) Iwa ( ir ) = Ipntr ( ir ) enddo ! fill indcol. do jcol = 1 , n do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) Indcol ( Iwa ( ir )) = jcol Iwa ( ir ) = Iwa ( ir ) + 1 enddo enddo end subroutine setr","tags":"","loc":"proc/setr.html"},{"title":"slo – AoC-2023","text":"private  subroutine slo(n, Indrow, Jpntr, Indcol, Ipntr, Ndeg, List, Maxclq, Iwa1, Iwa2, Iwa3, Iwa4) given the sparsity pattern of an m by n matrix a , this\nsubroutine determines the smallest-last ordering of the\ncolumns of a . the smallest-last ordering is defined for the loopless\ngraph g with vertices a(j), j = 1,2,...,n where a(j) is the j -th column of a and with edge (a(i),a(j)) if and only if\ncolumns i and j have a non-zero in the same row position. the smallest-last ordering is determined recursively by\nletting list(k), k = n,...,1 be a column with least degree\nin the subgraph spanned by the un-ordered columns. note that the value of m is not needed by slo and is\ntherefore not present in the subroutine statement. Arguments Type Intent Optional Attributes Name integer :: n a positive integer input variable set to the number\nof columns of a . integer, dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(*) :: Indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, dimension(*) :: Ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(n) :: Ndeg an integer input array of length n which specifies\nthe degree sequence. the degree of the j -th column\nof a is ndeg(j) . integer, dimension(n) :: List an integer output array of length n which specifies\nthe smallest-last ordering of the columns of a . the j -th\ncolumn in this order is list(j) . integer :: Maxclq an integer output variable set to the size\nof the largest clique found during the ordering. integer, dimension(0:n-1) :: Iwa1 integer work array of length n integer, dimension(n) :: Iwa2 integer work array of length n integer, dimension(n) :: Iwa3 integer work array of length n integer, dimension(n) :: Iwa4 integer work array of length n Called by proc~~slo~~CalledByGraph proc~slo dsm_module::slo proc~dsm dsm_module::dsm proc~dsm->proc~slo proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm program~dsm_test dsm_test program~dsm_test->proc~dsm proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine slo ( n , Indrow , Jpntr , Indcol , Ipntr , Ndeg , List , Maxclq , Iwa1 , & Iwa2 , Iwa3 , Iwa4 ) implicit none integer :: n !! a positive integer input variable set to the number !! of columns of `a`. integer :: Maxclq !! an integer output variable set to the size !! of the largest clique found during the ordering. integer , dimension ( * ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ) :: Indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( * ) :: Ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ) :: Ndeg !! an integer input array of length `n` which specifies !! the degree sequence. the degree of the `j`-th column !! of `a` is `ndeg(j)`. integer , dimension ( n ) :: List !! an integer output array of length `n` which specifies !! the smallest-last ordering of the columns of `a`. the `j`-th !! column in this order is `list(j)`. integer , dimension ( 0 : n - 1 ) :: Iwa1 !! integer work array of length `n` integer , dimension ( n ) :: Iwa2 !! integer work array of length `n` integer , dimension ( n ) :: Iwa3 !! integer work array of length `n` integer , dimension ( n ) :: Iwa4 !! integer work array of length `n` integer :: ic , ip , ir , jcol , jp , mindeg , numdeg , numord ! INITIALIZATION BLOCK. mindeg = n do jp = 1 , n Iwa1 ( jp - 1 ) = 0 Iwa4 ( jp ) = n List ( jp ) = Ndeg ( jp ) mindeg = min ( mindeg , Ndeg ( jp )) enddo ! CREATE A DOUBLY-LINKED LIST TO ACCESS THE DEGREES OF THE ! COLUMNS. THE POINTERS FOR THE LINKED LIST ARE AS FOLLOWS. ! ! EACH UN-ORDERED COLUMN IC IS IN A LIST (THE DEGREE LIST) ! OF COLUMNS WITH THE SAME DEGREE. ! ! IWA1(NUMDEG) IS THE FIRST COLUMN IN THE NUMDEG LIST ! UNLESS IWA1(NUMDEG) = 0. IN THIS CASE THERE ARE ! NO COLUMNS IN THE NUMDEG LIST. ! ! IWA2(IC) IS THE COLUMN BEFORE IC IN THE DEGREE LIST ! UNLESS IWA2(IC) = 0. IN THIS CASE IC IS THE FIRST ! COLUMN IN THIS DEGREE LIST. ! ! IWA3(IC) IS THE COLUMN AFTER IC IN THE DEGREE LIST ! UNLESS IWA3(IC) = 0. IN THIS CASE IC IS THE LAST ! COLUMN IN THIS DEGREE LIST. ! ! IF IC IS AN UN-ORDERED COLUMN, THEN LIST(IC) IS THE ! DEGREE OF IC IN THE GRAPH INDUCED BY THE UN-ORDERED ! COLUMNS. IF JCOL IS AN ORDERED COLUMN, THEN LIST(JCOL) ! IS THE SMALLEST-LAST ORDER OF COLUMN JCOL. do jp = 1 , n numdeg = Ndeg ( jp ) Iwa2 ( jp ) = 0 Iwa3 ( jp ) = Iwa1 ( numdeg ) if ( Iwa1 ( numdeg ) > 0 ) Iwa2 ( Iwa1 ( numdeg )) = jp Iwa1 ( numdeg ) = jp enddo Maxclq = 0 numord = n !  BEGINNING OF ITERATION LOOP. ! ! ! MARK THE SIZE OF THE LARGEST CLIQUE ! FOUND DURING THE ORDERING. 100 if ( mindeg + 1 == numord . and . Maxclq == 0 ) Maxclq = numord ! CHOOSE A COLUMN JCOL OF MINIMAL DEGREE MINDEG. 200 jcol = Iwa1 ( mindeg ) if ( jcol > 0 ) then List ( jcol ) = numord numord = numord - 1 ! TERMINATION TEST. if ( numord == 0 ) then ! INVERT THE ARRAY LIST. do jcol = 1 , n Iwa2 ( List ( jcol )) = jcol enddo do jp = 1 , n List ( jp ) = Iwa2 ( jp ) enddo else ! DELETE COLUMN JCOL FROM THE MINDEG LIST. Iwa1 ( mindeg ) = Iwa3 ( jcol ) if ( Iwa3 ( jcol ) > 0 ) Iwa2 ( Iwa3 ( jcol )) = 0 ! FIND ALL COLUMNS ADJACENT TO COLUMN JCOL. Iwa4 ( jcol ) = 0 ! DETERMINE ALL POSITIONS (IR,JCOL) WHICH CORRESPOND ! TO NON-ZEROES IN THE MATRIX. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! FOR EACH ROW IR, DETERMINE ALL POSITIONS (IR,IC) ! WHICH CORRESPOND TO NON-ZEROES IN THE MATRIX. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! ARRAY IWA4 MARKS COLUMNS WHICH ARE ADJACENT TO ! COLUMN JCOL. if ( Iwa4 ( ic ) > numord ) then Iwa4 ( ic ) = numord ! UPDATE THE POINTERS TO THE CURRENT DEGREE LISTS. numdeg = List ( ic ) List ( ic ) = List ( ic ) - 1 mindeg = min ( mindeg , List ( ic )) ! DELETE COLUMN IC FROM THE NUMDEG LIST. if ( Iwa2 ( ic ) == 0 ) then Iwa1 ( numdeg ) = Iwa3 ( ic ) else Iwa3 ( Iwa2 ( ic )) = Iwa3 ( ic ) endif if ( Iwa3 ( ic ) > 0 ) Iwa2 ( Iwa3 ( ic )) = Iwa2 ( ic ) ! ADD COLUMN IC TO THE NUMDEG-1 LIST. Iwa2 ( ic ) = 0 Iwa3 ( ic ) = Iwa1 ( numdeg - 1 ) if ( Iwa1 ( numdeg - 1 ) > 0 ) Iwa2 ( Iwa1 ( numdeg - 1 )) = ic Iwa1 ( numdeg - 1 ) = ic endif enddo enddo ! END OF ITERATION LOOP. goto 100 endif else mindeg = mindeg + 1 goto 200 endif end subroutine slo","tags":"","loc":"proc/slo.html"},{"title":"srtdat – AoC-2023","text":"private  subroutine srtdat(n, Nnz, Indrow, Indcol, Jpntr, Iwa) given the non-zero elements of an m by n matrix a in\narbitrary order as specified by their row and column\nindices, this subroutine permutes these elements so\nthat their column indices are in non-decreasing order. on input it is assumed that the elements are specified in indrow(k),indcol(k), k = 1,...,nnz . on output the elements are permuted so that indcol is\nin non-decreasing order. in addition, the array jpntr is set so that the row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that the value of m is not needed by srtdat and is\ntherefore not present in the subroutine statement. Arguments Type Intent Optional Attributes Name integer :: n a positive integer input variable set to the number\nof columns of a . integer :: Nnz a positive integer input variable set to the number\nof non-zero elements of a . integer, dimension(Nnz) :: Indrow an integer array of length nnz . on input indrow must contain the row indices of the non-zero elements of a .\non output indrow is permuted so that the corresponding\ncolumn indices of indcol are in non-decreasing order. integer, dimension(Nnz) :: Indcol an integer array of length nnz . on input indcol must contain the column indices of the non-zero elements\nof a . on output indcol is permuted so that these indices\nare in non-decreasing order. integer, dimension(n+1) :: Jpntr an integer output array of length n + 1 which\nspecifies the locations of the row indices in the output indrow . the row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(1) is set to 1 and that jpntr(n+1)-1 is then nnz . integer, dimension(n) :: Iwa an integer work array of length n . Called by proc~~srtdat~~CalledByGraph proc~srtdat dsm_module::srtdat proc~dsm dsm_module::dsm proc~dsm->proc~srtdat proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm program~dsm_test dsm_test program~dsm_test->proc~dsm proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine srtdat ( n , Nnz , Indrow , Indcol , Jpntr , Iwa ) implicit none integer :: n !! a positive integer input variable set to the number !! of columns of `a`. integer :: Nnz !! a positive integer input variable set to the number !! of non-zero elements of `a`. integer , dimension ( Nnz ) :: Indrow !! an integer array of length `nnz`. on input `indrow` !! must contain the row indices of the non-zero elements of `a`. !! on output `indrow` is permuted so that the corresponding !! column indices of `indcol` are in non-decreasing order. integer , dimension ( Nnz ) :: Indcol !! an integer array of length `nnz`. on input `indcol` !! must contain the column indices of the non-zero elements !! of `a`. on output `indcol` is permuted so that these indices !! are in non-decreasing order. integer , dimension ( n + 1 ) :: Jpntr !! an integer output array of length `n + 1` which !! specifies the locations of the row indices in the output !! `indrow`. the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(1)` is set to 1 and that `jpntr(n+1)-1` !! is then `nnz`. integer , dimension ( n ) :: Iwa !! an integer work array of length `n`. integer :: i , j , k , l ! store in array iwa the counts of non-zeroes in the columns. do j = 1 , n Iwa ( j ) = 0 enddo do k = 1 , Nnz Iwa ( Indcol ( k )) = Iwa ( Indcol ( k )) + 1 enddo ! set pointers to the start of the columns in indrow. Jpntr ( 1 ) = 1 do j = 1 , n Jpntr ( j + 1 ) = Jpntr ( j ) + Iwa ( j ) Iwa ( j ) = Jpntr ( j ) enddo k = 1 ! begin in-place sort. do j = Indcol ( k ) if ( k >= Jpntr ( j ) ) then ! current element is in position. now examine the ! next element or the first un-sorted element in ! the j-th group. k = max ( k + 1 , Iwa ( j )) else ! current element is not in position. place element ! in position and make the displaced element the ! current element. l = Iwa ( j ) Iwa ( j ) = Iwa ( j ) + 1 i = Indrow ( k ) Indrow ( k ) = Indrow ( l ) Indcol ( k ) = Indcol ( l ) Indrow ( l ) = i Indcol ( l ) = j endif if ( k > Nnz ) exit end do end subroutine srtdat","tags":"","loc":"proc/srtdat.html"},{"title":"fdjs – AoC-2023","text":"public  subroutine fdjs(m, n, Col, Ind, Npntr, Ngrp, Numgrp, d, Fjacd, Fjac) Given a consistent partition of the columns of an m by n jacobian matrix into groups, this subroutine computes\n  approximations to those columns in a given group.  the\n  approximations are stored into either a column-oriented\n  or a row-oriented pattern. a partition is consistent if the columns in any group\n  do not have a non-zero in the same row position. approximations to the columns of the jacobian matrix in a\n  given group can be obtained by specifying a difference\n  parameter array d with d(jcol) non-zero if and only if jcol is a column in the group, and an approximation to jac*d where jac denotes the jacobian matrix of a mapping f. d can be defined with the following segment of code. do jcol = 1 , n d ( jcol ) = 0.0 if ( ngrp ( jcol ) == numgrp ) d ( jcol ) = eta ( jcol ) end do in the above code numgrp is the given group number, ngrp(jcol) is the group number of column jcol , and eta(jcol) is the difference parameter used to\n  approximate column jcol of the jacobian matrix.\n  suitable values for the array eta must be provided. as mentioned above, an approximation to jac*d must\n  also be provided. for example, the approximation f ( x + d ) - f ( x ) corresponds to the forward difference formula at x . Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of the jacobian matrix. integer, intent(in) :: n a positive integer input variable set to the number\nof columns of the jacobian matrix. logical, intent(in) :: Col a logical input variable. if col is set true, then the\njacobian approximations are stored into a column-oriented\npattern. if col is set false, then the jacobian\napproximations are stored into a row-oriented pattern. integer, dimension(*) :: Ind an integer input array which contains the row\nindices for the non-zeroes in the jacobian matrix\nif col is true, and contains the column indices for\nthe non-zeroes in the jacobian matrix if col is false. integer, dimension(*) :: Npntr an integer input array which specifies the\nlocations of the row indices in ind if col is true, and\nspecifies the locations of the column indices in ind if col is false. if col is true, the indices for column j are ind(k), k = npntr(j),...,npntr(j+1)-1 .\nif col is false, the indices for row i are ind(k), k = npntr(i),...,npntr(i+1)-1 . Note that npntr(n+1)-1 if col is true, or npntr(m+1)-1 if col is false, is then the number of non-zero elements\nof the jacobian matrix. integer, dimension(n) :: Ngrp an integer input array of length n which specifies\nthe partition of the columns of the jacobian matrix.\ncolumn jcol belongs to group ngrp(jcol) . integer :: Numgrp a positive integer input variable set to a group\nnumber in the partition. the columns of the jacobian\nmatrix in this group are to be estimated on this call. real(kind=wp), dimension(n) :: d an input array of length n which contains the\ndifference parameter vector for the estimate of\nthe jacobian matrix columns in group numgrp . real(kind=wp), dimension(m) :: Fjacd an input array of length m which contains\nan approximation to the difference vector jac*d ,\nwhere jac denotes the jacobian matrix. real(kind=wp), dimension(*) :: Fjac an output array of length nnz , where nnz is the\nnumber of its non-zero elements. at each call of fdjs , fjac is updated to include the non-zero elements of the\njacobian matrix for those columns in group numgrp . fjac should not be altered between successive calls to fdjs . Called by proc~~fdjs~~CalledByGraph proc~fdjs dsm_module::fdjs program~dsm_test dsm_test program~dsm_test->proc~fdjs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fdjs ( m , n , Col , Ind , Npntr , Ngrp , Numgrp , d , Fjacd , Fjac ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of the jacobian matrix. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of the jacobian matrix. integer :: Numgrp !! a positive integer input variable set to a group !! number in the partition. the columns of the jacobian !! matrix in this group are to be estimated on this call. integer , dimension ( * ) :: Ind !! an integer input array which contains the row !! indices for the non-zeroes in the jacobian matrix !! if `col` is true, and contains the column indices for !! the non-zeroes in the jacobian matrix if `col` is false. integer , dimension ( * ) :: Npntr !! an integer input array which specifies the !! locations of the row indices in `ind` if `col` is true, and !! specifies the locations of the column indices in `ind` if !! `col` is false. if `col` is true, the indices for column `j` are !!       `ind(k), k = npntr(j),...,npntr(j+1)-1`. !! if `col` is false, the indices for row `i` are !!       `ind(k), k = npntr(i),...,npntr(i+1)-1`. !! ***Note*** that `npntr(n+1)-1` if `col` is true, or `npntr(m+1)-1` !! if `col` is false, is then the number of non-zero elements !! of the jacobian matrix. integer , dimension ( n ) :: Ngrp !! an integer input array of length `n` which specifies !! the partition of the columns of the jacobian matrix. !! column `jcol` belongs to group `ngrp(jcol)`. real ( wp ), dimension ( n ) :: d !! an input array of length `n` which contains the !! difference parameter vector for the estimate of !! the jacobian matrix columns in group `numgrp`. real ( wp ), dimension ( m ) :: Fjacd !! an input array of length `m` which contains !! an approximation to the difference vector `jac*d`, !! where `jac` denotes the jacobian matrix. real ( wp ), dimension ( * ) :: Fjac !! an output array of length `nnz`, where `nnz` is the !! number of its non-zero elements. at each call of `fdjs`, !! `fjac` is updated to include the non-zero elements of the !! jacobian matrix for those columns in group `numgrp`. `fjac` !! should not be altered between successive calls to `fdjs`. logical , intent ( in ) :: Col !! a logical input variable. if `col` is set true, then the !! jacobian approximations are stored into a column-oriented !! pattern. if `col` is set false, then the jacobian !! approximations are stored into a row-oriented pattern. integer :: ip , irow , jcol , jp ! compute estimates of jacobian matrix columns in group ! numgrp. the array fjacd must contain an approximation ! to jac*d, where jac denotes the jacobian matrix and d ! is a difference parameter vector with d(jcol) non-zero ! if and only if jcol is a column in group numgrp. if ( Col ) then ! column orientation. do jcol = 1 , n if ( Ngrp ( jcol ) == Numgrp ) then do jp = Npntr ( jcol ) , Npntr ( jcol + 1 ) - 1 irow = Ind ( jp ) Fjac ( jp ) = Fjacd ( irow ) / d ( jcol ) enddo endif enddo else ! row orientation. do irow = 1 , m do ip = Npntr ( irow ) , Npntr ( irow + 1 ) - 1 jcol = Ind ( ip ) if ( Ngrp ( jcol ) == Numgrp ) then Fjac ( ip ) = Fjacd ( irow ) / d ( jcol ) exit endif enddo enddo endif end subroutine fdjs","tags":"","loc":"proc/fdjs.html"},{"title":"match – AoC-2023","text":"function match(ipattern, ints) returns true if the pattern is valid for the int list. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: ipattern integer, intent(in), dimension(:) :: ints Return Value logical Called by proc~~match~~CalledByGraph proc~match problem_12::match proc~test problem_12::test proc~test->proc~match proc~test->proc~test proc~go~6 problem_12::go proc~go~6->proc~test program~problem_12 problem_12 program~problem_12->proc~go~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function match ( ipattern , ints ) !! returns true if the pattern is valid for the int list. integer , dimension (:), intent ( in ) :: ipattern integer , dimension (:), intent ( in ) :: ints integer :: i , iacc , int_checked integer , dimension ( 1 ) :: ifirst , iend logical :: accumulating ! .##..###... -> 2,3 ! start and end indices (ignoring leading and trailing spaces) ifirst = findloc ( ipattern , 1 ) iend = findloc ( ipattern , 1 , back = . true .) if ( ifirst ( 1 ) == 0 . or . iend ( 1 ) == 0 ) then ! all blank match = . false .; return end if ! step through the pattern and stop once we find it invalid accumulating = . true . iacc = 0 int_checked = 0 ! the count of ints that have been checked match = . true . ! initialize do i = ifirst ( 1 ), iend ( 1 ) select case ( ipattern ( i )) case ( POINT ) if ( accumulating ) then int_checked = int_checked + 1 ! check the next one if ( int_checked > size ( ints )) then ! too many ints match = . false . return else if ( ints ( int_checked ) /= iacc ) then ! doesn't match match = . false . return end if accumulating = . false . iacc = 0 end if case ( NUMBER ) if ( accumulating ) then iacc = iacc + 1 else ! start of a new number accumulating = . true . iacc = 1 end if if ( i == iend ( 1 )) then ! last number int_checked = int_checked + 1 ! check the next one if ( int_checked /= size ( ints )) then ! not enough ints match = . false . return else if ( ints ( int_checked ) /= iacc ) then ! doesn't match match = . false . return end if end if end select end do end function match","tags":"","loc":"proc/match.html"},{"title":"go – AoC-2023","text":"subroutine go(expand, isum) Arguments Type Intent Optional Attributes Name logical, intent(in) :: expand integer(kind=ip), intent(out) :: isum Calls proc~~go~6~~CallsGraph proc~go~6 problem_12::go interface~split aoc_utilities::split proc~go~6->interface~split proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~go~6->proc~number_of_lines_in_file proc~parse_ints aoc_utilities::parse_ints proc~go~6->proc~parse_ints proc~read_line aoc_utilities::read_line proc~go~6->proc~read_line proc~str_to_int_array_with_mapping aoc_utilities::str_to_int_array_with_mapping proc~go~6->proc~str_to_int_array_with_mapping proc~test problem_12::test proc~go~6->proc~test proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~test->proc~test proc~match problem_12::match proc~test->proc~match proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~go~6~~CalledByGraph proc~go~6 problem_12::go program~problem_12 problem_12 program~problem_12->proc~go~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine go ( expand , isum ) logical , intent ( in ) :: expand integer ( ip ), intent ( out ) :: isum integer :: iunit , n_lines , n_unknowns integer ( ip ) :: n_perms character ( len = :), allocatable :: line , pattern type ( string ), dimension (:), allocatable :: vals ! open(newunit=iunit, file='inputs/day12_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day12.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ints = parse_ints ( vals ( 2 )% str ) ! integer list  1,1,3 pattern = vals ( 1 )% str ! the pattern   #.#.### ! will convert the pattern to an array of numbers: ipattern = str_to_int_array_with_mapping ( pattern ,[ '.' , '#' , '?' ],& [ POINT , NUMBER , QUESTION ]) ! 1010111 if ( expand ) then ! brute force it ipattern = [ ipattern , QUESTION , ipattern , QUESTION , & ipattern , QUESTION , ipattern , QUESTION , & ipattern ] ints = [ ints , ints , ints , ints , ints ] end if n_unknowns = count ( ipattern == 2 ) n_valid = 0 ! number of valid permutations n_perms = 2 ** n_unknowns ! number of permutations ipattern_tmp = ipattern ! recursively test all the permutations if ( allocated ( a )) deallocate ( a ) allocate ( a ( n_unknowns )) call test ( 1 , n_unknowns ) isum = isum + n_valid ! write(*,*) iline, 'n_valid = ', n_valid end do end subroutine go","tags":"","loc":"proc/go~6.html"},{"title":"test – AoC-2023","text":"recursive subroutine test(i, n) each ? can be either a . or a #\ncheck pattern to match the int list Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: n Calls proc~~test~~CallsGraph proc~test problem_12::test proc~test->proc~test proc~match problem_12::match proc~test->proc~match Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~test~~CalledByGraph proc~test problem_12::test proc~test->proc~test proc~go~6 problem_12::go proc~go~6->proc~test program~problem_12 problem_12 program~problem_12->proc~go~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine test ( i , n ) !! each ? can be either a . or a # !! check pattern to match the int list integer , intent ( in ) :: i , n integer :: ix integer , dimension ( * ), parameter :: icoeffs = [ POINT , NUMBER ] !! set of coefficients ['.', '#'] ! what we are not doing here is accounting for permutations ! that we know do not match, because the begin with a sequence ! that doesn't match. those need to be skipped... if ( i > n ) then ! so we have an array of 0s and 1s -> replace the 2s in the ipattern with these !     ipattern: 2220111  -> ???.### !            a: 011      -> .## !       result: 0110111  -> .##.### !write(*,'(a,1x,i5,1x, *(I1))') 'test:', iline, ipattern_tmp ipattern_tmp = unpack ( a , mask = ipattern == QUESTION , field = ipattern ) if ( match ( ipattern_tmp , ints )) n_valid = n_valid + 1 else do ix = 1 , 2 a ( i ) = icoeffs ( ix ) call test ( i + 1 , n ) end do end if end subroutine test","tags":"","loc":"proc/test.html"},{"title":"fcn – AoC-2023","text":"subroutine fcn(n, x, Indcol, Ipntr, Fvec) Function subroutine for testing fdjs . Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: x (n) integer :: Indcol (*) integer :: Ipntr (n+1) real(kind=wp) :: Fvec (n) Called by proc~~fcn~~CalledByGraph proc~fcn dsm_test::fcn program~dsm_test dsm_test program~dsm_test->proc~fcn Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fcn ( n , x , Indcol , Ipntr , Fvec ) !! Function subroutine for testing [[fdjs]]. implicit none integer n integer Indcol ( * ) , Ipntr ( n + 1 ) real ( wp ) :: x ( n ) , Fvec ( n ) integer i , ip real ( wp ) :: sum do i = 1 , n sum = 0.0_wp do ip = Ipntr ( i ) , Ipntr ( i + 1 ) - 1 sum = sum + x ( Indcol ( ip )) enddo sum = sum + x ( i ) Fvec ( i ) = sum * ( 1.0_wp + sum ) + 1.0_wp enddo end subroutine fcn","tags":"","loc":"proc/fcn.html"},{"title":"func – AoC-2023","text":"function func(x) result(f) Test function to minimize. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x indep. variable Return Value real(kind=wp) function value f(x) Source Code function func ( x ) result ( f ) implicit none real ( wp ), intent ( in ) :: x !! indep. variable real ( wp ) :: f !! function value `f(x)` f = sin ( x ) end function func","tags":"","loc":"proc/func.html"},{"title":"in_seed_list – AoC-2023","text":"function in_seed_list(iseed) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: iseed Return Value logical Called by proc~~in_seed_list~~CalledByGraph proc~in_seed_list problem_5::in_seed_list program~problem_5 problem_5 program~problem_5->proc~in_seed_list Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function in_seed_list ( iseed ) ! for part b, is the seed in the initial list integer ( ip ), intent ( in ) :: iseed integer :: i do i = 1 , size ( seeds_list ), 2 if ( iseed >= seeds_list ( i ) . and . iseed <= seeds_list ( i ) + seeds_list ( i + 1 ) - 1 ) then in_seed_list = . true . return end if end do in_seed_list = . false . end function in_seed_list","tags":"","loc":"proc/in_seed_list.html"},{"title":"map – AoC-2023","text":"pure function map(ival, m, reverse) result(idest) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: ival type( mapping ), intent(in) :: m logical, intent(in) :: reverse Return Value integer(kind=ip) Called by proc~~map~~CalledByGraph proc~map problem_5::map proc~traverse problem_5::traverse proc~traverse->proc~map program~problem_5 problem_5 program~problem_5->proc~traverse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function map ( ival , m , reverse ) result ( idest ) integer ( ip ), intent ( in ) :: ival type ( mapping ), intent ( in ) :: m logical , intent ( in ) :: reverse ! if reversed, go from: dest -> src integer ( ip ) :: idest integer :: i if ( reverse ) then do i = 1 , size ( m % src_start ) ! locate ival (dest) in the dest start:end range if ( ival >= m % dest_start ( i ) . and . ival <= m % dest_end ( i )) then ! found it, map to dest idest = m % src_start ( i ) + ( ival - m % dest_start ( i )) ! this is the resultant isource return end if end do else do i = 1 , size ( m % src_start ) ! locate ival (source) in the source start:end range if ( ival >= m % src_start ( i ) . and . ival <= m % src_end ( i )) then ! found it, map to dest idest = m % dest_start ( i ) + ( ival - m % src_start ( i )) return end if end do end if idest = ival ! if not found in any of the sets end function map","tags":"","loc":"proc/map.html"},{"title":"traverse – AoC-2023","text":"pure function traverse(iseed, reverse) result(ilocation) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: iseed logical, intent(in) :: reverse if reverse, then ilocation -> iseed Return Value integer(kind=ip) Calls proc~~traverse~~CallsGraph proc~traverse problem_5::traverse proc~map problem_5::map proc~traverse->proc~map Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~traverse~~CalledByGraph proc~traverse problem_5::traverse program~problem_5 problem_5 program~problem_5->proc~traverse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function traverse ( iseed , reverse ) result ( ilocation ) integer ( ip ), intent ( in ) :: iseed logical , intent ( in ) :: reverse !! if reverse, then ilocation -> iseed integer ( ip ) :: ilocation integer :: i ilocation = iseed ! initialize if ( reverse ) then do i = NSTAGES , 1 , - 1 ilocation = map ( ilocation , mappings ( i ), reverse ) ! this is really iseed end do else do i = 1 , NSTAGES ilocation = map ( ilocation , mappings ( i ), reverse ) end do end if end function traverse","tags":"","loc":"proc/traverse.html"},{"title":"populate – AoC-2023","text":"subroutine populate(nums, m) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(3) :: nums type( mapping ), intent(inout) :: m Called by proc~~populate~~CalledByGraph proc~populate problem_5::populate program~problem_5 problem_5 program~problem_5->proc~populate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine populate ( nums , m ) integer ( ip ), dimension ( 3 ), intent ( in ) :: nums ! the three numbers from the line: ! [dest range start, src range start, range length type ( mapping ), intent ( inout ) :: m ! structure to add this data to associate ( dest => nums ( 1 ), source => nums ( 2 ), range => nums ( 3 ) ) m % dest_start = [ m % dest_start , dest ] m % dest_end = [ m % dest_end , dest + range - 1 ] m % src_start = [ m % src_start , source ] m % src_end = [ m % src_end , source + range - 1 ] end associate end subroutine populate","tags":"","loc":"proc/populate.html"},{"title":"go – AoC-2023","text":"recursive function go(ipattern, ints) result(ival) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ipattern integer(kind=ip), intent(in), dimension(:) :: ints Return Value integer(kind=ip) Calls proc~~go~~CallsGraph proc~go problem_12b::go proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~go->proc~get_from_cache~2 proc~ipoint problem_12b::ipoint proc~go->proc~ipoint proc~ipound problem_12b::ipound proc~go->proc~ipound proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~go->proc~put_in_cache~2 proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 proc~ipoint->proc~go proc~ipound->proc~go ints_tmp ints_tmp proc~ipound->ints_tmp ipattern_tmp ipattern_tmp proc~ipound->ipattern_tmp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~go~~CalledByGraph proc~go problem_12b::go proc~ipoint problem_12b::ipoint proc~go->proc~ipoint proc~ipound problem_12b::ipound proc~go->proc~ipound proc~ipoint->proc~go proc~ipound->proc~go program~problem_12b problem_12b program~problem_12b->proc~go Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive function go ( ipattern , ints ) result ( ival ) integer ( ip ), dimension (:), intent ( in ) :: ipattern integer ( ip ), dimension (:), intent ( in ) :: ints integer ( ip ) :: ival integer ( ip ), dimension (:), allocatable :: ival_vec integer ( ip ) :: idx logical :: found ! first check the cache: call cache % get ([ ipattern , ints ], idx , ival_vec , found ) if ( found ) then ival = ival_vec ( 1 ) else if ( size ( ints ) == 0 ) then ! no more ints ival = merge ( 0 , 1 , any ( ipattern == NUMBER )) ! if any more numbers, invalid else if ( size ( ipattern ) == 0 ) then ival = 0 ! too many ints else ! process next element in pattern select case ( ipattern ( 1 )) case ( NUMBER ); ival = ipound ( ipattern , ints ) case ( POINT ); ival = ipoint ( ipattern , ints ) case ( QUESTION ); ival = ipoint ( ipattern , ints ) + ipound ( ipattern , ints ) end select end if ! cache this function call: ival_vec = [ ival ] call cache % put ( idx ,[ ipattern , ints ], ival_vec ) end if end function go","tags":"","loc":"proc/go.html"},{"title":"ipound – AoC-2023","text":"recursive function ipound(ipattern, ints) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ipattern first char is a # integer(kind=ip), intent(in), dimension(:) :: ints Return Value integer(kind=ip) Calls proc~~ipound~~CallsGraph proc~ipound problem_12b::ipound ints_tmp ints_tmp proc~ipound->ints_tmp ipattern_tmp ipattern_tmp proc~ipound->ipattern_tmp proc~go problem_12b::go proc~ipound->proc~go proc~go->proc~ipound proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~go->proc~get_from_cache~2 proc~ipoint problem_12b::ipoint proc~go->proc~ipoint proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~go->proc~put_in_cache~2 proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 proc~ipoint->proc~go Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ipound~~CalledByGraph proc~ipound problem_12b::ipound proc~go problem_12b::go proc~ipound->proc~go proc~go->proc~ipound proc~ipoint problem_12b::ipoint proc~go->proc~ipoint proc~ipoint->proc~go program~problem_12b problem_12b program~problem_12b->proc~go Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive integer ( ip ) function ipound ( ipattern , ints ) integer ( ip ), dimension (:), intent ( in ) :: ipattern !! first char is a # integer ( ip ), dimension (:), intent ( in ) :: ints integer ( ip ), dimension (:), allocatable :: this_group ! check for the number of # that correspond to the first group if ( size ( ipattern ) >= ints ( 1 )) then this_group = ipattern ( 1 : ints ( 1 )) where ( this_group == QUESTION ) this_group = NUMBER ! replace ? with # if ( any ( this_group /= NUMBER )) then ! can't fit all the #'s so not valid ipound = 0 return else ! so far so good end if else ! not enough room to hold all the #'s ipound = 0 return end if if ( size ( ipattern ) == ints ( 1 )) then ! if this is the last group, then we are done ipound = merge ( 1 , 0 , size ( ints ) == 1 ) else ! the next character after this number must be a ? or . if ( size ( ipattern ) >= ints ( 1 ) + 1 ) then if ( any ( ipattern ( ints ( 1 ) + 1 ) == [ QUESTION , POINT ])) then block integer ( ip ), dimension (:), allocatable :: ipattern_tmp , ints_tmp ! to handle edge cases ! skip it and process the next group if ( size ( ipattern ) >= ints ( 1 ) + 2 ) then ipattern_tmp = ipattern ( ints ( 1 ) + 2 :) else allocate ( ipattern_tmp ( 0 )) end if if ( size ( ints ) >= 2 ) then ints_tmp = ints ( 2 :) else allocate ( ints_tmp ( 0 )) end if ipound = go ( ipattern_tmp , ints_tmp ) return end block end if end if ! not valid at this point ipound = 0 end if end function ipound","tags":"","loc":"proc/ipound.html"},{"title":"ipoint – AoC-2023","text":"recursive function ipoint(ipattern, ints) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ipattern first char is a . integer(kind=ip), intent(in), dimension(:) :: ints Return Value integer(kind=ip) Calls proc~~ipoint~~CallsGraph proc~ipoint problem_12b::ipoint proc~go problem_12b::go proc~ipoint->proc~go proc~go->proc~ipoint proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~go->proc~get_from_cache~2 proc~ipound problem_12b::ipound proc~go->proc~ipound proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~go->proc~put_in_cache~2 proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 proc~ipound->proc~go ints_tmp ints_tmp proc~ipound->ints_tmp ipattern_tmp ipattern_tmp proc~ipound->ipattern_tmp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ipoint~~CalledByGraph proc~ipoint problem_12b::ipoint proc~go problem_12b::go proc~ipoint->proc~go proc~go->proc~ipoint proc~ipound problem_12b::ipound proc~go->proc~ipound proc~ipound->proc~go program~problem_12b problem_12b program~problem_12b->proc~go Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive integer ( ip ) function ipoint ( ipattern , ints ) integer ( ip ), dimension (:), intent ( in ) :: ipattern !! first char is a . integer ( ip ), dimension (:), intent ( in ) :: ints if ( size ( ipattern ) <= 1 ) then ipoint = go ([ integer ( ip ) :: ], ints ) ! done, pass in empty array else ipoint = go ( ipattern ( 2 :), ints ) ! skip it and go to next one end if end function ipoint","tags":"","loc":"proc/ipoint.html"},{"title":"moves – AoC-2023","text":"pure function moves(istart, iend) result(imoves) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: istart indices for start and end nodes integer(kind=ip), intent(in) :: iend indices for start and end nodes Return Value integer(kind=ip) Called by proc~~moves~~CalledByGraph proc~moves problem_8::moves program~problem_8 problem_8 program~problem_8->proc~moves Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function moves ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart , iend !! indices for start and end nodes integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( idx == iend ) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves","tags":"","loc":"proc/moves.html"},{"title":"moves_any_z – AoC-2023","text":"pure function moves_any_z(istart, iend) result(imoves) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: istart indices for start and end nodes integer(kind=ip), intent(in), dimension(:) :: iend Return Value integer(kind=ip) Called by proc~~moves_any_z~~CalledByGraph proc~moves_any_z problem_8::moves_any_z program~problem_8 problem_8 program~problem_8->proc~moves_any_z Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function moves_any_z ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart !! indices for start and end nodes integer ( ip ), dimension (:), intent ( in ) :: iend integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( any ( idx == iend )) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves_any_z","tags":"","loc":"proc/moves_any_z.html"},{"title":"all_in_set – AoC-2023","text":"pure function all_in_set(ivals, iset) returns true if all the elements of ivals are in the set iset Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals integer(kind=ip), intent(in), dimension(:) :: iset Return Value logical Source Code pure logical function all_in_set ( ivals , iset ) !! returns true if all the elements of ivals are in the set iset integer ( ip ), dimension (:), intent ( in ) :: ivals , iset integer :: i all_in_set = . true . do i = 1 , size ( ivals ) if (. not . any ( ivals ( i ) == iset )) then all_in_set = . false . exit end if end do end function all_in_set","tags":"","loc":"proc/all_in_set.html"},{"title":"find_node – AoC-2023","text":"pure function find_node(name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value integer(kind=ip) Called by proc~~find_node~~CalledByGraph proc~find_node problem_8::find_node program~problem_8 problem_8 program~problem_8->proc~find_node Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer ( ip ) function find_node ( name ) character ( len =* ), intent ( in ) :: name integer ( ip ) :: i do i = 1 , size ( nodes ) if ( name == nodes ( i )% name ) then find_node = i return end if end do error stop 'could not find node' end function find_node","tags":"","loc":"proc/find_node.html"},{"title":"my_func – AoC-2023","text":"subroutine my_func(me, x, f, funcs_to_compute) Problem function Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: f integer, intent(in), dimension(:) :: funcs_to_compute Source Code subroutine my_func ( me , x , f , funcs_to_compute ) !! Problem function implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f integer , dimension (:), intent ( in ) :: funcs_to_compute if ( any ( funcs_to_compute == 1 )) f ( 1 ) = x ( 1 ) * x ( 2 ) - x ( 3 ) ** 3 if ( any ( funcs_to_compute == 2 )) f ( 2 ) = x ( 3 ) - 1.0_wp if ( any ( funcs_to_compute == 3 )) f ( 3 ) = x ( 4 ) * x ( 5 ) if ( any ( funcs_to_compute == 4 )) f ( 4 ) = 2.0_wp * x ( 6 ) + sin ( x ( 7 )) if ( any ( funcs_to_compute == 5 )) f ( 5 ) = cos ( x ( 8 )) + sqrt ( abs ( x ( 9 ))) if ( any ( funcs_to_compute == 6 )) f ( 6 ) = 1.0_wp / ( 1.0_wp + exp ( x ( 10 ))) func_evals = func_evals + 1 end subroutine my_func","tags":"","loc":"proc/my_func.html"},{"title":"vector_djb_hash – AoC-2023","text":"private pure function vector_djb_hash(r) result(hash) DJB hash algorithm for a real(wp) vector. See also J. Shahbazian, Fortran hashing algorithm, July 6, 2013 Fortran Dev Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: r the vector Return Value integer(kind=ip) the hash value Called by proc~~vector_djb_hash~~CalledByGraph proc~vector_djb_hash numdiff_cache_module::vector_djb_hash proc~get_from_cache numdiff_cache_module::function_cache%get_from_cache proc~get_from_cache->proc~vector_djb_hash proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~get_from_cache Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function vector_djb_hash ( r ) result ( hash ) real ( wp ), dimension (:), intent ( in ) :: r !! the vector integer ( ip ) :: hash !! the hash value integer :: i !! counter hash = 5381_ip do i = 1 , size ( r ) hash = ishft ( hash , 5_ip ) + hash + transfer ( r ( i ), 1_ip ) end do end function vector_djb_hash","tags":"","loc":"proc/vector_djb_hash.html"},{"title":"initialize_cache – AoC-2023","text":"private  subroutine initialize_cache(me, isize, n, m, chunk_size) Initialize the cache. Must be called first before use. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: isize the size of the hash table integer, intent(in) :: n number of independant variables (x) integer, intent(in) :: m number of functions (f) integer, intent(in), optional :: chunk_size chunk size to speed up reallocation\nof arrays. A good value is a guess for\nthe actual number of elements of f that\nwill be saved per value of x [default is 100] Calls proc~~initialize_cache~~CallsGraph proc~initialize_cache numdiff_cache_module::function_cache%initialize_cache proc~destroy_cache numdiff_cache_module::function_cache%destroy_cache proc~initialize_cache->proc~destroy_cache Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~initialize_cache~~CalledByGraph proc~initialize_cache numdiff_cache_module::function_cache%initialize_cache proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~initialize_cache proc~initialize_numdiff_for_diff numerical_differentiation_module::numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~initialize_cache program~test1 test1 program~test1->proc~initialize_numdiff program~test1->proc~initialize_numdiff_for_diff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize_cache ( me , isize , n , m , chunk_size ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: isize !! the size of the hash table integer , intent ( in ) :: n !! number of independant variables (x) integer , intent ( in ) :: m !! number of functions (f) integer , intent ( in ), optional :: chunk_size !! chunk size to speed up reallocation !! of arrays. A good value is a guess for !! the actual number of elements of `f` that !! will be saved per value of `x` [default is 100] call me % destroy () allocate ( me % c ( 0 : isize - 1 )) me % n = n me % m = m if ( present ( chunk_size )) then me % chunk_size = chunk_size else me % chunk_size = 100 end if end subroutine initialize_cache","tags":"","loc":"proc/initialize_cache.html"},{"title":"print_cache – AoC-2023","text":"private  subroutine print_cache(me, iunit) Print the contents of the cache. Used for debugging. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: iunit file unit for writing\n(assumed to be opened) Source Code subroutine print_cache ( me , iunit ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: iunit !! file unit for writing !! (assumed to be opened) integer :: i !! counter write ( iunit , '(A)' ) '' write ( iunit , '(A)' ) '------------------------' if ( allocated ( me % c )) then do i = 1 , size ( me % c ) if ( allocated ( me % c ( i )% x )) then write ( iunit , '(A)' ) '' write ( iunit , '(A,1X,I10)' ) 'Entry ' , i write ( iunit , '(A,1X,*(F27.16,1X))' ) 'x  :' , me % c ( i )% x if ( allocated ( me % c ( i )% f )) then write ( iunit , '(A,1X,*(I27,1X))' ) 'ifs:' , me % c ( i )% ifs write ( iunit , '(A,1X,*(F27.16,1X))' ) 'f  :' , me % c ( i )% f ( me % c ( i )% ifs ) end if write ( iunit , '(A)' ) '------------------------' end if end do else write ( iunit , '(A)' ) 'Cache is not initialized' write ( iunit , '(A)' ) '------------------------' end if write ( iunit , '(A)' ) '' end subroutine print_cache","tags":"","loc":"proc/print_cache.html"},{"title":"get_from_cache – AoC-2023","text":"private  subroutine get_from_cache(me, x, ifs, i, f, xfound, ffound) Check if the x vector is in the cache, if so return f .\nNote that only some of the elements may be present, so it will return\nthe ones there are there, and indicate which ones were found. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x independant variable vector integer, intent(in), dimension(:) :: ifs elements of f needed integer, intent(out) :: i index in the hash table real(kind=wp), intent(out), dimension(:) :: f f(x) from the cache (if it was found) logical, intent(out) :: xfound if x was found in the cache logical, intent(out), dimension(size(ifs)) :: ffound which ifs were found in the cache Calls proc~~get_from_cache~~CallsGraph proc~get_from_cache numdiff_cache_module::function_cache%get_from_cache proc~vector_djb_hash numdiff_cache_module::vector_djb_hash proc~get_from_cache->proc~vector_djb_hash Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_from_cache~~CalledByGraph proc~get_from_cache numdiff_cache_module::function_cache%get_from_cache proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~get_from_cache Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_from_cache ( me , x , ifs , i , f , xfound , ffound ) implicit none class ( function_cache ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! independant variable vector integer , dimension (:), intent ( in ) :: ifs !! elements of `f` needed integer , intent ( out ) :: i !! index in the hash table real ( wp ), dimension (:), intent ( out ) :: f !! `f(x)` from the cache (if it was found) logical , intent ( out ) :: xfound !! if `x` was found in the cache logical , dimension ( size ( ifs )), intent ( out ) :: ffound !! which `ifs` were found in the cache integer :: j !! counter ! initialize: xfound = . false . ffound = . false . if ( allocated ( me % c )) then ! get index in the hash table: i = mod ( abs ( vector_djb_hash ( x )), int ( size ( me % c ), ip ) ) ! check the table: if ( allocated ( me % c ( i )% x ) . and . allocated ( me % c ( i )% f )) then if ( size ( me % c ( i )% x ) == size ( x ) . and . & size ( me % c ( i )% f ) == size ( f )) then if ( all ( me % c ( i )% x == x )) then xfound = . true . ! return the elements that were found in the cache: f ( me % c ( i )% ifs ) = me % c ( i )% f ( me % c ( i )% ifs ) ! what indices are in the cache? do j = 1 , size ( ifs ) ffound ( j ) = any ( ifs ( j ) == me % c ( i )% ifs ) end do end if end if end if else error stop 'Error: the cache has not been initialized.' end if end subroutine get_from_cache","tags":"","loc":"proc/get_from_cache.html"},{"title":"put_in_cache – AoC-2023","text":"private  subroutine put_in_cache(me, i, x, f, ifs) Put a value into the cache. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: i index in the hash table real(kind=wp), intent(in), dimension(:) :: x independant variable vector (dimension n ) real(kind=wp), intent(in), dimension(:) :: f function vector f(x) (dimension m ) integer, intent(in), dimension(:) :: ifs elements of f to add (should all be >0, <=m ) Calls proc~~put_in_cache~~CallsGraph proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache interface~unique numdiff_utilities_module::unique proc~put_in_cache->interface~unique proc~unique_int numdiff_utilities_module::unique_int interface~unique->proc~unique_int proc~unique_real numdiff_utilities_module::unique_real interface~unique->proc~unique_real interface~expand_vector numdiff_utilities_module::expand_vector proc~unique_int->interface~expand_vector interface~sort_ascending numdiff_utilities_module::sort_ascending proc~unique_int->interface~sort_ascending proc~unique_real->interface~expand_vector proc~unique_real->interface~sort_ascending proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector->proc~expand_vector_real proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap numdiff_utilities_module::swap proc~sort_ascending_int->interface~swap proc~sort_ascending_real->interface~swap proc~swap_int numdiff_utilities_module::swap_int interface~swap->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~put_in_cache~~CalledByGraph proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine put_in_cache ( me , i , x , f , ifs ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: i !! index in the hash table real ( wp ), dimension (:), intent ( in ) :: x !! independant variable vector (dimension `n`) real ( wp ), dimension (:), intent ( in ) :: f !! function vector `f(x)` (dimension `m`) integer , dimension (:), intent ( in ) :: ifs !! elements of `f` to add (should all be `>0, <=m`) real ( wp ), parameter :: null = huge ( 1.0_wp ) !! an unusual value to initialize arrays if ( allocated ( me % c )) then if ( i <= size ( me % c )) then if ( allocated ( me % c ( i )% x )) then ! we need to check if there is an x already there, ! which may already have some function indices present. ! if same x, then add the new indices to them. ! if a different x, then replace indices. if ( all ( me % c ( i )% x == x )) then ! this x is already present in this location. ! so merge the new f,ifs into what is already there. if ( allocated ( me % c ( i )% f )) then me % c ( i )% ifs = unique ([ me % c ( i )% ifs , ifs ],& chunk_size = me % chunk_size ) else allocate ( me % c ( i )% f ( me % m )) me % c ( i )% f = null ! initialize to an unusual value me % c ( i )% ifs = ifs end if me % c ( i )% f ( ifs ) = f ( ifs ) else ! replace existing x and f. me % c ( i )% x = x me % c ( i )% ifs = ifs if ( allocated ( me % c ( i )% f )) deallocate ( me % c ( i )% f ) allocate ( me % c ( i )% f ( me % m )) me % c ( i )% f = null ! initialize to an unusual value me % c ( i )% f ( ifs ) = f ( ifs ) end if else ! new entry in the cache: me % c ( i )% x = x allocate ( me % c ( i )% f ( me % m )) me % c ( i )% f = null ! initialize to an unusual value me % c ( i )% ifs = ifs me % c ( i )% f ( ifs ) = f ( ifs ) end if else error stop 'Error: invalid index in hash table.' end if else error stop 'Error: the cache has not been initialized.' end if end subroutine put_in_cache","tags":"","loc":"proc/put_in_cache.html"},{"title":"destroy_cache – AoC-2023","text":"private  subroutine destroy_cache(me) Destroy a cache. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(out) :: me Called by proc~~destroy_cache~~CalledByGraph proc~destroy_cache numdiff_cache_module::function_cache%destroy_cache proc~initialize_cache numdiff_cache_module::function_cache%initialize_cache proc~initialize_cache->proc~destroy_cache proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~destroy_cache proc~initialize_numdiff->proc~initialize_cache proc~initialize_numdiff_for_diff numerical_differentiation_module::numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~destroy_cache proc~initialize_numdiff_for_diff->proc~initialize_cache program~test1 test1 program~test1->proc~initialize_numdiff program~test1->proc~initialize_numdiff_for_diff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy_cache ( me ) implicit none class ( function_cache ), intent ( out ) :: me end subroutine destroy_cache","tags":"","loc":"proc/destroy_cache.html"},{"title":"dag_get_edges – AoC-2023","text":"private pure function dag_get_edges(me, ivertex) result(edges) get the edges for the vertex (all the the vertices\nthat this vertex depends on). Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer, intent(in) :: ivertex Return Value integer, dimension(:), allocatable Source Code pure function dag_get_edges ( me , ivertex ) result ( edges ) implicit none class ( dag ), intent ( in ) :: me integer , intent ( in ) :: ivertex integer , dimension (:), allocatable :: edges if ( ivertex > 0 . and . ivertex <= me % n ) then edges = me % vertices ( ivertex )% edges ! auto LHS allocation end if end function dag_get_edges","tags":"","loc":"proc/dag_get_edges.html"},{"title":"dag_get_dependencies – AoC-2023","text":"private pure function dag_get_dependencies(me, ivertex) result(dep) get all the vertices that depend on this vertex. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer, intent(in) :: ivertex Return Value integer, dimension(:), allocatable the set of all vertices\nthan depend on ivertex Source Code pure function dag_get_dependencies ( me , ivertex ) result ( dep ) implicit none class ( dag ), intent ( in ) :: me integer , intent ( in ) :: ivertex integer , dimension (:), allocatable :: dep !! the set of all vertices !! than depend on `ivertex` integer :: i !! vertex counter if ( ivertex > 0 . and . ivertex <= me % n ) then ! have to check all the vertices: do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then if ( any ( me % vertices ( i )% edges == ivertex )) then if ( allocated ( dep )) then dep = [ dep , i ] ! auto LHS allocation else dep = [ i ] ! auto LHS allocation end if end if end if end do end if end function dag_get_dependencies","tags":"","loc":"proc/dag_get_dependencies.html"},{"title":"dag_generate_digraph – AoC-2023","text":"private  function dag_generate_digraph(me, rankdir, dpi) result(str) Generate a Graphviz digraph structure for the DAG. Example To convert this to a PDF using dot : dot -Tpdf -o test.pdf test.dot ,\n    where test.dot is str written to a file. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer, intent(in), optional :: dpi resolution (e.g. 300) Return Value character(len=:), allocatable Calls proc~~dag_generate_digraph~~CallsGraph proc~dag_generate_digraph dag_module::dag%dag_generate_digraph proc~integer_to_string~2 dag_module::integer_to_string proc~dag_generate_digraph->proc~integer_to_string~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dag_generate_digraph~~CalledByGraph proc~dag_generate_digraph dag_module::dag%dag_generate_digraph proc~dag_save_digraph dag_module::dag%dag_save_digraph proc~dag_save_digraph->proc~dag_generate_digraph program~dag_example dag_example program~dag_example->proc~dag_save_digraph program~problem_25 problem_25 program~problem_25->proc~dag_save_digraph Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function dag_generate_digraph ( me , rankdir , dpi ) result ( str ) implicit none class ( dag ), intent ( in ) :: me character ( len = :), allocatable :: str character ( len =* ), intent ( in ), optional :: rankdir !! right to left orientation (e.g. 'RL') integer , intent ( in ), optional :: dpi !! resolution (e.g. 300) integer :: i , j !! counter integer :: n_edges !! number of edges character ( len = :), allocatable :: attributes , label logical :: has_label , has_attributes character ( len =* ), parameter :: tab = '  ' !! for indenting character ( len =* ), parameter :: newline = new_line ( ' ' ) !! line break character if ( me % n == 0 ) return str = 'digraph G {' // newline // newline if ( present ( rankdir )) & str = str // tab // 'rankdir=' // rankdir // newline // newline if ( present ( dpi )) & str = str // tab // 'graph [ dpi = ' // integer_to_string ( dpi ) // ' ]' // newline // newline ! define the vertices: do i = 1 , me % n has_label = allocated ( me % vertices ( i )% label ) has_attributes = allocated ( me % vertices ( i )% attributes ) if ( has_label ) label = 'label=\"' // trim ( adjustl ( me % vertices ( i )% label )) // '\"' if ( has_label . and . has_attributes ) then attributes = '[' // trim ( adjustl ( me % vertices ( i )% attributes )) // ',' // label // ']' elseif ( has_label . and . . not . has_attributes ) then attributes = '[' // label // ']' elseif (. not . has_label . and . has_attributes ) then attributes = '[' // trim ( adjustl ( me % vertices ( i )% attributes )) // ']' else ! neither attributes = '' end if str = str // tab // integer_to_string ( i ) // ' ' // attributes // newline if ( i == me % n ) str = str // newline end do ! define the dependencies: do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then n_edges = size ( me % vertices ( i )% edges ) str = str // tab // integer_to_string ( i ) // merge ( ' -> ' , '    ' , n_edges /= 0 ) do j = 1 , n_edges ! comma-separated list: str = str // integer_to_string ( me % vertices ( i )% edges ( j )) if ( n_edges > 1 . and . j < n_edges ) str = str // ',' end do str = str // ';' // newline end if end do str = str // newline // '}' end function dag_generate_digraph","tags":"","loc":"proc/dag_generate_digraph.html"},{"title":"integer_to_string – AoC-2023","text":"private pure function integer_to_string(i) result(s) Integer to allocatable string. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=:), allocatable Called by proc~~integer_to_string~2~~CalledByGraph proc~integer_to_string~2 dag_module::integer_to_string proc~dag_generate_digraph dag_module::dag%dag_generate_digraph proc~dag_generate_digraph->proc~integer_to_string~2 proc~dag_set_vertex_info dag_module::dag%dag_set_vertex_info proc~dag_set_vertex_info->proc~integer_to_string~2 proc~dag_save_digraph dag_module::dag%dag_save_digraph proc~dag_save_digraph->proc~dag_generate_digraph program~dag_example dag_example program~dag_example->proc~dag_set_vertex_info program~dag_example->proc~dag_save_digraph program~problem_25 problem_25 program~problem_25->proc~dag_set_vertex_info program~problem_25->proc~dag_save_digraph Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function integer_to_string ( i ) result ( s ) implicit none integer , intent ( in ) :: i character ( len = :), allocatable :: s integer :: istat allocate ( character ( len = 64 ) :: s ) ! should be big enough write ( s , fmt = '(ss,I0)' , iostat = istat ) i if ( istat == 0 ) then s = trim ( adjustl ( s )) else s = '***' end if end function integer_to_string","tags":"","loc":"proc/integer_to_string~2.html"},{"title":"dag_destroy – AoC-2023","text":"private  subroutine dag_destroy(me) Destroy the dag . Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me Called by proc~~dag_destroy~~CalledByGraph proc~dag_destroy dag_module::dag%dag_destroy program~dag_example dag_example program~dag_example->proc~dag_destroy program~problem_25 problem_25 program~problem_25->proc~dag_destroy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_destroy ( me ) class ( dag ), intent ( inout ) :: me me % n = 0 if ( allocated ( me % vertices )) deallocate ( me % vertices ) end subroutine dag_destroy","tags":"","loc":"proc/dag_destroy.html"},{"title":"set_edge_vector – AoC-2023","text":"private  subroutine set_edge_vector(me, edges) specify the edge indices for this vertex Type Bound vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in), dimension(:) :: edges Calls proc~~set_edge_vector~~CallsGraph proc~set_edge_vector dag_module::vertex%set_edge_vector proc~add_edge dag_module::vertex%add_edge proc~set_edge_vector->proc~add_edge Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_edge_vector~~CalledByGraph proc~set_edge_vector dag_module::vertex%set_edge_vector none~set_edges dag_module::vertex%set_edges none~set_edges->proc~set_edge_vector proc~dag_set_edges dag_module::dag%dag_set_edges proc~dag_set_edges->none~set_edges program~dag_example dag_example program~dag_example->proc~dag_set_edges program~problem_25 problem_25 program~problem_25->proc~dag_set_edges Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_edge_vector ( me , edges ) class ( vertex ), intent ( inout ) :: me integer , dimension (:), intent ( in ) :: edges integer :: i !! counter if ( allocated ( me % edges )) then do i = 1 , size ( edges ) call me % add_edge ( edges ( i )) end do else allocate ( me % edges ( size ( edges ))) ! note: not checking for uniqueness here. me % edges = edges end if end subroutine set_edge_vector","tags":"","loc":"proc/set_edge_vector.html"},{"title":"add_edge – AoC-2023","text":"private  subroutine add_edge(me, edge) add an edge index for this vertex Type Bound vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in) :: edge Called by proc~~add_edge~~CalledByGraph proc~add_edge dag_module::vertex%add_edge none~set_edges dag_module::vertex%set_edges none~set_edges->proc~add_edge proc~set_edge_vector dag_module::vertex%set_edge_vector none~set_edges->proc~set_edge_vector proc~set_edge_vector->proc~add_edge proc~dag_set_edges dag_module::dag%dag_set_edges proc~dag_set_edges->none~set_edges program~dag_example dag_example program~dag_example->proc~dag_set_edges program~problem_25 problem_25 program~problem_25->proc~dag_set_edges Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine add_edge ( me , edge ) class ( vertex ), intent ( inout ) :: me integer , intent ( in ) :: edge if ( allocated ( me % edges )) then if (. not . any ( edge == me % edges )) then me % edges = [ me % edges , edge ] ! auto lhs reallocation end if else allocate ( me % edges ( 1 )) me % edges = [ edge ] end if end subroutine add_edge","tags":"","loc":"proc/add_edge.html"},{"title":"dag_set_vertices – AoC-2023","text":"private  subroutine dag_set_vertices(me, nvertices) set the number of vertices in the dag Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: nvertices number of vertices Called by proc~~dag_set_vertices~~CalledByGraph proc~dag_set_vertices dag_module::dag%dag_set_vertices program~dag_example dag_example program~dag_example->proc~dag_set_vertices program~problem_25 problem_25 program~problem_25->proc~dag_set_vertices Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_set_vertices ( me , nvertices ) class ( dag ), intent ( inout ) :: me integer , intent ( in ) :: nvertices !! number of vertices integer :: i me % n = nvertices allocate ( me % vertices ( nvertices )) me % vertices % ivertex = [( i , i = 1 , nvertices )] end subroutine dag_set_vertices","tags":"","loc":"proc/dag_set_vertices.html"},{"title":"dag_set_vertex_info – AoC-2023","text":"private  subroutine dag_set_vertex_info(me, ivertex, label, attributes) set info about a vertex in a dag. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: ivertex vertex number character(len=*), intent(in), optional :: label if a label is not set,\nthen the integer vertex\nnumber is used. character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. Calls proc~~dag_set_vertex_info~~CallsGraph proc~dag_set_vertex_info dag_module::dag%dag_set_vertex_info proc~integer_to_string~2 dag_module::integer_to_string proc~dag_set_vertex_info->proc~integer_to_string~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dag_set_vertex_info~~CalledByGraph proc~dag_set_vertex_info dag_module::dag%dag_set_vertex_info program~dag_example dag_example program~dag_example->proc~dag_set_vertex_info program~problem_25 problem_25 program~problem_25->proc~dag_set_vertex_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_set_vertex_info ( me , ivertex , label , attributes ) class ( dag ), intent ( inout ) :: me integer , intent ( in ) :: ivertex !! vertex number character ( len =* ), intent ( in ), optional :: label !! if a label is not set, !! then the integer vertex !! number is used. character ( len =* ), intent ( in ), optional :: attributes !! other attributes when !! saving as a diagraph. if ( present ( label )) then me % vertices ( ivertex )% label = label else ! just use the vertex number me % vertices ( ivertex )% label = integer_to_string ( ivertex ) end if if ( present ( attributes )) then me % vertices ( ivertex )% attributes = attributes end if end subroutine dag_set_vertex_info","tags":"","loc":"proc/dag_set_vertex_info.html"},{"title":"dag_set_edges – AoC-2023","text":"private  subroutine dag_set_edges(me, ivertex, edges) set the edges for a vertex in a dag Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: ivertex vertex number integer, intent(in), dimension(:) :: edges Calls proc~~dag_set_edges~~CallsGraph proc~dag_set_edges dag_module::dag%dag_set_edges none~set_edges dag_module::vertex%set_edges proc~dag_set_edges->none~set_edges proc~add_edge dag_module::vertex%add_edge none~set_edges->proc~add_edge proc~set_edge_vector dag_module::vertex%set_edge_vector none~set_edges->proc~set_edge_vector proc~set_edge_vector->proc~add_edge Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dag_set_edges~~CalledByGraph proc~dag_set_edges dag_module::dag%dag_set_edges program~dag_example dag_example program~dag_example->proc~dag_set_edges program~problem_25 problem_25 program~problem_25->proc~dag_set_edges Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_set_edges ( me , ivertex , edges ) class ( dag ), intent ( inout ) :: me integer , intent ( in ) :: ivertex !! vertex number integer , dimension (:), intent ( in ) :: edges call me % vertices ( ivertex )% set_edges ( edges ) end subroutine dag_set_edges","tags":"","loc":"proc/dag_set_edges.html"},{"title":"dag_toposort – AoC-2023","text":"private  subroutine dag_toposort(me, order, istat) Main toposort routine Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: order the toposort order integer, intent(out) :: istat Status flag: 0 if no errors -1 if circular dependency\n (in this case, order will not be allocated) Called by proc~~dag_toposort~~CalledByGraph proc~dag_toposort dag_module::dag%dag_toposort program~dag_example dag_example program~dag_example->proc~dag_toposort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_toposort ( me , order , istat ) class ( dag ), intent ( inout ) :: me integer , dimension (:), allocatable , intent ( out ) :: order !! the toposort order integer , intent ( out ) :: istat !! Status flag: !! !! * 0 if no errors !! * -1 if circular dependency !!  (in this case, `order` will not be allocated) integer :: i , iorder if ( me % n == 0 ) return allocate ( order ( me % n )) iorder = 0 ! index in order array istat = 0 ! no errors so far do i = 1 , me % n if (. not . me % vertices ( i )% marked ) call dfs ( me % vertices ( i )) if ( istat ==- 1 ) exit end do if ( istat ==- 1 ) deallocate ( order ) contains recursive subroutine dfs ( v ) !! depth-first graph traversal type ( vertex ), intent ( inout ) :: v integer :: j if ( istat ==- 1 ) return if ( v % checking ) then ! error: circular dependency istat = - 1 else if (. not . v % marked ) then v % checking = . true . if ( allocated ( v % edges )) then do j = 1 , size ( v % edges ) call dfs ( me % vertices ( v % edges ( j ))) if ( istat ==- 1 ) return end do end if v % checking = . false . v % marked = . true . iorder = iorder + 1 order ( iorder ) = v % ivertex end if end if end subroutine dfs end subroutine dag_toposort","tags":"","loc":"proc/dag_toposort.html"},{"title":"dag_generate_dependency_matrix – AoC-2023","text":"private  subroutine dag_generate_dependency_matrix(me, mat) Generate the dependency matrix for the DAG. This is an matrix with elements ,\nsuch that is true if vertex depends on vertex . Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me logical, intent(out), dimension(:,:), allocatable :: mat dependency matrix Called by proc~~dag_generate_dependency_matrix~~CalledByGraph proc~dag_generate_dependency_matrix dag_module::dag%dag_generate_dependency_matrix program~dag_example dag_example program~dag_example->proc~dag_generate_dependency_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_generate_dependency_matrix ( me , mat ) implicit none class ( dag ), intent ( in ) :: me logical , dimension (:,:), intent ( out ), allocatable :: mat !! dependency matrix integer :: i !! vertex counter if ( me % n > 0 ) then allocate ( mat ( me % n , me % n )) mat = . false . do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then mat ( i , me % vertices ( i )% edges ) = . true . end if end do end if end subroutine dag_generate_dependency_matrix","tags":"","loc":"proc/dag_generate_dependency_matrix.html"},{"title":"dag_save_digraph – AoC-2023","text":"private  subroutine dag_save_digraph(me, filename, rankdir, dpi) Generate a Graphviz digraph structure for the DAG and write it to a file. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: filename file name for diagraph character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer, intent(in), optional :: dpi resolution (e.g. 300) Calls proc~~dag_save_digraph~~CallsGraph proc~dag_save_digraph dag_module::dag%dag_save_digraph proc~dag_generate_digraph dag_module::dag%dag_generate_digraph proc~dag_save_digraph->proc~dag_generate_digraph proc~integer_to_string~2 dag_module::integer_to_string proc~dag_generate_digraph->proc~integer_to_string~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dag_save_digraph~~CalledByGraph proc~dag_save_digraph dag_module::dag%dag_save_digraph program~dag_example dag_example program~dag_example->proc~dag_save_digraph program~problem_25 problem_25 program~problem_25->proc~dag_save_digraph Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_save_digraph ( me , filename , rankdir , dpi ) implicit none class ( dag ), intent ( in ) :: me character ( len =* ), intent ( in ), optional :: filename !! file name for diagraph character ( len =* ), intent ( in ), optional :: rankdir !! right to left orientation (e.g. 'RL') integer , intent ( in ), optional :: dpi !! resolution (e.g. 300) integer :: iunit , istat character ( len = :), allocatable :: diagraph diagraph = me % generate_digraph ( rankdir , dpi ) open ( newunit = iunit , file = filename , status = 'REPLACE' , iostat = istat ) if ( istat == 0 ) then write ( iunit , fmt = '(A)' , iostat = istat ) diagraph else write ( * , * ) 'error opening ' // trim ( filename ) end if close ( iunit , iostat = istat ) end subroutine dag_save_digraph","tags":"","loc":"proc/dag_save_digraph.html"},{"title":"check – AoC-2023","text":"function check(i, j) if the char is part of a number, then get it and append to ivals Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Return Value logical Calls proc~~check~~CallsGraph proc~check problem_3::check proc~get_number problem_3::get_number proc~check->proc~get_number proc~is_number aoc_utilities::is_number proc~check->proc~is_number proc~is_symbol problem_3::is_symbol proc~get_number->proc~is_symbol proc~is_not_number aoc_utilities::is_not_number proc~is_symbol->proc~is_not_number proc~is_not_number->proc~is_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check~~CalledByGraph proc~check problem_3::check program~problem_3 problem_3 program~problem_3->proc~check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function check ( i , j ) !! if the char is part of a number, then get it and append to ivals integer , intent ( in ) :: i , j check = is_number ( array ( i , j )) if ( check ) ivals = [ ivals , get_number ( i , j )] end function check","tags":"","loc":"proc/check.html"},{"title":"is_symbol – AoC-2023","text":"function is_symbol(c) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical Calls proc~~is_symbol~~CallsGraph proc~is_symbol problem_3::is_symbol proc~is_not_number aoc_utilities::is_not_number proc~is_symbol->proc~is_not_number proc~is_number aoc_utilities::is_number proc~is_not_number->proc~is_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~is_symbol~~CalledByGraph proc~is_symbol problem_3::is_symbol proc~get_number problem_3::get_number proc~get_number->proc~is_symbol program~problem_3 problem_3 program~problem_3->proc~is_symbol program~problem_3->proc~get_number proc~check problem_3::check program~problem_3->proc~check proc~check->proc~get_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function is_symbol ( c ) character ( len = 1 ), intent ( in ) :: c is_symbol = is_not_number ( c ) . and . c /= '.' end function is_symbol","tags":"","loc":"proc/is_symbol.html"},{"title":"get_number – AoC-2023","text":"function get_number(i, j) get the full number contining the character at i,j Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Return Value integer(kind=ip) Calls proc~~get_number~~CallsGraph proc~get_number problem_3::get_number proc~is_symbol problem_3::is_symbol proc~get_number->proc~is_symbol proc~is_not_number aoc_utilities::is_not_number proc~is_symbol->proc~is_not_number proc~is_number aoc_utilities::is_number proc~is_not_number->proc~is_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_number~~CalledByGraph proc~get_number problem_3::get_number proc~check problem_3::check proc~check->proc~get_number program~problem_3 problem_3 program~problem_3->proc~get_number program~problem_3->proc~check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code integer ( ip ) function get_number ( i , j ) !! get the full number contining the character at i,j integer , intent ( in ) :: i , j jstart = j jend = j do if ( array ( i , jstart - 1 ) == '.' . or . is_symbol ( array ( i , jstart - 1 ))) exit jstart = jstart - 1 end do do if ( array ( i , jend + 1 ) == '.' . or . is_symbol ( array ( i , jend + 1 ))) exit jend = jend + 1 end do get_number = int ( array ( i , jstart : jend )) end function get_number","tags":"","loc":"proc/get_number.html"},{"title":"index_in_queue – AoC-2023","text":"function index_in_queue(state) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state Return Value integer(kind=ip) index in the queue. -1 if not present Called by proc~~index_in_queue~~CalledByGraph proc~index_in_queue problem_17::index_in_queue proc~check~2 problem_17::check proc~check~2->proc~index_in_queue program~problem_17 problem_17 program~problem_17->proc~check~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function index_in_queue ( state ) result ( idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ) :: idx !! index in the queue. -1 if not present integer :: i idx = - 1 if (. not . allocated ( queue )) error stop 'error: queue not allocated' do i = 1 , size ( queue ) if ( all ( state == queue ( i )% state )) then idx = i return end if end do end function index_in_queue","tags":"","loc":"proc/index_in_queue.html"},{"title":"check – AoC-2023","text":"subroutine check(idx, idirection) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: idx integer(kind=ip), intent(in) :: idirection direction to move from current Calls proc~~check~2~~CallsGraph proc~check~2 problem_17::check proc~add_to_queue problem_17::add_to_queue proc~check~2->proc~add_to_queue proc~index_in_queue problem_17::index_in_queue proc~check~2->proc~index_in_queue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check~2~~CalledByGraph proc~check~2 problem_17::check program~problem_17 problem_17 program~problem_17->proc~check~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine check ( idx , idirection ) implicit none integer ( ip ), intent ( in ) :: idx ! current item in the queue to process integer ( ip ), intent ( in ) :: idirection !! direction to move from current integer ( ip ) :: alt integer ( ip ), dimension ( 2 ) :: v ! neighbor to move to integer ( ip ) :: imovesv , idxv , distv integer ( ip ), dimension ( NSTATE ) :: istate logical :: in_queue associate ( i => queue ( idx )% state ( 1 ), & j => queue ( idx )% state ( 2 ), & direction => queue ( idx )% state ( 3 ), & n_moves => queue ( idx )% state ( 4 )) if ( direction ==- idirection ) return ! can't reverse ! the one to go to: if ( direction == idirection ) then if ( n_moves == MAX_MOVES_IN_DIR ) return ! can't move in this direction anymore imovesv = n_moves + 1 else imovesv = 1 ! reset on change of direction end if select case ( idirection ) case ( UP ); v = [ i - 1 , j ] case ( DOWN ); v = [ i + 1 , j ] case ( LEFT ); v = [ i , j - 1 ] case ( RIGHT ); v = [ i , j + 1 ] end select if ( v ( 1 ) < 1 . or . v ( 2 ) < 1 . or . v ( 1 ) > n_rows . or . v ( 2 ) > n_cols ) return ! can't go off the board istate = [ v ( 1 ), v ( 2 ), idirection , imovesv ] ! new state idxv = index_in_queue ( istate ) ! is it already in the queue in_queue = idxv > 0 ! if this one is already part of another path if ( in_queue ) then if ( queue ( idxv )% visited ) return ! already visited this one distv = queue ( idxv )% dist ! distance in the queue else !call add_to_queue(istate, idxv) ! add this to the queue for processing ! always add it ?? distv = huge ( 1_ip ) ! not processed yet, so huge number end if !alt = queue(idx)%dist + map(queue(idxv)%state(1), queue(idxv)%state(2)) alt = queue ( idx )% dist + map ( v ( 1 ), v ( 2 )) ! new distance if ( alt < distv ) then ! the new one is better, so replace values in the queue if (. not . in_queue ) call add_to_queue ( istate , idxv ) ! only add it if we accept it ???? ! accept this step queue ( idxv )% dist = alt ! new best dist queue ( idxv )% iprev = idx ! previous end if end associate end subroutine check","tags":"","loc":"proc/check~2.html"},{"title":"add_to_queue – AoC-2023","text":"subroutine add_to_queue(state, idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state integer(kind=ip), intent(out) :: idx index of the element in the queue Called by proc~~add_to_queue~~CalledByGraph proc~add_to_queue problem_17::add_to_queue proc~check~2 problem_17::check proc~check~2->proc~add_to_queue program~problem_17 problem_17 program~problem_17->proc~add_to_queue program~problem_17->proc~check~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine add_to_queue ( state , idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ), intent ( out ) :: idx !! index of the element in the queue if ( allocated ( queue )) then queue = [ queue , item ( state = state )] idx = size ( queue ) else queue = [ item ( state = state )] idx = 1 end if end subroutine add_to_queue","tags":"","loc":"proc/add_to_queue.html"},{"title":"go – AoC-2023","text":"subroutine go(puzzle, ileft, iskip) compute the number of cols to left of mirror (0 if none)\ncall with transpose(puzzle) to get number of rows above. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: puzzle integer, intent(out) :: ileft integer, intent(in), optional :: iskip don't consider this column Called by proc~~go~2~~CalledByGraph proc~go~2 problem_13::go program~problem_13 problem_13 program~problem_13->proc~go~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine go ( puzzle , ileft , iskip ) !! compute the number of cols to left of mirror (0 if none) !! call with transpose(puzzle) to get number of rows above. integer , dimension (:,:), intent ( in ) :: puzzle integer , intent ( out ) :: ileft integer , intent ( in ), optional :: iskip !! don't consider this column integer :: nrows , ncols , i , j logical :: mirror nrows = size ( puzzle , 1 ) ncols = size ( puzzle , 2 ) ileft = 0 do i = 1 , ncols - 1 if ( present ( iskip )) then if ( i == iskip ) cycle end if mirror = . true . do j = 1 , min ( i , ncols - i ) if ( any ( puzzle (:, i - j + 1 ) /= puzzle (:, i + j )) ) then mirror = . false . ! no mirror on this line exit end if end do if ( mirror ) then ileft = i exit end if end do end subroutine go","tags":"","loc":"proc/go~2.html"},{"title":"node_index – AoC-2023","text":"pure function node_index(node) find the node number for this name Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: node Return Value integer Called by proc~~node_index~~CalledByGraph proc~node_index problem_25::node_index program~problem_25 problem_25 program~problem_25->proc~node_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer function node_index ( node ) !! find the node number for this name character ( len =* ), intent ( in ) :: node integer , dimension ( 1 ) :: idx idx = findloc ( nodes , node ) node_index = idx ( 1 ) end function node_index","tags":"","loc":"proc/node_index.html"},{"title":"traverse – AoC-2023","text":"recursive subroutine traverse(i) travere the graph and visit all the connected nodes Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Called by proc~~traverse~2~~CalledByGraph proc~traverse~2 problem_25::traverse proc~traverse~2->proc~traverse~2 program~problem_25 problem_25 program~problem_25->proc~traverse~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine traverse ( i ) !! travere the graph and visit all the connected nodes integer , intent ( in ) :: i integer :: j if ( visited ( i )) return visited ( i ) = . true . do j = 1 , size ( graph ( i )% connections ) call traverse ( graph ( i )% connections ( j )) end do end subroutine traverse","tags":"","loc":"proc/traverse~2.html"},{"title":"hand_type – AoC-2023","text":"function hand_type(me, with_jokers) returns the type of hand Arguments Type Intent Optional Attributes Name class( hand ), intent(in) :: me logical, intent(in) :: with_jokers if considering jokers Return Value integer Calls proc~~hand_type~~CallsGraph proc~hand_type problem_7::hand_type interface~unique~2 aoc_utilities::unique proc~hand_type->interface~unique~2 proc~unique32 aoc_utilities::unique32 interface~unique~2->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique~2->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap~2 aoc_utilities::swap proc~sort_ascending->interface~swap~2 proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap~2->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap~2->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap~2->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hand_type~~CalledByGraph proc~hand_type problem_7::hand_type proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code integer function hand_type ( me , with_jokers ) !! returns the type of hand class ( hand ), intent ( in ) :: me logical , intent ( in ) :: with_jokers !! if considering jokers integer , dimension ( 5 ) :: i integer , dimension (:), allocatable :: u integer :: n_jokers , n_unique character ( len = 1 ), dimension ( 5 ) :: h h = me % cards i = ichar ( h ) ! convert to code u = unique ( i ) ! unique elements n_unique = size ( u ) if ( with_jokers . and . any ( h == 'J' )) then ! have to pick best hand for all jokers ! just do it by inspection n_jokers = count ( h == 'J' ) select case ( n_jokers ) case ( 5 ) hand_type = FIVE_OF_A_KIND !jjjjj case ( 4 ) hand_type = FIVE_OF_A_KIND !jjjja case ( 3 ) ! can always turn to 4 or 5 of a kind if ( n_unique == 2 ) then !jjjaa hand_type = FIVE_OF_A_KIND else ! jjjab hand_type = FOUR_OF_A_KIND end if case ( 2 ) if ( n_unique == 2 ) then !jjaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then !jjaab hand_type = FOUR_OF_A_KIND else !jjabc hand_type = THREE_OF_A_KIND end if case ( 1 ) if ( n_unique == 2 ) then !jaaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then if ( any ([ count ( i == u ( 1 )) == 3 , & count ( i == u ( 2 )) == 3 , & count ( i == u ( 3 )) == 3 ]) ) then !jaaab hand_type = FOUR_OF_A_KIND elseif ( ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 ) . or . & ( count ( i == u ( 2 )) == 2 . and . count ( i == u ( 2 )) == 2 ) ) then !jaabb hand_type = FULL_HOUSE end if else if ( n_unique == 4 ) then !jaabc hand_type = THREE_OF_A_KIND else if ( n_unique == 5 ) then !jabcd hand_type = ONE_PAIR end if end select else !Every hand is exactly one type. From strongest to weakest, they are: select case ( n_unique ) case ( 1 ) ! aaaaa hand_type = FIVE_OF_A_KIND case ( 2 ) ! aaaab, aaabb if (( count ( i == u ( 1 )) == 4 . and . count ( i == u ( 2 )) == 1 ) . or . & ( count ( i == u ( 1 )) == 1 . and . count ( i == u ( 2 )) == 4 ) ) then hand_type = FOUR_OF_A_KIND else if (( count ( i == u ( 1 )) == 3 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 3 ) ) then hand_type = FULL_HOUSE end if case ( 3 ) ! aaabc, aabcc if ( any ([ count ( i == u ( 1 )) == 3 , count ( i == u ( 2 )) == 3 , count ( i == u ( 3 )) == 3 ]) ) then hand_type = THREE_OF_A_KIND else if ( any ([ count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 , & count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 , & count ( i == u ( 2 )) == 2 . and . count ( i == u ( 3 )) == 2 ]) ) then hand_type = TWO_PAIR end if case ( 4 ) !aabcd hand_type = ONE_PAIR case ( 5 ) !abcde hand_type = HIGH_CARD ! High card, where all cards' labels are distinct: 23456 end select end if end function hand_type","tags":"","loc":"proc/hand_type.html"},{"title":"beats – AoC-2023","text":"function beats(hand1, hand2, with_jokers) return true if hand1 beats hand2 (has a higher score) Arguments Type Intent Optional Attributes Name class( hand ), intent(inout) :: hand1 class( hand ), intent(inout) :: hand2 logical, intent(in) :: with_jokers if considering jokers Return Value logical Calls proc~~beats~~CallsGraph proc~beats problem_7::beats proc~hand_type problem_7::hand_type proc~beats->proc~hand_type proc~index_in_cards problem_7::index_in_cards proc~beats->proc~index_in_cards interface~unique~2 aoc_utilities::unique proc~hand_type->interface~unique~2 proc~unique32 aoc_utilities::unique32 interface~unique~2->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique~2->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap~2 aoc_utilities::swap proc~sort_ascending->interface~swap~2 proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap~2->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap~2->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap~2->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~beats~~CalledByGraph proc~beats problem_7::beats program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function beats ( hand1 , hand2 , with_jokers ) !! return true if hand1 beats hand2 (has a higher score) class ( hand ), intent ( inout ) :: hand1 , hand2 logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i associate ( h1 => hand1 % cards , h2 => hand2 % cards ) ! recompute type if it hasn't already been computed if ( hand1 % type == 0 ) hand1 % type = hand_type ( hand1 , with_jokers ) if ( hand2 % type == 0 ) hand2 % type = hand_type ( hand2 , with_jokers ) if ( hand1 % type == hand2 % type ) then ! lower index is stronger do i = 1 , 5 if ( h1 ( i ) /= h2 ( i )) then beats = index_in_cards ( h1 ( i ), with_jokers ) < & index_in_cards ( h2 ( i ), with_jokers ) ! lower is stronger return end if end do else ! one hand beat the other beats = hand1 % type < hand2 % type ! lower score is better (1-7) end if end associate end function beats","tags":"","loc":"proc/beats.html"},{"title":"index_in_cards – AoC-2023","text":"function index_in_cards(c, with_jokers) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c logical, intent(in) :: with_jokers if considering jokers Return Value integer Called by proc~~index_in_cards~~CalledByGraph proc~index_in_cards problem_7::index_in_cards proc~beats problem_7::beats proc~beats->proc~index_in_cards program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code integer function index_in_cards ( c , with_jokers ) character ( len = 1 ), intent ( in ) :: c logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i do i = 1 , size ( cards_with_joker ) if ( with_jokers ) then if ( c == cards_with_joker ( i )) then index_in_cards = i return end if else if ( c == cards ( i )) then index_in_cards = i return end if end if end do error stop 'card not found' end function index_in_cards","tags":"","loc":"proc/index_in_cards.html"},{"title":"swap_hands – AoC-2023","text":"pure elemental subroutine swap_hands(i1, i2) swap function for hand type Arguments Type Intent Optional Attributes Name type( hand ), intent(inout) :: i1 type( hand ), intent(inout) :: i2 Called by proc~~swap_hands~~CalledByGraph proc~swap_hands problem_7::swap_hands program~problem_7 problem_7 program~problem_7->proc~swap_hands Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap_hands ( i1 , i2 ) !! swap function for hand type type ( hand ), intent ( inout ) :: i1 type ( hand ), intent ( inout ) :: i2 type ( hand ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_hands","tags":"","loc":"proc/swap_hands.html"},{"title":"destination – AoC-2023","text":"pure function destination(initial, direction, steps) result(final) get destination point Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(2) :: initial character(len=1), intent(in) :: direction integer(kind=ip), intent(in) :: steps Return Value integer(kind=ip), dimension(2) x,y of desination point Called by proc~~destination~~CalledByGraph proc~destination problem_18::destination proc~go~3 problem_18::go proc~go~3->proc~destination program~problem_18 problem_18 program~problem_18->proc~go~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function destination ( initial , direction , steps ) result ( final ) !! get destination point integer ( ip ), dimension ( 2 ), intent ( in ) :: initial character ( len = 1 ), intent ( in ) :: direction integer ( ip ), intent ( in ) :: steps integer ( ip ), dimension ( 2 ) :: final !! x,y of desination point select case ( direction ) case ( 'R' ); final = [ initial ( 1 ), initial ( 2 ) + steps ] case ( 'L' ); final = [ initial ( 1 ), initial ( 2 ) - steps ] case ( 'D' ); final = [ initial ( 1 ) + steps , initial ( 2 )] case ( 'U' ); final = [ initial ( 1 ) - steps , initial ( 2 )] end select end function destination","tags":"","loc":"proc/destination.html"},{"title":"go – AoC-2023","text":"subroutine go(partb, iresult) Arguments Type Intent Optional Attributes Name logical, intent(in) :: partb if solving part b integer(kind=ip), intent(out) :: iresult Calls proc~~go~3~~CallsGraph proc~go~3 problem_18::go interface~split aoc_utilities::split proc~go~3->interface~split proc~destination problem_18::destination proc~go~3->proc~destination proc~hex2int aoc_utilities::hex2int proc~go~3->proc~hex2int proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~go~3->proc~number_of_lines_in_file proc~parea aoc_utilities::parea proc~go~3->proc~parea proc~read_line aoc_utilities::read_line proc~go~3->proc~read_line proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~go~3~~CalledByGraph proc~go~3 problem_18::go program~problem_18 problem_18 program~problem_18->proc~go~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine go ( partb , iresult ) logical , intent ( in ) :: partb !! if solving part b integer ( ip ), intent ( out ) :: iresult integer :: iunit , iline , n_lines , n character ( len = :), allocatable :: line , hex type ( string ), dimension (:), allocatable :: vals character ( len = 1 ) :: direction integer ( ip ), dimension ( 2 ) :: iloc , iloc2 integer ( ip ) :: ival , isteps real ( wp ), dimension (:), allocatable :: xvec , yvec character ( len = 1 ), dimension ( 0 : 3 ) :: direction_str = [ 'R' , 'D' , 'L' , 'U' ] ! directions for part b : 0,1,2,3 ! open(newunit=iunit, file='inputs/day18_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day18.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) iloc = [ 0 , 0 ] ! where to start isteps = 0 xvec = [ 0 ]; yvec = [ 0 ] do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ! direction, number, (hex) if ( partb ) then ! values encoded in hex hex = vals ( 3 )% str ival = hex2int ( hex ( 3 : 7 )) direction = direction_str ( int ( hex ( 8 : 8 ))) else direction = vals ( 1 )% str ival = int ( vals ( 2 )% str ) end if isteps = isteps + ival ! keep track of the total perimeter size iloc2 = destination ( iloc , direction , ival ) ! destination oint xvec = [ xvec , real ( iloc2 ( 1 ), wp )] ! save the points of the polygon yvec = [ yvec , real ( iloc2 ( 2 ), wp )] ! iloc = iloc2 ! update for next move end do close ( iunit ) ! the area including the boundary = area + 1/2 the perimeter + 1 ! using NSWC parea function! n = size ( xvec ) iresult = int ( abs ( parea ( yvec , xvec , n )) + real ( isteps , wp ) / 2_ip + 1_ip , ip ) end subroutine go","tags":"","loc":"proc/go~3.html"},{"title":"go – AoC-2023","text":"function go(expansion_factor) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: expansion_factor Return Value integer(kind=ip) Calls proc~~go~7~~CallsGraph proc~go~7 problem_11::go interface~manhatten_distance aoc_utilities::manhatten_distance proc~go~7->interface~manhatten_distance proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~go~7->proc~read_file_to_char_array proc~manhatten_distance_64 aoc_utilities::manhatten_distance_64 interface~manhatten_distance->proc~manhatten_distance_64 proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~go~7~~CalledByGraph proc~go~7 problem_11::go program~problem_11 problem_11 program~problem_11->proc~go~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code integer ( ip ) function go ( expansion_factor ) integer ( ip ), intent ( in ) :: expansion_factor integer :: i , j , nrows , ncols , n_galaxies , n , k character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:,:), allocatable :: idists integer ( ip ), dimension (:), allocatable :: igal , jgal integer ( ip ), dimension (:,:), allocatable :: ix , iy ! array = read_file_to_char_array('inputs/day11_test.txt') array = read_file_to_char_array ( 'inputs/day11.txt' ) nrows = size ( array , 1 ); ncols = size ( array , 2 ) n_galaxies = count ( array == '#' ) ! track the real indices after expansion ix = transpose ( spread ([( i , i = 1 , ncols )], 1 , nrows )) ! row indices iy = spread ([( i , i = 1 , nrows )], 1 , ncols ) ! col indices igal = pack ( ix , array == '#' ) ! indices of galaxies jgal = pack ( iy , array == '#' ) ! expand the array, keeping track of the new row indices do i = 1 , nrows ! add rows if necessary if ( all ( array ( i ,:) == '.' )) ix ( i :,:) = ix ( i :,:) + expansion_factor - 1 ! new row end do do j = 1 , ncols ! add cols if necessary if ( all ( array (:, j ) == '.' )) iy (:, j :) = iy (:, j :) + expansion_factor - 1 ! new column end do ! now compute all the distances: allocate ( idists ( n_galaxies , n_galaxies )); idists = 0 do i = 1 , n_galaxies do j = 1 , n_galaxies if ( j <= i ) cycle ! only need the lower diagonal idists ( i , j ) = manhatten_distance ( ix ( igal ( i ), jgal ( i )), iy ( igal ( i ), jgal ( i )),& ix ( igal ( j ), jgal ( j )), iy ( igal ( j ), jgal ( j ))) end do end do go = sum ( idists ) end function go","tags":"","loc":"proc/go~7.html"},{"title":"set_status – AoC-2023","text":"private  subroutine set_status(me, istat, string, i, r) Set status flag and message. Type Bound nlesolver_type Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me integer, intent(in) :: istat status code character(len=*), intent(in) :: string status message integer, intent(in), optional :: i an integer value to append real(kind=wp), intent(in), optional :: r a real value to append Called by proc~~set_status~~CalledByGraph proc~set_status nlesolver_module::nlesolver_type%set_status proc~initialize_nlesolver_variables nlesolver_module::nlesolver_type%initialize_nlesolver_variables proc~initialize_nlesolver_variables->proc~set_status proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver proc~nlesolver_solver->proc~set_status program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->proc~initialize_nlesolver_variables program~nlesolver_test_1->proc~nlesolver_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_status ( me , istat , string , i , r ) implicit none class ( nlesolver_type ), intent ( inout ) :: me integer , intent ( in ) :: istat !! status code character ( len =* ), intent ( in ) :: string !! status message integer , intent ( in ), optional :: i !! an integer value to append real ( wp ), intent ( in ), optional :: r !! a real value to append character ( len = 256 ) :: numstr !! for number fo string conversion character ( len = :), allocatable :: message !! the full message to log integer :: iostat !! write `iostat` code message = trim ( string ) if ( present ( i )) then numstr = '' write ( numstr , fmt =* , iostat = iostat ) i if ( iostat /= 0 ) numstr = '****' message = message // ' ' // trim ( adjustl ( numstr )) end if if ( present ( r )) then numstr = '' write ( numstr , fmt =* , iostat = iostat ) r if ( iostat /= 0 ) numstr = '****' message = message // ' ' // trim ( adjustl ( numstr )) end if if ( me % verbose ) then write ( me % iunit , '(A)' , iostat = iostat ) message end if ! store in the class: me % istat = istat me % message = message end subroutine set_status","tags":"","loc":"proc/set_status.html"},{"title":"get_status – AoC-2023","text":"private  subroutine get_status(me, istat, message) Return the status code and message from the nlesolver_type class. Status codes -1   -- Error: Invalid alpha -2   -- Error: Invalid alpha_min -3   -- Error: Invalid alpha_max -4   -- Error: Alpha_min must be < alpha_max -5   -- Error: Invalid step_mode -6   -- Error solving linear system -7   -- Error: More than 5 steps in the uphill direction -8   -- Error: Divide by zero when computing Broyden update -9   -- Error: Out of memory -10  -- Error: function routine is not associated -11  -- Error: gradient routine is not associated -12  -- Error: backtracking linesearch c must be in range (0, 1) -13  -- Error: backtracking linesearch tau must be in range (0, 1) -999 -- Error: class has not been initialized 0    -- Class successfully initialized in initialize 1    -- Required accuracy achieved 2    -- Solution cannot be improved 3    -- Maximum number of iterations reached 4    -- Stopped by the user Type Bound nlesolver_type Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me integer, intent(out), optional :: istat Integer status code. character(len=:), intent(out), optional, allocatable :: message Text status message Called by proc~~get_status~~CalledByGraph proc~get_status nlesolver_module::nlesolver_type%get_status program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->proc~get_status Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_status ( me , istat , message ) implicit none class ( nlesolver_type ), intent ( inout ) :: me integer , intent ( out ), optional :: istat !! Integer status code. character ( len = :), allocatable , intent ( out ), optional :: message !! Text status message if ( present ( istat )) istat = me % istat if ( present ( message )) then if ( allocated ( me % message )) then message = trim ( me % message ) else message = 'Error: class has not been initialized' end if end if end subroutine get_status","tags":"","loc":"proc/get_status.html"},{"title":"initialize_nlesolver_variables – AoC-2023","text":"private  subroutine initialize_nlesolver_variables(me, n, m, max_iter, tol, alpha, alpha_min, alpha_max, tolx, fmin_tol, backtrack_c, backtrack_tau, use_broyden, broyden_update_n, step_mode, func, grad, export_iteration, user_input_check, verbose, iunit, n_uphill_max, n_intervals) Constructor for the class. Type Bound nlesolver_type Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me integer, intent(in) :: n number of optimization variables integer, intent(in) :: m number of constraints integer, intent(in) :: max_iter maximum number of iterations real(kind=wp), intent(in) :: tol function convergence tolerance real(kind=wp), intent(in), optional :: alpha constant step length for step_mode=1 (0,1] real(kind=wp), intent(in), optional :: alpha_min minimum step length (0,1] real(kind=wp), intent(in), optional :: alpha_max maximum step length (0,1] real(kind=wp), intent(in), optional :: tolx convergence tolerance for changes in x real(kind=wp), intent(in), optional :: fmin_tol convergence tolerance for fmin (used when step_mode=3 ) real(kind=wp), intent(in), optional :: backtrack_c backtracking linesearch parameter (0,1) real(kind=wp), intent(in), optional :: backtrack_tau backtracking linesearch parameter (0,1) logical, intent(in), optional :: use_broyden use a Broyden update (default is False) integer, intent(in), optional :: broyden_update_n For Broyden mode, update the full Jacobian\nat most every this many iterations (must be >1)\nIf <=1 then Jacobian is only computed on the\nfirst iteration. integer, intent(in), optional :: step_mode step mode: 1 = use the specified alpha (0,1] 2 = backtracking linesearch (between alpha_min and alpha_max ) 3 = exact linesearch (between alpha_min and alpha_max ) 4 = evaluate function at specified fixed points  (between alpha_min and alpha_max ) procedure( func_func ) :: func computes the function vector procedure( grad_func ) :: grad computes the jacobian procedure( export_func ), optional :: export_iteration function to export each iteration procedure( wait_func ), optional :: user_input_check check for user input (to stop solver if necessary) logical, intent(in), optional :: verbose for verbose status printing integer, intent(in), optional :: iunit unit for verbose printing (assumed to be open).\nby default this is output_unit . integer, intent(in), optional :: n_uphill_max maximum number of consecutive steps\nto allow where the value of f increases integer, intent(in), optional :: n_intervals number of intervals for fixed point linesearch Calls proc~~initialize_nlesolver_variables~~CallsGraph proc~initialize_nlesolver_variables nlesolver_module::nlesolver_type%initialize_nlesolver_variables proc~set_status nlesolver_module::nlesolver_type%set_status proc~initialize_nlesolver_variables->proc~set_status Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~initialize_nlesolver_variables~~CalledByGraph proc~initialize_nlesolver_variables nlesolver_module::nlesolver_type%initialize_nlesolver_variables program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->proc~initialize_nlesolver_variables Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize_nlesolver_variables ( me ,& n , m , max_iter , tol , alpha , alpha_min , alpha_max , tolx , fmin_tol ,& backtrack_c , backtrack_tau ,& use_broyden , broyden_update_n , step_mode , func , grad ,& export_iteration , user_input_check ,& verbose , iunit , n_uphill_max , n_intervals ) implicit none class ( nlesolver_type ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of optimization variables integer , intent ( in ) :: m !! number of constraints integer , intent ( in ) :: max_iter !! maximum number of iterations real ( wp ), intent ( in ) :: tol !! function convergence tolerance procedure ( func_func ) :: func !! computes the function vector procedure ( grad_func ) :: grad !! computes the jacobian integer , intent ( in ), optional :: step_mode !! step mode: !! !!  * 1 = use the specified `alpha` (0,1] !!  * 2 = backtracking linesearch (between `alpha_min` and `alpha_max`) !!  * 3 = exact linesearch (between `alpha_min` and `alpha_max`) !!  * 4 = evaluate function at specified fixed points  (between `alpha_min` and `alpha_max`) real ( wp ), intent ( in ), optional :: alpha !! constant step length for `step_mode=1` (0,1] real ( wp ), intent ( in ), optional :: alpha_min !! minimum step length (0,1] real ( wp ), intent ( in ), optional :: alpha_max !! maximum step length (0,1] real ( wp ), intent ( in ), optional :: tolx !! convergence tolerance for changes in `x` real ( wp ), intent ( in ), optional :: fmin_tol !! convergence tolerance for [[fmin]] (used when `step_mode=3`) real ( wp ), intent ( in ), optional :: backtrack_c !! backtracking linesearch parameter (0,1) real ( wp ), intent ( in ), optional :: backtrack_tau !! backtracking linesearch parameter (0,1) logical , intent ( in ), optional :: use_broyden !! use a Broyden update (default is False) integer , intent ( in ), optional :: broyden_update_n !! For Broyden mode, update the full Jacobian !! at most every this many iterations (must be >1) !! If <=1 then Jacobian is only computed on the !! first iteration. procedure ( export_func ), optional :: export_iteration !! function to export each iteration procedure ( wait_func ), optional :: user_input_check !! check for user input (to stop solver if necessary) logical , intent ( in ), optional :: verbose !! for verbose status printing integer , intent ( in ), optional :: iunit !! unit for verbose printing (assumed to be open). !! by default this is `output_unit`. integer , intent ( in ), optional :: n_uphill_max !! maximum number of consecutive steps !! to allow where the value of `f` increases integer , intent ( in ), optional :: n_intervals !! number of intervals for fixed point linesearch logical :: status_ok !! true if there were no errors status_ok = . true . !required: me % n = abs ( n ) me % m = abs ( m ) me % max_iter = abs ( max_iter ) me % tol = abs ( tol ) me % func => func me % grad => grad !optional: if ( present ( step_mode )) then select case ( step_mode ) case ( 1 ) ! = use the specified `alpha` (0,1] me % linesearch => simple_step case ( 2 ) ! = backtracking linesearch (between `alpha_min` and `alpha_max`) me % linesearch => backtracking_linesearch case ( 3 ) ! = exact linesearch (between `alpha_min` and `alpha_max`) me % linesearch => exact_linesearch case ( 4 ) ! = evaluate function at specified fixed points (between `alpha_min` and `alpha_max`) me % linesearch => fixed_point_linesearch case default status_ok = . false . call me % set_status ( istat = - 5 , string = 'Error: invalid step_mode:' , i = step_mode ) return end select else me % linesearch => simple_step end if if ( present ( alpha )) me % alpha = abs ( alpha ) if ( present ( alpha_min )) me % alpha_min = abs ( alpha_min ) if ( present ( alpha_max )) me % alpha_max = abs ( alpha_max ) if ( present ( tolx )) me % tolx = abs ( tolx ) if ( present ( backtrack_c )) me % c = abs ( backtrack_c ) if ( present ( backtrack_tau )) me % tau = abs ( backtrack_tau ) if ( present ( use_broyden )) me % use_broyden = use_broyden if ( present ( broyden_update_n )) me % broyden_update_n = abs ( broyden_update_n ) if ( present ( verbose )) me % verbose = verbose if ( present ( iunit )) me % iunit = iunit if ( present ( n_uphill_max )) me % n_uphill_max = abs ( n_uphill_max ) if ( present ( n_intervals )) me % n_intervals = max ( abs ( n_intervals ), 1 ) if ( present ( fmin_tol )) me % fmin_tol = abs ( fmin_tol ) if ( present ( export_iteration )) me % export_iteration => export_iteration if ( present ( user_input_check )) me % user_input_check => user_input_check ! error checks: if ( me % alpha < zero . or . me % alpha > one ) then status_ok = . false . call me % set_status ( istat = - 1 , string = 'Error: invalid alpha:' , r = me % alpha ) return end if if ( me % alpha_min < zero . or . me % alpha_min > one ) then status_ok = . false . call me % set_status ( istat = - 2 , string = 'Error: invalid alpha_min:' , r = me % alpha_min ) return end if if ( me % alpha_max < zero . or . me % alpha_max > one ) then status_ok = . false . call me % set_status ( istat = - 3 , string = 'Error: invalid alpha_max:' , r = me % alpha_max ) return end if if ( me % alpha_max <= me % alpha_min ) then status_ok = . false . call me % set_status ( istat = - 4 , string = 'Error: alpha_min must be < alpha_max' ) return end if if ( me % c < zero . or . me % c > one ) then status_ok = . false . call me % set_status ( istat = - 12 , string = 'Error: backtracking linesearch c must be in range (0, 1):' , r = me % c ) return end if if ( me % tau < zero . or . me % tau > one ) then status_ok = . false . call me % set_status ( istat = - 13 , string = 'Error: backtracking linesearch tau must be in range (0, 1):' , r = me % tau ) return end if if ( status_ok ) then call me % set_status ( istat = 0 , string = 'Class successfully initialized' ) end if end subroutine initialize_nlesolver_variables","tags":"","loc":"proc/initialize_nlesolver_variables.html"},{"title":"nlesolver_solver – AoC-2023","text":"private  subroutine nlesolver_solver(me, x) Main solver. Type Bound nlesolver_type Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x Calls proc~~nlesolver_solver~~CallsGraph proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver proc~linear_solver nlesolver_module::linear_solver proc~nlesolver_solver->proc~linear_solver proc~set_status nlesolver_module::nlesolver_type%set_status proc~nlesolver_solver->proc~set_status Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~nlesolver_solver~~CalledByGraph proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->proc~nlesolver_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine nlesolver_solver ( me , x ) implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( inout ) :: x real ( wp ), dimension (:) , allocatable :: fvec !! function vector real ( wp ), dimension (:,:), allocatable :: fjac !! jacobian matrix real ( wp ), dimension (:) , allocatable :: rhs !! linear system right-hand side real ( wp ), dimension (:) , allocatable :: p !! search direction real ( wp ), dimension (:) , allocatable :: xold !! previous value of `x` real ( wp ), dimension (:) , allocatable :: prev_fvec !! previous function vector real ( wp ), dimension (:,:), allocatable :: prev_fjac !! previous jacobian matrix real ( wp ), dimension (:,:), allocatable :: delf !! used for Broyden (rank 2 for `matmul`) real ( wp ), dimension (:,:), allocatable :: delx !! used for Broyden (rank 2 for `matmul`) logical :: user_stop !! user stop button flag integer :: info !! status flag from the [[linear_solver]] integer :: iter !! iteration counter real ( wp ) :: f !! magnitude of `fvec` real ( wp ) :: fold !! previous value of `f` integer :: n_uphill !! number of steps taken in the \"uphill\" direction !! (where `f` is increasing) real ( wp ) :: delxmag2 !! used for Broyden logical :: recompute_jac !! if using Broyden, and we want to call the user !! jacobian routine instead integer :: broyden_counter !! number of times the broyden update has been used integer :: alloc_stat !! allocation status flag if ( me % istat < 0 ) return ! class was not initialized properly if (. not . associated ( me % func )) then call me % set_status ( istat = - 10 , string = 'Error: function routine is not associated' ) return end if if (. not . associated ( me % grad )) then call me % set_status ( istat = - 11 , string = 'Error: gradient routine is not associated' ) return end if ! initialize: iter = 0 n_uphill = 0 recompute_jac = . false . broyden_counter = 0 ! allocate the arrays: alloc_stat = 0 if ( alloc_stat == 0 ) allocate ( fvec ( me % m ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( fjac ( me % m , me % n ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( rhs ( me % m ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( p ( me % n ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( xold ( me % n ) , stat = alloc_stat ) if ( me % use_broyden ) then ! only need these for broyden: if ( alloc_stat == 0 ) allocate ( prev_fvec ( me % m ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( prev_fjac ( me % m , me % n ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( delf ( me % m , 1 ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( delx ( me % n , 1 ) , stat = alloc_stat ) end if if ( alloc_stat /= 0 ) then call me % set_status ( istat = - 9 , string = 'Error: Out of memory' ) return else me % istat = - 998 me % message = 'Unknown error' end if ! evaluate the function: call me % func ( x , fvec ) f = norm2 ( fvec ) ! check to see if initial guess is a root: if ( f <= me % tol ) then call me % set_status ( istat = 1 , string = 'Required accuracy achieved' ) else ! main iteration loop: do iter = 1 , me % max_iter ! Export the current iteration: if ( associated ( me % export_iteration )) call me % export_iteration ( x , fvec , iter ) ! Check for user stop: if ( associated ( me % user_input_check )) then call me % user_input_check ( user_stop ) if ( user_stop ) then call me % set_status ( istat = 4 , string = 'Stopped by the user' ) exit end if end if if ( me % use_broyden . and . . not . recompute_jac ) then if ( iter == 1 ) then ! always compute Jacobian on the first iteration call me % grad ( x , fjac ) broyden_counter = 0 else ! and use Broyden update to estimate Jacobian ! for subsequent iterations. ! note: fvec was computed the last iteration delx (:, 1 ) = x - xold delf (:, 1 ) = fvec - prev_fvec delxmag2 = dot_product ( delx (:, 1 ), delx (:, 1 )) if ( delxmag2 < eps ) then call me % set_status ( istat = - 8 , & string = 'Error: Divide by zero when computing Broyden update' ) exit end if ! Jacobian estimate: fjac = prev_fjac + & matmul (( delf - matmul ( prev_fjac , delx )),& transpose ( delx )) / delxmag2 broyden_counter = broyden_counter + 1 end if prev_fjac = fjac prev_fvec = fvec else ! compute the jacobian: call me % grad ( x , fjac ) recompute_jac = . false . ! for broyden broyden_counter = 0 end if xold = x fold = f ! compute the search direction p by solving linear system: rhs = - fvec ! RHS of the linear system call linear_solver ( me % m , me % n , fjac , rhs , p , info ) ! check for errors: if ( info /= 0 ) then call me % set_status ( istat = - 6 , string = 'Error solving linear system. info =' , i = info ) exit else ! next step, using the specified method: call me % linesearch ( xold , p , fjac , x , f , fvec ) ! keep track of the number of steps in the \"uphill\" direction: if ( f > fold ) then n_uphill = n_uphill + 1 else n_uphill = 0 end if ! check for stopping conditions if ( f <= me % tol ) then call me % set_status ( istat = 1 , string = 'Required accuracy achieved' ) exit elseif ( maxval ( abs ( x - xold )) <= me % tolx ) then call me % set_status ( istat = 2 , string = 'Solution cannot be improved' ) exit elseif ( iter == me % max_iter ) then call me % set_status ( istat = 3 , string = 'Maximum number of iterations reached' ) exit elseif ( n_uphill > me % n_uphill_max ) then call me % set_status ( istat = 5 , string = 'Too many steps in the uphill direction' ) exit elseif ( me % use_broyden ) then ! If delxmag2 is too small when using broyden, just ! call the user-supplied jacobian function to avoid ! a divide by zero on the next step. This should ! normally only happen when the solution is almost converged. if ( norm2 ( x - xold ) ** 2 <= eps ) then recompute_jac = . true . else if ( me % broyden_update_n > 0 ) then ! Note that we also recompute if we have taken an uphill step if ( broyden_counter == me % broyden_update_n . or . n_uphill > 0 ) then ! time to recompute the full jacobian recompute_jac = . true . end if end if end if endif end if end do !end of iterations loop end if !Export the last iteration: iter = iter + 1 if ( associated ( me % export_iteration )) call me % export_iteration ( x , fvec , iter ) end subroutine nlesolver_solver","tags":"","loc":"proc/nlesolver_solver.html"},{"title":"destroy_nlesolver_variables – AoC-2023","text":"private  subroutine destroy_nlesolver_variables(me) Destructor Type Bound nlesolver_type Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(out) :: me Source Code subroutine destroy_nlesolver_variables ( me ) implicit none class ( nlesolver_type ), intent ( out ) :: me me % message = 'Error: class has not been initialized' me % istat = - 999 end subroutine destroy_nlesolver_variables","tags":"","loc":"proc/destroy_nlesolver_variables.html"},{"title":"linear_solver – AoC-2023","text":"private  subroutine linear_solver(m, n, a, b, x, info) Solve the linear system: , using a dense, direct method. if n=m : use LAPACK dgesv (LU decomposition) if n/=m : use LAPACK dgels (if m>n uses QR factorization,\n  if m<n uses LQ factorization) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m number of rows in a integer, intent(in) :: n number of columns in a real(kind=wp), intent(in), dimension(m,n) :: a A matrix of the linear system real(kind=wp), intent(in), dimension(m) :: b RHS of the linear system real(kind=wp), intent(out), dimension(n) :: x the solution of the linear system. integer, intent(out) :: info output status flag ( =0 if success) Called by proc~~linear_solver~~CalledByGraph proc~linear_solver nlesolver_module::linear_solver proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver proc~nlesolver_solver->proc~linear_solver program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->proc~nlesolver_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine linear_solver ( m , n , a , b , x , info ) implicit none integer , intent ( in ) :: n !! number of columns in `a` integer , intent ( in ) :: m !! number of rows in `a` real ( wp ), dimension ( m , n ), intent ( in ) :: a !! `A` matrix of the linear system real ( wp ), dimension ( m ), intent ( in ) :: b !! RHS of the linear system real ( wp ), dimension ( n ), intent ( out ) :: x !! the solution of the linear system. integer , intent ( out ) :: info !! output status flag (`=0` if success) ! LAPACK routine interfaces: interface subroutine dgesv ( n , nrhs , a , lda , ipiv , b , ldb , info ) !! See: [?gesv](https://www.intel.com/content/www/us/en/develop/documentation/onemkl-developer-reference-fortran/top/lapack-routines/lapack-linear-equation-routines/lapack-linear-equation-driver-routines/gesv.html) import :: wp implicit none integer :: info integer :: lda integer :: ldb integer :: n integer :: nrhs integer :: ipiv ( * ) real ( wp ) :: a ( lda , * ) real ( wp ) :: b ( ldb , * ) end subroutine dgesv subroutine dgels ( trans , m , n , nrhs , a , lda , b , ldb , work , lwork , info ) !! See: [?gels](https://www.intel.com/content/www/us/en/develop/documentation/onemkl-developer-reference-fortran/top/lapack-routines/lapack-least-squares-and-eigenvalue-problem/lapack-least-squares-eigenvalue-problem-driver/linear-least-squares-lls-problems-lapack-driver/gels.html) import :: wp implicit none character :: trans integer :: info integer :: lda integer :: ldb integer :: lwork integer :: m integer :: n integer :: nrhs real ( wp ) :: a ( lda , * ) real ( wp ) :: b ( ldb , * ) real ( wp ) :: work ( * ) end subroutine dgels end interface integer , dimension (:), allocatable :: ipiv !! pivot indices array real ( wp ), dimension (:,:), allocatable :: bmat !! copy of `b` so it won't be overwritten real ( wp ), dimension (:), allocatable :: work !! work array for `dgels` real ( wp ), dimension (:,:), allocatable :: amat !! copy of `a` so it won't be overwritten integer :: lwork !! size of `work` allocate ( amat ( m , n )) allocate ( bmat ( max ( 1 , m , n ), 1 )) if ( n == m ) then !normal inverse allocate ( ipiv ( n )) amat = a bmat ( 1 : n , 1 ) = b call dgesv ( n , 1 , amat , n , ipiv , bmat , n , info ) x = bmat ( 1 : n , 1 ) else amat = a bmat = zero bmat ( 1 : m , 1 ) = b lwork = min ( m , n ) + max ( 1 , m , n ) allocate ( work ( lwork )) call dgels ( 'N' , m , n , 1 , amat , m , bmat , max ( 1 , m , n ), work , lwork , info ) x = bmat ( 1 : n , 1 ) end if end subroutine linear_solver","tags":"","loc":"proc/linear_solver.html"},{"title":"simple_step – AoC-2023","text":"private  subroutine simple_step(me, xold, p, fjac, x, f, fvec) Take a simple step in the search direction of p * alpha . Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: xold previous value of x real(kind=wp), intent(in), dimension(me%n) :: p search direction real(kind=wp), intent(in), dimension(me%m,me%n) :: fjac jacobian matrix real(kind=wp), intent(out), dimension(me%n) :: x new x real(kind=wp), intent(inout) :: f magnitude of fvec real(kind=wp), intent(inout), dimension(me%m) :: fvec function vector Source Code subroutine simple_step ( me , xold , p , fjac , x , f , fvec ) implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: xold !! previous value of `x` real ( wp ), dimension ( me % n ), intent ( in ) :: p !! search direction real ( wp ), dimension ( me % m , me % n ), intent ( in ) :: fjac !! jacobian matrix real ( wp ), dimension ( me % n ), intent ( out ) :: x !! new `x` real ( wp ), intent ( inout ) :: f !! magnitude of `fvec` real ( wp ), dimension ( me % m ), intent ( inout ) :: fvec !! function vector x = xold + p * me % alpha !evaluate the function at the new point: call me % func ( x , fvec ) f = norm2 ( fvec ) end subroutine simple_step","tags":"","loc":"proc/simple_step.html"},{"title":"backtracking_linesearch – AoC-2023","text":"private  subroutine backtracking_linesearch(me, xold, p, fjac, x, f, fvec) Backtracking line search. See also [Backtracking line search](https: Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: xold previous value of x real(kind=wp), intent(in), dimension(me%n) :: p search direction real(kind=wp), intent(in), dimension(me%m,me%n) :: fjac jacobian matrix real(kind=wp), intent(out), dimension(me%n) :: x new x real(kind=wp), intent(inout) :: f magnitude of fvec real(kind=wp), intent(inout), dimension(me%m) :: fvec function vector Source Code subroutine backtracking_linesearch ( me , xold , p , fjac , x , f , fvec ) implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: xold !! previous value of `x` real ( wp ), dimension ( me % n ), intent ( in ) :: p !! search direction real ( wp ), dimension ( me % m , me % n ), intent ( in ) :: fjac !! jacobian matrix real ( wp ), dimension ( me % n ), intent ( out ) :: x !! new `x` real ( wp ), intent ( inout ) :: f !! magnitude of `fvec` real ( wp ), dimension ( me % m ), intent ( inout ) :: fvec !! function vector integer :: i !! counter real ( wp ) :: slope !! local slope of the function of `alpha` along the search direction used for line search logical :: min_alpha_reached !! if the minimum step size is reached during the line search real ( wp ) :: alpha !! `alpha` for the line search real ( wp ) :: ftmp !! `f` value for linesearch real ( wp ) :: t !! used for line search real ( wp ), dimension (:), allocatable :: gradf !! line search objective function gradient vector real ( wp ), dimension (:), allocatable :: xtmp !! `x` value for linesearch real ( wp ), dimension (:), allocatable :: fvectmp !! `fvec` value for linesearch ! allocate arrays: allocate ( gradf ( me % n )) allocate ( xtmp ( me % n )) allocate ( fvectmp ( me % m )) ! compute the gradient of the function to be minimized ! (which in this case is 1/2 the norm of fvec). Use the chain ! rule and the Jacobian matrix already computed. do i = 1 , me % n gradf ( i ) = dot_product ( fvec , fjac (:, i )) end do slope = dot_product ( p , gradf ) t = - me % c * slope if ( me % verbose ) then write ( me % iunit , '(1P,*(A,1X,E16.6))' ) '        slope    = ' , slope write ( me % iunit , '(1P,*(A,1X,E16.6))' ) '        t        = ' , t end if ! perform the line search: min_alpha_reached = . false . alpha = me % alpha_max ! start with the largest step do xtmp = xold + p * alpha call me % func ( xtmp , fvectmp ) ftmp = norm2 ( fvectmp ) if ( me % verbose ) then write ( me % iunit , '(1P,*(A,1X,E16.6))' ) '        alpha    = ' , alpha , ' f       = ' , ftmp if ( f - ftmp >= alpha * t ) then write ( me % iunit , '(1P,2(A,1X,E16.6),1X,A)' ) '        f - ftmp = ' , f - ftmp , ' alpha*t = ' , alpha * t , ' [ACCEPTED]' else write ( me % iunit , '(1P,*(A,1X,E16.6))' ) '        f - ftmp = ' , f - ftmp , ' alpha*t = ' , alpha * t end if end if if ((( f - ftmp ) / 2.0_wp >= alpha * t ) . or . min_alpha_reached ) then if ( min_alpha_reached ) then write ( me % iunit , '(A)' ) '        Minimum alpha reached' end if ! Armijo-Goldstein condition is satisfied ! (or the min step has been reached) x = xtmp fvec = fvectmp f = ftmp exit end if alpha = alpha * me % tau ! reduce step size if ( alpha <= me % alpha_min ) then alpha = me % alpha_min min_alpha_reached = . true . ! will stop on the next step end if end do end subroutine backtracking_linesearch","tags":"","loc":"proc/backtracking_linesearch.html"},{"title":"exact_linesearch – AoC-2023","text":"private  subroutine exact_linesearch(me, xold, p, fjac, x, f, fvec) An exact linesearch that uses a derivative-free minimizer to\nfind the minimum value of f(x) between x = xold + p * alpha_min and x = xold + p * alpha_max . Usually this is overkill and not necessary, but is here as an option for testing. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: xold previous value of x real(kind=wp), intent(in), dimension(me%n) :: p search direction real(kind=wp), intent(in), dimension(me%m,me%n) :: fjac jacobian matrix real(kind=wp), intent(out), dimension(me%n) :: x new x real(kind=wp), intent(inout) :: f magnitude of fvec real(kind=wp), intent(inout), dimension(me%m) :: fvec function vector Calls proc~~exact_linesearch~~CallsGraph proc~exact_linesearch nlesolver_module::exact_linesearch proc~fmin fmin_module::fmin proc~exact_linesearch->proc~fmin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine exact_linesearch ( me , xold , p , fjac , x , f , fvec ) implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: xold !! previous value of `x` real ( wp ), dimension ( me % n ), intent ( in ) :: p !! search direction real ( wp ), dimension ( me % m , me % n ), intent ( in ) :: fjac !! jacobian matrix real ( wp ), dimension ( me % n ), intent ( out ) :: x !! new `x` real ( wp ), intent ( inout ) :: f !! magnitude of `fvec` real ( wp ), dimension ( me % m ), intent ( inout ) :: fvec !! function vector real ( wp ), dimension (:), allocatable :: xnew !! used in [[func_for_fmin]] real ( wp ) :: alpha_min allocate ( xnew ( me % n )) ! find the minimum value of f in the range of alphas: alpha_min = fmin ( func_for_fmin , me % alpha_min , me % alpha_max , me % fmin_tol ) if ( me % verbose ) write ( me % iunit , '(1P,*(A,1X,E16.6))' ) '        alpha_min = ' , alpha_min x = xold + p * alpha_min if ( all ( x == xnew )) then ! already computed in the func else call me % func ( x , fvec ) f = norm2 ( fvec ) end if contains real ( wp ) function func_for_fmin ( alpha ) !! function for [[fmin]] implicit none real ( wp ), intent ( in ) :: alpha !! indep variable xnew = xold + p * alpha call me % func ( xnew , fvec ) func_for_fmin = norm2 ( fvec ) ! return result f = func_for_fmin ! just in case this is the solution end function func_for_fmin end subroutine exact_linesearch","tags":"","loc":"proc/exact_linesearch.html"},{"title":"fixed_point_linesearch – AoC-2023","text":"private  subroutine fixed_point_linesearch(me, xold, p, fjac, x, f, fvec) A simple search that just evaluates the function at a specified\nnumber of points and picks the one with the minimum function value. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: xold previous value of x real(kind=wp), intent(in), dimension(me%n) :: p search direction real(kind=wp), intent(in), dimension(me%m,me%n) :: fjac jacobian matrix real(kind=wp), intent(out), dimension(me%n) :: x new x real(kind=wp), intent(inout) :: f magnitude of fvec real(kind=wp), intent(inout), dimension(me%m) :: fvec function vector Source Code subroutine fixed_point_linesearch ( me , xold , p , fjac , x , f , fvec ) implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: xold !! previous value of `x` real ( wp ), dimension ( me % n ), intent ( in ) :: p !! search direction real ( wp ), dimension ( me % m , me % n ), intent ( in ) :: fjac !! jacobian matrix real ( wp ), dimension ( me % n ), intent ( out ) :: x !! new `x` real ( wp ), intent ( inout ) :: f !! magnitude of `fvec` real ( wp ), dimension ( me % m ), intent ( inout ) :: fvec !! function vector integer :: i !! counter integer :: n_points !! number of points to compute real ( wp ), dimension (:), allocatable :: alphas_to_try !! set of `alpha` values to try real ( wp ), dimension (:), allocatable :: x_tmp !! temp `x` real ( wp ), dimension (:), allocatable :: fvec_tmp !! temp `fvec` real ( wp ) :: f_tmp !! temp `f` real ( wp ) :: step_size !! step size for `alpha` integer :: n !! number of steps to divide the interval ! 1 o-----------o ! 2 o-----o-----o ! 3 o---o---o---o n = me % n_intervals n_points = n + 1 allocate ( alphas_to_try ( n_points )) allocate ( x_tmp ( me % n )) allocate ( fvec_tmp ( me % m )) step_size = ( me % alpha_max - me % alpha_min ) / real ( n , wp ) ! compute the alphas: alphas_to_try ( 1 ) = me % alpha_min do i = 2 , n alphas_to_try ( i ) = alphas_to_try ( i - 1 ) + step_size end do alphas_to_try ( n_points ) = me % alpha_max ! now compute the functions at these alphas: f = big do i = 1 , n_points x_tmp = xold + p * alphas_to_try ( i ) ! evaluate the function at tthis point: call me % func ( x_tmp , fvec_tmp ) f_tmp = norm2 ( fvec_tmp ) if ( f_tmp <= f ) then ! new best point x = x_tmp f = f_tmp fvec = fvec_tmp end if end do end subroutine fixed_point_linesearch","tags":"","loc":"proc/fixed_point_linesearch.html"},{"title":"func – AoC-2023","text":"function func(x) Problem function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) Called by proc~~func~2~~CalledByGraph proc~func~2 test2::func proc~my_func~2 test2::my_func proc~my_func~2->proc~func~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function func ( x ) !! Problem function real ( wp ), intent ( in ) :: x real ( wp ) :: func func = x + sin ( x ) end function func","tags":"","loc":"proc/func~2.html"},{"title":"deriv – AoC-2023","text":"function deriv(x) Problem function true derivative Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) Called by proc~~deriv~~CalledByGraph proc~deriv test2::deriv program~test2 test2 program~test2->proc~deriv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function deriv ( x ) !! Problem function true derivative real ( wp ), intent ( in ) :: x real ( wp ) :: deriv deriv = 1.0_wp + cos ( x ) end function deriv","tags":"","loc":"proc/deriv.html"},{"title":"my_func – AoC-2023","text":"subroutine my_func(me, x, f, funcs_to_compute) Problem function interface for numdiff Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: f integer, intent(in), dimension(:) :: funcs_to_compute Calls proc~~my_func~2~~CallsGraph proc~my_func~2 test2::my_func proc~func~2 test2::func proc~my_func~2->proc~func~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine my_func ( me , x , f , funcs_to_compute ) !! Problem function interface for numdiff class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f integer , dimension (:), intent ( in ) :: funcs_to_compute if ( any ( funcs_to_compute == 1 )) f ( 1 ) = func ( x ( 1 )) func_evals = func_evals + 1 end subroutine my_func","tags":"","loc":"proc/my_func~2.html"},{"title":"go – AoC-2023","text":"function go(time, distance) result(iproduct) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: time integer(kind=ip), intent(in), dimension(:) :: distance Return Value integer(kind=ip) Called by proc~~go~8~~CalledByGraph proc~go~8 problem_6::go program~problem_6 problem_6 program~problem_6->proc~go~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function go ( time , distance ) result ( iproduct ) integer ( ip ), dimension (:), intent ( in ) :: time integer ( ip ), dimension (:), intent ( in ) :: distance integer ( ip ) :: iproduct integer ( ip ) :: i , ihold , iways , idistance iproduct = 1 do i = 1 , size ( time ) iways = 0 do ihold = 1 , time ( i ) ! time to hold the button idistance = ihold * ( time ( i ) - ihold ) if ( idistance > distance ( i )) iways = iways + 1 end do iproduct = iproduct * iways end do end function go","tags":"","loc":"proc/go~8.html"},{"title":"go – AoC-2023","text":"recursive subroutine go(i, j, direction_from) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i grid coordinate integer, intent(in) :: j grid coordinate integer, intent(in) :: direction_from direction coming from (TOP,BOTTOM,LEFT,RIGHT Called by proc~~go~4~~CalledByGraph proc~go~4 problem_16::go proc~go~4->proc~go~4 program~problem_16 problem_16 program~problem_16->proc~go~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine go ( i , j , direction_from ) integer , intent ( in ) :: i , j !! grid coordinate integer , intent ( in ) :: direction_from !! direction coming from (TOP,BOTTOM,LEFT,RIGHT integer :: k if ( i > nrows . or . i < 1 . or . j > ncols . or . j < 1 ) return ! off the board if ( visited ( direction_from , i , j )) return ! this case has already been done visited ( direction_from , i , j ) = . true . ! mark this one as visited in this direction associate ( c => array ( i , j )) select case ( c ) case ( '.' ) ! continue in same direction k = 1 do ! loop until we hit something else ! (to avoid unnecessary recursion) select case ( direction_from ) case ( TOP ) ! V if (( i + k ) > nrows ) return if ( array ( i + k , j ) /= '.' ) then call go ( i + k , j , direction_from ) return end if visited ( direction_from , i + k , j ) = . true . case ( BOTTOM ) ! &#94; if (( i - k ) < 1 ) return if ( array ( i - k , j ) /= '.' ) then call go ( i - k , j , direction_from ) return end if visited ( direction_from , i - k , j ) = . true . case ( LEFT ) ! --> if (( j + k ) > ncols ) return if ( array ( i , j + k ) /= '.' ) then call go ( i , j + k , direction_from ) return end if visited ( direction_from , i , j + k ) = . true . case ( RIGHT ) ! <-- if (( j - k ) < 1 ) return if ( array ( i , j - k ) /= '.' ) then call go ( i , j - k , direction_from ) return end if visited ( direction_from , i , j - k ) = . true . end select k = k + 1 end do case ( '-' ) select case ( direction_from ) case ( TOP , BOTTOM ) ! V, &#94; call go ( i , j + 1 , LEFT ) ! split call go ( i , j - 1 , RIGHT ) case ( LEFT ) ! --> call go ( i , j + 1 , LEFT ) case ( RIGHT ) ! <-- call go ( i , j - 1 , RIGHT ) end select case ( '|' ) select case ( direction_from ) case ( TOP ) ! V call go ( i + 1 , j , TOP ) case ( BOTTOM ) ! &#94; call go ( i - 1 , j , BOTTOM ) case ( LEFT , RIGHT ) ! -->, <-- call go ( i + 1 , j , TOP ) call go ( i - 1 , j , BOTTOM ) end select case ( '/' ) select case ( direction_from ) case ( TOP ) ! V call go ( i , j - 1 , RIGHT ) case ( BOTTOM ) ! &#94; call go ( i , j + 1 , LEFT ) case ( LEFT ) ! --> call go ( i - 1 , j , BOTTOM ) case ( RIGHT ) ! <-- call go ( i + 1 , j , TOP ) end select case ( '\\' ) select case ( direction_from ) case ( TOP ) ! V call go ( i , j + 1 , LEFT ) case ( BOTTOM ) ! &#94; call go ( i , j - 1 , RIGHT ) case ( LEFT ) ! --> call go ( i + 1 , j , TOP ) case ( RIGHT ) ! <-- call go ( i - 1 , j , BOTTOM ) end select end select end associate end subroutine go","tags":"","loc":"proc/go~4.html"},{"title":"func – AoC-2023","text":"subroutine func(me, x, f) compute the function Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: f Source Code subroutine func ( me , x , f ) !! compute the function implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f f_evals = f_evals + 1 f ( 1 ) = x ( 1 ) ** 2 + x ( 2 ) - 0.1_wp f ( 2 ) = x ( 2 ) + 0.2_wp ! root is 5.477226E-01  -2.000000E-01 end subroutine func","tags":"","loc":"proc/func~3.html"},{"title":"grad – AoC-2023","text":"subroutine grad(me, x, g) compute the gradient of the function (Jacobian): Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:,:) :: g Source Code subroutine grad ( me , x , g ) !! compute the gradient of the function (Jacobian): implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:,:), intent ( out ) :: g f_evals = f_evals + 2 ! to approximate forward diff derivatives g ( 1 , 1 ) = 2.0_wp * x ( 1 ) !df(1)/dx g ( 2 , 1 ) = 0.0_wp !df(2)/dx g ( 1 , 2 ) = 1.0_wp !df(1)/dy g ( 2 , 2 ) = 1.0_wp !df(2)/dy end subroutine grad","tags":"","loc":"proc/grad.html"},{"title":"export – AoC-2023","text":"subroutine export(me, x, f, iter) export an iteration: Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: f integer, intent(in) :: iter iteration number Source Code subroutine export ( me , x , f , iter ) !! export an iteration: implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: f integer , intent ( in ) :: iter !! iteration number write ( * , '(1P,I3,1X,A,I3,A,*(E15.6))' ) iter , '(' , f_evals , ')' , x , norm2 ( f ) end subroutine export","tags":"","loc":"proc/export.html"},{"title":"is_node – AoC-2023","text":"pure function is_node(i, j) returns true if a node is at these coordinates Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value logical Source Code pure logical function is_node ( i , j ) !! returns true if a node is at these coordinates integer ( ip ), intent ( in ) :: i , j is_node = any ( inodes == i . and . jnodes == j ) end function is_node","tags":"","loc":"proc/is_node.html"},{"title":"node_number – AoC-2023","text":"pure function node_number(i, j) returns the index of these coordinates in\nthe list of nodes (0 if it is not a node) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value integer(kind=ip) Called by proc~~node_number~~CalledByGraph proc~node_number problem_23::node_number proc~build_graph problem_23::build_graph proc~build_graph->proc~node_number proc~build_graph->proc~build_graph proc~go~5 problem_23::go proc~go~5->proc~build_graph program~problem_23 problem_23 program~problem_23->proc~go~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer ( ip ) function node_number ( i , j ) !! returns the index of these coordinates in !! the list of nodes (0 if it is not a node) integer ( ip ), intent ( in ) :: i , j integer ( ip ), dimension ( 1 ) :: iloc iloc = findloc ( inodes == i . and . jnodes == j , . true .) node_number = iloc ( 1 ) end function node_number","tags":"","loc":"proc/node_number.html"},{"title":"count_adjacent – AoC-2023","text":"pure function count_adjacent(i, j) result(icount) count the number of adjacent cells not a tree Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value integer(kind=ip) Calls proc~~count_adjacent~~CallsGraph proc~count_adjacent problem_23::count_adjacent proc~not_tree problem_23::not_tree proc~count_adjacent->proc~not_tree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~count_adjacent~~CalledByGraph proc~count_adjacent problem_23::count_adjacent proc~go~5 problem_23::go proc~go~5->proc~count_adjacent program~problem_23 problem_23 program~problem_23->proc~go~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function count_adjacent ( i , j ) result ( icount ) !! count the number of adjacent cells not a tree integer ( ip ), intent ( in ) :: i , j integer ( ip ) :: icount icount = 0 if ( i >= 1 ) icount = icount + count ([ not_tree ( i - 1 , j )]) if ( i <= nrows ) icount = icount + count ([ not_tree ( i + 1 , j )]) if ( j <= ncols ) icount = icount + count ([ not_tree ( i , j + 1 )]) if ( j >= 1 ) icount = icount + count ([ not_tree ( i , j - 1 )]) end function count_adjacent","tags":"","loc":"proc/count_adjacent.html"},{"title":"get_cell – AoC-2023","text":"pure function get_cell(i, j) result(a) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i coordinates integer(kind=ip), intent(in) :: j coordinates Return Value character(len=1) Called by proc~~get_cell~~CalledByGraph proc~get_cell problem_23::get_cell proc~build_graph problem_23::build_graph proc~build_graph->proc~get_cell proc~build_graph->proc~build_graph proc~go~5 problem_23::go proc~go~5->proc~build_graph program~problem_23 problem_23 program~problem_23->proc~go~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function get_cell ( i , j ) result ( a ) integer ( ip ), intent ( in ) :: i , j !! coordinates character ( len = 1 ) :: a if ( slopes ) then a = array ( i , j ) else a = '.' ! ignore the slopes for part b end if end function get_cell","tags":"","loc":"proc/get_cell.html"},{"title":"not_tree – AoC-2023","text":"pure function not_tree(i, j) returns true if the cell isn't a tree Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i coordinates integer(kind=ip), intent(in) :: j coordinates Return Value logical Called by proc~~not_tree~~CalledByGraph proc~not_tree problem_23::not_tree proc~count_adjacent problem_23::count_adjacent proc~count_adjacent->proc~not_tree proc~go~5 problem_23::go proc~go~5->proc~count_adjacent program~problem_23 problem_23 program~problem_23->proc~go~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function not_tree ( i , j ) !! returns true if the cell isn't a tree integer ( ip ), intent ( in ) :: i , j !! coordinates if ( i < 1 . or . i > nrows . or . j < 1 . or . j > ncols ) then not_tree = . false . ! off the board, call it a tree else not_tree = array ( i , j ) /= '#' end if end function not_tree","tags":"","loc":"proc/not_tree.html"},{"title":"go – AoC-2023","text":"subroutine go(case, filename, parta) solve the case Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: case case name for printing character(len=*), intent(in) :: filename input file to read logical, intent(in) :: parta if this is part a, then consider the slopes Calls proc~~go~5~~CallsGraph proc~go~5 problem_23::go proc~build_graph problem_23::build_graph proc~go~5->proc~build_graph proc~count_adjacent problem_23::count_adjacent proc~go~5->proc~count_adjacent proc~dijkstra problem_23::dijkstra proc~go~5->proc~dijkstra proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~go~5->proc~read_file_to_char_array proc~traverse~3 problem_23::traverse proc~go~5->proc~traverse~3 proc~build_graph->proc~build_graph proc~add_edge~2 problem_23::add_edge proc~build_graph->proc~add_edge~2 proc~get_cell problem_23::get_cell proc~build_graph->proc~get_cell proc~node_number problem_23::node_number proc~build_graph->proc~node_number proc~not_tree problem_23::not_tree proc~count_adjacent->proc~not_tree proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line proc~traverse~3->proc~traverse~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~go~5~~CalledByGraph proc~go~5 problem_23::go program~problem_23 problem_23 program~problem_23->proc~go~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine go ( case , filename , parta ) !! solve the case character ( len =* ), intent ( in ) :: case !! case name for printing character ( len =* ), intent ( in ) :: filename !! input file to read logical , intent ( in ) :: parta !! if this is part a, then consider the slopes integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: istart , iend , idist , i , j logical , parameter :: use_dijkstra = . false . !.... doesn't work yet .... don't know why ....... ! initialize: max_dist = 0 slopes = parta if ( allocated ( nodes )) deallocate ( nodes ) if ( allocated ( visited )) deallocate ( visited ) if ( allocated ( nodes_visited )) deallocate ( nodes_visited ) if ( allocated ( inodes )) deallocate ( inodes ) if ( allocated ( jnodes )) deallocate ( jnodes ) if ( allocated ( node_dist )) deallocate ( node_dist ) if ( allocated ( node_prev )) deallocate ( node_prev ) ! read the data file: array = read_file_to_char_array ( filename ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) iloc = findloc ( array ( 1 ,:), '.' ); istart = iloc ( 1 ) ! get start and end columns iloc = findloc ( array ( nrows ,:), '.' ); iend = iloc ( 1 ) ! ! identify the coordinates of all the nodes: inodes = [ 1 ] ! start node jnodes = [ istart ] do i = 1 , nrows do j = 1 , ncols if ( count_adjacent ( i , j ) >= 3 ) then inodes = [ inodes , i ] jnodes = [ jnodes , j ] end if end do end do inodes = [ inodes , nrows ] ! end node jnodes = [ jnodes , iend ] total_nodes = size ( inodes ) ! for each node, find the other nodes they are ! connected to and the distances between them (the edges) allocate ( nodes ( total_nodes )) allocate ( visited ( nrows , ncols )) do i = 1 , total_nodes visited = . false . idist = 0 call build_graph ( i , inodes ( i ), jnodes ( i ), idist , visited ) end do if ( use_dijkstra ) then !write(*,*) 'hello use_dijkstra'         ! ... something wrong here... don't get the right answer ! based on AOC 2021, Problem 15 allocate ( node_dist ( total_nodes )); node_dist = - 1 ; node_dist ( 1 ) = 0 allocate ( node_prev ( total_nodes )); node_prev = - 1 allocate ( nodes_visited ( total_nodes )); nodes_visited = . false . do iloc = maxloc ( node_dist , mask = . not . nodes_visited ) i = iloc ( 1 ) nodes_visited ( i ) = . true . if ( i == total_nodes ) exit ! we are done! !write(*,*) 'visited ', i if ( allocated ( nodes ( i )% inext )) then do j = 1 , size ( nodes ( i )% inext ) ! adjacent nodes to this one call dijkstra ( i , j ) end do end if !if (all(nodes_visited)) exit ! done end do !write(*,*) case, node_dist(size(node_dist)) ! result for this case (last node) !write(*,*) nodes_visited !write(*,*) node_dist else ! start at first, and find the longest that gets to the last. ! recursively traverse the graph. visited = . false . allocate ( nodes_visited ( total_nodes )); nodes_visited = . false . call traverse ( 1_ip , 0_ip , nodes_visited ) write ( * , * ) case , max_dist ! result for this case end if end subroutine go","tags":"","loc":"proc/go~5.html"},{"title":"dijkstra – AoC-2023","text":"subroutine dijkstra(u, inext) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: u integer(kind=ip), intent(in) :: inext Called by proc~~dijkstra~~CalledByGraph proc~dijkstra problem_23::dijkstra proc~go~5 problem_23::go proc~go~5->proc~dijkstra program~problem_23 problem_23 program~problem_23->proc~go~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dijkstra ( u , inext ) integer ( ip ), intent ( in ) :: u ! current integer ( ip ), intent ( in ) :: inext ! index in inext array of the next node integer ( ip ) :: idist associate ( next_node => nodes ( u )% inext ( inext ), & distance_to_next_node => nodes ( u )% idist ( inext )) if ( nodes_visited ( next_node )) return ! already visited this one idist = node_dist ( u ) + distance_to_next_node ! add distance from u to v if ( idist > node_dist ( next_node )) then !write(*,*) 'highest so far: ', idist node_dist ( next_node ) = idist node_prev ( next_node ) = u end if end associate end subroutine dijkstra","tags":"","loc":"proc/dijkstra.html"},{"title":"build_graph – AoC-2023","text":"recursive subroutine build_graph(node_num, i, j, idist, visited) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: node_num current node number integer(kind=ip), intent(in) :: i current position integer(kind=ip), intent(in) :: j current position integer(kind=ip), intent(in) :: idist current distance (number of steps) logical, intent(in), dimension(:,:) :: visited elements visited in this path (not counting this one) Calls proc~~build_graph~~CallsGraph proc~build_graph problem_23::build_graph proc~build_graph->proc~build_graph proc~add_edge~2 problem_23::add_edge proc~build_graph->proc~add_edge~2 proc~get_cell problem_23::get_cell proc~build_graph->proc~get_cell proc~node_number problem_23::node_number proc~build_graph->proc~node_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~build_graph~~CalledByGraph proc~build_graph problem_23::build_graph proc~build_graph->proc~build_graph proc~go~5 problem_23::go proc~go~5->proc~build_graph program~problem_23 problem_23 program~problem_23->proc~go~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine build_graph ( node_num , i , j , idist , visited ) integer ( ip ), intent ( in ) :: node_num !! current node number integer ( ip ), intent ( in ) :: i , j !! current position integer ( ip ), intent ( in ) :: idist !! current distance (number of steps) logical , dimension (:,:), intent ( in ) :: visited !! elements visited in this path (not counting this one) logical , dimension (:,:), allocatable :: tmp_visited integer ( ip ) :: child_node_num if ( i < 1 . or . i > nrows . or . j < 1 . or . j > ncols ) return if ( visited ( i , j )) return if ( array ( i , j ) == '#' ) return ! can't continue from here ! go until we hit another node child_node_num = node_number ( i , j ) if ( child_node_num > 0 . and . child_node_num /= node_num ) then ! we have reached another node call add_edge ( node_num , child_node_num , idist ) else ! continue processing this edge tmp_visited = visited !make a copy and mark this one tmp_visited ( i , j ) = . true . ! we are here now associate ( a => get_cell ( i , j )) ! paths (.), forest (#), and steep slopes (&#94;, >, v, and <). select case ( a ) case ( '.' ) ! path call build_graph ( node_num , i - 1 , j , idist + 1 , tmp_visited ) call build_graph ( node_num , i + 1 , j , idist + 1 , tmp_visited ) call build_graph ( node_num , i , j + 1 , idist + 1 , tmp_visited ) call build_graph ( node_num , i , j - 1 , idist + 1 , tmp_visited ) ! these don't have a choice, must go in these directions: case ( '&#94;' ); call build_graph ( node_num , i - 1 , j , idist + 1 , tmp_visited ) case ( 'v' ); call build_graph ( node_num , i + 1 , j , idist + 1 , tmp_visited ) case ( '>' ); call build_graph ( node_num , i , j + 1 , idist + 1 , tmp_visited ) case ( '<' ); call build_graph ( node_num , i , j - 1 , idist + 1 , tmp_visited ) end select end associate end if end subroutine build_graph","tags":"","loc":"proc/build_graph.html"},{"title":"traverse – AoC-2023","text":"recursive subroutine traverse(node_num, idist, nodes_visited) traverse the graph until we get to the end and check the max distance Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: node_num current node integer(kind=ip), intent(in) :: idist distance to get here logical, intent(in), dimension(:) :: nodes_visited Called by proc~~traverse~3~~CalledByGraph proc~traverse~3 problem_23::traverse proc~traverse~3->proc~traverse~3 proc~go~5 problem_23::go proc~go~5->proc~traverse~3 program~problem_23 problem_23 program~problem_23->proc~go~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine traverse ( node_num , idist , nodes_visited ) !! traverse the graph until we get to the end and check the max distance integer ( ip ), intent ( in ) :: node_num !! current node integer ( ip ), intent ( in ) :: idist !! distance to get here logical , dimension (:), intent ( in ) :: nodes_visited logical , dimension (:), allocatable :: tmp_nodes_visited integer :: i if ( nodes_visited ( node_num )) return ! already visited this node if ( node_num == total_nodes ) then ! reached the destination if ( idist > max_dist ) max_dist = idist ! best so far else ! are their child nodes? if ( allocated ( nodes ( node_num )% inext )) then tmp_nodes_visited = nodes_visited tmp_nodes_visited ( node_num ) = . true . ! mark this node do i = 1 , size ( nodes ( node_num )% inext ) call traverse ( nodes ( node_num )% inext ( i ), idist + nodes ( node_num )% idist ( i ), tmp_nodes_visited ) end do end if end if end subroutine traverse","tags":"","loc":"proc/traverse~3.html"},{"title":"add_edge – AoC-2023","text":"subroutine add_edge(inode, ichild, idist) add an edge to this node (path to another node with the specified distance) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: inode integer(kind=ip), intent(in) :: ichild integer(kind=ip), intent(in) :: idist Called by proc~~add_edge~2~~CalledByGraph proc~add_edge~2 problem_23::add_edge proc~build_graph problem_23::build_graph proc~build_graph->proc~add_edge~2 proc~build_graph->proc~build_graph proc~go~5 problem_23::go proc~go~5->proc~build_graph program~problem_23 problem_23 program~problem_23->proc~go~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine add_edge ( inode , ichild , idist ) !! add an edge to this node (path to another node with the specified distance) integer ( ip ), intent ( in ) :: inode , ichild , idist if (. not . allocated ( nodes ( inode )% inext )) then allocate ( nodes ( inode )% inext ( 0 )) allocate ( nodes ( inode )% idist ( 0 )) end if nodes ( inode )% inext = [ nodes ( inode )% inext , ichild ] nodes ( inode )% idist = [ nodes ( inode )% idist , idist ] end subroutine add_edge","tags":"","loc":"proc/add_edge~2.html"},{"title":"char_to_int – AoC-2023","text":"private pure function char_to_int(str) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer Called by proc~~char_to_int~~CalledByGraph proc~char_to_int aoc_utilities::char_to_int interface~int aoc_utilities::int interface~int->proc~char_to_int proc~char_array_to_int aoc_utilities::char_array_to_int interface~int->proc~char_array_to_int proc~char_array_to_int->proc~char_to_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function char_to_int ( str ) result ( i ) character ( len =* ), intent ( in ) :: str integer :: i read ( str , * ) i end function char_to_int","tags":"","loc":"proc/char_to_int.html"},{"title":"string_to_int – AoC-2023","text":"private pure elemental function string_to_int(me) result(i) Basic string to integer routine Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer Called by proc~~string_to_int~~CalledByGraph proc~string_to_int aoc_utilities::string%string_to_int interface~int aoc_utilities::int interface~int->proc~string_to_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental function string_to_int ( me ) result ( i ) class ( string ), intent ( in ) :: me integer :: i i = int ( me % str ) end function string_to_int","tags":"","loc":"proc/string_to_int.html"},{"title":"string_to_int_64 – AoC-2023","text":"private pure elemental function string_to_int_64(me) result(i) Basic string to integer routine Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer(kind=ip) Called by proc~~string_to_int_64~~CalledByGraph proc~string_to_int_64 aoc_utilities::string%string_to_int_64 program~problem_24 problem_24 program~problem_24->proc~string_to_int_64 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental function string_to_int_64 ( me ) result ( i ) class ( string ), intent ( in ) :: me integer ( ip ) :: i i = int ( me % str , ip ) end function string_to_int_64","tags":"","loc":"proc/string_to_int_64.html"},{"title":"char_to_int64 – AoC-2023","text":"private pure function char_to_int64(str, kind) result(i) Basic string to integer(ip) routine.\nHacky hack just so we can overload as int() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: kind Return Value integer(kind=ip) Called by proc~~char_to_int64~~CalledByGraph proc~char_to_int64 aoc_utilities::char_to_int64 interface~int aoc_utilities::int interface~int->proc~char_to_int64 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function char_to_int64 ( str , kind ) result ( i ) character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: kind integer ( ip ) :: i if ( kind /= ip ) error stop 'error' read ( str , * ) i end function char_to_int64","tags":"","loc":"proc/char_to_int64.html"},{"title":"char_array_to_int – AoC-2023","text":"private pure function char_array_to_int(str_array) result(i) Character array to integer routine Arguments Type Intent Optional Attributes Name character(len=1), intent(in), dimension(:) :: str_array example ['1','3'] --> 13 Return Value integer Calls proc~~char_array_to_int~~CallsGraph proc~char_array_to_int aoc_utilities::char_array_to_int proc~char_to_int aoc_utilities::char_to_int proc~char_array_to_int->proc~char_to_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~char_array_to_int~~CalledByGraph proc~char_array_to_int aoc_utilities::char_array_to_int interface~int aoc_utilities::int interface~int->proc~char_array_to_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function char_array_to_int ( str_array ) result ( i ) character ( len = 1 ), dimension (:), intent ( in ) :: str_array !! example ['1','3'] --> 13 integer :: i character ( len = :), allocatable :: str integer :: k str = '' do k = 1 , size ( str_array ) str = str // str_array ( k ) end do i = char_to_int ( str ) end function char_array_to_int","tags":"","loc":"proc/char_array_to_int.html"},{"title":"int_array_to_char_array – AoC-2023","text":"public pure function int_array_to_char_array(iarray) result(carray) integer array to Character array Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: iarray Return Value character(len=1), dimension(:,:), allocatable Source Code pure function int_array_to_char_array ( iarray ) result ( carray ) integer , dimension (:,:), intent ( in ) :: iarray character ( len = 1 ), dimension (:,:), allocatable :: carray integer :: i , j allocate ( carray ( size ( iarray , 1 ), size ( iarray , 2 ))) do i = 1 , size ( iarray , 1 ) do j = 1 , size ( iarray , 2 ) write ( carray ( i , j ), '(I1)' ) iarray ( i , j ) end do end do end function int_array_to_char_array","tags":"","loc":"proc/int_array_to_char_array.html"},{"title":"read_file_to_char_array – AoC-2023","text":"public  function read_file_to_char_array(filename, border) result(array) Read a file into a 2d character array. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=1), intent(in), optional :: border if true, extra border is added with this char Return Value character(len=1), dimension(:,:), allocatable Calls proc~~read_file_to_char_array~~CallsGraph proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_file_to_char_array~~CalledByGraph proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~go~5 problem_23::go proc~go~5->proc~read_file_to_char_array proc~go~7 problem_11::go proc~go~7->proc~read_file_to_char_array program~problem_10 problem_10 program~problem_10->proc~read_file_to_char_array program~problem_16 problem_16 program~problem_16->proc~read_file_to_char_array program~problem_21 problem_21 program~problem_21->proc~read_file_to_char_array program~problem_3 problem_3 program~problem_3->proc~read_file_to_char_array program~problem_11 problem_11 program~problem_11->proc~go~7 program~problem_23 problem_23 program~problem_23->proc~go~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function read_file_to_char_array ( filename , border ) result ( array ) character ( len =* ), intent ( in ) :: filename character ( len = 1 ), intent ( in ), optional :: border !! if true, extra border is added with this char character ( len = 1 ), dimension (:,:), allocatable :: array integer :: i , j , iunit , n_lines , n_cols character ( len = :), allocatable :: line open ( newunit = iunit , file = filename , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) line = read_line ( iunit ); n_cols = len ( line ) rewind ( iunit ) if ( present ( border )) then allocate ( array ( 0 : n_lines + 1 , 0 : n_cols + 1 )) ! padding with border array = border else allocate ( array ( n_lines , n_cols )) end if do i = 1 , n_lines line = read_line ( iunit ) do j = 1 , n_cols array ( i , j ) = line ( j : j ) end do end do close ( iunit ) end function read_file_to_char_array","tags":"","loc":"proc/read_file_to_char_array.html"},{"title":"read_file_to_int_array – AoC-2023","text":"public  function read_file_to_int_array(filename) result(array) Read a file into a 2d character array. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer, dimension(:,:), allocatable Calls proc~~read_file_to_int_array~~CallsGraph proc~read_file_to_int_array aoc_utilities::read_file_to_int_array proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_int_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_int_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_file_to_int_array~~CalledByGraph proc~read_file_to_int_array aoc_utilities::read_file_to_int_array program~problem_17 problem_17 program~problem_17->proc~read_file_to_int_array program~problem_17~2 problem_17 program~problem_17~2->proc~read_file_to_int_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function read_file_to_int_array ( filename ) result ( array ) character ( len =* ), intent ( in ) :: filename integer , dimension (:,:), allocatable :: array integer :: i , iunit , n_lines , n_cols character ( len = :), allocatable :: line open ( newunit = iunit , file = filename , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) line = read_line ( iunit ) n_cols = len ( line ) rewind ( iunit ) allocate ( array ( n_lines , n_cols )) do i = 1 , n_lines line = read_line ( iunit ) read ( line , '(*(I1))' ) array ( i , 1 : n_cols ) end do close ( iunit ) end function read_file_to_int_array","tags":"","loc":"proc/read_file_to_int_array.html"},{"title":"read_file_to_integer_array – AoC-2023","text":"public  function read_file_to_integer_array(filename) result(iarray) Read a file into an integer array (one element per line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer, dimension(:), allocatable Calls proc~~read_file_to_integer_array~~CallsGraph proc~read_file_to_integer_array aoc_utilities::read_file_to_integer_array proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_integer_array->proc~number_of_lines_in_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function read_file_to_integer_array ( filename ) result ( iarray ) character ( len =* ), intent ( in ) :: filename integer , dimension (:), allocatable :: iarray integer :: i , iunit , n_lines , istat open ( newunit = iunit , file = filename , iostat = istat ) if ( istat /= 0 ) error stop ' error reading file' n_lines = number_of_lines_in_file ( iunit ) allocate ( iarray ( n_lines )) do i = 1 , n_lines read ( iunit , '(I10)' ) iarray ( i ) end do close ( iunit ) end function read_file_to_integer_array","tags":"","loc":"proc/read_file_to_integer_array.html"},{"title":"read_file_to_integer64_array – AoC-2023","text":"public  function read_file_to_integer64_array(filename) result(iarray) Read a file into an ip integer array (one element per line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer(kind=ip), dimension(:), allocatable Calls proc~~read_file_to_integer64_array~~CallsGraph proc~read_file_to_integer64_array aoc_utilities::read_file_to_integer64_array proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_integer64_array->proc~number_of_lines_in_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function read_file_to_integer64_array ( filename ) result ( iarray ) character ( len =* ), intent ( in ) :: filename integer ( ip ), dimension (:), allocatable :: iarray integer :: i , iunit , n_lines , istat open ( newunit = iunit , file = filename , iostat = istat ) if ( istat /= 0 ) error stop ' error reading file' n_lines = number_of_lines_in_file ( iunit ) allocate ( iarray ( n_lines )) do i = 1 , n_lines read ( iunit , * ) iarray ( i ) end do close ( iunit ) end function read_file_to_integer64_array","tags":"","loc":"proc/read_file_to_integer64_array.html"},{"title":"number_of_lines_in_file – AoC-2023","text":"public  function number_of_lines_in_file(iunit) result(n_lines) Returns the number of lines in a file (assumed to be open) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit the file unit number\n(assumed to be open) Return Value integer the number of lines in the file Called by proc~~number_of_lines_in_file~~CalledByGraph proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~go~3 problem_18::go proc~go~3->proc~number_of_lines_in_file proc~go~6 problem_12::go proc~go~6->proc~number_of_lines_in_file proc~initialize problem_22::initialize proc~initialize->proc~number_of_lines_in_file proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_file_to_int_array aoc_utilities::read_file_to_int_array proc~read_file_to_int_array->proc~number_of_lines_in_file proc~read_file_to_integer64_array aoc_utilities::read_file_to_integer64_array proc~read_file_to_integer64_array->proc~number_of_lines_in_file proc~read_file_to_integer_array aoc_utilities::read_file_to_integer_array proc~read_file_to_integer_array->proc~number_of_lines_in_file program~problem_1 problem_1 program~problem_1->proc~number_of_lines_in_file program~problem_12b problem_12b program~problem_12b->proc~number_of_lines_in_file program~problem_13 problem_13 program~problem_13->proc~number_of_lines_in_file program~problem_19 problem_19 program~problem_19->proc~number_of_lines_in_file program~problem_19b problem_19b program~problem_19b->proc~number_of_lines_in_file program~problem_2 problem_2 program~problem_2->proc~number_of_lines_in_file program~problem_24 problem_24 program~problem_24->proc~number_of_lines_in_file program~problem_25 problem_25 program~problem_25->proc~number_of_lines_in_file program~problem_4 problem_4 program~problem_4->proc~number_of_lines_in_file program~problem_5 problem_5 program~problem_5->proc~number_of_lines_in_file program~problem_7 problem_7 program~problem_7->proc~number_of_lines_in_file program~problem_8 problem_8 program~problem_8->proc~number_of_lines_in_file program~problem_9 problem_9 program~problem_9->proc~number_of_lines_in_file proc~go~5 problem_23::go proc~go~5->proc~read_file_to_char_array proc~go~7 problem_11::go proc~go~7->proc~read_file_to_char_array program~problem_10 problem_10 program~problem_10->proc~read_file_to_char_array program~problem_12 problem_12 program~problem_12->proc~go~6 program~problem_16 problem_16 program~problem_16->proc~read_file_to_char_array program~problem_17 problem_17 program~problem_17->proc~read_file_to_int_array program~problem_17~2 problem_17 program~problem_17~2->proc~read_file_to_int_array program~problem_18 problem_18 program~problem_18->proc~go~3 program~problem_21 problem_21 program~problem_21->proc~read_file_to_char_array program~problem_22 problem_22 program~problem_22->proc~initialize program~problem_3 problem_3 program~problem_3->proc~read_file_to_char_array program~problem_11 problem_11 program~problem_11->proc~go~7 program~problem_23 problem_23 program~problem_23->proc~go~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function number_of_lines_in_file ( iunit ) result ( n_lines ) integer , intent ( in ) :: iunit !! the file unit number !! (assumed to be open) integer :: n_lines !! the number of lines in the file character ( len = 1 ) :: tmp integer :: istat rewind ( iunit ) n_lines = 0 do read ( iunit , fmt = '(A1)' , iostat = istat ) tmp if ( is_iostat_end ( istat )) exit n_lines = n_lines + 1 end do rewind ( iunit ) end function number_of_lines_in_file","tags":"","loc":"proc/number_of_lines_in_file.html"},{"title":"split2 – AoC-2023","text":"private pure function split2(s, token) result(vals) Split a string , given a token. Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: s character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable Calls proc~~split2~~CallsGraph proc~split2 aoc_utilities::split2 proc~split1 aoc_utilities::split1 proc~split2->proc~split1 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~split2~~CalledByGraph proc~split2 aoc_utilities::split2 interface~split aoc_utilities::split interface~split->proc~split2 proc~go~3 problem_18::go proc~go~3->interface~split proc~go~6 problem_12::go proc~go~6->interface~split proc~initialize problem_22::initialize proc~initialize->interface~split proc~parse_nums64 aoc_utilities::parse_nums64 proc~parse_nums64->interface~split proc~parse_rule problem_19::parse_rule proc~parse_rule->interface~split proc~parse_rule~2 problem_19b::parse_rule proc~parse_rule~2->interface~split program~problem_12b problem_12b program~problem_12b->interface~split program~problem_15 problem_15 program~problem_15->interface~split program~problem_19 problem_19 program~problem_19->interface~split program~problem_19->proc~parse_rule program~problem_19b problem_19b program~problem_19b->interface~split program~problem_19b->proc~parse_rule~2 program~problem_2 problem_2 program~problem_2->interface~split program~problem_24 problem_24 program~problem_24->interface~split program~problem_25 problem_25 program~problem_25->interface~split program~problem_4 problem_4 program~problem_4->interface~split program~problem_7 problem_7 program~problem_7->interface~split interface~parse aoc_utilities::parse interface~parse->proc~parse_nums64 program~problem_12 problem_12 program~problem_12->proc~go~6 program~problem_18 problem_18 program~problem_18->proc~go~3 program~problem_22 problem_22 program~problem_22->proc~initialize program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function split2 ( s , token ) result ( vals ) implicit none type ( string ), intent ( in ) :: s character ( len =* ), intent ( in ) :: token type ( string ), dimension (:), allocatable :: vals if ( allocated ( s % str )) then vals = split1 ( s % str , token ) else error stop 'error: string not allocated' end if end function split2","tags":"","loc":"proc/split2.html"},{"title":"split1 – AoC-2023","text":"private pure function split1(str, token) result(vals) Split a character string using a token.\n  This routine is inspired by the Python split function. Example character ( len = :), allocatable :: s type ( string ), dimension (:), allocatable :: vals s = '1,2,3,4,5' call split ( s , ',' , vals ) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable Calls proc~~split1~~CallsGraph proc~split1 aoc_utilities::split1 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~split1~~CalledByGraph proc~split1 aoc_utilities::split1 interface~split aoc_utilities::split interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~split2->proc~split1 proc~go~3 problem_18::go proc~go~3->interface~split proc~go~6 problem_12::go proc~go~6->interface~split proc~initialize problem_22::initialize proc~initialize->interface~split proc~parse_nums64 aoc_utilities::parse_nums64 proc~parse_nums64->interface~split proc~parse_rule problem_19::parse_rule proc~parse_rule->interface~split proc~parse_rule~2 problem_19b::parse_rule proc~parse_rule~2->interface~split program~problem_12b problem_12b program~problem_12b->interface~split program~problem_15 problem_15 program~problem_15->interface~split program~problem_19 problem_19 program~problem_19->interface~split program~problem_19->proc~parse_rule program~problem_19b problem_19b program~problem_19b->interface~split program~problem_19b->proc~parse_rule~2 program~problem_2 problem_2 program~problem_2->interface~split program~problem_24 problem_24 program~problem_24->interface~split program~problem_25 problem_25 program~problem_25->interface~split program~problem_4 problem_4 program~problem_4->interface~split program~problem_7 problem_7 program~problem_7->interface~split interface~parse aoc_utilities::parse interface~parse->proc~parse_nums64 program~problem_12 problem_12 program~problem_12->proc~go~6 program~problem_18 problem_18 program~problem_18->proc~go~3 program~problem_22 problem_22 program~problem_22->proc~initialize program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function split1 ( str , token ) result ( vals ) implicit none character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ) :: token type ( string ), dimension (:), allocatable :: vals integer :: i !! counter integer :: len_str !! significant length of `str` integer :: len_token !! length of the token integer :: n_tokens !! number of tokens integer :: i1 !! index integer :: i2 !! index integer :: j !! counters integer , dimension (:), allocatable :: itokens !! start indices of the !! token locations in `str` len_token = len ( token ) ! length of the token n_tokens = 0 ! initialize the token counter j = 0 ! index to start looking for the next token ! first, count the number of times the token ! appears in the string, and get the token indices. ! ! Examples: !  ',         '    --> 1 !  '1234,67,90'    --> 5,8 !  '123,      '    --> 4 ! length of the string if ( token == ' ' ) then ! in this case, we can't ignore trailing space len_str = len ( str ) else ! safe to ignore trailing space when looking for tokens len_str = len_trim ( str ) end if j = 1 n_tokens = 0 do if ( j > len_str ) exit ! end of string, finished i = index ( str ( j :), token ) ! index of next token in remaining string if ( i <= 0 ) exit ! no more tokens found call expand_vector ( itokens , n_tokens , i + j - 1 ) ! save the token location j = j + i + ( len_token - 1 ) end do call expand_vector ( itokens , n_tokens , finished = . true .) ! resize the vector allocate ( vals ( n_tokens + 1 )) if ( n_tokens > 0 ) then len_str = len ( str ) i1 = 1 i2 = itokens ( 1 ) - 1 if ( i2 >= i1 ) then vals ( 1 )% str = str ( i1 : i2 ) else vals ( 1 )% str = '' !the first character is a token end if !      1 2 3 !    'a,b,c,d' do i = 2 , n_tokens i1 = itokens ( i - 1 ) + len_token i2 = itokens ( i ) - 1 if ( i2 >= i1 ) then vals ( i )% str = str ( i1 : i2 ) else vals ( i )% str = '' !empty element (e.g., 'abc,,def') end if end do i1 = itokens ( n_tokens ) + len_token i2 = len_str if ( itokens ( n_tokens ) + len_token <= len_str ) then vals ( n_tokens + 1 )% str = str ( i1 : i2 ) else vals ( n_tokens + 1 )% str = '' !the last character was a token end if else !no tokens present, so just return the original string: vals ( 1 )% str = str end if end function split1","tags":"","loc":"proc/split1.html"},{"title":"read_line – AoC-2023","text":"public  function read_line(iunit, status_ok) result(line) Reads the next line from a file. Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit logical, intent(out), optional :: status_ok true if no problems Return Value character(len=:), allocatable Called by proc~~read_line~~CalledByGraph proc~read_line aoc_utilities::read_line proc~go~3 problem_18::go proc~go~3->proc~read_line proc~go~6 problem_12::go proc~go~6->proc~read_line proc~initialize problem_22::initialize proc~initialize->proc~read_line proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~read_file_to_char_array->proc~read_line proc~read_file_to_int_array aoc_utilities::read_file_to_int_array proc~read_file_to_int_array->proc~read_line program~problem_1 problem_1 program~problem_1->proc~read_line program~problem_12b problem_12b program~problem_12b->proc~read_line program~problem_13 problem_13 program~problem_13->proc~read_line program~problem_15 problem_15 program~problem_15->proc~read_line program~problem_19 problem_19 program~problem_19->proc~read_line program~problem_19b problem_19b program~problem_19b->proc~read_line program~problem_2 problem_2 program~problem_2->proc~read_line program~problem_24 problem_24 program~problem_24->proc~read_line program~problem_25 problem_25 program~problem_25->proc~read_line program~problem_4 problem_4 program~problem_4->proc~read_line program~problem_5 problem_5 program~problem_5->proc~read_line program~problem_7 problem_7 program~problem_7->proc~read_line program~problem_8 problem_8 program~problem_8->proc~read_line program~problem_9 problem_9 program~problem_9->proc~read_line proc~go~5 problem_23::go proc~go~5->proc~read_file_to_char_array proc~go~7 problem_11::go proc~go~7->proc~read_file_to_char_array program~problem_10 problem_10 program~problem_10->proc~read_file_to_char_array program~problem_12 problem_12 program~problem_12->proc~go~6 program~problem_16 problem_16 program~problem_16->proc~read_file_to_char_array program~problem_17 problem_17 program~problem_17->proc~read_file_to_int_array program~problem_17~2 problem_17 program~problem_17~2->proc~read_file_to_int_array program~problem_18 problem_18 program~problem_18->proc~go~3 program~problem_21 problem_21 program~problem_21->proc~read_file_to_char_array program~problem_22 problem_22 program~problem_22->proc~initialize program~problem_3 problem_3 program~problem_3->proc~read_file_to_char_array program~problem_11 problem_11 program~problem_11->proc~go~7 program~problem_23 problem_23 program~problem_23->proc~go~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function read_line ( iunit , status_ok ) result ( line ) integer , intent ( in ) :: iunit character ( len = :), allocatable :: line logical , intent ( out ), optional :: status_ok !! true if no problems integer :: nread !! character count specifier for read statement integer :: istat !! file read io status flag character ( len = chunk_size ) :: buffer !! the file read buffer nread = 0 buffer = '' line = '' if ( present ( status_ok )) status_ok = . true . do ! read in the next block of text from the line: read ( iunit , fmt = '(A)' , advance = 'NO' , size = nread , iostat = istat ) buffer if ( IS_IOSTAT_END ( istat ) . or . IS_IOSTAT_EOR ( istat )) then ! add the last block of text before the end of record if ( nread > 0 ) line = line // buffer ( 1 : nread ) exit else if ( istat == 0 ) then ! all the characters were read line = line // buffer ! add this block of text to the string else ! some kind of error if ( present ( status_ok )) then status_ok = . false . exit else error stop 'Read error' end if end if end do end function read_line","tags":"","loc":"proc/read_line.html"},{"title":"unique32 – AoC-2023","text":"private  function unique32(vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec Return Value integer, dimension(:), allocatable Calls proc~~unique32~~CallsGraph proc~unique32 aoc_utilities::unique32 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap~2 aoc_utilities::swap proc~sort_ascending->interface~swap~2 proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap~2->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap~2->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap~2->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~unique32~~CalledByGraph proc~unique32 aoc_utilities::unique32 interface~unique~2 aoc_utilities::unique interface~unique~2->proc~unique32 proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->interface~unique~2 proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->interface~unique~2 proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_pieces_above->interface~unique~2 proc~get_pieces_below->interface~unique~2 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique~2 program~problem_25 problem_25 program~problem_25->interface~unique~2 proc~beats problem_7::beats proc~beats->proc~hand_type proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_22->proc~get_pieces_above program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down program~problem_7 problem_7 program~problem_7->proc~beats proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function unique32 ( vec ) result ( vec_unique ) integer , dimension (:), intent ( in ) :: vec integer , dimension (:), allocatable :: vec_unique integer :: i , num logical , dimension ( size ( vec )) :: mask mask = . false . do i = 1 , size ( vec ) !count the number of occurrences of this element: num = count ( vec ( i ) == vec ) if ( num == 1 ) then !there is only one, flag it: mask ( i ) = . true . else !flag this value only if it hasn't already been flagged: if (. not . any ( vec ( i ) == vec . and . mask ) ) mask ( i ) = . true . end if end do !return only flagged elements: allocate ( vec_unique ( count ( mask )) ) vec_unique = pack ( vec , mask ) ! also sort it: call sort ( vec_unique ) end function unique32","tags":"","loc":"proc/unique32.html"},{"title":"unique64 – AoC-2023","text":"private  function unique64(vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: vec Return Value integer(kind=ip), dimension(:), allocatable Calls proc~~unique64~~CallsGraph proc~unique64 aoc_utilities::unique64 interface~sort aoc_utilities::sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap~2 aoc_utilities::swap proc~sort_ascending->interface~swap~2 proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap~2->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap~2->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap~2->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~unique64~~CalledByGraph proc~unique64 aoc_utilities::unique64 interface~unique~2 aoc_utilities::unique interface~unique~2->proc~unique64 proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->interface~unique~2 proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->interface~unique~2 proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_pieces_above->interface~unique~2 proc~get_pieces_below->interface~unique~2 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique~2 program~problem_25 problem_25 program~problem_25->interface~unique~2 proc~beats problem_7::beats proc~beats->proc~hand_type proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_22->proc~get_pieces_above program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down program~problem_7 problem_7 program~problem_7->proc~beats proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function unique64 ( vec ) result ( vec_unique ) integer ( ip ), dimension (:), intent ( in ) :: vec integer ( ip ), dimension (:), allocatable :: vec_unique integer ( ip ) :: i , num logical , dimension ( size ( vec )) :: mask mask = . false . do i = 1 , size ( vec ) !count the number of occurrences of this element: num = count ( vec ( i ) == vec ) if ( num == 1 ) then !there is only one, flag it: mask ( i ) = . true . else !flag this value only if it hasn't already been flagged: if (. not . any ( vec ( i ) == vec . and . mask ) ) mask ( i ) = . true . end if end do !return only flagged elements: allocate ( vec_unique ( count ( mask )) ) vec_unique = pack ( vec , mask ) ! also sort it: call sort ( vec_unique ) end function unique64","tags":"","loc":"proc/unique64.html"},{"title":"parse_ints – AoC-2023","text":"public  function parse_ints(line) result(ints) parse positive ints from a string that also includes text Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer, dimension(:), allocatable Called by proc~~parse_ints~~CalledByGraph proc~parse_ints aoc_utilities::parse_ints proc~go~6 problem_12::go proc~go~6->proc~parse_ints program~problem_12b problem_12b program~problem_12b->proc~parse_ints program~problem_4 problem_4 program~problem_4->proc~parse_ints program~problem_12 problem_12 program~problem_12->proc~go~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function parse_ints ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer , dimension (:), allocatable :: ints ! array of integers integer :: i , j , n integer :: istart character ( len =* ), parameter :: tokens = '0123456789' n = len ( line ) istart = 0 allocate ( ints ( 0 )) do i = 1 , n if ( index ( tokens , line ( i : i )) > 0 ) then if ( istart == 0 ) istart = i else if ( istart /= 0 ) ints = [ ints , int ( line ( istart : i - 1 ))] ! get previous int istart = 0 end if end do if ( istart /= 0 ) ints = [ ints , int ( line ( istart : n ))] ! get last int end function parse_ints","tags":"","loc":"proc/parse_ints.html"},{"title":"parse_ints64 – AoC-2023","text":"public  function parse_ints64(line) result(ints) Parse positive ints from a string that also includes text Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=ip), dimension(:), allocatable Called by proc~~parse_ints64~~CalledByGraph proc~parse_ints64 aoc_utilities::parse_ints64 program~problem_5 problem_5 program~problem_5->proc~parse_ints64 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function parse_ints64 ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer ( ip ), dimension (:), allocatable :: ints ! array of integers integer ( ip ) :: i , j , n integer ( ip ) :: istart character ( len =* ), parameter :: tokens = '0123456789' n = len ( line ) istart = 0 allocate ( ints ( 0 )) do i = 1 , n if ( index ( tokens , line ( i : i )) > 0 ) then if ( istart == 0 ) istart = i else if ( istart /= 0 ) ints = [ ints , int ( line ( istart : i - 1 ), kind = ip )] ! get previous int istart = 0 end if end do if ( istart /= 0 ) ints = [ ints , int ( line ( istart : n ), kind = ip )] ! get last int end function parse_ints64","tags":"","loc":"proc/parse_ints64.html"},{"title":"parse_nums64 – AoC-2023","text":"private  function parse_nums64(line) result(ints) parse space-deliminated ip sequence (positive or negative) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=ip), dimension(:), allocatable Calls proc~~parse_nums64~~CallsGraph proc~parse_nums64 aoc_utilities::parse_nums64 interface~split aoc_utilities::split proc~parse_nums64->interface~split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~parse_nums64~~CalledByGraph proc~parse_nums64 aoc_utilities::parse_nums64 interface~parse aoc_utilities::parse interface~parse->proc~parse_nums64 program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function parse_nums64 ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer ( ip ), dimension (:), allocatable :: ints ! array of integers ints = int ( split ( line , ' ' )) end function parse_nums64","tags":"","loc":"proc/parse_nums64.html"},{"title":"startswith_cc – AoC-2023","text":"private pure function startswith_cc(str, substring) starts with function for strings Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical Called by proc~~startswith_cc~~CalledByGraph proc~startswith_cc aoc_utilities::startswith_cc interface~startswith aoc_utilities::startswith interface~startswith->proc~startswith_cc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith program~problem_5 problem_5 program~problem_5->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function startswith_cc ( str , substring ) character ( len =* ), intent ( in ) :: str , substring startswith_cc = index ( str , substring ) == 1 end function startswith_cc","tags":"","loc":"proc/startswith_cc.html"},{"title":"startswith_ss – AoC-2023","text":"private pure function startswith_ss(str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str type( string ), intent(in) :: substring Return Value logical Calls proc~~startswith_ss~~CallsGraph proc~startswith_ss aoc_utilities::startswith_ss interface~startswith aoc_utilities::startswith proc~startswith_ss->interface~startswith interface~startswith->proc~startswith_ss proc~startswith_cc aoc_utilities::startswith_cc interface~startswith->proc~startswith_cc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~startswith_ss~~CalledByGraph proc~startswith_ss aoc_utilities::startswith_ss interface~startswith aoc_utilities::startswith proc~startswith_ss->interface~startswith interface~startswith->proc~startswith_ss proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith program~problem_5 problem_5 program~problem_5->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function startswith_ss ( str , substring ) type ( string ), intent ( in ) :: str , substring startswith_ss = startswith ( str % str , substring % str ) end function startswith_ss","tags":"","loc":"proc/startswith_ss.html"},{"title":"startswith_sc – AoC-2023","text":"private pure function startswith_sc(str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical Calls proc~~startswith_sc~~CallsGraph proc~startswith_sc aoc_utilities::startswith_sc interface~startswith aoc_utilities::startswith proc~startswith_sc->interface~startswith interface~startswith->proc~startswith_sc proc~startswith_cc aoc_utilities::startswith_cc interface~startswith->proc~startswith_cc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_cs->interface~startswith proc~startswith_ss->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~startswith_sc~~CalledByGraph proc~startswith_sc aoc_utilities::startswith_sc interface~startswith aoc_utilities::startswith proc~startswith_sc->interface~startswith interface~startswith->proc~startswith_sc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_cs->interface~startswith proc~startswith_ss->interface~startswith program~problem_5 problem_5 program~problem_5->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function startswith_sc ( str , substring ) type ( string ), intent ( in ) :: str character ( len =* ), intent ( in ) :: substring startswith_sc = startswith ( str % str , substring ) end function startswith_sc","tags":"","loc":"proc/startswith_sc.html"},{"title":"startswith_cs – AoC-2023","text":"private pure function startswith_cs(str, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str type( string ), intent(in) :: substring Return Value logical Calls proc~~startswith_cs~~CallsGraph proc~startswith_cs aoc_utilities::startswith_cs interface~startswith aoc_utilities::startswith proc~startswith_cs->interface~startswith interface~startswith->proc~startswith_cs proc~startswith_cc aoc_utilities::startswith_cc interface~startswith->proc~startswith_cc proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~startswith_cs~~CalledByGraph proc~startswith_cs aoc_utilities::startswith_cs interface~startswith aoc_utilities::startswith proc~startswith_cs->interface~startswith interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith program~problem_5 problem_5 program~problem_5->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function startswith_cs ( str , substring ) character ( len =* ), intent ( in ) :: str type ( string ), intent ( in ) :: substring startswith_cs = startswith ( str , substring % str ) end function startswith_cs","tags":"","loc":"proc/startswith_cs.html"},{"title":"is_number – AoC-2023","text":"public  function is_number(c) returns true if the character is a number from 0 to 9. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical Called by proc~~is_number~~CalledByGraph proc~is_number aoc_utilities::is_number proc~check problem_3::check proc~check->proc~is_number proc~get_number problem_3::get_number proc~check->proc~get_number proc~is_not_number aoc_utilities::is_not_number proc~is_not_number->proc~is_number proc~is_symbol problem_3::is_symbol proc~is_symbol->proc~is_not_number program~problem_3 problem_3 program~problem_3->proc~check program~problem_3->proc~is_not_number program~problem_3->proc~is_symbol program~problem_3->proc~get_number proc~get_number->proc~is_symbol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function is_number ( c ) character ( len = 1 ), intent ( in ) :: c is_number = c >= '0' . and . c <= '9' end function is_number","tags":"","loc":"proc/is_number.html"},{"title":"is_not_number – AoC-2023","text":"public  function is_not_number(c) returns true if the character is not a number. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical Calls proc~~is_not_number~~CallsGraph proc~is_not_number aoc_utilities::is_not_number proc~is_number aoc_utilities::is_number proc~is_not_number->proc~is_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~is_not_number~~CalledByGraph proc~is_not_number aoc_utilities::is_not_number proc~is_symbol problem_3::is_symbol proc~is_symbol->proc~is_not_number program~problem_3 problem_3 program~problem_3->proc~is_not_number program~problem_3->proc~is_symbol proc~get_number problem_3::get_number program~problem_3->proc~get_number proc~check problem_3::check program~problem_3->proc~check proc~get_number->proc~is_symbol proc~check->proc~get_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function is_not_number ( c ) character ( len = 1 ), intent ( in ) :: c is_not_number = . not . is_number ( c ) end function is_not_number","tags":"","loc":"proc/is_not_number.html"},{"title":"str_to_array – AoC-2023","text":"public  function str_to_array(s) result(a) convert the character string to an array of characters Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value character(len=1), dimension(len(s)) Called by proc~~str_to_array~~CalledByGraph proc~str_to_array aoc_utilities::str_to_array program~problem_7 problem_7 program~problem_7->proc~str_to_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function str_to_array ( s ) result ( a ) character ( len =* ), intent ( in ) :: s character ( len = 1 ), dimension ( len ( s )) :: a integer :: i do i = 1 , len ( s ) ! transfer a ( i ) = s ( i : i ) end do end function str_to_array","tags":"","loc":"proc/str_to_array.html"},{"title":"lcm – AoC-2023","text":"public pure function lcm(i, j) LCM. based on code from NCAR Command Language Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value integer(kind=ip) Called by proc~~lcm~~CalledByGraph proc~lcm aoc_utilities::lcm program~problem_8 problem_8 program~problem_8->proc~lcm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer ( ip ) function lcm ( i , j ) integer ( ip ), intent ( in ) :: i , j integer ( ip ) :: rem , m , n m = abs ( i ) n = abs ( j ) lcm = 0 if ( m <= 0 . or . n <= 0 ) return do rem = mod ( m , n ) if ( rem <= 0 ) exit m = n n = rem end do lcm = abs ( i * j / n ) end function lcm","tags":"","loc":"proc/lcm.html"},{"title":"reverse – AoC-2023","text":"public pure function reverse(ivals) result(ireverse) Reverse an ip vector Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals Return Value integer(kind=ip), dimension(size(ivals)) Called by proc~~reverse~~CalledByGraph proc~reverse aoc_utilities::reverse program~problem_9 problem_9 program~problem_9->proc~reverse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function reverse ( ivals ) result ( ireverse ) integer ( ip ), dimension (:), intent ( in ) :: ivals integer ( ip ), dimension ( size ( ivals )) :: ireverse integer :: i ireverse = [( ivals ( i ), i = size ( ivals ), 1 , - 1 )] end function reverse","tags":"","loc":"proc/reverse.html"},{"title":"diff – AoC-2023","text":"public pure function diff(ivals) result(idiff) Difference ip vector Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals Return Value integer(kind=ip), dimension(:), allocatable Called by proc~~diff~2~~CalledByGraph proc~diff~2 aoc_utilities::diff proc~extrapolate problem_9::extrapolate proc~extrapolate->proc~diff~2 program~problem_9 problem_9 program~problem_9->proc~extrapolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function diff ( ivals ) result ( idiff ) integer ( ip ), dimension (:), intent ( in ) :: ivals integer ( ip ), dimension (:), allocatable :: idiff integer :: i !! counter idiff = [( ivals ( i + 1 ) - ivals ( i ), i = 1 , size ( ivals ) - 1 )] end function diff","tags":"","loc":"proc/diff~2.html"},{"title":"parea – AoC-2023","text":"public  function parea(x, y, nb) given a sequence of nb points (x(i),y(i)). parea computes\nthe area bounded by the closed polygonal curve which passes\nthrough the points in the order that they are indexed. the\nfinal point of the curve is assumed to be the first point\ngiven. therefore, it need not be listed at the end of x and\ny. the curve is not required to be simple. Original version from the NSWC Library Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (nb) real(kind=wp), intent(in) :: y (nb) integer, intent(in) :: nb Return Value real(kind=wp) Called by proc~~parea~~CalledByGraph proc~parea aoc_utilities::parea proc~go~3 problem_18::go proc~go~3->proc~parea program~problem_18 problem_18 program~problem_18->proc~go~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code real ( wp ) function parea ( x , y , nb ) real ( wp ), intent ( in ) :: x ( nb ), y ( nb ) integer , intent ( in ) :: nb real ( wp ) :: a integer :: n , nm1 , i n = nb if ( x ( 1 ) == x ( n ) . and . y ( 1 ) == y ( n )) n = n - 1 if ( n - 3 < 0 ) then parea = 0.0_wp else if ( n - 3 == 0 ) then parea = 0.5_wp * (( x ( 2 ) - x ( 1 )) * ( y ( 3 ) - y ( 1 )) - ( x ( 3 ) - x ( 1 )) * ( y ( 2 ) - y ( 1 ))) else nm1 = n - 1 a = x ( 1 ) * ( y ( 2 ) - y ( n )) + x ( n ) * ( y ( 1 ) - y ( nm1 )) do i = 2 , nm1 a = a + x ( i ) * ( y ( i + 1 ) - y ( i - 1 )) end do parea = 0.5_wp * a end if end function parea","tags":"","loc":"proc/parea.html"},{"title":"manhatten_distance_64 – AoC-2023","text":"private pure function manhatten_distance_64(x1, y1, x2, y2) Manhattan distance between two ip points. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: x1 integer(kind=ip), intent(in) :: y1 integer(kind=ip), intent(in) :: x2 integer(kind=ip), intent(in) :: y2 Return Value integer(kind=ip) Called by proc~~manhatten_distance_64~~CalledByGraph proc~manhatten_distance_64 aoc_utilities::manhatten_distance_64 interface~manhatten_distance aoc_utilities::manhatten_distance interface~manhatten_distance->proc~manhatten_distance_64 proc~go~7 problem_11::go proc~go~7->interface~manhatten_distance program~problem_11 problem_11 program~problem_11->proc~go~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer ( ip ) function manhatten_distance_64 ( x1 , y1 , x2 , y2 ) integer ( ip ), intent ( in ) :: x1 , y1 , x2 , y2 manhatten_distance_64 = abs ( x1 - x2 ) + abs ( y1 - y2 ) end function manhatten_distance_64","tags":"","loc":"proc/manhatten_distance_64.html"},{"title":"str_to_int_array_with_mapping – AoC-2023","text":"public pure function str_to_int_array_with_mapping(str, ichars, iints) result(array) Convert a string to a numeric array by mapping characters to integers (user-specified) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=1), intent(in), dimension(:) :: ichars characters to process integer, intent(in), dimension(:) :: iints int values of the chars Return Value integer, dimension(:), allocatable Called by proc~~str_to_int_array_with_mapping~~CalledByGraph proc~str_to_int_array_with_mapping aoc_utilities::str_to_int_array_with_mapping proc~go~6 problem_12::go proc~go~6->proc~str_to_int_array_with_mapping program~problem_13 problem_13 program~problem_13->proc~str_to_int_array_with_mapping program~problem_12 problem_12 program~problem_12->proc~go~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function str_to_int_array_with_mapping ( str , ichars , iints ) result ( array ) character ( len =* ), intent ( in ) :: str character ( len = 1 ), dimension (:), intent ( in ) :: ichars !! characters to process integer , dimension (:), intent ( in ) :: iints !! int values of the chars integer , dimension (:), allocatable :: array integer :: i integer , dimension ( 1 ) :: iloc allocate ( array ( len ( str ))) do i = 1 , len ( str ) iloc = findloc ( ichars , str ( i : i )) if ( iloc ( 1 ) > 0 ) then array ( i ) = iints ( iloc ( 1 )) else error stop 'error: could not map character: ' // str ( i : i ) end if end do end function str_to_int_array_with_mapping","tags":"","loc":"proc/str_to_int_array_with_mapping.html"},{"title":"str_to_int64_array_with_mapping – AoC-2023","text":"public pure function str_to_int64_array_with_mapping(str, ichars, iints) result(array) Convert a string to a numeric array by mapping characters to integers (user-specified) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=1), intent(in), dimension(:) :: ichars characters to process integer(kind=ip), intent(in), dimension(:) :: iints int values of the chars Return Value integer(kind=ip), dimension(:), allocatable Called by proc~~str_to_int64_array_with_mapping~~CalledByGraph proc~str_to_int64_array_with_mapping aoc_utilities::str_to_int64_array_with_mapping program~problem_12b problem_12b program~problem_12b->proc~str_to_int64_array_with_mapping Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function str_to_int64_array_with_mapping ( str , ichars , iints ) result ( array ) character ( len =* ), intent ( in ) :: str character ( len = 1 ), dimension (:), intent ( in ) :: ichars !! characters to process integer ( ip ), dimension (:), intent ( in ) :: iints !! int values of the chars integer ( ip ), dimension (:), allocatable :: array integer :: i integer , dimension ( 1 ) :: iloc allocate ( array ( len ( str ))) do i = 1 , len ( str ) iloc = findloc ( ichars , str ( i : i )) if ( iloc ( 1 ) > 0 ) then array ( i ) = iints ( iloc ( 1 )) else error stop 'error: could not map character: ' // str ( i : i ) end if end do end function str_to_int64_array_with_mapping","tags":"","loc":"proc/str_to_int64_array_with_mapping.html"},{"title":"hex2int – AoC-2023","text":"public pure function hex2int(hex) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: hex Return Value integer Called by proc~~hex2int~~CalledByGraph proc~hex2int aoc_utilities::hex2int proc~go~3 problem_18::go proc~go~3->proc~hex2int program~problem_18 problem_18 program~problem_18->proc~go~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer function hex2int ( hex ) character ( len =* ), intent ( in ) :: hex integer :: i , n , ipower ! 70c71 -> 461937 n = len ( hex ) hex2int = 0 !base 16 (0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f) ipower = - 1 do i = n , 1 , - 1 ipower = ipower + 1 associate ( c => hex ( i : i )) if ( c >= 'a' . and . c <= 'f' ) then hex2int = hex2int + ( 10 + iachar ( c ) - iachar ( 'a' )) * ( 16 ** ipower ) else hex2int = hex2int + ( iachar ( c ) - iachar ( '0' )) * ( 16 ** ipower ) end if end associate end do end function hex2int","tags":"","loc":"proc/hex2int.html"},{"title":"cross – AoC-2023","text":"public pure function cross(r, v) result(c) Cross product of two real 3x1 vectors Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r real(kind=wp), intent(in), dimension(3) :: v Return Value real(kind=wp), dimension(3) Source Code pure function cross ( r , v ) result ( c ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r real ( wp ), dimension ( 3 ), intent ( in ) :: v real ( wp ), dimension ( 3 ) :: c c ( 1 ) = r ( 2 ) * v ( 3 ) - v ( 2 ) * r ( 3 ) c ( 2 ) = r ( 3 ) * v ( 1 ) - v ( 3 ) * r ( 1 ) c ( 3 ) = r ( 1 ) * v ( 2 ) - v ( 1 ) * r ( 2 ) end function cross","tags":"","loc":"proc/cross.html"},{"title":"clock_start – AoC-2023","text":"private  subroutine clock_start(me) Start the clock Type Bound clock Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me Called by proc~~clock_start~~CalledByGraph proc~clock_start aoc_utilities::clock%clock_start program~problem_1 problem_1 program~problem_1->proc~clock_start program~problem_10 problem_10 program~problem_10->proc~clock_start program~problem_11 problem_11 program~problem_11->proc~clock_start program~problem_12 problem_12 program~problem_12->proc~clock_start program~problem_12b problem_12b program~problem_12b->proc~clock_start program~problem_13 problem_13 program~problem_13->proc~clock_start program~problem_15 problem_15 program~problem_15->proc~clock_start program~problem_16 problem_16 program~problem_16->proc~clock_start program~problem_17 problem_17 program~problem_17->proc~clock_start program~problem_17~2 problem_17 program~problem_17~2->proc~clock_start program~problem_18 problem_18 program~problem_18->proc~clock_start program~problem_19 problem_19 program~problem_19->proc~clock_start program~problem_19b problem_19b program~problem_19b->proc~clock_start program~problem_2 problem_2 program~problem_2->proc~clock_start program~problem_21 problem_21 program~problem_21->proc~clock_start program~problem_22 problem_22 program~problem_22->proc~clock_start program~problem_23 problem_23 program~problem_23->proc~clock_start program~problem_24 problem_24 program~problem_24->proc~clock_start program~problem_25 problem_25 program~problem_25->proc~clock_start program~problem_3 problem_3 program~problem_3->proc~clock_start program~problem_4 problem_4 program~problem_4->proc~clock_start program~problem_5 problem_5 program~problem_5->proc~clock_start program~problem_6 problem_6 program~problem_6->proc~clock_start program~problem_7 problem_7 program~problem_7->proc~clock_start program~problem_8 problem_8 program~problem_8->proc~clock_start program~problem_9 problem_9 program~problem_9->proc~clock_start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine clock_start ( me ) class ( clock ), intent ( inout ) :: me call system_clock ( me % begin , me % rate ) end subroutine clock_start","tags":"","loc":"proc/clock_start.html"},{"title":"clock_end – AoC-2023","text":"private  subroutine clock_end(me, case_str) Print runtime in milliseconds form the start of the clock. Type Bound clock Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me character(len=*), intent(in) :: case_str description of the case Called by proc~~clock_end~~CalledByGraph proc~clock_end aoc_utilities::clock%clock_end program~problem_1 problem_1 program~problem_1->proc~clock_end program~problem_10 problem_10 program~problem_10->proc~clock_end program~problem_11 problem_11 program~problem_11->proc~clock_end program~problem_12 problem_12 program~problem_12->proc~clock_end program~problem_12b problem_12b program~problem_12b->proc~clock_end program~problem_13 problem_13 program~problem_13->proc~clock_end program~problem_15 problem_15 program~problem_15->proc~clock_end program~problem_16 problem_16 program~problem_16->proc~clock_end program~problem_17 problem_17 program~problem_17->proc~clock_end program~problem_17~2 problem_17 program~problem_17~2->proc~clock_end program~problem_18 problem_18 program~problem_18->proc~clock_end program~problem_19 problem_19 program~problem_19->proc~clock_end program~problem_19b problem_19b program~problem_19b->proc~clock_end program~problem_2 problem_2 program~problem_2->proc~clock_end program~problem_21 problem_21 program~problem_21->proc~clock_end program~problem_22 problem_22 program~problem_22->proc~clock_end program~problem_23 problem_23 program~problem_23->proc~clock_end program~problem_24 problem_24 program~problem_24->proc~clock_end program~problem_25 problem_25 program~problem_25->proc~clock_end program~problem_3 problem_3 program~problem_3->proc~clock_end program~problem_4 problem_4 program~problem_4->proc~clock_end program~problem_5 problem_5 program~problem_5->proc~clock_end program~problem_6 problem_6 program~problem_6->proc~clock_end program~problem_7 problem_7 program~problem_7->proc~clock_end program~problem_8 problem_8 program~problem_8->proc~clock_end program~problem_9 problem_9 program~problem_9->proc~clock_end Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine clock_end ( me , case_str ) class ( clock ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: case_str !! description of the case integer :: itime !! time in integer milliseconds call system_clock ( me % end ) itime = int ( 1000 * ( me % end - me % begin ) / real ( me % rate , wp )) write ( * , '(a,I4,a)' ) trim ( case_str ) // ' runtime: ' , itime , ' ms' write ( * , '(a)' ) '---------------------------' write ( * , * ) '' end subroutine clock_end","tags":"","loc":"proc/clock_end.html"},{"title":"sort_ascending – AoC-2023","text":"private  subroutine sort_ascending(ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec Calls proc~~sort_ascending~~CallsGraph proc~sort_ascending aoc_utilities::sort_ascending interface~swap~2 aoc_utilities::swap proc~sort_ascending->interface~swap~2 proc~swap32 aoc_utilities::swap32 interface~swap~2->proc~swap32 proc~swap64 aoc_utilities::swap64 interface~swap~2->proc~swap64 proc~swap_str aoc_utilities::swap_str interface~swap~2->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sort_ascending~~CalledByGraph proc~sort_ascending aoc_utilities::sort_ascending interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique~2 aoc_utilities::unique interface~unique~2->proc~unique32 interface~unique~2->proc~unique64 proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->interface~unique~2 proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->interface~unique~2 proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_pieces_above->interface~unique~2 proc~get_pieces_below->interface~unique~2 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique~2 program~problem_25 problem_25 program~problem_25->interface~unique~2 proc~beats problem_7::beats proc~beats->proc~hand_type proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_22->proc~get_pieces_above program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down program~problem_7 problem_7 program~problem_7->proc~beats proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine sort_ascending ( ivec ) integer , dimension (:), intent ( inout ) :: ivec integer , parameter :: max_size_for_insertion_sort = 20 !! max size for using insertion sort. call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending","tags":"","loc":"proc/sort_ascending.html"},{"title":"sort_ascending_64 – AoC-2023","text":"private  subroutine sort_ascending_64(ivec) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout), dimension(:) :: ivec Calls proc~~sort_ascending_64~~CallsGraph proc~sort_ascending_64 aoc_utilities::sort_ascending_64 proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sort_ascending_64~~CalledByGraph proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending_64 proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique~2 aoc_utilities::unique interface~unique~2->proc~unique32 interface~unique~2->proc~unique64 proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->interface~unique~2 proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->interface~unique~2 proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_pieces_above->interface~unique~2 proc~get_pieces_below->interface~unique~2 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique~2 program~problem_25 problem_25 program~problem_25->interface~unique~2 proc~beats problem_7::beats proc~beats->proc~hand_type proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_22->proc~get_pieces_above program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down program~problem_7 problem_7 program~problem_7->proc~beats proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine sort_ascending_64 ( ivec ) integer ( ip ), dimension (:), intent ( inout ) :: ivec integer ( ip ), parameter :: max_size_for_insertion_sort = 20 !! max size for using insertion sort. call quicksort ( 1_ip , size ( ivec , kind = ip )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array integer ( ip ), intent ( in ) :: ilow integer ( ip ), intent ( in ) :: ihigh integer ( ip ) :: ipivot !! pivot element integer ( ip ) :: i !! counter integer ( ip ) :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap64 ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer ( ip ), intent ( in ) :: ilow integer ( ip ), intent ( in ) :: ihigh integer ( ip ), intent ( out ) :: ipivot integer ( ip ) :: i , ip call swap64 ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap64 ( ivec ( ip ), ivec ( i )) end if end do call swap64 ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending_64","tags":"","loc":"proc/sort_ascending_64.html"},{"title":"swap32 – AoC-2023","text":"private pure elemental subroutine swap32(i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 Called by proc~~swap32~~CalledByGraph proc~swap32 aoc_utilities::swap32 interface~swap~2 aoc_utilities::swap interface~swap~2->proc~swap32 proc~sort_ascending aoc_utilities::sort_ascending proc~sort_ascending->interface~swap~2 interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique~2 aoc_utilities::unique interface~unique~2->proc~unique32 interface~unique~2->proc~unique64 proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->interface~unique~2 proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->interface~unique~2 proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_pieces_above->interface~unique~2 proc~get_pieces_below->interface~unique~2 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique~2 program~problem_25 problem_25 program~problem_25->interface~unique~2 proc~beats problem_7::beats proc~beats->proc~hand_type proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_22->proc~get_pieces_above program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down program~problem_7 problem_7 program~problem_7->proc~beats proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap32 ( i1 , i2 ) integer , intent ( inout ) :: i1 integer , intent ( inout ) :: i2 integer :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap32","tags":"","loc":"proc/swap32.html"},{"title":"swap64 – AoC-2023","text":"private pure elemental subroutine swap64(i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: i1 integer(kind=ip), intent(inout) :: i2 Called by proc~~swap64~~CalledByGraph proc~swap64 aoc_utilities::swap64 interface~swap~2 aoc_utilities::swap interface~swap~2->proc~swap64 proc~sort_ascending_64 aoc_utilities::sort_ascending_64 proc~sort_ascending_64->proc~swap64 interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending_64 proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending->interface~swap~2 proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique~2 aoc_utilities::unique interface~unique~2->proc~unique32 interface~unique~2->proc~unique64 proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->interface~unique~2 proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->interface~unique~2 proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_pieces_above->interface~unique~2 proc~get_pieces_below->interface~unique~2 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique~2 program~problem_25 problem_25 program~problem_25->interface~unique~2 proc~beats problem_7::beats proc~beats->proc~hand_type proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_22->proc~get_pieces_above program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down program~problem_7 problem_7 program~problem_7->proc~beats proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap64 ( i1 , i2 ) integer ( ip ), intent ( inout ) :: i1 integer ( ip ), intent ( inout ) :: i2 integer ( ip ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap64","tags":"","loc":"proc/swap64.html"},{"title":"swap_str – AoC-2023","text":"private pure elemental subroutine swap_str(i1, i2) Swap two character string values Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: i1 character(len=*), intent(inout) :: i2 Called by proc~~swap_str~~CalledByGraph proc~swap_str aoc_utilities::swap_str interface~swap~2 aoc_utilities::swap interface~swap~2->proc~swap_str proc~sort_ascending aoc_utilities::sort_ascending proc~sort_ascending->interface~swap~2 interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique~2 aoc_utilities::unique interface~unique~2->proc~unique32 interface~unique~2->proc~unique64 proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->interface~unique~2 proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->interface~unique~2 proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_pieces_above->interface~unique~2 proc~get_pieces_below->interface~unique~2 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique~2 program~problem_25 problem_25 program~problem_25->interface~unique~2 proc~beats problem_7::beats proc~beats->proc~hand_type proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_22->proc~get_pieces_above program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down program~problem_7 problem_7 program~problem_7->proc~beats proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap_str ( i1 , i2 ) character ( len =* ), intent ( inout ) :: i1 character ( len =* ), intent ( inout ) :: i2 character ( len = len ( i1 )) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_str","tags":"","loc":"proc/swap_str.html"},{"title":"expand_vector – AoC-2023","text":"private pure subroutine expand_vector(vec, n, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) Called by proc~~expand_vector~~CalledByGraph proc~expand_vector aoc_utilities::expand_vector proc~split1 aoc_utilities::split1 proc~split1->proc~expand_vector interface~split aoc_utilities::split interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~split2->proc~split1 proc~go~3 problem_18::go proc~go~3->interface~split proc~go~6 problem_12::go proc~go~6->interface~split proc~initialize problem_22::initialize proc~initialize->interface~split proc~parse_nums64 aoc_utilities::parse_nums64 proc~parse_nums64->interface~split proc~parse_rule problem_19::parse_rule proc~parse_rule->interface~split proc~parse_rule~2 problem_19b::parse_rule proc~parse_rule~2->interface~split program~problem_12b problem_12b program~problem_12b->interface~split program~problem_15 problem_15 program~problem_15->interface~split program~problem_19 problem_19 program~problem_19->interface~split program~problem_19->proc~parse_rule program~problem_19b problem_19b program~problem_19b->interface~split program~problem_19b->proc~parse_rule~2 program~problem_2 problem_2 program~problem_2->interface~split program~problem_24 problem_24 program~problem_24->interface~split program~problem_25 problem_25 program~problem_25->interface~split program~problem_4 problem_4 program~problem_4->interface~split program~problem_7 problem_7 program~problem_7->interface~split interface~parse aoc_utilities::parse interface~parse->proc~parse_nums64 program~problem_12 problem_12 program~problem_12->proc~go~6 program~problem_18 problem_18 program~problem_18->proc~go~3 program~problem_22 problem_22 program~problem_22->proc~initialize program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine expand_vector ( vec , n , val , finished ) integer , dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) integer , dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector","tags":"","loc":"proc/expand_vector.html"},{"title":"locpt – AoC-2023","text":"public pure subroutine locpt(x0, y0, x, y, n, l, m) given a polygonal line connecting the vertices (x(i),y(i))\n  (i = 1,...,n) taken in this order. it is assumed that the\n  polygonal path is a loop, where (x(n),y(n)) = (x(1),y(1))\n  or there is an arc from (x(n),y(n)) to (x(1),y(1)). (x0,y0) is an arbitrary point and l and m are variables.\n  l and m are assigned the following values: l = - 1 if ( x0 , y0 ) is outside the polygonal path l = 0 if ( x0 , y0 ) lies on the polygonal path l = 1 if ( x0 , y0 ) is inside the polygonal path m = 0 if (x0,y0) is on or outside the path. if (x0,y0)\n  is inside the path then m is the winding number of the\n  path around the point (x0,y0). History Original version from the NSWC Library Modified by J. Williams : 08/04/2012 : refactored to modern Fortran Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: y0 real(kind=wp), intent(in), dimension(n) :: x real(kind=wp), intent(in), dimension(n) :: y integer, intent(in) :: n integer, intent(out) :: l integer, intent(out) :: m Called by proc~~locpt~~CalledByGraph proc~locpt aoc_utilities::locpt program~problem_10 problem_10 program~problem_10->proc~locpt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine locpt ( x0 , y0 , x , y , n , l , m ) implicit none !arguments: integer , intent ( in ) :: n real ( wp ), intent ( in ) :: x0 real ( wp ), intent ( in ) :: y0 real ( wp ), dimension ( n ), intent ( in ) :: x real ( wp ), dimension ( n ), intent ( in ) :: y integer , intent ( out ) :: l integer , intent ( out ) :: m !constants: real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) real ( wp ), parameter :: pi = atan2 ( 0.0_wp , - 1.0_wp ) real ( wp ), parameter :: pi2 = 2.0_wp * pi real ( wp ), parameter :: tol = 4.0_wp * eps * pi !local variables: integer :: i , n0 real ( wp ) :: u , v , theta1 , sum , theta , angle , thetai n0 = n if ( x ( 1 ) == x ( n ) . and . y ( 1 ) == y ( n )) n0 = n - 1 l = - 1 m = 0 u = x ( 1 ) - x0 v = y ( 1 ) - y0 if ( u == 0.0_wp . and . v == 0.0_wp ) then l = 0 !(x0, y0) is on the boundary of the path else if ( n0 >= 2 ) then theta1 = atan2 ( v , u ) sum = 0.0_wp theta = theta1 do i = 2 , n0 u = x ( i ) - x0 v = y ( i ) - y0 if ( u == 0.0_wp . and . v == 0.0_wp ) then l = 0 !(x0, y0) is on the boundary of the path exit end if thetai = atan2 ( v , u ) angle = abs ( thetai - theta ) if ( abs ( angle - pi ) < tol ) then l = 0 !(x0, y0) is on the boundary of the path exit end if if ( angle > pi ) angle = angle - pi2 if ( theta > thetai ) angle = - angle sum = sum + angle theta = thetai end do if ( l /= 0 ) then angle = abs ( theta1 - theta ) if ( abs ( angle - pi ) < tol ) then l = 0 !(x0, y0) is on the boundary of the path else if ( angle > pi ) angle = angle - pi2 if ( theta > theta1 ) angle = - angle sum = sum + angle !sum = 2*pi*m where m is the winding number m = abs ( sum ) / pi2 + 0.2_wp if ( m /= 0 ) then l = 1 if ( sum < 0.0_wp ) m = - m end if end if end if end if end if end subroutine locpt","tags":"","loc":"proc/locpt.html"},{"title":"inverse – AoC-2023","text":"public  subroutine inverse(a, ainv, status_ok) inverse of a 2x2 matrix. See: https: Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: a real(kind=wp), intent(out), dimension(2,2) :: ainv logical, intent(out) :: status_ok Source Code subroutine inverse ( a , ainv , status_ok ) real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: a real ( wp ), dimension ( 2 , 2 ), intent ( out ) :: ainv logical , intent ( out ) :: status_ok real ( wp ), parameter :: eps = 1.0e-10_wp real ( wp ), dimension ( 2 , 2 ) :: cofactor associate ( det => a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 2 , 1 ) ) if ( abs ( det ) <= eps ) then ainv = 0.0_wp status_ok = . false . else cofactor ( 1 , 1 ) = + a ( 2 , 2 ) cofactor ( 1 , 2 ) = - a ( 2 , 1 ) cofactor ( 2 , 1 ) = - a ( 1 , 2 ) cofactor ( 2 , 2 ) = + a ( 1 , 1 ) ainv = transpose ( cofactor ) / det status_ok = . true . end if end associate end subroutine inverse","tags":"","loc":"proc/inverse.html"},{"title":"sort – AoC-2023","text":"public interface sort Calls interface~~sort~~CallsGraph interface~sort aoc_utilities::sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap~2 aoc_utilities::swap proc~sort_ascending->interface~swap~2 proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap~2->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap~2->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap~2->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~sort~~CalledByGraph interface~sort aoc_utilities::sort proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique~2 aoc_utilities::unique interface~unique~2->proc~unique32 interface~unique~2->proc~unique64 proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->interface~unique~2 proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->interface~unique~2 proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_pieces_above->interface~unique~2 proc~get_pieces_below->interface~unique~2 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique~2 program~problem_25 problem_25 program~problem_25->interface~unique~2 proc~beats problem_7::beats proc~beats->proc~hand_type proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_22->proc~get_pieces_above program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down program~problem_7 problem_7 program~problem_7->proc~beats proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine sort_ascending (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_64 (ivec) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout), dimension(:) :: ivec","tags":"","loc":"interface/sort.html"},{"title":"parse – AoC-2023","text":"public interface parse Calls interface~~parse~~CallsGraph interface~parse aoc_utilities::parse proc~parse_nums64 aoc_utilities::parse_nums64 interface~parse->proc~parse_nums64 interface~split aoc_utilities::split proc~parse_nums64->interface~split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~parse~~CalledByGraph interface~parse aoc_utilities::parse program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function parse_nums64 (line) result(ints) parse space-deliminated ip sequence (positive or negative) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=ip), dimension(:), allocatable","tags":"","loc":"interface/parse.html"},{"title":"split – AoC-2023","text":"public interface split Calls interface~~split~~CallsGraph interface~split aoc_utilities::split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~split~~CalledByGraph interface~split aoc_utilities::split proc~go~3 problem_18::go proc~go~3->interface~split proc~go~6 problem_12::go proc~go~6->interface~split proc~initialize problem_22::initialize proc~initialize->interface~split proc~parse_nums64 aoc_utilities::parse_nums64 proc~parse_nums64->interface~split proc~parse_rule problem_19::parse_rule proc~parse_rule->interface~split proc~parse_rule~2 problem_19b::parse_rule proc~parse_rule~2->interface~split program~problem_12b problem_12b program~problem_12b->interface~split program~problem_15 problem_15 program~problem_15->interface~split program~problem_19 problem_19 program~problem_19->interface~split program~problem_19->proc~parse_rule program~problem_19b problem_19b program~problem_19b->interface~split program~problem_19b->proc~parse_rule~2 program~problem_2 problem_2 program~problem_2->interface~split program~problem_24 problem_24 program~problem_24->interface~split program~problem_25 problem_25 program~problem_25->interface~split program~problem_4 problem_4 program~problem_4->interface~split program~problem_7 problem_7 program~problem_7->interface~split interface~parse aoc_utilities::parse interface~parse->proc~parse_nums64 program~problem_12 problem_12 program~problem_12->proc~go~6 program~problem_18 problem_18 program~problem_18->proc~go~3 program~problem_22 problem_22 program~problem_22->proc~initialize program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function split1 (str, token) result(vals) Split a character string using a token.\n  This routine is inspired by the Python split function. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable private pure function split2 (s, token) result(vals) Split a string , given a token. Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: s character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable","tags":"","loc":"interface/split.html"},{"title":"int – AoC-2023","text":"public interface int Calls interface~~int~~CallsGraph interface~int aoc_utilities::int proc~char_array_to_int aoc_utilities::char_array_to_int interface~int->proc~char_array_to_int proc~char_to_int aoc_utilities::char_to_int interface~int->proc~char_to_int proc~char_to_int64 aoc_utilities::char_to_int64 interface~int->proc~char_to_int64 proc~string_to_int aoc_utilities::string%string_to_int interface~int->proc~string_to_int proc~char_array_to_int->proc~char_to_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure elemental function string_to_int (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer private pure function char_to_int (str) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer private pure function char_to_int64 (str, kind) result(i) Basic string to integer(ip) routine.\nHacky hack just so we can overload as int() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: kind Return Value integer(kind=ip) private pure function char_array_to_int (str_array) result(i) Character array to integer routine Arguments Type Intent Optional Attributes Name character(len=1), intent(in), dimension(:) :: str_array example ['1','3'] --> 13 Return Value integer","tags":"","loc":"interface/int.html"},{"title":"unique – AoC-2023","text":"public interface unique Calls interface~~unique~2~~CallsGraph interface~unique~2 aoc_utilities::unique proc~unique32 aoc_utilities::unique32 interface~unique~2->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique~2->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap~2 aoc_utilities::swap proc~sort_ascending->interface~swap~2 proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap~2->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap~2->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap~2->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~unique~2~~CalledByGraph interface~unique~2 aoc_utilities::unique proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->interface~unique~2 proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->interface~unique~2 proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_pieces_above->interface~unique~2 proc~get_pieces_below->interface~unique~2 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique~2 program~problem_25 problem_25 program~problem_25->interface~unique~2 proc~beats problem_7::beats proc~beats->proc~hand_type proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_22->proc~get_pieces_above program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down program~problem_7 problem_7 program~problem_7->proc~beats proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function unique32 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec Return Value integer, dimension(:), allocatable private  function unique64 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: vec Return Value integer(kind=ip), dimension(:), allocatable","tags":"","loc":"interface/unique~2.html"},{"title":"startswith – AoC-2023","text":"public interface startswith test if a string starts with a specified substring Calls interface~~startswith~~CallsGraph interface~startswith aoc_utilities::startswith proc~startswith_cc aoc_utilities::startswith_cc interface~startswith->proc~startswith_cc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~startswith~~CalledByGraph interface~startswith aoc_utilities::startswith proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith program~problem_5 problem_5 program~problem_5->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function startswith_cc (str, substring) starts with function for strings Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_ss (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str type( string ), intent(in) :: substring Return Value logical private pure function startswith_sc (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_cs (str, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str type( string ), intent(in) :: substring Return Value logical","tags":"","loc":"interface/startswith.html"},{"title":"swap – AoC-2023","text":"public interface swap Calls interface~~swap~2~~CallsGraph interface~swap~2 aoc_utilities::swap proc~swap32 aoc_utilities::swap32 interface~swap~2->proc~swap32 proc~swap64 aoc_utilities::swap64 interface~swap~2->proc~swap64 proc~swap_str aoc_utilities::swap_str interface~swap~2->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~swap~2~~CalledByGraph interface~swap~2 aoc_utilities::swap proc~sort_ascending aoc_utilities::sort_ascending proc~sort_ascending->interface~swap~2 interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique~2 aoc_utilities::unique interface~unique~2->proc~unique32 interface~unique~2->proc~unique64 proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->interface~unique~2 proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->interface~unique~2 proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_pieces_above->interface~unique~2 proc~get_pieces_below->interface~unique~2 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique~2 program~problem_25 problem_25 program~problem_25->interface~unique~2 proc~beats problem_7::beats proc~beats->proc~hand_type proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_22->proc~get_pieces_above program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down program~problem_7 problem_7 program~problem_7->proc~beats proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure elemental subroutine swap32 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap64 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: i1 integer(kind=ip), intent(inout) :: i2 private pure elemental subroutine swap_str (i1, i2) Swap two character string values Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: i1 character(len=*), intent(inout) :: i2","tags":"","loc":"interface/swap~2.html"},{"title":"manhatten_distance – AoC-2023","text":"public interface manhatten_distance Calls interface~~manhatten_distance~~CallsGraph interface~manhatten_distance aoc_utilities::manhatten_distance proc~manhatten_distance_64 aoc_utilities::manhatten_distance_64 interface~manhatten_distance->proc~manhatten_distance_64 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~manhatten_distance~~CalledByGraph interface~manhatten_distance aoc_utilities::manhatten_distance proc~go~7 problem_11::go proc~go~7->interface~manhatten_distance program~problem_11 problem_11 program~problem_11->proc~go~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function manhatten_distance_64 (x1, y1, x2, y2) Manhattan distance between two ip points. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: x1 integer(kind=ip), intent(in) :: y1 integer(kind=ip), intent(in) :: x2 integer(kind=ip), intent(in) :: y2 Return Value integer(kind=ip)","tags":"","loc":"interface/manhatten_distance.html"},{"title":"index_in_queue – AoC-2023","text":"function index_in_queue(state) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state Return Value integer(kind=ip) index in the queue. -1 if not present Calls proc~~index_in_queue~2~~CallsGraph proc~index_in_queue~2 problem_17::index_in_queue proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~index_in_queue~2->proc~get_from_cache~2 proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~index_in_queue~2->proc~put_in_cache~2 proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~index_in_queue~2~~CalledByGraph proc~index_in_queue~2 problem_17::index_in_queue proc~check~3 problem_17::check proc~check~3->proc~index_in_queue~2 program~problem_17~2 problem_17 program~problem_17~2->proc~check~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function index_in_queue ( state ) result ( idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ) :: idx !! index in the queue. -1 if not present integer ( ip ) :: i logical :: found integer ( ip ) :: cache_idx integer ( ip ), dimension (:), allocatable :: cache_ival call cache % get ( state , cache_idx , cache_ival , found ) if ( found ) then idx = cache_ival ( 1 ) else idx = - 1 if (. not . allocated ( queue )) error stop 'error: queue not allocated' do i = 1 , queue_size if ( all ( state == queue ( i )% state )) then idx = i exit end if end do if ( idx /= - 1 ) call cache % put ( cache_idx , state ,[ idx ]) end if end function index_in_queue","tags":"","loc":"proc/index_in_queue~2.html"},{"title":"check – AoC-2023","text":"subroutine check(idx, idirection) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: idx integer(kind=ip), intent(in) :: idirection direction to move from current Calls proc~~check~3~~CallsGraph proc~check~3 problem_17::check proc~add_to_queue~2 problem_17::add_to_queue proc~check~3->proc~add_to_queue~2 proc~index_in_queue~2 problem_17::index_in_queue proc~check~3->proc~index_in_queue~2 proc~expand_queue problem_17::expand_queue proc~add_to_queue~2->proc~expand_queue proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~index_in_queue~2->proc~get_from_cache~2 proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~index_in_queue~2->proc~put_in_cache~2 proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check~3~~CalledByGraph proc~check~3 problem_17::check program~problem_17~2 problem_17 program~problem_17~2->proc~check~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine check ( idx , idirection ) implicit none integer ( ip ), intent ( in ) :: idx ! current item in the queue to process integer ( ip ), intent ( in ) :: idirection !! direction to move from current integer ( ip ) :: alt integer ( ip ), dimension ( 2 ) :: v ! neighbor to move to integer ( ip ) :: imovesv , idxv , distv integer ( ip ), dimension ( NSTATE ) :: istate logical :: in_queue associate ( i => queue ( idx )% state ( 1 ), & j => queue ( idx )% state ( 2 ), & direction => queue ( idx )% state ( 3 ), & n_moves => queue ( idx )% state ( 4 )) if ( direction ==- idirection ) return ! can't reverse ! the one to go to: if ( direction == idirection ) then if ( n_moves == MAX_MOVES_IN_DIR ) return ! can't move in this direction anymore imovesv = n_moves + 1 else if ( n_moves /= 0 . and . n_moves < 4 ) return ! must move at last 4 before a turn! imovesv = 1 ! reset on change of direction end if select case ( idirection ) case ( UP ); v = [ i - 1 , j ] case ( DOWN ); v = [ i + 1 , j ] case ( LEFT ); v = [ i , j - 1 ] case ( RIGHT ); v = [ i , j + 1 ] end select if ( v ( 1 ) < 1 . or . v ( 2 ) < 1 . or . v ( 1 ) > n_rows . or . v ( 2 ) > n_cols ) return ! can't go off the board if ( v ( 1 ) == n_rows . and . v ( 2 ) == n_cols . and . imovesv < 4 ) return ! require at least 4 to end istate = [ v ( 1 ), v ( 2 ), idirection , imovesv ] ! new state idxv = index_in_queue ( istate ) ! is it already in the queue in_queue = idxv > 0 ! if this one is already part of another path if ( in_queue ) then if ( queue ( idxv )% visited ) return ! already visited this one distv = queue ( idxv )% dist ! distance in the queue else !call add_to_queue(istate, idxv) ! add this to the queue for processing ! always add it ?? distv = huge ( 1_ip ) ! not processed yet, so huge number end if !alt = queue(idx)%dist + map(queue(idxv)%state(1), queue(idxv)%state(2)) alt = queue ( idx )% dist + map ( v ( 1 ), v ( 2 )) ! new distance if ( alt < distv ) then ! the new one is better, so replace values in the queue if (. not . in_queue ) call add_to_queue ( istate , idxv ) ! only add it if we accept it ???? ! accept this step queue ( idxv )% dist = alt ! new best dist queue ( idxv )% iprev = idx ! previous end if end associate end subroutine check","tags":"","loc":"proc/check~3.html"},{"title":"add_to_queue – AoC-2023","text":"subroutine add_to_queue(state, idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state integer(kind=ip), intent(out) :: idx index of the element in the queue Calls proc~~add_to_queue~2~~CallsGraph proc~add_to_queue~2 problem_17::add_to_queue proc~expand_queue problem_17::expand_queue proc~add_to_queue~2->proc~expand_queue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~add_to_queue~2~~CalledByGraph proc~add_to_queue~2 problem_17::add_to_queue proc~check~3 problem_17::check proc~check~3->proc~add_to_queue~2 program~problem_17~2 problem_17 program~problem_17~2->proc~add_to_queue~2 program~problem_17~2->proc~check~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine add_to_queue ( state , idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ), intent ( out ) :: idx !! index of the element in the queue if ( allocated ( queue )) then call expand_queue ( queue , queue_size , item ( state = state )) idx = queue_size else queue = [ item ( state = state )] queue_size = 1 idx = 1 end if end subroutine add_to_queue","tags":"","loc":"proc/add_to_queue~2.html"},{"title":"expand_queue – AoC-2023","text":"pure subroutine expand_queue(vec, n, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name type( item ), intent(inout), dimension(:), allocatable :: vec integer(kind=ip), intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call type( item ), intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) Called by proc~~expand_queue~~CalledByGraph proc~expand_queue problem_17::expand_queue proc~add_to_queue~2 problem_17::add_to_queue proc~add_to_queue~2->proc~expand_queue proc~check~3 problem_17::check proc~check~3->proc~add_to_queue~2 program~problem_17~2 problem_17 program~problem_17~2->proc~add_to_queue~2 program~problem_17~2->proc~check~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine expand_queue ( vec , n , val , finished ) integer ( ip ), parameter :: chunk_size = 1000 type ( item ), dimension (:), allocatable , intent ( inout ) :: vec integer ( ip ), intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call type ( item ), intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) type ( item ), dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_queue","tags":"","loc":"proc/expand_queue.html"},{"title":"vector_djb_hash – AoC-2023","text":"private pure function vector_djb_hash(r) result(hash) DJB hash algorithm for a integer(ip) vector. See also J. Shahbazian, Fortran hashing algorithm, July 6, 2013 Fortran Dev Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: r the vector Return Value integer(kind=ip) the hash value Called by proc~~vector_djb_hash~2~~CalledByGraph proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~get_from_cache~2->proc~vector_djb_hash~2 proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->proc~get_from_cache~2 proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->proc~get_from_cache~2 proc~get_all_pieces_below->proc~get_all_pieces_below proc~go problem_12b::go proc~go->proc~get_from_cache~2 proc~ipoint problem_12b::ipoint proc~go->proc~ipoint proc~ipound problem_12b::ipound proc~go->proc~ipound proc~index_in_queue~2 problem_17::index_in_queue proc~index_in_queue~2->proc~get_from_cache~2 proc~check~3 problem_17::check proc~check~3->proc~index_in_queue~2 proc~ipoint->proc~go proc~ipound->proc~go program~problem_12b problem_12b program~problem_12b->proc~go program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_17~2 problem_17 program~problem_17~2->proc~check~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function vector_djb_hash ( r ) result ( hash ) integer ( ip ), dimension (:), intent ( in ) :: r !! the vector integer ( ip ) :: hash !! the hash value integer :: i !! counter hash = 5381_ip do i = 1 , size ( r ) hash = ishft ( hash , 5_ip ) + hash + r ( i ) end do end function vector_djb_hash","tags":"","loc":"proc/vector_djb_hash~2.html"},{"title":"initialize_cache – AoC-2023","text":"private  subroutine initialize_cache(me, isize, chunk_size) Initialize the cache. Must be called first before use. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: isize the size of the hash table integer, intent(in), optional :: chunk_size chunk size to speed up reallocation\nof arrays. A good value is a guess for\nthe actual number of elements of f that\nwill be saved per value of x [default is 100] Calls proc~~initialize_cache~2~~CallsGraph proc~initialize_cache~2 aoc_cache_module::function_cache%initialize_cache proc~destroy_cache~2 aoc_cache_module::function_cache%destroy_cache proc~initialize_cache~2->proc~destroy_cache~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~initialize_cache~2~~CalledByGraph proc~initialize_cache~2 aoc_cache_module::function_cache%initialize_cache program~problem_12b problem_12b program~problem_12b->proc~initialize_cache~2 program~problem_17~2 problem_17 program~problem_17~2->proc~initialize_cache~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize_cache ( me , isize , chunk_size ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: isize !! the size of the hash table integer , intent ( in ), optional :: chunk_size !! chunk size to speed up reallocation !! of arrays. A good value is a guess for !! the actual number of elements of `f` that !! will be saved per value of `x` [default is 100] call me % destroy () allocate ( me % c ( 0 : isize - 1 )) if ( present ( chunk_size )) then me % chunk_size = chunk_size else me % chunk_size = 100 end if end subroutine initialize_cache","tags":"","loc":"proc/initialize_cache~2.html"},{"title":"get_from_cache – AoC-2023","text":"private  subroutine get_from_cache(me, x, i, f, found) Check if the x vector is in the cache, if so return f .\nNote that only some of the elements may be present, so it will return\nthe ones there are there, and indicate which ones were found. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer(kind=ip), intent(in), dimension(:) :: x independant variable vector integer(kind=ip), intent(out) :: i index in the hash table integer(kind=ip), intent(out), dimension(:), allocatable :: f f(x) from the cache (if it was found) logical, intent(out) :: found if x was found in the cache Calls proc~~get_from_cache~2~~CallsGraph proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_from_cache~2~~CalledByGraph proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->proc~get_from_cache~2 proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->proc~get_from_cache~2 proc~get_all_pieces_below->proc~get_all_pieces_below proc~go problem_12b::go proc~go->proc~get_from_cache~2 proc~ipoint problem_12b::ipoint proc~go->proc~ipoint proc~ipound problem_12b::ipound proc~go->proc~ipound proc~index_in_queue~2 problem_17::index_in_queue proc~index_in_queue~2->proc~get_from_cache~2 proc~check~3 problem_17::check proc~check~3->proc~index_in_queue~2 proc~ipoint->proc~go proc~ipound->proc~go program~problem_12b problem_12b program~problem_12b->proc~go program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_17~2 problem_17 program~problem_17~2->proc~check~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_from_cache ( me , x , i , f , found ) implicit none class ( function_cache ), intent ( inout ) :: me integer ( ip ), dimension (:), intent ( in ) :: x !! independant variable vector integer ( ip ), intent ( out ) :: i !! index in the hash table integer ( ip ), dimension (:), allocatable , intent ( out ) :: f !! `f(x)` from the cache (if it was found) logical , intent ( out ) :: found !! if `x` was found in the cache integer :: j !! counter ! initialize: found = . false . if ( allocated ( me % c )) then ! get index in the hash table: i = mod ( abs ( vector_djb_hash ( x )), int ( size ( me % c ), ip ) ) ! check the table: if ( allocated ( me % c ( i )% x )) then if ( size ( me % c ( i )% x ) == size ( x )) then if ( all ( me % c ( i )% x == x )) then found = . true . f = me % c ( i )% f end if end if end if else error stop 'Error: the cache has not been initialized.' end if end subroutine get_from_cache","tags":"","loc":"proc/get_from_cache~2.html"},{"title":"put_in_cache – AoC-2023","text":"private  subroutine put_in_cache(me, i, x, f) Put a value into the cache. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer(kind=ip), intent(in) :: i index in the hash table integer(kind=ip), intent(in), dimension(:) :: x independant variable vector integer(kind=ip), intent(in), dimension(:) :: f function Called by proc~~put_in_cache~2~~CalledByGraph proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->proc~put_in_cache~2 proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->proc~put_in_cache~2 proc~get_all_pieces_below->proc~get_all_pieces_below proc~go problem_12b::go proc~go->proc~put_in_cache~2 proc~ipoint problem_12b::ipoint proc~go->proc~ipoint proc~ipound problem_12b::ipound proc~go->proc~ipound proc~index_in_queue~2 problem_17::index_in_queue proc~index_in_queue~2->proc~put_in_cache~2 proc~check~3 problem_17::check proc~check~3->proc~index_in_queue~2 proc~ipoint->proc~go proc~ipound->proc~go program~problem_12b problem_12b program~problem_12b->proc~go program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_17~2 problem_17 program~problem_17~2->proc~check~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine put_in_cache ( me , i , x , f ) implicit none class ( function_cache ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: i !! index in the hash table integer ( ip ), dimension (:), intent ( in ) :: x !! independant variable vector integer ( ip ), dimension (:), intent ( in ) :: f !! function integer ( ip ), parameter :: null = huge ( 1 ) !! an unusual value to initialize arrays if ( allocated ( me % c )) then if ( i <= size ( me % c )) then ! add to the cache me % c ( i )% x = x me % c ( i )% f = f else error stop 'Error: invalid index in hash table.' end if else error stop 'Error: the cache has not been initialized.' end if end subroutine put_in_cache","tags":"","loc":"proc/put_in_cache~2.html"},{"title":"destroy_cache – AoC-2023","text":"private  subroutine destroy_cache(me) Destroy a cache. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(out) :: me Called by proc~~destroy_cache~2~~CalledByGraph proc~destroy_cache~2 aoc_cache_module::function_cache%destroy_cache proc~initialize_cache~2 aoc_cache_module::function_cache%initialize_cache proc~initialize_cache~2->proc~destroy_cache~2 program~problem_12b problem_12b program~problem_12b->proc~initialize_cache~2 program~problem_17~2 problem_17 program~problem_17~2->proc~initialize_cache~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy_cache ( me ) implicit none class ( function_cache ), intent ( out ) :: me end subroutine destroy_cache","tags":"","loc":"proc/destroy_cache~2.html"},{"title":"get_all_pieces_above – AoC-2023","text":"recursive function get_all_pieces_above(i) result(ipieces) reursively get a list of all pieces above piece i Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i Return Value integer(kind=ip), dimension(:), allocatable Calls proc~~get_all_pieces_above~~CallsGraph proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->proc~get_all_pieces_above interface~unique~2 aoc_utilities::unique proc~get_all_pieces_above->interface~unique~2 proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~get_all_pieces_above->proc~get_from_cache~2 proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~get_all_pieces_above->proc~put_in_cache~2 proc~unique32 aoc_utilities::unique32 interface~unique~2->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique~2->proc~unique64 proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 proc~get_pieces_above->interface~unique~2 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap~2 aoc_utilities::swap proc~sort_ascending->interface~swap~2 proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap~2->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap~2->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap~2->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_all_pieces_above~~CalledByGraph proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->proc~get_all_pieces_above program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive function get_all_pieces_above ( i ) result ( ipieces ) !! reursively get a list of all pieces above piece i integer ( ip ), intent ( in ) :: i integer ( ip ), dimension (:), allocatable :: ipieces integer :: j !! counter logical :: found integer ( ip ) :: idx call above_cache % get ([ i ], idx , ipieces , found ) if (. not . found ) then allocate ( ipieces ( 0 )) associate ( tmp => get_pieces_above ( i )) if ( size ( tmp ) > 0 ) then ipieces = [ ipieces , tmp ] ! ones directly above do j = 1 , size ( tmp ) ! go up the tree ipieces = [ ipieces , get_all_pieces_above ( tmp ( j ))] end do ipieces = unique ( ipieces ) end if end associate call above_cache % put ( idx ,[ i ], ipieces ) end if end function get_all_pieces_above","tags":"","loc":"proc/get_all_pieces_above.html"},{"title":"get_all_pieces_below – AoC-2023","text":"recursive function get_all_pieces_below(i, iskip) result(ipieces) reursively get a list of all pieces below piece i Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: iskip skip this one and it's children Return Value integer(kind=ip), dimension(:), allocatable Calls proc~~get_all_pieces_below~~CallsGraph proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->proc~get_all_pieces_below interface~unique~2 aoc_utilities::unique proc~get_all_pieces_below->interface~unique~2 proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~get_all_pieces_below->proc~get_from_cache~2 proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~get_all_pieces_below->proc~put_in_cache~2 proc~unique32 aoc_utilities::unique32 interface~unique~2->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique~2->proc~unique64 proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 proc~get_pieces_below->interface~unique~2 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap~2 aoc_utilities::swap proc~sort_ascending->interface~swap~2 proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap~2->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap~2->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap~2->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_all_pieces_below~~CalledByGraph proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->proc~get_all_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_below Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive function get_all_pieces_below ( i , iskip ) result ( ipieces ) !! reursively get a list of all pieces below piece i integer ( ip ), intent ( in ) :: i integer ( ip ), intent ( in ) :: iskip !! skip this one and it's children integer ( ip ), dimension (:), allocatable :: ipieces integer :: j !! counter logical :: found integer ( ip ) :: idx integer ( ip ), dimension (:), allocatable :: tmp call below_cache % get ([ i , iskip ], idx , ipieces , found ) if (. not . found ) then allocate ( ipieces ( 0 )) if ( i == iskip ) return tmp = get_pieces_below ( i ) if ( size ( tmp ) > 0 ) then tmp = pack ( tmp , tmp /= iskip ) ! remove the skipped one ipieces = [ ipieces , tmp ] ! ones directly below do j = 1 , size ( tmp ) ! go down the tree ipieces = [ ipieces , get_all_pieces_below ( tmp ( j ), iskip = iskip )] end do ipieces = unique ( ipieces ) end if call below_cache % put ( idx ,[ i , iskip ], ipieces ) end if end function get_all_pieces_below","tags":"","loc":"proc/get_all_pieces_below.html"},{"title":"get_pieces_above – AoC-2023","text":"function get_pieces_above(i) result(ipieces) get set of pieces directly above piece i Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i Return Value integer(kind=ip), dimension(:), allocatable Calls proc~~get_pieces_above~~CallsGraph proc~get_pieces_above problem_22::get_pieces_above interface~unique~2 aoc_utilities::unique proc~get_pieces_above->interface~unique~2 proc~unique32 aoc_utilities::unique32 interface~unique~2->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique~2->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap~2 aoc_utilities::swap proc~sort_ascending->interface~swap~2 proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap~2->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap~2->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap~2->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_pieces_above~~CalledByGraph proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_above->proc~get_all_pieces_above program~problem_22 problem_22 program~problem_22->proc~get_pieces_above program~problem_22->proc~get_all_pieces_above Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function get_pieces_above ( i ) result ( ipieces ) !! get set of pieces directly above piece i integer ( ip ), intent ( in ) :: i integer ( ip ), dimension (:), allocatable :: ipieces integer ( ip ) :: x , y , z !! counter allocate ( ipieces ( 0 )) do x = istart_array ( i , 1 ), iend_array ( i , 1 ) do y = istart_array ( i , 2 ), iend_array ( i , 2 ) do z = istart_array ( i , 3 ), iend_array ( i , 3 ) if ( z + 1 <= ubound ( array , 3 )) then if ( array ( x , y , z + 1 ) /= 0 ) ipieces = [ ipieces , array ( x , y , z + 1 )] ! above this one end if end do end do end do ipieces = unique ( pack ( ipieces , ipieces /= i )) ! exclude the ones in this piece end function get_pieces_above","tags":"","loc":"proc/get_pieces_above.html"},{"title":"get_pieces_below – AoC-2023","text":"function get_pieces_below(i) result(ipieces) get set of pieces directly below piece i Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i Return Value integer(kind=ip), dimension(:), allocatable Calls proc~~get_pieces_below~~CallsGraph proc~get_pieces_below problem_22::get_pieces_below interface~unique~2 aoc_utilities::unique proc~get_pieces_below->interface~unique~2 proc~unique32 aoc_utilities::unique32 interface~unique~2->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique~2->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap~2 aoc_utilities::swap proc~sort_ascending->interface~swap~2 proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap~2->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap~2->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap~2->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_pieces_below~~CalledByGraph proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_all_pieces_below->proc~get_all_pieces_below proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_pieces_below program~problem_22->proc~get_all_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function get_pieces_below ( i ) result ( ipieces ) !! get set of pieces directly below piece i integer ( ip ), intent ( in ) :: i integer ( ip ), dimension (:), allocatable :: ipieces integer ( ip ) :: x , y , z !! counter allocate ( ipieces ( 0 )) do x = istart_array ( i , 1 ), iend_array ( i , 1 ) do y = istart_array ( i , 2 ), iend_array ( i , 2 ) do z = istart_array ( i , 3 ), iend_array ( i , 3 ) if ( z - 1 > 0 ) then ! 0 is the floor if ( array ( x , y , z - 1 ) /= 0 ) ipieces = [ ipieces , array ( x , y , z - 1 )] ! below this one end if end do end do end do ipieces = unique ( pack ( ipieces , ipieces /= i )) ! exclude the ones in this piece end function get_pieces_below","tags":"","loc":"proc/get_pieces_below.html"},{"title":"initialize – AoC-2023","text":"subroutine initialize() read the data Arguments None Calls proc~~initialize~~CallsGraph proc~initialize problem_22::initialize interface~split aoc_utilities::split proc~initialize->interface~split proc~drop problem_22::drop proc~initialize->proc~drop proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~initialize->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~initialize->proc~read_line proc~update_array problem_22::update_array proc~initialize->proc~update_array proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~move_piece_down problem_22::move_piece_down proc~drop->proc~move_piece_down proc~move_piece_down->proc~update_array proc~get_pieces_below problem_22::get_pieces_below proc~move_piece_down->proc~get_pieces_below proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 interface~unique~2 aoc_utilities::unique proc~get_pieces_below->interface~unique~2 proc~unique32 aoc_utilities::unique32 interface~unique~2->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique~2->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap~2 aoc_utilities::swap proc~sort_ascending->interface~swap~2 proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap~2->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap~2->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap~2->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~initialize~~CalledByGraph proc~initialize problem_22::initialize program~problem_22 problem_22 program~problem_22->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize () !! read the data ! open(newunit=iunit, file='inputs/day22_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day22.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) if ( allocated ( istart_array )) deallocate ( istart_array ); allocate ( istart_array ( n_lines , 3 )) if ( allocated ( iend_array )) deallocate ( iend_array ); allocate ( iend_array ( n_lines , 3 )) do i = 1 , n_lines line = read_line ( iunit ); start_end = split ( line , '~' ) starts = split ( start_end ( 1 )% str , ',' ) ends = split ( start_end ( 2 )% str , ',' ) istart_array ( i ,:) = [( int ( starts ( j )% str ), j = 1 , 3 )] iend_array ( i ,:) = [( int ( ends ( j )% str ), j = 1 , 3 )] end do close ( iunit ) ! create the array to hold all the pieces: if ( allocated ( array )) deallocate ( array ) allocate ( array ( 0 : maxval ([ istart_array (:, 1 ), iend_array (:, 1 )]),& 0 : maxval ([ istart_array (:, 2 ), iend_array (:, 2 )]),& 0 : maxval ([ istart_array (:, 3 ), iend_array (:, 3 )]))) call update_array () ! set array values from the start/end arrays call drop () ! continue forward in time until all the bricks settle. end subroutine initialize","tags":"","loc":"proc/initialize.html"},{"title":"drop – AoC-2023","text":"subroutine drop() continue forward in time until all the bricks settle. Arguments None Calls proc~~drop~~CallsGraph proc~drop problem_22::drop proc~move_piece_down problem_22::move_piece_down proc~drop->proc~move_piece_down proc~get_pieces_below problem_22::get_pieces_below proc~move_piece_down->proc~get_pieces_below proc~update_array problem_22::update_array proc~move_piece_down->proc~update_array interface~unique~2 aoc_utilities::unique proc~get_pieces_below->interface~unique~2 proc~unique32 aoc_utilities::unique32 interface~unique~2->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique~2->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap~2 aoc_utilities::swap proc~sort_ascending->interface~swap~2 proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap~2->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap~2->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap~2->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~drop~~CalledByGraph proc~drop problem_22::drop proc~initialize problem_22::initialize proc~initialize->proc~drop program~problem_22 problem_22 program~problem_22->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine drop () !! continue forward in time until all the bricks settle. logical :: moved , tmp_moved integer ( ip ) :: i do moved = . false . do i = 1 , n_lines call move_piece_down ( i , tmp_moved ) if ( tmp_moved ) moved = . true . ! at least one was moved end do if (. not . moved ) exit ! done moving all the pieces end do end subroutine drop","tags":"","loc":"proc/drop.html"},{"title":"update_array – AoC-2023","text":"subroutine update_array() populate the array using the start/end indices Arguments None Called by proc~~update_array~~CalledByGraph proc~update_array problem_22::update_array proc~initialize problem_22::initialize proc~initialize->proc~update_array proc~drop problem_22::drop proc~initialize->proc~drop proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~update_array proc~drop->proc~move_piece_down program~problem_22 problem_22 program~problem_22->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine update_array () !! populate the array using the start/end indices integer :: i array = 0 do i = 1 , n_lines array ( istart_array ( i , 1 ): iend_array ( i , 1 ),& istart_array ( i , 2 ): iend_array ( i , 2 ),& istart_array ( i , 3 ): iend_array ( i , 3 )) = i end do end subroutine update_array","tags":"","loc":"proc/update_array.html"},{"title":"move_piece_down – AoC-2023","text":"subroutine move_piece_down(i, moved) move a piece down (fall one square) if it can be moved Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i piece number logical, intent(out) :: moved if it was actually movec Calls proc~~move_piece_down~~CallsGraph proc~move_piece_down problem_22::move_piece_down proc~get_pieces_below problem_22::get_pieces_below proc~move_piece_down->proc~get_pieces_below proc~update_array problem_22::update_array proc~move_piece_down->proc~update_array interface~unique~2 aoc_utilities::unique proc~get_pieces_below->interface~unique~2 proc~unique32 aoc_utilities::unique32 interface~unique~2->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique~2->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap~2 aoc_utilities::swap proc~sort_ascending->interface~swap~2 proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap~2->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap~2->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap~2->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~move_piece_down~~CalledByGraph proc~move_piece_down problem_22::move_piece_down proc~drop problem_22::drop proc~drop->proc~move_piece_down proc~initialize problem_22::initialize proc~initialize->proc~drop program~problem_22 problem_22 program~problem_22->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine move_piece_down ( i , moved ) !! move a piece down (fall one square) if it can be moved integer ( ip ), intent ( in ) :: i !! piece number logical , intent ( out ) :: moved !! if it was actually movec moved = . false . if ( size ( get_pieces_below ( i )) == 0 ) then ! can only move if nothing below if ( istart_array ( i , 3 ) > 1 . and . iend_array ( i , 3 ) > 1 ) then istart_array ( i , 3 ) = istart_array ( i , 3 ) - 1 iend_array ( i , 3 ) = iend_array ( i , 3 ) - 1 moved = . true . call update_array () end if end if end subroutine move_piece_down","tags":"","loc":"proc/move_piece_down.html"},{"title":"rating – AoC-2023","text":"pure function rating(p) Arguments Type Intent Optional Attributes Name type( part ), intent(in) :: p Return Value integer(kind=ip) Called by proc~~rating~~CalledByGraph proc~rating problem_19::rating program~problem_19 problem_19 program~problem_19->proc~rating Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer ( ip ) function rating ( p ) type ( part ), intent ( in ) :: p rating = sum ( p % xmas ) end function rating","tags":"","loc":"proc/rating.html"},{"title":"process – AoC-2023","text":"function process(p) result(accepted) process this part through all the workflows. Arguments Type Intent Optional Attributes Name type( part ), intent(in) :: p Return Value logical Calls proc~~process~~CallsGraph proc~process problem_19::process proc~workflow_name_to_index problem_19::workflow_name_to_index proc~process->proc~workflow_name_to_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~process~~CalledByGraph proc~process problem_19::process program~problem_19 problem_19 program~problem_19->proc~process Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function process ( p ) result ( accepted ) !! process this part through all the workflows. type ( part ), intent ( in ) :: p logical :: accepted integer :: i , irule i = workflow_name_to_index ( 'in' ) ! start at the first workflow irule = 1 ! first rule do associate ( r => workflows ( i )% rules ( irule ) ) ! check if we are done if ( r % accept ) then ; accepted = . true .; return ; end if if ( r % reject ) then ; accepted = . false .; return ; end if if ( r % operator > 0 ) then ! process the operator select case ( r % operator ) case ( 1 ) ! < if ( p % xmas ( r % operator_arg ) < r % operator_val ) then ! check if done if ( r % goto == 'A' ) then ; accepted = . true .; return ; end if if ( r % goto == 'R' ) then ; accepted = . false .; return ; end if ! go to next workflow: i = workflow_name_to_index ( r % goto ) !write(*,*) 'goto '//r%goto irule = 1 ! start at first rule of new workflow else irule = irule + 1 ! next rule end if case ( 2 ) ! > if ( p % xmas ( r % operator_arg ) > r % operator_val ) then ! check if done if ( r % goto == 'A' ) then ; accepted = . true .; return ; end if if ( r % goto == 'R' ) then ; accepted = . false .; return ; end if ! go to next workflow: i = workflow_name_to_index ( r % goto ) irule = 1 ! start at first rule of new workflow else irule = irule + 1 ! next rule end if end select else ! goto another workflow i = workflow_name_to_index ( r % goto ) irule = 1 ! start at first rule of new workflow end if end associate end do end function process","tags":"","loc":"proc/process.html"},{"title":"workflow_name_to_index – AoC-2023","text":"function workflow_name_to_index(name) result(idx) get the index of this workflow in the array Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value integer Called by proc~~workflow_name_to_index~~CalledByGraph proc~workflow_name_to_index problem_19::workflow_name_to_index proc~process problem_19::process proc~process->proc~workflow_name_to_index program~problem_19 problem_19 program~problem_19->proc~process Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function workflow_name_to_index ( name ) result ( idx ) !! get the index of this workflow in the array character ( len =* ), intent ( in ) :: name integer :: idx do idx = 1 , size ( workflows ) if ( name == workflows ( idx )% name ) return ! found it end do if ( idx > size ( workflows )) error stop 'workflow not found: ' // name end function workflow_name_to_index","tags":"","loc":"proc/workflow_name_to_index.html"},{"title":"parse_rule – AoC-2023","text":"function parse_rule(s) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value type( rule ) Calls proc~~parse_rule~~CallsGraph proc~parse_rule problem_19::parse_rule interface~split aoc_utilities::split proc~parse_rule->interface~split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~parse_rule~~CalledByGraph proc~parse_rule problem_19::parse_rule program~problem_19 problem_19 program~problem_19->proc~parse_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function parse_rule ( s ) result ( r ) character ( len =* ), intent ( in ) :: s type ( rule ) :: r type ( string ), dimension (:), allocatable :: v character ( len =* ), parameter :: xmas = 'xmas' ! 1,2,3,4 if ( s == 'A' ) then r % accept = . true . else if ( s == 'R' ) then r % reject = . true . else if ( index ( s , '>' ) > 0 ) then v = split ( s ( 3 :), ':' ) ! example: a<2006:qkq r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 2 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else if ( index ( s , '<' ) > 0 ) then v = split ( s ( 3 :), ':' ) r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 1 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else r % goto = s ! it's a workflow name end if end if end function parse_rule","tags":"","loc":"proc/parse_rule.html"},{"title":"process – AoC-2023","text":"recursive function process(iworkflow, irule, p) result(iaccepted) process this part range starting with irule Arguments Type Intent Optional Attributes Name integer, intent(in) :: iworkflow integer, intent(in) :: irule type( part ), intent(in) :: p Return Value integer(kind=ip) Calls proc~~process~2~~CallsGraph proc~process~2 problem_19b::process proc~process~2->proc~process~2 proc~get_accepted problem_19b::get_accepted proc~process~2->proc~get_accepted proc~workflow_name_to_index~2 problem_19b::workflow_name_to_index proc~process~2->proc~workflow_name_to_index~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~process~2~~CalledByGraph proc~process~2 problem_19b::process proc~process~2->proc~process~2 program~problem_19b problem_19b program~problem_19b->proc~process~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive function process ( iworkflow , irule , p ) result ( iaccepted ) !! process this part range starting with irule integer , intent ( in ) :: iworkflow integer , intent ( in ) :: irule type ( part ), intent ( in ) :: p integer ( ip ) :: iaccepted integer ( ip ), dimension (:), allocatable :: itmp , itmp_t , itmp_f integer ( ip ) :: i type ( part ) :: pt , pf iaccepted = 0 associate ( r => workflows ( iworkflow )% rules ( irule ) ) ! check if we are done if ( r % accept ) then iaccepted = get_accepted ( p ) return else if ( r % reject ) then iaccepted = 0 return end if ! process recursively, by splitting up the intervals when necessary if ( r % operator > 0 ) then ! process the operator select case ( r % operator ) case ( 1 ) ! < ! always create the two sets and process the two cases below ! [note that some sets maybe empty] ! ! example: ![1,200]   < 10   ==> [1,9]    TRUE !                     [10,200] FALSE itmp = [( i , i = p % xmas ( r % operator_arg )% v ( 1 ), p % xmas ( r % operator_arg )% v ( 2 ))] itmp_t = pack ( itmp , mask = itmp < r % operator_val ) !true itmp_f = pack ( itmp , mask = itmp >= r % operator_val ) !false if ( size ( itmp_t ) > 0 ) then ! some are true pt = p pt % xmas ( r % operator_arg )% v = [ itmp_t ( 1 ), itmp_t ( size ( itmp_t ))] if ( r % goto == 'A' ) then iaccepted = iaccepted + get_accepted ( pt ) else if ( r % goto /= 'R' ) then ! go to next workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , pt ) end if end if if ( size ( itmp_f ) > 0 ) then ! some are false pf = p pf % xmas ( r % operator_arg )% v = [ itmp_f ( 1 ), itmp_f ( size ( itmp_f ))] iaccepted = iaccepted + process ( iworkflow , irule + 1 , pf ) ! next rule end if case ( 2 ) ! > itmp = [( i , i = p % xmas ( r % operator_arg )% v ( 1 ), p % xmas ( r % operator_arg )% v ( 2 ))] itmp_t = pack ( itmp , mask = itmp > r % operator_val ) !true itmp_f = pack ( itmp , mask = itmp <= r % operator_val ) !false if ( size ( itmp_t ) > 0 ) then ! some are true pt = p pt % xmas ( r % operator_arg )% v = [ itmp_t ( 1 ), itmp_t ( size ( itmp_t ))] if ( r % goto == 'A' ) then iaccepted = iaccepted + get_accepted ( pt ) else if ( r % goto /= 'R' ) then ! go to next workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , pt ) end if end if if ( size ( itmp_f ) > 0 ) then ! some are false pf = p pf % xmas ( r % operator_arg )% v = [ itmp_f ( 1 ), itmp_f ( size ( itmp_f ))] iaccepted = iaccepted + process ( iworkflow , irule + 1 , pf ) ! next rule end if end select else ! goto another workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , p ) end if end associate !end do end function process","tags":"","loc":"proc/process~2.html"},{"title":"get_accepted – AoC-2023","text":"function get_accepted(p) count of all the parts in the set Arguments Type Intent Optional Attributes Name type( part ), intent(in) :: p Return Value integer(kind=ip) Called by proc~~get_accepted~~CalledByGraph proc~get_accepted problem_19b::get_accepted proc~process~2 problem_19b::process proc~process~2->proc~get_accepted proc~process~2->proc~process~2 program~problem_19b problem_19b program~problem_19b->proc~process~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code integer ( ip ) function get_accepted ( p ) !! count of all the parts in the set type ( part ), intent ( in ) :: p get_accepted = ( 1 + ( p % xmas ( 1 )% v ( 2 ) - p % xmas ( 1 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 2 )% v ( 2 ) - p % xmas ( 2 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 3 )% v ( 2 ) - p % xmas ( 3 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 4 )% v ( 2 ) - p % xmas ( 4 )% v ( 1 ))) end function get_accepted","tags":"","loc":"proc/get_accepted.html"},{"title":"workflow_name_to_index – AoC-2023","text":"function workflow_name_to_index(name) result(idx) get the index of this workflow in the array Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value integer Called by proc~~workflow_name_to_index~2~~CalledByGraph proc~workflow_name_to_index~2 problem_19b::workflow_name_to_index proc~process~2 problem_19b::process proc~process~2->proc~workflow_name_to_index~2 proc~process~2->proc~process~2 program~problem_19b problem_19b program~problem_19b->proc~workflow_name_to_index~2 program~problem_19b->proc~process~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function workflow_name_to_index ( name ) result ( idx ) !! get the index of this workflow in the array character ( len =* ), intent ( in ) :: name integer :: idx do idx = 1 , size ( workflows ) if ( name == workflows ( idx )% name ) return ! found it end do if ( idx > size ( workflows )) error stop 'workflow not found: ' // name end function workflow_name_to_index","tags":"","loc":"proc/workflow_name_to_index~2.html"},{"title":"parse_rule – AoC-2023","text":"function parse_rule(s) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value type( rule ) Calls proc~~parse_rule~2~~CallsGraph proc~parse_rule~2 problem_19b::parse_rule interface~split aoc_utilities::split proc~parse_rule~2->interface~split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~parse_rule~2~~CalledByGraph proc~parse_rule~2 problem_19b::parse_rule program~problem_19b problem_19b program~problem_19b->proc~parse_rule~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function parse_rule ( s ) result ( r ) character ( len =* ), intent ( in ) :: s type ( rule ) :: r type ( string ), dimension (:), allocatable :: v character ( len =* ), parameter :: xmas = 'xmas' ! 1,2,3,4 if ( s == 'A' ) then r % accept = . true . else if ( s == 'R' ) then r % reject = . true . else if ( index ( s , '>' ) > 0 ) then v = split ( s ( 3 :), ':' ) ! example: a<2006:qkq r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 2 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else if ( index ( s , '<' ) > 0 ) then v = split ( s ( 3 :), ':' ) r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 1 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else r % goto = s ! it's a workflow name end if end if end function parse_rule","tags":"","loc":"proc/parse_rule~2.html"},{"title":"numerical_differentiation_module – AoC-2023","text":"Numerical differentiation module for computing the Jacobian matrix\n(the derivative matrix of m functions w.r.t. n variables) using\nfinite differences. Uses iso_fortran_env dsm_module numdiff_cache_module diff_module numdiff_utilities_module numdiff_kinds_module module~~numerical_differentiation_module~~UsesGraph module~numerical_differentiation_module numerical_differentiation_module iso_fortran_env iso_fortran_env module~numerical_differentiation_module->iso_fortran_env module~diff_module diff_module module~numerical_differentiation_module->module~diff_module module~dsm_module dsm_module module~numerical_differentiation_module->module~dsm_module module~numdiff_cache_module numdiff_cache_module module~numerical_differentiation_module->module~numdiff_cache_module module~numdiff_kinds_module numdiff_kinds_module module~numerical_differentiation_module->module~numdiff_kinds_module module~numdiff_utilities_module numdiff_utilities_module module~numerical_differentiation_module->module~numdiff_utilities_module module~diff_module->module~numdiff_kinds_module module~dsm_module->module~numdiff_kinds_module module~numdiff_cache_module->iso_fortran_env module~numdiff_cache_module->module~numdiff_kinds_module module~numdiff_cache_module->module~numdiff_utilities_module module~numdiff_kinds_module->iso_fortran_env module~numdiff_utilities_module->module~numdiff_kinds_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~numerical_differentiation_module~~UsedByGraph module~numerical_differentiation_module numerical_differentiation_module program~test1 test1 program~test1->module~numerical_differentiation_module program~test2 test2 program~test2->module~numerical_differentiation_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=wp), private, parameter :: zero = 0.0_wp Interfaces public        interface finite_diff_method constructor private  function initialize_finite_difference_method (id, name, class, dx_factors, df_factors, df_den_factor) result(me) Constructor for a finite_diff_method . Note factors are input as integers for convenience, but are converted\n      to reals for the actual computations. (note: this means we can't\n      currently define methods that have non-integer factors). Arguments Type Intent Optional Attributes Name integer, intent(in) :: id unique ID for the method character(len=*), intent(in) :: name the name of the method integer, intent(in) :: class 2=backward diffs, 3=central diffs, etc... integer, intent(in), dimension(:) :: dx_factors multiplicative factors for dx perturbation integer, intent(in), dimension(:) :: df_factors multiplicative factors for accumulating function evaluations integer, intent(in) :: df_den_factor denominator factor for finite difference equation (times dx) Return Value type( finite_diff_method ) Abstract Interfaces abstract interface private  subroutine func(me, x, f, funcs_to_compute) The function (vector array of output functions f , computed\nfrom a vector of input variables x ).\nThis must be defined for all computations. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x array of variables (size n ) real(kind=wp), intent(out), dimension(:) :: f array of functions (size m ) integer, intent(in), dimension(:) :: funcs_to_compute the elements of the\nfunction vector that need\nto be computed (the other\nare ignored) abstract interface private  subroutine spars_f(me, x) The function to compute the sparsity pattern.\nIt populates the irow and icol variables in the class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) abstract interface private  subroutine info_f(me, column, i, x) User-defined info function (optional).\nInforms user what is being done during Jacobian computation.\nIt can be used to perform any setup operations that need to\ndone on the user's end. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in), dimension(:) :: column the columns being computed. integer, intent(in) :: i perturbing these columns for the i th time (1,2,...) real(kind=wp), intent(in), dimension(:) :: x the nominal variable vector abstract interface private  subroutine jacobian_f(me, x, dx, jac) Actual function for computing the Jacobian\ncalled by compute_jacobian . Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0) for each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector (size num_nonzero_elements ) Derived Types type, public :: finite_diff_method defines the finite difference method\nused to compute the Jacobian. Read more… Components Type Visibility Attributes Name Initial integer, private :: id = 0 unique ID for the method character(len=:), private, allocatable :: name the name of the method integer, private :: class = 0 2=backward diffs, 3=central diffs, etc... real(kind=wp), private, dimension(:), allocatable :: dx_factors multiplicative factors for dx perturbation real(kind=wp), private, dimension(:), allocatable :: df_factors multiplicative factors for accumulating function evaluations real(kind=wp), private :: df_den_factor = zero denominator factor for finite difference equation (times dx ) Constructor constructor private\n\n                    \n                    function initialize_finite_difference_method (id, name, class, dx_factors, df_factors, df_den_factor) Constructor for a finite_diff_method . Read more… Type-Bound Procedures procedure, public :: get_formula procedure, public :: print => print_finite_difference_method type, public :: meth_array to store an array of finite_diff_method types\nthis is used when the mode=2 option is used\nin numdiff_type Components Type Visibility Attributes Name Initial type( finite_diff_method ), private, dimension(:), allocatable :: meth type, public :: sparsity_pattern A sparsity pattern Components Type Visibility Attributes Name Initial logical, private :: sparsity_computed = .false. has the sparsity pattern already been computed? integer, private :: num_nonzero_elements = 0 number of nonzero elements in the jacobian\n(will be the dimension of irow and icol ) integer, private, dimension(:), allocatable :: irow sparsity pattern - rows of non-zero elements integer, private, dimension(:), allocatable :: icol sparsity pattern - columns of non-zero elements logical, private :: linear_sparsity_computed = .false. if the linear pattern has been populated integer, private :: num_nonzero_linear_elements = 0 number of constant elements in the jacobian integer, private, dimension(:), allocatable :: linear_irow linear sparsity pattern - rows of non-zero elements integer, private, dimension(:), allocatable :: linear_icol linear sparsity pattern - columns of non-zero elements real(kind=wp), private, dimension(:), allocatable :: linear_vals linear elements of the jacobian integer, private, dimension(:), allocatable :: indices index vector [1,2,...,num_nonzero_elements] for putting df into jac integer, private :: maxgrp = 0 the number of groups in the partition\nof the columns of a . integer, private, dimension(:), allocatable :: ngrp specifies the partition of the columns of a .\ncolumn jcol belongs to group ngrp(jcol) . size(n) Type-Bound Procedures procedure, private :: dsm_wrapper procedure, private :: compute_indices procedure, public :: destroy => destroy_sparsity procedure, public :: print => print_sparsity procedure, public :: columns_in_partition_group type, public :: numdiff_type base type for sparsity and Jacobian computations. Components Type Visibility Attributes Name Initial logical, private :: exception_raised = .false. if true, an exception has been raised integer, private :: istat = 0 a non-zero value will cause all routine to exit.\nthis can be set to -1 by calling terminate . character(len=:), private, allocatable :: error_msg error message (if istat/=0 ) integer, private :: n = 0 number of x variables integer, private :: m = 0 number of f functions real(kind=wp), private, dimension(:), allocatable :: xlow lower bounds on x real(kind=wp), private, dimension(:), allocatable :: xhigh upper bounds on x logical, private :: print_messages = .true. if true, warning messages are printed\nto the error_unit for any errors. integer, private :: chunk_size = 100 chuck size for allocating the arrays (>0) integer, private :: perturb_mode = 1 perturbation mode: Read more… real(kind=wp), private, dimension(:), allocatable :: dpert perturbation vector for x logical, private :: partition_sparsity_pattern = .false. to partition the sparsity pattern using dsm type( sparsity_pattern ), private :: sparsity the sparsity pattern real(kind=wp), private, dimension(:), allocatable :: xlow_for_sparsity lower bounds on x for computing sparsity (optional) real(kind=wp), private, dimension(:), allocatable :: xhigh_for_sparsity upper bounds on x for computing sparsity (optional) real(kind=wp), private, dimension(:), allocatable :: dpert_for_sparsity perturbation vector for x when computing\nsparsity for sparsity_mode=4 integer, private :: num_sparsity_points = 3 for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern.\nSee compute_sparsity_random_2 integer, private :: sparsity_perturb_mode = 1 perturbation mode (if sparsity_mode=4 ): Read more… logical, private :: compute_linear_sparsity_pattern = .false. to also compute the linear sparsity pattern real(kind=wp), private :: linear_sparsity_tol = epsilon(1.0_wp) the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), private :: function_precision_tol = epsilon(1.0_wp) the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, private :: mode = 1 1 = use meth (specified methods), 2 = use class (specified class, method is selected on-the-fly). type( finite_diff_method ), private, dimension(:), allocatable :: meth the finite difference method to use\ncompute the n th column of the Jacobian size(n) .  Either this or class is used integer, private, dimension(:), allocatable :: class the class of method to use to\ncompute the n th column of the Jacobian size(n) . Either this or meth is used type( meth_array ), private, dimension(:), allocatable :: class_meths array of methods for the specified classes.\nused with class when mode=2 real(kind=wp), private :: eps = 1.0e-9_wp tolerance parameter for diff real(kind=wp), private :: acc = 0.0_wp tolerance parameter for diff type( function_cache ), private :: cache if using the function cache logical, private :: use_diff = .false. if we are using the Neville's process method,\nrather than finite differences procedure( func ), private, pointer :: problem_func => null() the user-defined function procedure( func ), private, pointer :: compute_function => null() compute the user-defined function\nthis can point to the problem_func or, if using\nthe cache, it points to compute_function_with_cache . procedure( spars_f ), private, pointer :: compute_sparsity => null() for computing the sparsity pattern procedure( info_f ), private, pointer :: info_function => null() an optional function the user can define\nwhich is called when each column of the jacobian is computed.\nIt can be used to perform any setup operations. procedure( jacobian_f ), private, pointer :: jacobian_function => null() the low-level function called by compute_jacobian that actually computes the jacobian. Type-Bound Procedures procedure, public :: initialize => initialize_numdiff initialize the class procedure, public :: diff_initialize => initialize_numdiff_for_diff initialize the class procedure, public :: compute_jacobian main routine to compute the Jacobian\nusing the selected options. It\nreturns the sparse (vector) form. procedure, public :: compute_jacobian_dense return the dense size(m,n) matrix form of the Jacobian. procedure, public :: compute_jacobian_times_vector returns the product of the Jacobian\nmatrix and an input vector procedure, public :: destroy => destroy_numdiff_type destroy the class procedure, public :: print_sparsity_pattern print the sparsity pattern in vector form to a file procedure, public :: print_sparsity_matrix print the sparsity pattern in matrix form to a file procedure, public :: set_sparsity_pattern manually set the sparsity pattern procedure, public :: select_finite_diff_method select a method in a specified class so\nthat the variable bounds are not violated\nwhen by the perturbations. procedure, public :: select_finite_diff_method_for_partition_group version of select_finite_diff_method for partitioned sparsity pattern. procedure, public :: set_numdiff_bounds can be called to change the variable bounds. procedure, public :: compute_sparsity_pattern if the user needs to compute the sparsity pattern manually.\n(otherwise it will be done the first time the Jacobian is computed) procedure, public :: get_sparsity_pattern returns the sparsity pattern (if it is allocated) procedure, public :: terminate can be called by user to stop the computation procedure, public :: failed to check if an exception was raised. procedure, public :: get_error_status the status of error condition procedure, private :: destroy_sparsity_pattern destroy the sparsity pattern procedure, private :: compute_perturb_vector procedure, private :: compute_perturbation_vector computes the variable perturbation factor procedure, private :: compute_sparsity_perturbation_vector procedure, private :: perturb_x_and_compute_f procedure, private :: perturb_x_and_compute_f_partitioned procedure, private :: set_numdiff_sparsity_bounds procedure, private :: set_sparsity_mode procedure, private :: generate_dense_sparsity_partition procedure, private :: compute_jacobian_for_sparsity procedure, private :: resize_sparsity_vectors procedure, private :: raise_exception procedure, private :: clear_exceptions Functions private  function initialize_finite_difference_method (id, name, class, dx_factors, df_factors, df_den_factor) result(me) Constructor for a finite_diff_method . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: id unique ID for the method character(len=*), intent(in) :: name the name of the method integer, intent(in) :: class 2=backward diffs, 3=central diffs, etc... integer, intent(in), dimension(:) :: dx_factors multiplicative factors for dx perturbation integer, intent(in), dimension(:) :: df_factors multiplicative factors for accumulating function evaluations integer, intent(in) :: df_den_factor denominator factor for finite difference equation (times dx) Return Value type( finite_diff_method ) public  function get_all_methods_in_class (class) result(list_of_methods) Returns all the methods with the given class (i.e., number of points in the formula). Arguments Type Intent Optional Attributes Name integer, intent(in) :: class the class is the number of points in the\nfinite different computation Return Value type( meth_array ) all the methods with the specified class private pure function failed (me) Returns True if an exception has been raised. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(in) :: me Return Value logical private  function integer_to_string (i, with_sign) result(str) Convert an integer to a string. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i the integer logical, intent(in), optional :: with_sign also include the sign (default is False) Return Value character(len=:), allocatable integer converted to a string Subroutines private  subroutine print_finite_difference_method (me, iunit) Print the contents of a finite_diff_method . Used for debugging. Arguments Type Intent Optional Attributes Name class( finite_diff_method ), intent(in) :: me integer, intent(in) :: iunit file unit for printing\n(assumed to be opened) private  subroutine compute_function_with_cache (me, x, f, funcs_to_compute) Wrapper for computing the function, using the cache. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x array of variables (size n ) real(kind=wp), intent(out), dimension(:) :: f array of functions (size m ) integer, intent(in), dimension(:) :: funcs_to_compute the elements of the\nfunction vector that need\nto be computed (the other\nare ignored) private  subroutine get_formula (me, formula) Return a string with the finite difference formula. Read more… Arguments Type Intent Optional Attributes Name class( finite_diff_method ), intent(in) :: me character(len=:), intent(out), allocatable :: formula public  subroutine get_finite_diff_formula (id, formula, name) Return a string with the finite difference formula.\n  Input is the method id code. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: id the id code for the method character(len=:), intent(out), allocatable :: formula the formula string character(len=:), intent(out), optional, allocatable :: name private  subroutine get_finite_difference_method (id, fd, found) Return a finite_diff_method given the id code.\n  (the id codes begin at 1, are sequential, and uniquely define the method). Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: id the id code for the method type( finite_diff_method ), intent(out) :: fd this method (can be used\nin compute_jacobian ) logical, intent(out) :: found true if it was found private  subroutine select_finite_diff_method (me, x, xlow, xhigh, dx, list_of_methods, fd, status_ok) Select a finite diff method of a given class so that the perturbations\nof x will not violate the variable bounds. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in) :: x the variable value real(kind=wp), intent(in) :: xlow the variable lower bound real(kind=wp), intent(in) :: xhigh the variable upper bound real(kind=wp), intent(in) :: dx the perturbation value (>0) type( meth_array ), intent(in) :: list_of_methods list of available methods to choose from type( finite_diff_method ), intent(out) :: fd this method can be used logical, intent(out) :: status_ok true if it really doesn't violate the bounds\n(say, the bounds are very close to each other)\nif status_ok=False , then the first method in\nthe given class is returned in fd . private  subroutine select_finite_diff_method_for_partition_group (me, x, xlow, xhigh, dx, list_of_methods, fd, status_ok) Select a finite diff method of a given class so that the perturbations\nof x will not violate the variable bounds for any variable in the group. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x the variable values real(kind=wp), intent(in), dimension(:) :: xlow the variable lower bounds real(kind=wp), intent(in), dimension(:) :: xhigh the variable upper bounds real(kind=wp), intent(in), dimension(:) :: dx the perturbation values (>0) type( meth_array ), intent(in) :: list_of_methods list of available methods to choose from type( finite_diff_method ), intent(out) :: fd this method can be used logical, intent(out) :: status_ok true if it really doesn't violate the bounds\n(say, the bounds are very close to each other)\nif status_ok=False , then the first method in\nthe given class is returned in fd . private  subroutine initialize_numdiff_for_diff (me, n, m, xlow, xhigh, problem_func, sparsity_mode, info, chunk_size, eps, acc, cache_size, xlow_for_sparsity, xhigh_for_sparsity, dpert_for_sparsity, sparsity_perturb_mode, linear_sparsity_tol, function_precision_tol, num_sparsity_points, print_messages) Alternate version of initialize_numdiff routine when\nusing diff to compute the Jacobian. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: n number of x variables integer, intent(in) :: m number of f functions real(kind=wp), intent(in), dimension(n) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(n) :: xhigh upper bounds on x procedure( func ) :: problem_func the user function that defines the problem\n(returns m functions) integer, intent(in) :: sparsity_mode the sparsity computation method: Read more… procedure( info_f ), optional :: info a function the user can define\nwhich is called when each column\nof the jacobian is computed.\nIt can be used to perform any\nsetup operations. integer, intent(in), optional :: chunk_size chunk size for allocating the arrays\n(must be >0) [default is 100] real(kind=wp), intent(in), optional :: eps tolerance parameter for diff if not present, default is 1.0e-9_wp real(kind=wp), intent(in), optional :: acc tolerance parameter for diff if not present, default is 0.0_wp integer, intent(in), optional :: cache_size if present, this is the cache size\nfor the function cache\n(default is not to enable cache) real(kind=wp), intent(in), optional, dimension(n) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(n) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. real(kind=wp), intent(in), optional, dimension(n) :: dpert_for_sparsity required if sparsity_mode=4 integer, intent(in), optional :: sparsity_perturb_mode perturbation mode (required if sparsity_mode=4 ): Read more… real(kind=wp), intent(in), optional :: linear_sparsity_tol the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), intent(in), optional :: function_precision_tol the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, intent(in), optional :: num_sparsity_points for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern. logical, intent(in), optional :: print_messages if true, print error messages to error_unit .\ndefault is True. private  subroutine set_numdiff_bounds (me, xlow, xhigh) Change the variable bounds in a numdiff_type . Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(:) :: xhigh upper bounds on x private  subroutine set_sparsity_mode (me, sparsity_mode, xlow_for_sparsity, xhigh_for_sparsity) Set sparsity mode. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. real(kind=wp), intent(in), optional, dimension(:) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(:) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. private  subroutine set_numdiff_sparsity_bounds (me, xlow, xhigh) Sets the variable bounds for sparsity in a numdiff_type .\n  These are only used for sparsity_mode=2 . Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), optional, dimension(:) :: xlow lower bounds on x to be used for\nsparsity computation. If not present,\nthen then xlow values in the class are used. real(kind=wp), intent(in), optional, dimension(:) :: xhigh upper bounds on x to be used for\nsparsity computation. If not present,\nthen then xhigh values in the class are used. private  subroutine initialize_numdiff (me, n, m, xlow, xhigh, perturb_mode, dpert, problem_func, sparsity_mode, jacobian_method, jacobian_methods, class, classes, info, chunk_size, partition_sparsity_pattern, cache_size, xlow_for_sparsity, xhigh_for_sparsity, dpert_for_sparsity, sparsity_perturb_mode, linear_sparsity_tol, function_precision_tol, num_sparsity_points) Initialize a numdiff_type class. This must be called first. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: n number of x variables integer, intent(in) :: m number of f functions real(kind=wp), intent(in), dimension(n) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(n) :: xhigh upper bounds on x integer, intent(in) :: perturb_mode perturbation mode: 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), dimension(n) :: dpert perturbation vector for x procedure( func ) :: problem_func the user function that defines the problem\n(returns m functions) integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. integer, intent(in), optional :: jacobian_method id code for the finite difference method\nto use for all n variables.\nsee get_finite_difference_method integer, intent(in), optional, dimension(n) :: jacobian_methods id codes for the finite difference method\nto use for each variable.\nsee get_finite_difference_method integer, intent(in), optional :: class method class for the finite difference method\nto use for all n variables.\nsee get_finite_difference_method integer, intent(in), optional, dimension(n) :: classes method class for the finite difference methods\nto use for each variable.\nsee get_finite_difference_method procedure( info_f ), optional :: info a function the user can define\nwhich is called when each column\nof the jacobian is computed.\nIt can be used to perform any\nsetup operations. integer, intent(in), optional :: chunk_size chunk size for allocating the arrays\n(must be >0) [default is 100] logical, intent(in), optional :: partition_sparsity_pattern if the sparisty pattern is to\nbe partitioned using DSM [default is False] integer, intent(in), optional :: cache_size if present, this is the cache size\nfor the function cache\n(default is not to enable cache) real(kind=wp), intent(in), optional, dimension(n) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(n) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. real(kind=wp), intent(in), optional, dimension(n) :: dpert_for_sparsity for sparsity_mode=4 , the perturbation integer, intent(in), optional :: sparsity_perturb_mode perturbation mode (required if sparsity_mode=4 ): 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), optional :: linear_sparsity_tol the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), intent(in), optional :: function_precision_tol the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, intent(in), optional :: num_sparsity_points for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern. private  subroutine destroy_numdiff_type (me) destroy the numdiff_type class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(out) :: me private  subroutine destroy_sparsity (me) destroy a sparsity_pattern type. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(out) :: me private  subroutine dsm_wrapper (me, n, m, info) Wrapper for dsm to compute the sparsity pattern partition. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(inout) :: me integer, intent(in) :: n number of columns of jacobian matrix integer, intent(in) :: m number of rows of jacobian matrix integer, intent(out) :: info status output from dsm private  subroutine columns_in_partition_group (me, igroup, n_cols, cols, nonzero_rows, indices, status_ok) Returns the columns in a sparsity partition group. Read more… Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(in) :: me integer, intent(in) :: igroup group number. Should be >0 and <=me%mxgrp integer, intent(out) :: n_cols number of columns in the igroup group. integer, intent(out), dimension(:), allocatable :: cols the column numbers in the igroup group.\n(if none, then it is not allocated) integer, intent(out), dimension(:), allocatable :: nonzero_rows the row numbers of all the nonzero\nJacobian elements in this group integer, intent(out), dimension(:), allocatable :: indices nonzero indices in jac for a group logical, intent(out) :: status_ok true if the partition is valid private  subroutine destroy_sparsity_pattern (me) Destroy the sparsity pattern in the class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me private  subroutine compute_indices (me) Computes the indices vector in the class. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(inout) :: me private  subroutine set_sparsity_pattern (me, irow, icol, linear_irow, linear_icol, linear_vals, maxgrp, ngrp) To specify the sparsity pattern directly if it is already known. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in), dimension(:) :: irow sparsity pattern nonzero elements row indices integer, intent(in), dimension(:) :: icol sparsity pattern nonzero elements column indices integer, intent(in), optional, dimension(:) :: linear_irow linear sparsity pattern nonzero elements row indices integer, intent(in), optional, dimension(:) :: linear_icol linear sparsity pattern nonzero elements column indices real(kind=wp), intent(in), optional, dimension(:) :: linear_vals linear sparsity values (constant elements of the Jacobian) integer, intent(in), optional :: maxgrp DSM sparsity partition\n[only used if me%partition_sparsity_pattern=True ] integer, intent(in), optional, dimension(:) :: ngrp DSM sparsity partition (size n )\n[only used if me%partition_sparsity_pattern=True ] private  subroutine compute_sparsity_dense (me, x) assume all elements of Jacobian are non-zero. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) private  subroutine generate_dense_sparsity_partition (me) Generate a \"dense\" sparsity partition. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me private  subroutine compute_sparsity_random (me, x) Compute the sparsity pattern by computing the function at three\n\"random\" points in the [ xlow_for_sparsity , xhigh_for_sparsity ] interval\nand checking if the function values are the same. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n )\n(not used here) private  subroutine resize_sparsity_vectors (me, n_icol, n_irow, n_linear_icol, n_linear_irow, n_linear_vals) Resize the sparsity arrays after accumulating them. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(inout) :: n_icol integer, intent(inout) :: n_irow integer, intent(inout) :: n_linear_icol integer, intent(inout) :: n_linear_irow integer, intent(inout) :: n_linear_vals private  subroutine compute_sparsity_random_2 (me, x) Compute the sparsity pattern by computing a 2-point jacobian at a specified\nnumber of \"random\" points ( num_sparsity_points ) in the\n[ xlow_for_sparsity , xhigh_for_sparsity ] interval and checking if\nthey are the same. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n )\n(not used here) private  subroutine compute_sparsity_pattern (me, x, irow, icol, linear_irow, linear_icol, linear_vals) Computes the sparsity pattern and return it.\nUses the settings currently in the class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) integer, intent(out), dimension(:), allocatable :: irow sparsity pattern nonzero elements row indices integer, intent(out), dimension(:), allocatable :: icol sparsity pattern nonzero elements column indices integer, intent(out), optional, dimension(:), allocatable :: linear_irow linear sparsity pattern\nnonzero elements row indices integer, intent(out), optional, dimension(:), allocatable :: linear_icol linear sparsity pattern nonzero\nelements column indices real(kind=wp), intent(out), optional, dimension(:), allocatable :: linear_vals linear sparsity values (constant\nelements of the Jacobian) private  subroutine get_sparsity_pattern (me, irow, icol, linear_irow, linear_icol, linear_vals, maxgrp, ngrp) Returns the sparsity pattern from the class.\nIf it hasn't been computed, the output arrays will not be allocated. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: irow sparsity pattern nonzero elements row indices integer, intent(out), dimension(:), allocatable :: icol sparsity pattern nonzero elements column indices integer, intent(out), optional, dimension(:), allocatable :: linear_irow linear sparsity pattern\nnonzero elements row indices integer, intent(out), optional, dimension(:), allocatable :: linear_icol linear sparsity pattern nonzero\nelements column indices real(kind=wp), intent(out), optional, dimension(:), allocatable :: linear_vals linear sparsity values (constant\nelements of the Jacobian) integer, intent(out), optional :: maxgrp DSM sparsity partition integer, intent(out), optional, dimension(:), allocatable :: ngrp DSM sparsity partition private  subroutine compute_jacobian_dense (me, x, jac) just a wrapper for compute_jacobian , that returns a dense ( m x n ) matrix. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:,:), allocatable :: jac the jacobian matrix private  subroutine perturb_x_and_compute_f (me, x, dx_factor, dx, df_factor, column, idx, df) Perturb the specified optimization variable, and compute the function.\nThis routine is designed so that df is accumulated as each function\nevaluation is done, to avoid having to allocate more temporary storage. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x nominal variable vector real(kind=wp), intent(in) :: dx_factor factor to multiply dx real(kind=wp), intent(in), dimension(:) :: dx the perturbation value for this column real(kind=wp), intent(in) :: df_factor factor to multiply function value integer, intent(in) :: column the variable to perturb integer, intent(in), dimension(:) :: idx the elements in this\ncolumn of the Jacobian\nto compute (passed to function) real(kind=wp), intent(inout), dimension(me%m) :: df the accumulated function value\nnote: for the first call, this\nshould be set to zero private  subroutine compute_jacobian_times_vector (me, x, v, z) Returns the product J*v , where J is the m x n Jacobian matrix\n  and v is an n x 1 vector. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(:) :: v vector (size n ) real(kind=wp), intent(out), dimension(:) :: z The product J*v (size m ) private  subroutine compute_jacobian (me, x, jac) Compute the Jacobian. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:), allocatable :: jac sparse jacobian vector private  subroutine compute_jacobian_for_sparsity (me, i, class_meths, x, jac) A separate version of compute_jacobian to be used only when\n  computing the sparsity pattern in compute_sparsity_random_2 .\n  It uses class_meths and the sparsity dperts and bounds. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: i the column being computed type( meth_array ), intent(in) :: class_meths set of finite diff methods to use real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:), allocatable :: jac sparse jacobian vector private  subroutine compute_jacobian_standard (me, x, dx, jac) Compute the Jacobian using finite differences.\n(one column at a time) Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector (size num_nonzero_elements ) private  subroutine compute_jacobian_with_diff (me, x, dx, jac) Compute the Jacobian one element at a time using the Neville's process\nalgorithm diff . This takes a very large number of function evaluations,\nbut should give a very accurate answer. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector (size num_nonzero_elements ) private  subroutine compute_jacobian_partitioned (me, x, dx, jac) Compute the Jacobian using finite differences,\n(using the partitioned sparsity pattern to compute multiple columns\nat a time). Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0) for each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector private  subroutine perturb_x_and_compute_f_partitioned (me, x, dx_factor, dx, df_factor, columns, idx, df) Perturb the specified optimization variable, and compute the function.\nThis routine is designed so that df is accumulated as each function\nevaluation is done, to avoid having to allocate more temporary storage. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x nominal variable vector real(kind=wp), intent(in) :: dx_factor factor to multiply dx real(kind=wp), intent(in), dimension(:) :: dx the perturbation value for this column real(kind=wp), intent(in) :: df_factor factor to multiply function value integer, intent(in), dimension(:) :: columns the variables to perturb integer, intent(in), dimension(:) :: idx the elements in this\ncolumn of the Jacobian\nto compute (passed to function) real(kind=wp), intent(inout), dimension(me%m) :: df the accumulated function value\nnote: for the first call, this\nshould be set to zero private  subroutine compute_perturb_vector (me, x, dpert, perturb_mode, dx) Compute dx , the perturbation vector for x Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dpert integer, intent(in) :: perturb_mode real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable private  subroutine compute_perturbation_vector (me, x, dx) Compute dx , the perturbation vector for x used\nwhen computing the gradients. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable private  subroutine compute_sparsity_perturbation_vector (me, x, dx) Compute dx , the perturbation vector for x used\nwhen computing the sparsity pattern. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable private  subroutine print_sparsity (me, n, m, iunit, dense) Print the sparsity pattern. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(in) :: me integer, intent(in) :: n number of variables (columns of jacobian) integer, intent(in) :: m number of functions (rows of jacobian) integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) logical, intent(in), optional :: dense if present and true, the matrix form\nof the sparsity pattern is printed\n(default is vector form) private  subroutine print_sparsity_pattern (me, iunit) Print the sparsity pattern in vector form ( irow , icol ). Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) private  subroutine print_sparsity_matrix (me, iunit) Print the sparsity pattern in matrix form. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) private  subroutine terminate (me) A user-callable routine. When called, it will terminate\nall computations and return. The istat return code will be\nset to -1 . This can be called in the function or the info function. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me private  subroutine raise_exception (me, istat, routine, error_msg) Raise an exception. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: istat error code. character(len=*), intent(in) :: routine the routine where the error was raised. character(len=*), intent(in) :: error_msg error message string. private  subroutine clear_exceptions (me) Clear all exceptions. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me private  subroutine get_error_status (me, istat, error_msg) Returns the current error code and message. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(in) :: me integer, intent(out), optional :: istat error code ( istat=0 means no errors). character(len=:), intent(out), optional, allocatable :: error_msg error message string.","tags":"","loc":"module/numerical_differentiation_module.html"},{"title":"problem_15_module – AoC-2023","text":"A module for problem 15, part 2. Uses iso_fortran_env aoc_utilities module~~problem_15_module~~UsesGraph module~problem_15_module problem_15_module iso_fortran_env iso_fortran_env module~problem_15_module->iso_fortran_env module~aoc_utilities aoc_utilities module~problem_15_module->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~problem_15_module~~UsedByGraph module~problem_15_module problem_15_module program~problem_15 problem_15 program~problem_15->module~problem_15_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: lens Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: label integer(kind=ip), public :: focal_length = 0 type, public :: box Components Type Visibility Attributes Name Initial type( lens ), public, dimension(:), allocatable :: lenses the lenses in the box Type-Bound Procedures procedure, public :: add_lens procedure, public :: remove_lens Subroutines public  subroutine add_lens (me, l) Arguments Type Intent Optional Attributes Name class( box ), intent(inout) :: me type( lens ), intent(in) :: l lense to add public  subroutine remove_lens (me, label) remove the lens with the label (if present) Arguments Type Intent Optional Attributes Name class( box ), intent(inout) :: me character(len=*), intent(in) :: label","tags":"","loc":"module/problem_15_module.html"},{"title":"diff_module – AoC-2023","text":"Numerical differentiation of a 1D function f(x) using Neville's process. Authors J. Oliver, \"An algorithm for numerical differentiation of a function\n     of one real variable\", Journal of Computational and Applied Mathematics\n     6 (2) (1980) 145–160. [Algol 60 source in original paper] David Kahaner, Fortran 77 code from NIST Jacob Williams : 2/17/2013 : Converted to modern Fortran.\n     Some refactoring, addition of test cases. Uses numdiff_kinds_module module~~diff_module~~UsesGraph module~diff_module diff_module module~numdiff_kinds_module numdiff_kinds_module module~diff_module->module~numdiff_kinds_module iso_fortran_env iso_fortran_env module~numdiff_kinds_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~diff_module~~UsedByGraph module~diff_module diff_module module~numerical_differentiation_module numerical_differentiation_module module~numerical_differentiation_module->module~diff_module program~test1 test1 program~test1->module~numerical_differentiation_module program~test2 test2 program~test2->module~numerical_differentiation_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface private  function func(me, x) result(fx) interface to function for diff Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me real(kind=wp), intent(in) :: x Return Value real(kind=wp) Derived Types type, public :: diff_func class to define the function for diff Components Type Visibility Attributes Name Initial logical, private :: stop = .false. procedure( func ), private, pointer :: f => null() Type-Bound Procedures procedure, private :: faccur procedure, public :: set_function procedure, public :: compute_derivative => diff procedure, public :: terminate Subroutines private  subroutine set_function (me, f) Author Jacob Williams Date 12/27/2015 Set the function in a diff_func .\nMust be called before diff . Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me procedure( func ) :: f private  subroutine terminate (me) Can be called by the user in the function to terminate the computation.\nThis will set ifail=-1 . Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me private  subroutine diff (me, iord, x0, xmin, xmax, eps, accr, deriv, error, ifail) the procedure diff calculates the first, second or\nthird order derivative of a function by using neville's process to\nextrapolate from a sequence of simple polynomial approximations based on\ninterpolating points distributed symmetrically about x0 (or lying only on\none side of x0 should this be necessary).  if the specified tolerance is\nnon-zero then the procedure attempts to satisfy this absolute or relative\naccuracy requirement, while if it is unsuccessful or if the tolerance is\nset to zero then the result having the minimum achievable estimated error\nis returned instead. Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me integer, intent(in) :: iord 1, 2 or 3 specifies that the first, second or third order\nderivative,respectively, is required. real(kind=wp), intent(in) :: x0 the point at which the derivative of the function is to be calculated. real(kind=wp), intent(in) :: xmin xmin , xmax restrict the interpolating points to lie in [ xmin , xmax ], which\nshould be the largest interval including x0 in which the function is\ncalculable and continuous. real(kind=wp), intent(in) :: xmax xmin , xmax restrict the interpolating points to lie in [ xmin , xmax ], which\nshould be the largest interval including x0 in which the function is\ncalculable and continuous. real(kind=wp), intent(in) :: eps denotes the tolerance, either absolute or relative. eps=0 specifies that\nthe error is to be minimised, while eps>0 or eps<0 specifies that the\nabsolute or relative error, respectively, must not exceed abs(eps) if\npossible.  the accuracy requirement should not be made stricter than\nnecessary, since the amount of computation tends to increase as\nthe magnitude of eps decreases, and is particularly high when eps=0 . real(kind=wp), intent(in) :: accr denotes that the absolute ( accr>0 ) or relative ( accr<0 ) errors in the\ncomputed values of the function are most unlikely to exceed abs(accr) , which\nshould be as small as possible.  if the user cannot estimate accr with\ncomplete confidence, then it should be set to zero. real(kind=wp), intent(out) :: deriv the calculated value of the derivative real(kind=wp), intent(out) :: error an estimated upper bound on the magnitude of the absolute error in\nthe calculated result.  it should always be examined, since in extreme case\nmay indicate that there are no correct significant digits in the value\nreturned for derivative. integer, intent(out) :: ifail will have one of the following values on exit: 0 the procedure was successful. 1 the estimated error in the result exceeds the (non-zero) requested\n     error, but the most accurate result possible has been returned. 2 input data incorrect (derivative and error will be undefined). 3 the interval [ xmin , xmax ] is too small (derivative and error will be\n     undefined). -1 stopped by the user. private  subroutine faccur (me, h0, h1, facc, x0, twoinf, f0, f1, ifail) This procedure attempts to estimate the level of rounding errors in\nthe calculated function values near the point x0+h0 by fitting a\nleast-squares straight-line approximation to the function at the\nsix points x0+h0-j*h1 , ( j = 0,1,3,5,7,9 ), and then setting facc to\ntwice the largest deviation of the function values from this line. hi is adjusted if necessary so that it is approximately 8 times the\nsmallest spacing at which the function values are unequal near x0+h0 . Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me real(kind=wp), intent(inout) :: h0 real(kind=wp), intent(inout) :: h1 real(kind=wp), intent(out) :: facc real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: twoinf real(kind=wp), intent(in) :: f0 real(kind=wp), intent(in) :: f1 integer, intent(out) :: ifail 0 if no error, -1 if user termination.","tags":"","loc":"module/diff_module.html"},{"title":"fmin_module – AoC-2023","text":"Module for fmin 1D derative-free function minimizer. License [BSD-3](https: Note The default real kind ( wp ) can be\n      changed using optional preprocessor flags.\n      This library was built with real kind: real(kind=real64) [8 bytes] Uses iso_fortran_env module~~fmin_module~~UsesGraph module~fmin_module fmin_module iso_fortran_env iso_fortran_env module~fmin_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~fmin_module~~UsedByGraph module~fmin_module fmin_module module~nlesolver_module nlesolver_module module~nlesolver_module->module~fmin_module program~test test program~test->module~fmin_module program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->module~nlesolver_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: fmin_rk = real64 real kind used by this module [8 bytes] integer, private, parameter :: wp = fmin_rk local copy of fmin_rk with a shorter name Abstract Interfaces abstract interface private  function func(x) result(f) interface for user function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x indep. variable Return Value real(kind=wp) function value f(x) Functions public  function fmin (f, ax, bx, tol) result(xmin) An approximation x to the point where f attains a minimum on\n  the interval (ax,bx) is determined. Read more… Arguments Type Intent Optional Attributes Name procedure( func ) :: f the function to minimize real(kind=wp), intent(in) :: ax left endpoint of initial interval real(kind=wp), intent(in) :: bx right endpoint of initial interval real(kind=wp), intent(in) :: tol desired length of the interval of\nuncertainty of the final result (>=0) Return Value real(kind=wp) abcissa approximating the point where\nf attains a minimum","tags":"","loc":"module/fmin_module.html"},{"title":"numdiff_utilities_module – AoC-2023","text":"Utility routines. Uses numdiff_kinds_module module~~numdiff_utilities_module~~UsesGraph module~numdiff_utilities_module numdiff_utilities_module module~numdiff_kinds_module numdiff_kinds_module module~numdiff_utilities_module->module~numdiff_kinds_module iso_fortran_env iso_fortran_env module~numdiff_kinds_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~numdiff_utilities_module~~UsedByGraph module~numdiff_utilities_module numdiff_utilities_module module~numdiff_cache_module numdiff_cache_module module~numdiff_cache_module->module~numdiff_utilities_module module~numerical_differentiation_module numerical_differentiation_module module~numerical_differentiation_module->module~numdiff_utilities_module module~numerical_differentiation_module->module~numdiff_cache_module program~test1 test1 program~test1->module~numerical_differentiation_module program~test2 test2 program~test2->module~numerical_differentiation_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: max_size_for_insertion_sort = 20 max size for using insertion sort. Interfaces public        interface expand_vector private pure subroutine expand_vector_int (vec, n, chunk_size, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) private pure subroutine expand_vector_real (vec, n, chunk_size, val, finished) Add elements to the real vector in chunks. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) real(kind=wp), intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) public        interface unique private  function unique_int (vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value integer, dimension(:), allocatable unique elements of ivec private  function unique_real (vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value real(kind=wp), dimension(:), allocatable unique elements of ivec public        interface sort_ascending private  subroutine sort_ascending_int (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_real (ivec) Sorts a real array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: ivec private        interface swap private pure elemental subroutine swap_int (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap_real (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: i1 real(kind=wp), intent(inout) :: i2 Functions private  function unique_int (vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value integer, dimension(:), allocatable unique elements of ivec private  function unique_real (vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value real(kind=wp), dimension(:), allocatable unique elements of ivec public pure function equal_within_tol (vals, tol) result(equal) Returns true if the values in the array are the same\n(to within the specified absolute tolerance). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: vals a set of values real(kind=wp), intent(in) :: tol a positive tolerance value Return Value logical true if they are equal\nwithin the tolerance public  function divide_interval (num_points) result(points) Returns a set of slightly randomized equally-spaced\n  points that divide an interval. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_points the number of points in the interval Return Value real(kind=wp), dimension(:), allocatable the resultant vector Subroutines private pure subroutine expand_vector_int (vec, n, chunk_size, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) private pure subroutine expand_vector_real (vec, n, chunk_size, val, finished) Add elements to the real vector in chunks. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) real(kind=wp), intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) private  subroutine sort_ascending_int (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_real (ivec) Sorts a real array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: ivec private pure elemental subroutine swap_int (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap_real (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: i1 real(kind=wp), intent(inout) :: i2","tags":"","loc":"module/numdiff_utilities_module.html"},{"title":"dsm_module – AoC-2023","text":"Jacobian partitioning using the DSM algorithm. Reference Argonne National Laboratory. MINPACK Project. July 1983.\n    Thomas F. Coleman, Burton S. Garbow, Jorge J. More Thomas F. Coleman, Burton S. Garbow, Jorge J. More, \"Algorithm 618:\n    FORTRAN subroutines for estimating sparse Jacobian Matrices\",\n    ACM Transactions on Mathematical Software (TOMS),\n    Volume 10 Issue 3, Sept. 1984, Pages 346-347 History Jacob Williams, Nov. 2016, extensive refactoring into modern Fortran. Uses numdiff_kinds_module module~~dsm_module~~UsesGraph module~dsm_module dsm_module module~numdiff_kinds_module numdiff_kinds_module module~dsm_module->module~numdiff_kinds_module iso_fortran_env iso_fortran_env module~numdiff_kinds_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~dsm_module~~UsedByGraph module~dsm_module dsm_module module~numerical_differentiation_module numerical_differentiation_module module~numerical_differentiation_module->module~dsm_module program~dsm_test dsm_test program~dsm_test->module~dsm_module program~test1 test1 program~test1->module~numerical_differentiation_module program~test2 test2 program~test2->module~numerical_differentiation_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine dsm (m, n, npairs, indrow, indcol, ngrp, maxgrp, mingrp, info, ipntr, jpntr) The purpose of dsm is to determine an optimal or near-\noptimal consistent partition of the columns of a sparse m by n matrix a . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m number of rows of a (>0) integer, intent(in) :: n number of columns of a (>0) integer, intent(in) :: npairs number of ( indrow , indcol ) pairs used\nto describe the sparsity pattern of a (>0) integer, intent(inout), dimension(npairs) :: indrow an integer array of length npairs . on input indrow must contain the row indices of the non-zero elements of a .\non output indrow is permuted so that the corresponding\ncolumn indices are in non-decreasing order. the column\nindices can be recovered from the array jpntr . integer, intent(inout), dimension(npairs) :: indcol an integer array of length npairs . on input indcol must contain the column indices of the non-zero elements of a . on output indcol is permuted so that the corresponding\nrow indices are in non-decreasing order. the row indices\ncan be recovered from the array ipntr . integer, intent(out), dimension(n) :: ngrp specifies the partition of the columns of a .\ncolumn jcol belongs to group ngrp(jcol) . integer, intent(out) :: maxgrp the number of groups in the partition\nof the columns of a . integer, intent(out) :: mingrp a lower bound for the number of groups\nin any consistent partition of the\ncolumns of a . integer, intent(out) :: info for normal termination info = 1 .\nif m , n , or npairs is not positive,\nthen info = 0 . if the k-th element of indrow is not an integer between\n1 and m or the k-th element of indcol is not an integer between 1 and n,\nthen info = -k . integer, intent(out), dimension(m+1) :: ipntr an integer output array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 .\nnote that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(out), dimension(n+1) :: jpntr jpntr is an integer output array of length n + 1 which\nspecifies the locations of the row indices in indrow.\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 .\nnote that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . private  subroutine degr (n, indrow, jpntr, indcol, ipntr, ndeg, iwa) Given the sparsity pattern of an m by n matrix a ,\n  this subroutine determines the degree sequence for\n  the intersection graph of the columns of a . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a . integer, intent(in), dimension(*) :: indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, intent(in), dimension(n+1) :: jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(in), dimension(*) :: indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, intent(in), dimension(*) :: ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(out), dimension(n) :: ndeg an integer output array of length n which\nspecifies the degree sequence. the degree of the j -th column of a is ndeg(j) . integer, dimension(n) :: iwa an integer work array of length n private  subroutine ido (m, n, Indrow, Jpntr, Indcol, Ipntr, Ndeg, List, Maxclq, Iwa1, Iwa2, Iwa3, Iwa4) given the sparsity pattern of an m by n matrix a , this\nsubroutine determines an incidence-degree ordering of the\ncolumns of a . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of a . integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a . integer, intent(in), dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, intent(in), dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(in), dimension(*) :: Indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, intent(in), dimension(m+1) :: Ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(in), dimension(n) :: Ndeg an integer input array of length n which specifies\nthe degree sequence. the degree of the j -th column\nof a is ndeg(j) . integer, intent(out), dimension(n) :: List an integer output array of length n which specifies\nthe incidence-degree ordering of the columns of a . the j -th\ncolumn in this order is list(j) . integer, intent(out) :: Maxclq an integer output variable set to the size\nof the largest clique found during the ordering. integer, dimension(0:n-1) :: Iwa1 integer work array of length n . integer, dimension(n) :: Iwa2 integer work array of length n . integer, dimension(n) :: Iwa3 integer work array of length n . integer, dimension(n) :: Iwa4 integer work array of length n . private  subroutine numsrt (n, Nmax, Num, Mode, Index, Last, Next) Given a sequence of integers, this subroutine groups\n  together those indices with the same sequence value\n  and, optionally, sorts the sequence into either\n  ascending or descending order. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable. integer :: Nmax a positive integer input variable. integer, dimension(n) :: Num an input array of length n which contains the\nsequence of integers to be grouped and sorted. it\nis assumed that the integers are each from the set 0,1,...,nmax . integer :: Mode an integer input variable. the sequence num is\nsorted in ascending order if mode is positive and in\ndescending order if mode is negative. if mode is 0,\nno sorting is done. integer, dimension(n) :: Index an integer output array of length n set so\nthat the sequence num(index(i)), i = 1,2,...,n is sorted according to the setting of mode.\nif mode is 0, index is not referenced. integer, dimension(0:Nmax) :: Last an integer output array of length nmax + 1 . the\nindex of num for the last occurrence of l is last(l) for any l = 0,1,...,nmax unless last(l) = 0 . in\nthis case l does not appear in num . integer, dimension(n) :: Next an integer output array of length n . if num(k) = l , then the index of num for the previous\noccurrence of l is next(k) for any l = 0,1,...,nmax unless next(k) = 0 . in this case there is no previous\noccurrence of l in num . private  subroutine seq (n, Indrow, Jpntr, Indcol, Ipntr, List, Ngrp, Maxgrp, Iwa) given the sparsity pattern of an m by n matrix a , this\nsubroutine determines a consistent partition of the\ncolumns of a by a sequential algorithm. Read more… Arguments Type Intent Optional Attributes Name integer :: n a positive integer input variable set to the number\nof columns of a . integer, dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(*) :: Indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, dimension(*) :: Ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(n) :: List an integer input array of length n which specifies\nthe order to be used by the sequential algorithm.\nthe j -th column in this order is list(j) . integer, dimension(n) :: Ngrp an integer output array of length n which specifies\nthe partition of the columns of a . column jcol belongs\nto group ngrp(jcol) . integer :: Maxgrp an integer output variable which specifies the\nnumber of groups in the partition of the columns of a . integer, dimension(n) :: Iwa an integer work array of length n private  subroutine setr (m, n, Indrow, Jpntr, Indcol, Ipntr, Iwa) given a column-oriented definition of the sparsity pattern\nof an m by n matrix a , this subroutine determines a\nrow-oriented definition of the sparsity pattern of a . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of a . integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a . integer, dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(*) :: Indcol an integer output array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, dimension(m+1) :: Ipntr an integer output array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(1) is set to 1 and that ipntr(m+1)-1 is\nthen the number of non-zero elements of the matrix a . integer, dimension(m) :: Iwa an integer work array of length m . private  subroutine slo (n, Indrow, Jpntr, Indcol, Ipntr, Ndeg, List, Maxclq, Iwa1, Iwa2, Iwa3, Iwa4) given the sparsity pattern of an m by n matrix a , this\nsubroutine determines the smallest-last ordering of the\ncolumns of a . Read more… Arguments Type Intent Optional Attributes Name integer :: n a positive integer input variable set to the number\nof columns of a . integer, dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(*) :: Indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, dimension(*) :: Ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(n) :: Ndeg an integer input array of length n which specifies\nthe degree sequence. the degree of the j -th column\nof a is ndeg(j) . integer, dimension(n) :: List an integer output array of length n which specifies\nthe smallest-last ordering of the columns of a . the j -th\ncolumn in this order is list(j) . integer :: Maxclq an integer output variable set to the size\nof the largest clique found during the ordering. integer, dimension(0:n-1) :: Iwa1 integer work array of length n integer, dimension(n) :: Iwa2 integer work array of length n integer, dimension(n) :: Iwa3 integer work array of length n integer, dimension(n) :: Iwa4 integer work array of length n private  subroutine srtdat (n, Nnz, Indrow, Indcol, Jpntr, Iwa) given the non-zero elements of an m by n matrix a in\narbitrary order as specified by their row and column\nindices, this subroutine permutes these elements so\nthat their column indices are in non-decreasing order. Read more… Arguments Type Intent Optional Attributes Name integer :: n a positive integer input variable set to the number\nof columns of a . integer :: Nnz a positive integer input variable set to the number\nof non-zero elements of a . integer, dimension(Nnz) :: Indrow an integer array of length nnz . on input indrow must contain the row indices of the non-zero elements of a .\non output indrow is permuted so that the corresponding\ncolumn indices of indcol are in non-decreasing order. integer, dimension(Nnz) :: Indcol an integer array of length nnz . on input indcol must contain the column indices of the non-zero elements\nof a . on output indcol is permuted so that these indices\nare in non-decreasing order. integer, dimension(n+1) :: Jpntr an integer output array of length n + 1 which\nspecifies the locations of the row indices in the output indrow . the row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(1) is set to 1 and that jpntr(n+1)-1 is then nnz . integer, dimension(n) :: Iwa an integer work array of length n . public  subroutine fdjs (m, n, Col, Ind, Npntr, Ngrp, Numgrp, d, Fjacd, Fjac) Given a consistent partition of the columns of an m by n jacobian matrix into groups, this subroutine computes\n  approximations to those columns in a given group.  the\n  approximations are stored into either a column-oriented\n  or a row-oriented pattern. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of the jacobian matrix. integer, intent(in) :: n a positive integer input variable set to the number\nof columns of the jacobian matrix. logical, intent(in) :: Col a logical input variable. if col is set true, then the\njacobian approximations are stored into a column-oriented\npattern. if col is set false, then the jacobian\napproximations are stored into a row-oriented pattern. integer, dimension(*) :: Ind an integer input array which contains the row\nindices for the non-zeroes in the jacobian matrix\nif col is true, and contains the column indices for\nthe non-zeroes in the jacobian matrix if col is false. integer, dimension(*) :: Npntr an integer input array which specifies the\nlocations of the row indices in ind if col is true, and\nspecifies the locations of the column indices in ind if col is false. if col is true, the indices for column j are ind(k), k = npntr(j),...,npntr(j+1)-1 .\nif col is false, the indices for row i are ind(k), k = npntr(i),...,npntr(i+1)-1 . Note that npntr(n+1)-1 if col is true, or npntr(m+1)-1 if col is false, is then the number of non-zero elements\nof the jacobian matrix. integer, dimension(n) :: Ngrp an integer input array of length n which specifies\nthe partition of the columns of the jacobian matrix.\ncolumn jcol belongs to group ngrp(jcol) . integer :: Numgrp a positive integer input variable set to a group\nnumber in the partition. the columns of the jacobian\nmatrix in this group are to be estimated on this call. real(kind=wp), dimension(n) :: d an input array of length n which contains the\ndifference parameter vector for the estimate of\nthe jacobian matrix columns in group numgrp . real(kind=wp), dimension(m) :: Fjacd an input array of length m which contains\nan approximation to the difference vector jac*d ,\nwhere jac denotes the jacobian matrix. real(kind=wp), dimension(*) :: Fjac an output array of length nnz , where nnz is the\nnumber of its non-zero elements. at each call of fdjs , fjac is updated to include the non-zero elements of the\njacobian matrix for those columns in group numgrp . fjac should not be altered between successive calls to fdjs .","tags":"","loc":"module/dsm_module.html"},{"title":"numdiff_cache_module – AoC-2023","text":"For caching function evaluations. Uses numdiff_utilities_module numdiff_kinds_module iso_fortran_env module~~numdiff_cache_module~~UsesGraph module~numdiff_cache_module numdiff_cache_module iso_fortran_env iso_fortran_env module~numdiff_cache_module->iso_fortran_env module~numdiff_kinds_module numdiff_kinds_module module~numdiff_cache_module->module~numdiff_kinds_module module~numdiff_utilities_module numdiff_utilities_module module~numdiff_cache_module->module~numdiff_utilities_module module~numdiff_kinds_module->iso_fortran_env module~numdiff_utilities_module->module~numdiff_kinds_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~numdiff_cache_module~~UsedByGraph module~numdiff_cache_module numdiff_cache_module module~numerical_differentiation_module numerical_differentiation_module module~numerical_differentiation_module->module~numdiff_cache_module program~test1 test1 program~test1->module~numerical_differentiation_module program~test2 test2 program~test2->module~numerical_differentiation_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, private :: fx an [x,f(x)] cached pair. Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:), allocatable :: x vector of input values real(kind=wp), private, dimension(:), allocatable :: f vector of output functions f(x) note: only the elements indicated by ifs will have valid values. The others will\nbe dummy values. integer, private, dimension(:), allocatable :: ifs elements of f present in the cache\n(this is just an array of the indices\npresent in f ) type, public :: function_cache a vector function cache. Components Type Visibility Attributes Name Initial integer, private :: n = 0 size of x integer, private :: m = 0 size of f type( fx ), private, dimension(:), allocatable :: c the cache of f(x) integer, private :: chunk_size = 100 for resizing vectors\nin the unique function Type-Bound Procedures procedure, public :: initialize => initialize_cache procedure, public :: get => get_from_cache procedure, public :: put => put_in_cache procedure, public :: destroy => destroy_cache procedure, public :: print => print_cache Functions private pure function vector_djb_hash (r) result(hash) DJB hash algorithm for a real(wp) vector. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: r the vector Return Value integer(kind=ip) the hash value Subroutines private  subroutine initialize_cache (me, isize, n, m, chunk_size) Initialize the cache. Must be called first before use. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: isize the size of the hash table integer, intent(in) :: n number of independant variables (x) integer, intent(in) :: m number of functions (f) integer, intent(in), optional :: chunk_size chunk size to speed up reallocation\nof arrays. A good value is a guess for\nthe actual number of elements of f that\nwill be saved per value of x [default is 100] private  subroutine print_cache (me, iunit) Print the contents of the cache. Used for debugging. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: iunit file unit for writing\n(assumed to be opened) private  subroutine get_from_cache (me, x, ifs, i, f, xfound, ffound) Check if the x vector is in the cache, if so return f .\nNote that only some of the elements may be present, so it will return\nthe ones there are there, and indicate which ones were found. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x independant variable vector integer, intent(in), dimension(:) :: ifs elements of f needed integer, intent(out) :: i index in the hash table real(kind=wp), intent(out), dimension(:) :: f f(x) from the cache (if it was found) logical, intent(out) :: xfound if x was found in the cache logical, intent(out), dimension(size(ifs)) :: ffound which ifs were found in the cache private  subroutine put_in_cache (me, i, x, f, ifs) Put a value into the cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: i index in the hash table real(kind=wp), intent(in), dimension(:) :: x independant variable vector (dimension n ) real(kind=wp), intent(in), dimension(:) :: f function vector f(x) (dimension m ) integer, intent(in), dimension(:) :: ifs elements of f to add (should all be >0, <=m ) private  subroutine destroy_cache (me) Destroy a cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(out) :: me","tags":"","loc":"module/numdiff_cache_module.html"},{"title":"dag_module – AoC-2023","text":"DAG Module. Used by module~~dag_module~~UsedByGraph module~dag_module dag_module program~dag_example dag_example program~dag_example->module~dag_module program~problem_25 problem_25 program~problem_25->module~dag_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, private :: vertex a vertex of a directed acyclic graph (DAG) Components Type Visibility Attributes Name Initial integer, private, dimension(:), allocatable :: edges these are the vertices that this vertex depends on integer, private :: ivertex = 0 vertex number logical, private :: checking = .false. used for toposort logical, private :: marked = .false. used for toposort character(len=:), private, allocatable :: label used for diagraph character(len=:), private, allocatable :: attributes used for diagraph Type-Bound Procedures generic, public :: set_edges => set_edge_vector , add_edge procedure, public :: set_edge_vector procedure, public :: add_edge type, public :: dag a directed acyclic graph (DAG) Components Type Visibility Attributes Name Initial integer, private :: n = 0 number of vertices type( vertex ), private, dimension(:), allocatable :: vertices the vertices in the DAG. Type-Bound Procedures procedure, public :: set_vertices => dag_set_vertices procedure, public :: set_edges => dag_set_edges procedure, public :: set_vertex_info => dag_set_vertex_info procedure, public :: toposort => dag_toposort procedure, public :: generate_digraph => dag_generate_digraph procedure, public :: generate_dependency_matrix => dag_generate_dependency_matrix procedure, public :: save_digraph => dag_save_digraph procedure, public :: get_edges => dag_get_edges procedure, public :: get_dependencies => dag_get_dependencies procedure, public :: destroy => dag_destroy Functions private pure function dag_get_edges (me, ivertex) result(edges) get the edges for the vertex (all the the vertices\nthat this vertex depends on). Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer, intent(in) :: ivertex Return Value integer, dimension(:), allocatable private pure function dag_get_dependencies (me, ivertex) result(dep) get all the vertices that depend on this vertex. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer, intent(in) :: ivertex Return Value integer, dimension(:), allocatable the set of all vertices\nthan depend on ivertex private  function dag_generate_digraph (me, rankdir, dpi) result(str) Generate a Graphviz digraph structure for the DAG. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer, intent(in), optional :: dpi resolution (e.g. 300) Return Value character(len=:), allocatable private pure function integer_to_string (i) result(s) Integer to allocatable string. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=:), allocatable Subroutines private  subroutine dag_destroy (me) Destroy the dag . Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me private  subroutine set_edge_vector (me, edges) specify the edge indices for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in), dimension(:) :: edges private  subroutine add_edge (me, edge) add an edge index for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in) :: edge private  subroutine dag_set_vertices (me, nvertices) set the number of vertices in the dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: nvertices number of vertices private  subroutine dag_set_vertex_info (me, ivertex, label, attributes) set info about a vertex in a dag. Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: ivertex vertex number character(len=*), intent(in), optional :: label if a label is not set,\nthen the integer vertex\nnumber is used. character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. private  subroutine dag_set_edges (me, ivertex, edges) set the edges for a vertex in a dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: ivertex vertex number integer, intent(in), dimension(:) :: edges private  subroutine dag_toposort (me, order, istat) Main toposort routine Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: order the toposort order integer, intent(out) :: istat Status flag: Read more… private  subroutine dag_generate_dependency_matrix (me, mat) Generate the dependency matrix for the DAG. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me logical, intent(out), dimension(:,:), allocatable :: mat dependency matrix private  subroutine dag_save_digraph (me, filename, rankdir, dpi) Generate a Graphviz digraph structure for the DAG and write it to a file. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: filename file name for diagraph character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer, intent(in), optional :: dpi resolution (e.g. 300)","tags":"","loc":"module/dag_module.html"},{"title":"nlesolver_module – AoC-2023","text":"A basic multidimensional nonlinear equation solver, using a Newton-Raphson type direct method. Features Works with square, under-determined, or over-determined systems. Uses LAPACK routines ( dgesv or dgels ) to solve the linear system. Has a Broyden update option. Has various line search options. References https: http: http: http: Author Jacob Williams License BSD-3 Todo add an istat output to func and grad, for user stopping\n      or to take a smaller stop (if istat>0 take a smaller step, if istat<0 abort) Note The default real kind ( wp ) can be\n      changed using optional preprocessor flags.\n      This library was built with real kind: real(kind=real64) [8 bytes] Uses fmin_module iso_fortran_env module~~nlesolver_module~~UsesGraph module~nlesolver_module nlesolver_module iso_fortran_env iso_fortran_env module~nlesolver_module->iso_fortran_env module~fmin_module fmin_module module~nlesolver_module->module~fmin_module module~fmin_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~nlesolver_module~~UsedByGraph module~nlesolver_module nlesolver_module program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->module~nlesolver_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: nlesolver_rk = real64 real kind used by this module [8 bytes] integer, private, parameter :: wp = nlesolver_rk local copy of nlesolver_rk with a shorter name real(kind=wp), private, parameter :: zero = 0.0_wp real(kind=wp), private, parameter :: one = 1.0_wp real(kind=wp), private, parameter :: two = 2.0_wp real(kind=wp), private, parameter :: eps = epsilon(one) machine real(kind=wp), private, parameter :: big = huge(one) Abstract Interfaces abstract interface private  subroutine func_func(me, x, f) compute the function Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: f abstract interface private  subroutine grad_func(me, x, g) compute the gradient of the function (Jacobian): Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:,:) :: g abstract interface private  subroutine export_func(me, x, f, iter) export an iteration: Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: f integer, intent(in) :: iter iteration number abstract interface private  subroutine wait_func(me, user_stop) enable a user-triggered stop of the iterations: Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me logical, intent(out) :: user_stop abstract interface private  subroutine linesearch_func(me, xold, p, fjac, x, f, fvec) line search method. Note that not all inputs/outputs are\nused by all methods. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: xold previous value of x real(kind=wp), intent(in), dimension(me%n) :: p search direction real(kind=wp), intent(in), dimension(me%m,me%n) :: fjac jacobian matrix real(kind=wp), intent(out), dimension(me%n) :: x new x real(kind=wp), intent(inout) :: f real(kind=wp), intent(inout), dimension(me%m) :: fvec Derived Types type, public :: nlesolver_type Nonlinear equations solver class. Components Type Visibility Attributes Name Initial integer, private :: n = 0 number of opt vars integer, private :: m = 0 number of constraints integer, private :: max_iter = 100 maximum number of iterations real(kind=wp), private :: tol = 1.0e-6_wp convergence tolerance for function values real(kind=wp), private :: alpha = 1.0_wp step length (when specified constant) real(kind=wp), private :: alpha_min = 0.1_wp minimum step length (when allowed to vary) real(kind=wp), private :: alpha_max = 1.0_wp maximum step length (when allowed to vary) real(kind=wp), private :: tolx = 1.0e-8_wp convergence tolerance for x real(kind=wp), private :: c = 0.5_wp backtracking linesearch parameter (0,1) real(kind=wp), private :: tau = 0.5_wp backtracking linesearch parameter (0,1) real(kind=wp), private :: fmin_tol = 1.0e-5_wp tolerance for \"exact\" linesearch integer, private :: n_intervals = 2 number of intervals for fixed point linesearch logical, private :: use_broyden = .false. if true, a Broyden update is used\nrather than computing the Jacobian\nat every step. The grad function is\nonly called for the initial evaluation. integer, private :: broyden_update_n = 4 if this value is >0 , the Broyden update\nis computed at most this many times before\nthe full Jacobian is recomputed. integer, private :: n_uphill_max = 5 maximum number of consecutive steps\nto allow where the value of f increases logical, private :: verbose = .false. verbose output printing integer, private :: iunit = output_unit output unit for printing (assumed to be open). character(len=:), private, allocatable :: message latest status message integer, private :: istat = -999 latest status message procedure( func_func ), private, pointer :: func => null() user-supplied routine to compute the function procedure( grad_func ), private, pointer :: grad => null() user-supplied routine tocompute the gradient of the function procedure( export_func ), private, pointer :: export_iteration => null() user-supplied routine to export iterations procedure( wait_func ), private, pointer :: user_input_check => null() user-supplied routine to enable user to stop iterations procedure( linesearch_func ), private, pointer :: linesearch => null() line search method (determined by step_mode user input in initialize ) Type-Bound Procedures procedure, public :: initialize => initialize_nlesolver_variables procedure, public :: solve => nlesolver_solver procedure, public :: destroy => destroy_nlesolver_variables procedure, public :: status => get_status procedure, private :: set_status Subroutines private  subroutine set_status (me, istat, string, i, r) Set status flag and message. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me integer, intent(in) :: istat status code character(len=*), intent(in) :: string status message integer, intent(in), optional :: i an integer value to append real(kind=wp), intent(in), optional :: r a real value to append private  subroutine get_status (me, istat, message) Return the status code and message from the nlesolver_type class. Read more… Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me integer, intent(out), optional :: istat Integer status code. character(len=:), intent(out), optional, allocatable :: message Text status message private  subroutine initialize_nlesolver_variables (me, n, m, max_iter, tol, alpha, alpha_min, alpha_max, tolx, fmin_tol, backtrack_c, backtrack_tau, use_broyden, broyden_update_n, step_mode, func, grad, export_iteration, user_input_check, verbose, iunit, n_uphill_max, n_intervals) Constructor for the class. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me integer, intent(in) :: n number of optimization variables integer, intent(in) :: m number of constraints integer, intent(in) :: max_iter maximum number of iterations real(kind=wp), intent(in) :: tol function convergence tolerance real(kind=wp), intent(in), optional :: alpha constant step length for step_mode=1 (0,1] real(kind=wp), intent(in), optional :: alpha_min minimum step length (0,1] real(kind=wp), intent(in), optional :: alpha_max maximum step length (0,1] real(kind=wp), intent(in), optional :: tolx convergence tolerance for changes in x real(kind=wp), intent(in), optional :: fmin_tol convergence tolerance for fmin (used when step_mode=3 ) real(kind=wp), intent(in), optional :: backtrack_c backtracking linesearch parameter (0,1) real(kind=wp), intent(in), optional :: backtrack_tau backtracking linesearch parameter (0,1) logical, intent(in), optional :: use_broyden use a Broyden update (default is False) integer, intent(in), optional :: broyden_update_n For Broyden mode, update the full Jacobian\nat most every this many iterations (must be >1)\nIf <=1 then Jacobian is only computed on the\nfirst iteration. integer, intent(in), optional :: step_mode step mode: Read more… procedure( func_func ) :: func computes the function vector procedure( grad_func ) :: grad computes the jacobian procedure( export_func ), optional :: export_iteration function to export each iteration procedure( wait_func ), optional :: user_input_check check for user input (to stop solver if necessary) logical, intent(in), optional :: verbose for verbose status printing integer, intent(in), optional :: iunit unit for verbose printing (assumed to be open).\nby default this is output_unit . integer, intent(in), optional :: n_uphill_max maximum number of consecutive steps\nto allow where the value of f increases integer, intent(in), optional :: n_intervals number of intervals for fixed point linesearch private  subroutine nlesolver_solver (me, x) Main solver. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x private  subroutine destroy_nlesolver_variables (me) Destructor Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(out) :: me private  subroutine linear_solver (m, n, a, b, x, info) Solve the linear system: , using a dense, direct method. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m number of rows in a integer, intent(in) :: n number of columns in a real(kind=wp), intent(in), dimension(m,n) :: a A matrix of the linear system real(kind=wp), intent(in), dimension(m) :: b RHS of the linear system real(kind=wp), intent(out), dimension(n) :: x the solution of the linear system. integer, intent(out) :: info output status flag ( =0 if success) private  subroutine simple_step (me, xold, p, fjac, x, f, fvec) Take a simple step in the search direction of p * alpha . Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: xold previous value of x real(kind=wp), intent(in), dimension(me%n) :: p search direction real(kind=wp), intent(in), dimension(me%m,me%n) :: fjac jacobian matrix real(kind=wp), intent(out), dimension(me%n) :: x new x real(kind=wp), intent(inout) :: f magnitude of fvec real(kind=wp), intent(inout), dimension(me%m) :: fvec function vector private  subroutine backtracking_linesearch (me, xold, p, fjac, x, f, fvec) Backtracking line search. Read more… Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: xold previous value of x real(kind=wp), intent(in), dimension(me%n) :: p search direction real(kind=wp), intent(in), dimension(me%m,me%n) :: fjac jacobian matrix real(kind=wp), intent(out), dimension(me%n) :: x new x real(kind=wp), intent(inout) :: f magnitude of fvec real(kind=wp), intent(inout), dimension(me%m) :: fvec function vector private  subroutine exact_linesearch (me, xold, p, fjac, x, f, fvec) An exact linesearch that uses a derivative-free minimizer to\nfind the minimum value of f(x) between x = xold + p * alpha_min and x = xold + p * alpha_max . Read more… Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: xold previous value of x real(kind=wp), intent(in), dimension(me%n) :: p search direction real(kind=wp), intent(in), dimension(me%m,me%n) :: fjac jacobian matrix real(kind=wp), intent(out), dimension(me%n) :: x new x real(kind=wp), intent(inout) :: f magnitude of fvec real(kind=wp), intent(inout), dimension(me%m) :: fvec function vector private  subroutine fixed_point_linesearch (me, xold, p, fjac, x, f, fvec) A simple search that just evaluates the function at a specified\nnumber of points and picks the one with the minimum function value. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: xold previous value of x real(kind=wp), intent(in), dimension(me%n) :: p search direction real(kind=wp), intent(in), dimension(me%m,me%n) :: fjac jacobian matrix real(kind=wp), intent(out), dimension(me%n) :: x new x real(kind=wp), intent(inout) :: f magnitude of fvec real(kind=wp), intent(inout), dimension(me%m) :: fvec function vector","tags":"","loc":"module/nlesolver_module.html"},{"title":"aoc_utilities – AoC-2023","text":"Helper classes and routines for Advent of Code Author Jacob Williams hex string to int value. lowercase letters assumed!\n  no error checking here! Uses iso_fortran_env module~~aoc_utilities~~UsesGraph module~aoc_utilities aoc_utilities iso_fortran_env iso_fortran_env module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aoc_utilities~~UsedByGraph module~aoc_utilities aoc_utilities module~aoc_cache_module aoc_cache_module module~aoc_cache_module->module~aoc_utilities module~problem_15_module problem_15_module module~problem_15_module->module~aoc_utilities program~problem_1 problem_1 program~problem_1->module~aoc_utilities program~problem_10 problem_10 program~problem_10->module~aoc_utilities program~problem_11 problem_11 program~problem_11->module~aoc_utilities program~problem_12 problem_12 program~problem_12->module~aoc_utilities program~problem_12b problem_12b program~problem_12b->module~aoc_utilities program~problem_12b->module~aoc_cache_module program~problem_13 problem_13 program~problem_13->module~aoc_utilities program~problem_15 problem_15 program~problem_15->module~aoc_utilities program~problem_15->module~problem_15_module program~problem_16 problem_16 program~problem_16->module~aoc_utilities program~problem_17 problem_17 program~problem_17->module~aoc_utilities program~problem_17~2 problem_17 program~problem_17~2->module~aoc_utilities program~problem_17~2->module~aoc_cache_module program~problem_18 problem_18 program~problem_18->module~aoc_utilities program~problem_19 problem_19 program~problem_19->module~aoc_utilities program~problem_19b problem_19b program~problem_19b->module~aoc_utilities program~problem_2 problem_2 program~problem_2->module~aoc_utilities program~problem_21 problem_21 program~problem_21->module~aoc_utilities program~problem_22 problem_22 program~problem_22->module~aoc_utilities program~problem_22->module~aoc_cache_module program~problem_23 problem_23 program~problem_23->module~aoc_utilities program~problem_24 problem_24 program~problem_24->module~aoc_utilities program~problem_25 problem_25 program~problem_25->module~aoc_utilities program~problem_3 problem_3 program~problem_3->module~aoc_utilities program~problem_4 problem_4 program~problem_4->module~aoc_utilities program~problem_5 problem_5 program~problem_5->module~aoc_utilities program~problem_6 problem_6 program~problem_6->module~aoc_utilities program~problem_7 problem_7 program~problem_7->module~aoc_utilities program~problem_8 problem_8 program~problem_8->module~aoc_utilities program~problem_9 problem_9 program~problem_9->module~aoc_utilities Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, private, parameter :: chunk_size = 100 for dynamic allocations type( clock ), public :: clk a public clock to use for timing in the problems Interfaces public        interface sort private  subroutine sort_ascending (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_64 (ivec) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout), dimension(:) :: ivec public        interface parse private  function parse_nums64 (line) result(ints) parse space-deliminated ip sequence (positive or negative) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=ip), dimension(:), allocatable public        interface split private pure function split1 (str, token) result(vals) Split a character string using a token.\n  This routine is inspired by the Python split function. Example character ( len = :), allocatable :: s type ( string ), dimension (:), allocatable :: vals s = '1,2,3,4,5' call split ( s , ',' , vals ) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable private pure function split2 (s, token) result(vals) Split a string , given a token. Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: s character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable public        interface int private pure elemental function string_to_int (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer private pure function char_to_int (str) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer private pure function char_to_int64 (str, kind) result(i) Basic string to integer(ip) routine.\nHacky hack just so we can overload as int() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: kind Return Value integer(kind=ip) private pure function char_array_to_int (str_array) result(i) Character array to integer routine Arguments Type Intent Optional Attributes Name character(len=1), intent(in), dimension(:) :: str_array example ['1','3'] --> 13 Return Value integer public        interface unique private  function unique32 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec Return Value integer, dimension(:), allocatable private  function unique64 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: vec Return Value integer(kind=ip), dimension(:), allocatable public        interface startswith test if a string starts with a specified substring private pure function startswith_cc (str, substring) starts with function for strings Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_ss (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str type( string ), intent(in) :: substring Return Value logical private pure function startswith_sc (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_cs (str, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str type( string ), intent(in) :: substring Return Value logical public        interface swap private pure elemental subroutine swap32 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap64 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: i1 integer(kind=ip), intent(inout) :: i2 private pure elemental subroutine swap_str (i1, i2) Swap two character string values Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: i1 character(len=*), intent(inout) :: i2 public        interface manhatten_distance private pure function manhatten_distance_64 (x1, y1, x2, y2) Manhattan distance between two ip points. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: x1 integer(kind=ip), intent(in) :: y1 integer(kind=ip), intent(in) :: x2 integer(kind=ip), intent(in) :: y2 Return Value integer(kind=ip) Derived Types type, public :: clock Components Type Visibility Attributes Name Initial integer(kind=ip), private :: begin integer(kind=ip), private :: end integer(kind=ip), private :: rate Type-Bound Procedures procedure, public :: tic => clock_start procedure, public :: toc => clock_end type, public :: string a type containing an allocatable character string.\nso we can have an array of strings of different lengths. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: str Type-Bound Procedures procedure, public :: to_int => string_to_int convert to integer procedure, public :: to_int_64 => string_to_int_64 type, public :: int64_vec an type that contains an allocatable ip array.\nso we can have an array of these. Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(:), allocatable :: vals Functions private pure function char_to_int (str) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer private pure elemental function string_to_int (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer private pure elemental function string_to_int_64 (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer(kind=ip) private pure function char_to_int64 (str, kind) result(i) Basic string to integer(ip) routine.\nHacky hack just so we can overload as int() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: kind Return Value integer(kind=ip) private pure function char_array_to_int (str_array) result(i) Character array to integer routine Arguments Type Intent Optional Attributes Name character(len=1), intent(in), dimension(:) :: str_array example ['1','3'] --> 13 Return Value integer public pure function int_array_to_char_array (iarray) result(carray) integer array to Character array Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: iarray Return Value character(len=1), dimension(:,:), allocatable public  function read_file_to_char_array (filename, border) result(array) Read a file into a 2d character array. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=1), intent(in), optional :: border if true, extra border is added with this char Return Value character(len=1), dimension(:,:), allocatable public  function read_file_to_int_array (filename) result(array) Read a file into a 2d character array. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer, dimension(:,:), allocatable public  function read_file_to_integer_array (filename) result(iarray) Read a file into an integer array (one element per line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer, dimension(:), allocatable public  function read_file_to_integer64_array (filename) result(iarray) Read a file into an ip integer array (one element per line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer(kind=ip), dimension(:), allocatable public  function number_of_lines_in_file (iunit) result(n_lines) Returns the number of lines in a file (assumed to be open) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit the file unit number\n(assumed to be open) Return Value integer the number of lines in the file private pure function split2 (s, token) result(vals) Split a string , given a token. Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: s character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable private pure function split1 (str, token) result(vals) Split a character string using a token.\n  This routine is inspired by the Python split function. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable public  function read_line (iunit, status_ok) result(line) Reads the next line from a file. Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit logical, intent(out), optional :: status_ok true if no problems Return Value character(len=:), allocatable private  function unique32 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec Return Value integer, dimension(:), allocatable private  function unique64 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: vec Return Value integer(kind=ip), dimension(:), allocatable public  function parse_ints (line) result(ints) parse positive ints from a string that also includes text Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer, dimension(:), allocatable public  function parse_ints64 (line) result(ints) Parse positive ints from a string that also includes text Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=ip), dimension(:), allocatable private  function parse_nums64 (line) result(ints) parse space-deliminated ip sequence (positive or negative) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=ip), dimension(:), allocatable private pure function startswith_cc (str, substring) starts with function for strings Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_ss (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str type( string ), intent(in) :: substring Return Value logical private pure function startswith_sc (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_cs (str, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str type( string ), intent(in) :: substring Return Value logical public  function is_number (c) returns true if the character is a number from 0 to 9. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical public  function is_not_number (c) returns true if the character is not a number. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical public  function str_to_array (s) result(a) convert the character string to an array of characters Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value character(len=1), dimension(len(s)) public pure function lcm (i, j) LCM. based on code from NCAR Command Language Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value integer(kind=ip) public pure function reverse (ivals) result(ireverse) Reverse an ip vector Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals Return Value integer(kind=ip), dimension(size(ivals)) public pure function diff (ivals) result(idiff) Difference ip vector Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals Return Value integer(kind=ip), dimension(:), allocatable public  function parea (x, y, nb) given a sequence of nb points (x(i),y(i)). parea computes\nthe area bounded by the closed polygonal curve which passes\nthrough the points in the order that they are indexed. the\nfinal point of the curve is assumed to be the first point\ngiven. therefore, it need not be listed at the end of x and\ny. the curve is not required to be simple. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (nb) real(kind=wp), intent(in) :: y (nb) integer, intent(in) :: nb Return Value real(kind=wp) private pure function manhatten_distance_64 (x1, y1, x2, y2) Manhattan distance between two ip points. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: x1 integer(kind=ip), intent(in) :: y1 integer(kind=ip), intent(in) :: x2 integer(kind=ip), intent(in) :: y2 Return Value integer(kind=ip) public pure function str_to_int_array_with_mapping (str, ichars, iints) result(array) Convert a string to a numeric array by mapping characters to integers (user-specified) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=1), intent(in), dimension(:) :: ichars characters to process integer, intent(in), dimension(:) :: iints int values of the chars Return Value integer, dimension(:), allocatable public pure function str_to_int64_array_with_mapping (str, ichars, iints) result(array) Convert a string to a numeric array by mapping characters to integers (user-specified) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=1), intent(in), dimension(:) :: ichars characters to process integer(kind=ip), intent(in), dimension(:) :: iints int values of the chars Return Value integer(kind=ip), dimension(:), allocatable public pure function hex2int (hex) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: hex Return Value integer public pure function cross (r, v) result(c) Cross product of two real 3x1 vectors Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r real(kind=wp), intent(in), dimension(3) :: v Return Value real(kind=wp), dimension(3) Subroutines private  subroutine clock_start (me) Start the clock Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me private  subroutine clock_end (me, case_str) Print runtime in milliseconds form the start of the clock. Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me character(len=*), intent(in) :: case_str description of the case private  subroutine sort_ascending (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_64 (ivec) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout), dimension(:) :: ivec private pure elemental subroutine swap32 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap64 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: i1 integer(kind=ip), intent(inout) :: i2 private pure elemental subroutine swap_str (i1, i2) Swap two character string values Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: i1 character(len=*), intent(inout) :: i2 private pure subroutine expand_vector (vec, n, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) public pure subroutine locpt (x0, y0, x, y, n, l, m) given a polygonal line connecting the vertices (x(i),y(i))\n  (i = 1,...,n) taken in this order. it is assumed that the\n  polygonal path is a loop, where (x(n),y(n)) = (x(1),y(1))\n  or there is an arc from (x(n),y(n)) to (x(1),y(1)). Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: y0 real(kind=wp), intent(in), dimension(n) :: x real(kind=wp), intent(in), dimension(n) :: y integer, intent(in) :: n integer, intent(out) :: l integer, intent(out) :: m public  subroutine inverse (a, ainv, status_ok) inverse of a 2x2 matrix. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: a real(kind=wp), intent(out), dimension(2,2) :: ainv logical, intent(out) :: status_ok","tags":"","loc":"module/aoc_utilities.html"},{"title":"aoc_cache_module – AoC-2023","text":"For caching function evaluations. This is based on the cache module from NumDiff .\nIt has been modified to cache integers ( int64 ) instead of reals. Uses aoc_utilities module~~aoc_cache_module~~UsesGraph module~aoc_cache_module aoc_cache_module module~aoc_utilities aoc_utilities module~aoc_cache_module->module~aoc_utilities iso_fortran_env iso_fortran_env module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aoc_cache_module~~UsedByGraph module~aoc_cache_module aoc_cache_module program~problem_12b problem_12b program~problem_12b->module~aoc_cache_module program~problem_17~2 problem_17 program~problem_17~2->module~aoc_cache_module program~problem_22 problem_22 program~problem_22->module~aoc_cache_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, private :: fx an [x,f(x)] cached pair.\nx is a vector and f is a vector. Components Type Visibility Attributes Name Initial integer(kind=ip), private, dimension(:), allocatable :: x vector of input values integer(kind=ip), private, dimension(:), allocatable :: f output functions type, public :: function_cache a vector function cache. Components Type Visibility Attributes Name Initial type( fx ), private, dimension(:), allocatable :: c the cache of f(x) integer, private :: chunk_size = 100 for resizing vectors\nin the unique function Type-Bound Procedures procedure, public :: initialize => initialize_cache procedure, public :: get => get_from_cache procedure, public :: put => put_in_cache procedure, public :: destroy => destroy_cache Functions private pure function vector_djb_hash (r) result(hash) DJB hash algorithm for a integer(ip) vector. Read more… Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: r the vector Return Value integer(kind=ip) the hash value Subroutines private  subroutine initialize_cache (me, isize, chunk_size) Initialize the cache. Must be called first before use. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: isize the size of the hash table integer, intent(in), optional :: chunk_size chunk size to speed up reallocation\nof arrays. A good value is a guess for\nthe actual number of elements of f that\nwill be saved per value of x [default is 100] private  subroutine get_from_cache (me, x, i, f, found) Check if the x vector is in the cache, if so return f .\nNote that only some of the elements may be present, so it will return\nthe ones there are there, and indicate which ones were found. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer(kind=ip), intent(in), dimension(:) :: x independant variable vector integer(kind=ip), intent(out) :: i index in the hash table integer(kind=ip), intent(out), dimension(:), allocatable :: f f(x) from the cache (if it was found) logical, intent(out) :: found if x was found in the cache private  subroutine put_in_cache (me, i, x, f) Put a value into the cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer(kind=ip), intent(in) :: i index in the hash table integer(kind=ip), intent(in), dimension(:) :: x independant variable vector integer(kind=ip), intent(in), dimension(:) :: f function private  subroutine destroy_cache (me) Destroy a cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(out) :: me","tags":"","loc":"module/aoc_cache_module.html"},{"title":"numdiff_kinds_module – AoC-2023","text":"Numeric kinds for NumDiff. Note The default real kind ( wp ) can be\n      changed using optional preprocessor flags.\n      This library was built with real kind: real(kind=real64) [8 bytes] Uses iso_fortran_env module~~numdiff_kinds_module~~UsesGraph module~numdiff_kinds_module numdiff_kinds_module iso_fortran_env iso_fortran_env module~numdiff_kinds_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~numdiff_kinds_module~~UsedByGraph module~numdiff_kinds_module numdiff_kinds_module module~diff_module diff_module module~diff_module->module~numdiff_kinds_module module~dsm_module dsm_module module~dsm_module->module~numdiff_kinds_module module~numdiff_cache_module numdiff_cache_module module~numdiff_cache_module->module~numdiff_kinds_module module~numdiff_utilities_module numdiff_utilities_module module~numdiff_cache_module->module~numdiff_utilities_module module~numdiff_utilities_module->module~numdiff_kinds_module module~numerical_differentiation_module numerical_differentiation_module module~numerical_differentiation_module->module~numdiff_kinds_module module~numerical_differentiation_module->module~diff_module module~numerical_differentiation_module->module~dsm_module module~numerical_differentiation_module->module~numdiff_cache_module module~numerical_differentiation_module->module~numdiff_utilities_module program~dsm_test dsm_test program~dsm_test->module~numdiff_kinds_module program~dsm_test->module~dsm_module program~test1 test1 program~test1->module~numdiff_kinds_module program~test1->module~numerical_differentiation_module program~test2 test2 program~test2->module~numdiff_kinds_module program~test2->module~numerical_differentiation_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: wp = real64 default real kind [8 bytes]","tags":"","loc":"module/numdiff_kinds_module.html"},{"title":"problem_1 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_1~~UsesGraph program~problem_1 problem_1 iso_fortran_env iso_fortran_env program~problem_1->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_1->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_1~~CallsGraph program~problem_1 problem_1 proc~clock_end aoc_utilities::clock%clock_end program~problem_1->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_1->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_1->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_1->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit logical :: status_ok character(len=:), allocatable :: line integer :: n_lines integer :: i integer :: j integer :: k integer :: n integer :: isum integer :: ifirst integer :: ilast integer :: idxfirst integer :: idxlast character(len=*), parameter,               dimension(9) :: ichars = ['one&nbsp;&nbsp;', 'two&nbsp;&nbsp;', 'three', 'four ', 'five ', 'six&nbsp;&nbsp;', 'seven', 'eight', 'nine '] Source Code program problem_1 use iso_fortran_env use aoc_utilities implicit none integer :: iunit logical :: status_ok character ( len = :), allocatable :: line integer :: n_lines integer :: i , j , k , n , isum , ifirst , ilast , idxfirst , idxlast character ( len =* ), dimension ( 9 ), parameter :: ichars = [ & 'one  ' , & 'two  ' , & 'three' , & 'four ' , & 'five ' , & 'six  ' , & 'seven' , & 'eight' , & 'nine ' ] call clk % tic () isum = 0 open ( newunit = iunit , file = 'inputs/day1.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) do i = 1 , n_lines ! remove all the chars before the first and after the last number line = read_line ( iunit , status_ok ) n = len ( line ) do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) exit ! done line ( j : j ) = ' ' end do do j = n , 1 , - 1 if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) exit ! done line ( j : j ) = ' ' end do line = trim ( adjustl ( line )) n = len ( line ) isum = isum + 10 * int ( line ( 1 : 1 )) + int ( line ( n : n )) end do write ( * , * ) '1a: sum:' , isum close ( iunit ) ! -------- part 2 ----------- open ( newunit = iunit , file = 'inputs/day1.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do i = 1 , n_lines line = read_line ( iunit , status_ok ) n = len ( line ) ! keep track of the index of the first and last number (digit or string) ifirst = huge ( 1 ) idxfirst = huge ( 1 ) do j = 1 , size ( ichars ) k = min ( index ( line , trim ( ichars ( j ))), index ( line , trim ( ichars ( j )), back = . true .) ) ! accounts for duplicates if ( k > 0 . and . k <= idxfirst ) then ifirst = j idxfirst = k end if end do do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) then if ( j <= idxfirst ) then ifirst = int ( line ( j : j )) idxfirst = j end if end if end do ilast = 0 idxlast = 0 do j = 1 , size ( ichars ) k = max ( index ( line , trim ( ichars ( j ))), index ( line , trim ( ichars ( j )), back = . true .) ) ! accounts for duplicates if ( k > 0 . and . k >= idxlast ) then ilast = j idxlast = k end if end do do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) then if ( j >= idxlast ) then ilast = int ( line ( j : j )) idxlast = j end if end if end do isum = isum + 10 * ifirst + ilast end do write ( * , * ) '1b: sum:' , isum call clk % toc ( '1' ) end program problem_1","tags":"","loc":"program/problem_1.html"},{"title":"problem_10 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_10~~UsesGraph program~problem_10 problem_10 iso_fortran_env iso_fortran_env program~problem_10->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_10->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_10~~CallsGraph program~problem_10 problem_10 proc~clock_end aoc_utilities::clock%clock_end program~problem_10->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_10->proc~clock_start proc~locpt aoc_utilities::locpt program~problem_10->proc~locpt proc~move problem_10::move program~problem_10->proc~move proc~read_file_to_char_array aoc_utilities::read_file_to_char_array program~problem_10->proc~read_file_to_char_array proc~move->proc~move proc~pipe_info problem_10::pipe_info proc~move->proc~pipe_info proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: j integer :: nrows integer :: ncols integer :: imove integer :: l integer :: m logical, dimension(:,:), allocatable :: icounts character(len=1), dimension(:,:), allocatable :: array integer, dimension(:,:), allocatable :: distance integer, dimension(:,:), allocatable :: distance_reverse logical, dimension(:,:), allocatable :: visited real(kind=wp), dimension(:), allocatable :: x path cooidinates real(kind=wp), dimension(:), allocatable :: y path cooidinates integer, dimension(2) :: Sij i,j of the S char in array Functions pure function pipe_info (p) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: p Return Value character(len=2) Subroutines recursive subroutine move (i, j, direction, distance, save_path) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: direction integer, intent(inout), dimension(:,:) :: distance logical, intent(in) :: save_path to save the path coordinates Source Code program problem_10 use iso_fortran_env use aoc_utilities implicit none integer :: i , j , nrows , ncols , imove , l , m logical , dimension (:,:), allocatable :: icounts character ( len = 1 ), dimension (:,:), allocatable :: array integer , dimension (:,:), allocatable :: distance , distance_reverse logical , dimension (:,:), allocatable :: visited real ( wp ), dimension (:), allocatable :: x , y !! path cooidinates integer , dimension ( 2 ) :: Sij !! i,j of the S char in array call clk % tic () array = read_file_to_char_array ( 'inputs/day10.txt' , '.' ) ! pad with . to simplify edge logic nrows = size ( array , 1 ) ncols = size ( array , 2 ) allocate ( distance ( nrows , ncols )); distance = - 1 allocate ( distance_reverse ( nrows , ncols )); distance_reverse = - 1 allocate ( visited ( nrows , ncols )) ! start at the S coordinate: Sij = findloc ( array , 'S' ) x = [ Sij ( 1 )] ! to store the path for part b y = [ Sij ( 2 )] ! traverse the maze: visited = . false .; visited ( Sij ( 1 ), Sij ( 2 )) = . true .; distance ( Sij ( 1 ), Sij ( 2 )) = 0 do imove = 1 , 4 call move ( Sij ( 1 ), Sij ( 2 ), imove , distance , . true .) end do ! traverse the maze again in reverse: visited = . false .; visited ( Sij ( 1 ), Sij ( 2 )) = . true .; distance_reverse ( Sij ( 1 ), Sij ( 2 )) = 0 do imove = 4 , 1 , - 1 call move ( Sij ( 1 ), Sij ( 2 ), imove , distance_reverse , . false .) end do ! where they match is the distance furthest away from the start write ( * , * ) '10a: ' , pack ( distance , mask = ( distance == distance_reverse . and . distance > 0 )) ! for part b, use locpt to test all the points ! allow openmp to be used here to do each row in parallel allocate ( icounts ( nrows , ncols )); icounts = . false . !$OMP PARALLEL DO SHARED(icounts,x,y) PRIVATE(i,j,l,m) do i = 2 , nrows - 1 ! we can skip the padding do j = 2 , ncols - 1 if ( any ( i == x . and . j == y )) cycle ! skip if on path call locpt ( real ( i , wp ), real ( j , wp ), x , y , size ( x ), l , m ) if ( l == 1 ) icounts ( i , j ) = . true . ! if (i,j) is inside the polygonal path end do end do !$OMP END PARALLEL DO write ( * , * ) '10b: ' , count ( icounts ) call clk % toc ( '10' ) contains recursive subroutine move ( i , j , direction , distance , save_path ) integer , intent ( in ) :: i , j , direction integer , dimension (:,:), intent ( inout ) :: distance logical , intent ( in ) :: save_path !! to save the path coordinates integer :: inew , jnew , imove logical :: valid_move select case ( direction ) case ( 1 ); inew = i - 1 ; jnew = j ! north case ( 2 ); inew = i + 1 ; jnew = j ! south case ( 3 ); inew = i ; jnew = j + 1 ! east case ( 4 ); inew = i ; jnew = j - 1 ! west end select if ( visited ( inew , jnew ) . or . array ( inew , jnew ) == '.' ) return ! can we move in this direction? valid_move = . false . associate ( current_pipe => array ( i , j ), & current_distance => distance ( i , j ), & move_to => array ( inew , jnew ) ) select case ( current_pipe ) case ( 'S' ) ! don't know what the first pip is, so have to try them all select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '|' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south end select case ( '-' ) select case ( direction ) case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'L' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select case ( 'J' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '7' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'F' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select end select if ( valid_move ) then distance ( inew , jnew ) = current_distance + 1 visited ( inew , jnew ) = . true . do imove = 1 , 4 call move ( inew , jnew , imove , distance , save_path ) end do if ( save_path ) then x = [ x , real ( inew , wp )] ! save cordinates of point on the path y = [ y , real ( jnew , wp )] end if end if end associate end subroutine move pure character ( len = 2 ) function pipe_info ( p ) character ( len = 1 ), intent ( in ) :: p select case ( p ) case ( '|' ); pipe_info = 'NS' ! | is a vertical pipe connecting north and south. case ( '-' ); pipe_info = 'EW' ! - is a horizontal pipe connecting east and west. case ( 'L' ); pipe_info = 'NE' ! L is a 90-degree bend connecting north and east. case ( 'J' ); pipe_info = 'NW' ! J is a 90-degree bend connecting north and west. case ( '7' ); pipe_info = 'SW' ! 7 is a 90-degree bend connecting south and west. case ( 'F' ); pipe_info = 'SE' ! F is a 90-degree bend connecting south and east. end select end function pipe_info end program problem_10","tags":"","loc":"program/problem_10.html"},{"title":"problem_15 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities problem_15_module program~~problem_15~~UsesGraph program~problem_15 problem_15 iso_fortran_env iso_fortran_env program~problem_15->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_15->module~aoc_utilities module~problem_15_module problem_15_module program~problem_15->module~problem_15_module module~aoc_utilities->iso_fortran_env module~problem_15_module->iso_fortran_env module~problem_15_module->module~aoc_utilities Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_15~~CallsGraph program~problem_15 problem_15 interface~split aoc_utilities::split program~problem_15->interface~split proc~add_lens problem_15_module::box%add_lens program~problem_15->proc~add_lens proc~clock_end aoc_utilities::clock%clock_end program~problem_15->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_15->proc~clock_start proc~hash problem_15::hash program~problem_15->proc~hash proc~read_line aoc_utilities::read_line program~problem_15->proc~read_line proc~remove_lens problem_15_module::box%remove_lens program~problem_15->proc~remove_lens proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: iunit integer :: j type( string ), dimension(:), allocatable :: vals type( string ), dimension(:), allocatable :: vals2 integer(kind=ip), dimension(:), allocatable :: ivals type( box ), dimension(0:255) :: boxes integer(kind=ip) :: ibox character(len=:), allocatable :: label integer(kind=ip) :: ival integer(kind=ip) :: focusing_power integer(kind=ip) :: lens_focusing_power Functions pure elemental function hash (s) Determine the ASCII code for the current character of the string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value integer(kind=ip) Source Code program problem_15 use iso_fortran_env use aoc_utilities use problem_15_module implicit none integer :: i , iunit , j type ( string ), dimension (:), allocatable :: vals , vals2 integer ( ip ), dimension (:), allocatable :: ivals type ( box ), dimension ( 0 : 255 ) :: boxes ! for part 2 integer ( ip ) :: ibox ! 0-255 character ( len = :), allocatable :: label integer ( ip ) :: ival , focusing_power , lens_focusing_power call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day15_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day15.txt' , status = 'OLD' ) vals = split ( read_line ( iunit ), ',' ) close ( iunit ) allocate ( ivals ( size ( vals ))) do i = 1 , size ( vals ) ! part 1: ivals ( i ) = hash ( vals ( i )% str ) ! part 2: if ( index ( vals ( i )% str , '=' ) > 0 ) then vals2 = split ( vals ( i )% str , '=' ) label = vals2 ( 1 )% str ibox = hash ( label ) ival = int ( vals2 ( 2 )% str ) ! focal length call boxes ( ibox )% add_lens ( lens ( label , ival )) else if ( index ( vals ( i )% str , '-' ) > 0 ) then vals2 = split ( vals ( i )% str , '-' ) label = vals2 ( 1 )% str ibox = hash ( label ) call boxes ( ibox )% remove_lens ( label ) end if end do write ( * , * ) '15a: ' , sum ( ivals ) focusing_power = 0 do i = 0 , 255 ! all the boxes if ( allocated ( boxes ( i )% lenses )) then do j = 1 , size ( boxes ( i )% lenses ) ! all the lenses in the box lens_focusing_power = ( i + 1 ) * ( j ) * ( boxes ( i )% lenses ( j )% focal_length ) focusing_power = focusing_power + lens_focusing_power end do end if end do write ( * , * ) '15b: ' , focusing_power call clk % toc ( '15' ) contains pure elemental integer ( ip ) function hash ( s ) !! Determine the ASCII code for the current character of the string. character ( len =* ), intent ( in ) :: s integer :: i hash = 0 do i = 1 , len ( s ) hash = modulo ( 17_ip * ( hash + iachar ( s ( i : i ))), 256_ip ) end do end function hash end program problem_15","tags":"","loc":"program/problem_15.html"},{"title":"problem_24 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_24~~UsesGraph program~problem_24 problem_24 iso_fortran_env iso_fortran_env program~problem_24->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_24->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_24~~CallsGraph program~problem_24 problem_24 interface~split aoc_utilities::split program~problem_24->interface~split proc~clock_end aoc_utilities::clock%clock_end program~problem_24->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_24->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_24->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_24->proc~read_line proc~string_to_int_64 aoc_utilities::string%string_to_int_64 program~problem_24->proc~string_to_int_64 proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit integer :: n_lines integer :: i integer :: j character(len=:), allocatable :: line type( string ), dimension(:), allocatable :: vals type( string ), dimension(:), allocatable :: rvals type( string ), dimension(:), allocatable :: vvals integer(kind=ip), dimension(:), allocatable :: xvec integer(kind=ip), dimension(:), allocatable :: yvec integer(kind=ip), dimension(:), allocatable :: zvec integer(kind=ip), dimension(:), allocatable :: vxvec integer(kind=ip), dimension(:), allocatable :: vyvec integer(kind=ip), dimension(:), allocatable :: vzvec integer(kind=ip) :: n_intersections real(kind=wp), dimension(2) :: tvec real(kind=wp), dimension(2) :: xy_inter integer(kind=ip) :: min_val integer(kind=ip) :: max_val Source Code program problem_24 use iso_fortran_env , only : wp => real64 , ip => int64 ! use long ints use aoc_utilities implicit none integer :: iunit , n_lines , i , j character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals , rvals , vvals integer ( ip ), dimension (:), allocatable :: xvec , yvec , zvec , vxvec , vyvec , vzvec integer ( ip ) :: n_intersections real ( wp ), dimension ( 2 ) :: tvec real ( wp ), dimension ( 2 ) :: xy_inter integer ( ip ) :: min_val , max_val call clk % tic () ! read the data: ! open(newunit=iunit, file='inputs/day24_test.txt', status='OLD'); min_val=7_ip; max_val = 27_ip open ( newunit = iunit , file = 'inputs/day24.txt' , status = 'OLD' ); min_val = 20000000000000 0.0_wp ; max_val = 40000000000000 0.0_wp n_lines = number_of_lines_in_file ( iunit ) allocate ( xvec ( 0 ), yvec ( 0 ), zvec ( 0 ), vxvec ( 0 ), vyvec ( 0 ), vzvec ( 0 )) do i = 1 , n_lines line = read_line ( iunit ) vals = split ( line , '@' ) rvals = split ( trim ( vals ( 1 )% str ), ',' ) xvec = [ xvec , rvals ( 1 )% to_int_64 ()] yvec = [ yvec , rvals ( 2 )% to_int_64 ()] zvec = [ zvec , rvals ( 3 )% to_int_64 ()] vvals = split ( trim ( vals ( 2 )% str ), ',' ) vxvec = [ vxvec , vvals ( 1 )% to_int_64 ()] vyvec = [ vyvec , vvals ( 2 )% to_int_64 ()] vzvec = [ vzvec , vvals ( 3 )% to_int_64 ()] end do close ( iunit ) n_intersections = 0 do i = 1 , n_lines do j = 1 , i - 1 associate ( x => xvec ( i ), y => yvec ( i ), & dx => vxvec ( i ), dy => vyvec ( i ), & u => xvec ( j ), v => yvec ( j ), & du => vxvec ( j ), dv => vyvec ( j ) ) if ( dy * du /= dv * dx ) then tvec = [( dv * ( x - u ) - du * ( y - v )) / ( dy * du - dx * dv ), & ( dy * ( u - x ) - dx * ( v - y )) / ( dv * dx - du * dy ) ] xy_inter = [ x + tvec ( 1 ) * dx , y + tvec ( 1 ) * dy ] if ( all ( tvec > 0.0_wp ) . and . & all ([ xy_inter >= min_val . and . xy_inter <= max_val ])) then n_intersections = n_intersections + 1 end if end if end associate end do end do write ( * , * ) '21a : ' , n_intersections call clk % toc ( '24' ) end program problem_24","tags":"","loc":"program/problem_24.html"},{"title":"problem_21 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_21~~UsesGraph program~problem_21 problem_21 iso_fortran_env iso_fortran_env program~problem_21->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_21->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_21~~CallsGraph program~problem_21 problem_21 proc~clock_end aoc_utilities::clock%clock_end program~problem_21->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_21->proc~clock_start proc~read_file_to_char_array aoc_utilities::read_file_to_char_array program~problem_21->proc~read_file_to_char_array proc~step problem_21::step program~problem_21->proc~step proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial character(len=1), dimension(:,:), allocatable :: array integer :: nrows integer :: ncols integer :: i integer :: j integer, dimension(2) :: iloc integer, dimension(:,:), allocatable :: icount Subroutines recursive subroutine step (array) take all valid steps from any # elements in array Arguments Type Intent Optional Attributes Name character(len=1), intent(inout), dimension(:,:), allocatable :: array Source Code program problem_21 use aoc_utilities use iso_fortran_env implicit none character ( len = 1 ), dimension (:,:), allocatable :: array integer :: nrows , ncols , i , j integer , dimension ( 2 ) :: iloc integer , dimension (:,:), allocatable :: icount call clk % tic () ! array = read_file_to_char_array('inputs/day21_test.txt', border='#') array = read_file_to_char_array ( 'inputs/day21.txt' , border = '.' ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) allocate ( icount ( nrows , ncols )); icount = 0 iloc = findloc ( array , 'S' ) ! find starting point i = iloc ( 1 ) j = iloc ( 2 ) array ( i , j ) = 'O' ! starting here do i = 1 , 64 call step ( array ) end do write ( * , * ) '21a: ' , count ( array == 'O' ) call clk % toc ( '21' ) contains recursive subroutine step ( array ) !! take all valid steps from any # elements in array character ( len = 1 ), dimension (:,:), intent ( inout ), allocatable :: array integer :: i , j logical :: steped character ( len = 1 ), dimension (:,:), allocatable :: tmp tmp = array do i = 1 , nrows do j = 1 , ncols if ( array ( i , j ) == 'O' ) then steped = . false . ! try a step in each direction: if ( array ( i - 1 , j ) == '.' ) then tmp ( i - 1 , j ) = 'O' ; steped = . true . end if if ( array ( i + 1 , j ) == '.' ) then tmp ( i + 1 , j ) = 'O' ; steped = . true . end if if ( array ( i , j - 1 ) == '.' ) then tmp ( i , j - 1 ) = 'O' ; steped = . true . end if if ( array ( i , j + 1 ) == '.' ) then tmp ( i , j + 1 ) = 'O' ; steped = . true . end if if ( steped ) tmp ( i , j ) = '.' end if end do end do call move_alloc ( tmp , array ) end subroutine step end program problem_21","tags":"","loc":"program/problem_21.html"},{"title":"problem_9 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_9~~UsesGraph program~problem_9 problem_9 iso_fortran_env iso_fortran_env program~problem_9->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_9->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_9~~CallsGraph program~problem_9 problem_9 interface~parse aoc_utilities::parse program~problem_9->interface~parse proc~clock_end aoc_utilities::clock%clock_end program~problem_9->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_9->proc~clock_start proc~extrapolate problem_9::extrapolate program~problem_9->proc~extrapolate proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_9->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_9->proc~read_line proc~reverse aoc_utilities::reverse program~problem_9->proc~reverse proc~parse_nums64 aoc_utilities::parse_nums64 interface~parse->proc~parse_nums64 proc~diff~2 aoc_utilities::diff proc~extrapolate->proc~diff~2 interface~split aoc_utilities::split proc~parse_nums64->interface~split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: iunit integer :: n_lines integer(kind=ip) :: isum Functions pure function extrapolate (ivals) result(iextrap) extrapolate the next value in the sequence using\na difference table. Straightfoward implemention:\ncreate the full table, and then evaluate it. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals Return Value integer(kind=ip) Source Code program problem_9 use iso_fortran_env use aoc_utilities implicit none integer :: i , iunit , n_lines integer ( ip ) :: isum call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day9_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day9.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = sum ([( extrapolate ( parse ( read_line ( iunit ))), i = 1 , n_lines )]) close ( iunit ) write ( * , * ) '9a: sum: ' , isum open ( newunit = iunit , file = 'inputs/day9.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = sum ([( extrapolate ( reverse ( parse ( read_line ( iunit )))), i = 1 , n_lines )]) close ( iunit ) write ( * , * ) '9b: sum: ' , isum call clk % toc ( '9' ) contains pure function extrapolate ( ivals ) result ( iextrap ) !! extrapolate the next value in the sequence using !! a difference table. Straightfoward implemention: !! create the full table, and then evaluate it. integer ( ip ), dimension (:), intent ( in ) :: ivals integer ( ip ) :: iextrap integer :: i , n type ( int64_vec ), dimension (:), allocatable :: diff_table !! difference table (vector of vectors) ! create the difference table: diff_table = [ int64_vec ( ivals )]; n = 1 do n = n + 1 diff_table = [ diff_table , int64_vec ( diff ( diff_table ( n - 1 )% vals ))] ! next line is diff of previous line if ( all ( diff_table ( n )% vals == 0 )) exit end do ! extrapolate iextrap = 0 do i = n - 1 , 1 , - 1 associate ( ilast => diff_table ( i )% vals ( size ( diff_table ( i )% vals )) ) iextrap = iextrap + ilast end associate end do end function extrapolate end program problem_9","tags":"","loc":"program/problem_9.html"},{"title":"dag_example – AoC-2023","text":"Uses dag_module program~~dag_example~~UsesGraph program~dag_example dag_example module~dag_module dag_module program~dag_example->module~dag_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. DAG module test program. Calls program~~dag_example~~CallsGraph program~dag_example dag_example proc~dag_destroy dag_module::dag%dag_destroy program~dag_example->proc~dag_destroy proc~dag_generate_dependency_matrix dag_module::dag%dag_generate_dependency_matrix program~dag_example->proc~dag_generate_dependency_matrix proc~dag_save_digraph dag_module::dag%dag_save_digraph program~dag_example->proc~dag_save_digraph proc~dag_set_edges dag_module::dag%dag_set_edges program~dag_example->proc~dag_set_edges proc~dag_set_vertex_info dag_module::dag%dag_set_vertex_info program~dag_example->proc~dag_set_vertex_info proc~dag_set_vertices dag_module::dag%dag_set_vertices program~dag_example->proc~dag_set_vertices proc~dag_toposort dag_module::dag%dag_toposort program~dag_example->proc~dag_toposort proc~dag_generate_digraph dag_module::dag%dag_generate_digraph proc~dag_save_digraph->proc~dag_generate_digraph none~set_edges dag_module::vertex%set_edges proc~dag_set_edges->none~set_edges proc~integer_to_string~2 dag_module::integer_to_string proc~dag_set_vertex_info->proc~integer_to_string~2 proc~add_edge dag_module::vertex%add_edge none~set_edges->proc~add_edge proc~set_edge_vector dag_module::vertex%set_edge_vector none~set_edges->proc~set_edge_vector proc~dag_generate_digraph->proc~integer_to_string~2 proc~set_edge_vector->proc~add_edge Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( dag ) :: d integer, dimension(:), allocatable :: order integer :: istat integer :: i integer :: r integer :: c logical, dimension(:,:), allocatable :: mat dependency matrix integer, parameter :: n_nodes = 6 character(len=*), parameter :: filetype = 'pdf' filetype for output plot ('pdf', png', etc.) Source Code program dag_example use dag_module implicit none type ( dag ) :: d integer , dimension (:), allocatable :: order integer :: istat integer :: i , r , c logical , dimension (:,:), allocatable :: mat !! dependency matrix integer , parameter :: n_nodes = 6 character ( len =* ), parameter :: filetype = 'pdf' !! filetype for output plot ('pdf', png', etc.) ! TODO combine set_edges and set_vertex_info into one routine maybe. call d % set_vertices ( n_nodes ) call d % set_edges ( 2 ,[ 1 ]) !2 depends on 1 call d % set_edges ( 3 ,[ 5 , 1 ]) !3 depends on 5 and 1 call d % set_edges ( 4 ,[ 5 ]) !4 depends on 5 call d % set_edges ( 5 ,[ 2 ]) !5 depends on 2 call d % set_edges ( 6 ,[ 2 , 4 ]) !6 depends on 2 and 4 call d % toposort ( order , istat ) write ( * , * ) '' write ( * , * ) 'istat=' , istat write ( * , * ) 'order=' , order ! prints 1,2,5,3,4 do i = 1 , n_nodes if ( i == 3 . or . i == 6 ) then call d % set_vertex_info ( i , attributes = 'shape=square,fillcolor=\"SlateGray1\",style=filled' ) else call d % set_vertex_info ( i , attributes = 'shape=circle,fillcolor=\"cornsilk\",style=filled' ) end if end do write ( * , * ) '' write ( * , * ) 'diagraph:' write ( * , * ) '' call d % save_digraph ( 'test.dot' , 'RL' , 300 ) call execute_command_line ( 'cat test.dot' ) call execute_command_line ( 'dot -T' // filetype // ' -o test.' // filetype // ' test.dot' ) write ( * , * ) '' write ( * , * ) 'dependency matrix:' write ( * , * ) '' call d % generate_dependency_matrix ( mat ) do r = 1 , n_nodes do c = 1 , n_nodes if ( mat ( r , c )) then write ( * , '(A)' , advance = 'NO' ) 'X' else write ( * , '(A)' , advance = 'NO' ) 'O' end if end do write ( * , '(A)' ) '' end do ! cleanup: call d % destroy () end program dag_example","tags":"","loc":"program/dag_example.html"},{"title":"problem_4 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_4~~UsesGraph program~problem_4 problem_4 iso_fortran_env iso_fortran_env program~problem_4->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_4->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_4~~CallsGraph program~problem_4 problem_4 interface~split aoc_utilities::split program~problem_4->interface~split proc~clock_end aoc_utilities::clock%clock_end program~problem_4->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_4->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_4->proc~number_of_lines_in_file proc~parse_ints aoc_utilities::parse_ints program~problem_4->proc~parse_ints proc~read_line aoc_utilities::read_line program~problem_4->proc~read_line proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit integer :: n_lines integer :: i integer :: points integer :: j integer :: iwin type( string ), dimension(:), allocatable :: vals type( string ), dimension(:), allocatable :: vals2 integer, dimension(:), allocatable :: iwinning integer, dimension(:), allocatable :: ihave integer, dimension(:), allocatable :: n_matches character(len=:), allocatable :: line integer, dimension(:,:), allocatable :: card_matrix Source Code program problem_4 use iso_fortran_env use aoc_utilities implicit none integer :: iunit , n_lines , i , points , j , iwin type ( string ), dimension (:), allocatable :: vals , vals2 integer , dimension (:), allocatable :: iwinning , ihave , n_matches character ( len = :), allocatable :: line integer , dimension (:,:), allocatable :: card_matrix call clk % tic () ! open(newunit=iunit, file='inputs/day4_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day4.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( n_matches ( n_lines )) ! for part 2 allocate ( card_matrix ( 0 : n_lines , n_lines )) ! for part 2 ! Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53 points = 0 do i = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ': ' ) vals2 = split ( vals ( 2 ), ' | ' ) iwinning = parse_ints ( vals2 ( 1 )% str ) ! winning list ihave = parse_ints ( vals2 ( 2 )% str ) ! ones you have ! count the number of ones you have in the winning set: iwin = 0 do j = 1 , size ( ihave ) iwin = iwin + count ( ihave ( j ) == iwinning ) end do n_matches ( i ) = iwin points = points + 2 ** ( iwin - 1 ) end do close ( iunit ) write ( * , * ) '4a : points : ' , points card_matrix = 0 card_matrix ( 0 ,:) = 1 ! start with one card each do i = 1 , n_lines associate ( n => n_matches ( i )) if ( n > 0 ) card_matrix ( i , i + 1 : i + n ) = sum ( card_matrix (:, i )) end associate end do write ( * , * ) '4b : scratchcards :' , sum ( card_matrix ) call clk % toc ( '4' ) end program problem_4","tags":"","loc":"program/problem_4.html"},{"title":"problem_12 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_12~~UsesGraph program~problem_12 problem_12 iso_fortran_env iso_fortran_env program~problem_12->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_12->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_12~~CallsGraph program~problem_12 problem_12 proc~clock_end aoc_utilities::clock%clock_end program~problem_12->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_12->proc~clock_start proc~go~6 problem_12::go program~problem_12->proc~go~6 interface~split aoc_utilities::split proc~go~6->interface~split proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~go~6->proc~number_of_lines_in_file proc~parse_ints aoc_utilities::parse_ints proc~go~6->proc~parse_ints proc~read_line aoc_utilities::read_line proc~go~6->proc~read_line proc~str_to_int_array_with_mapping aoc_utilities::str_to_int_array_with_mapping proc~go~6->proc~str_to_int_array_with_mapping proc~test problem_12::test proc~go~6->proc~test proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~test->proc~test proc~match problem_12::match proc~test->proc~match proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: POINT = 0 integer, parameter :: NUMBER = 1 integer, parameter :: QUESTION = 2 integer, dimension(:), allocatable :: a integer, dimension(:), allocatable :: ints integer, dimension(:), allocatable :: ipattern integer, dimension(:), allocatable :: ipattern_tmp integer(kind=ip) :: n_valid integer(kind=ip) :: isum integer :: iline Functions function match (ipattern, ints) returns true if the pattern is valid for the int list. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: ipattern integer, intent(in), dimension(:) :: ints Return Value logical Subroutines subroutine go (expand, isum) Arguments Type Intent Optional Attributes Name logical, intent(in) :: expand integer(kind=ip), intent(out) :: isum recursive subroutine test (i, n) each ? can be either a . or a #\ncheck pattern to match the int list Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: n Source Code program problem_12 use iso_fortran_env use aoc_utilities implicit none integer , parameter :: POINT = 0 integer , parameter :: NUMBER = 1 integer , parameter :: QUESTION = 2 ! some global variables integer , dimension (:), allocatable :: a , ints , ipattern , ipattern_tmp integer ( ip ) :: n_valid integer ( ip ) :: isum integer :: iline call clk % tic () call go (. false ., isum ); write ( * , * ) '12a: ' , isum ! call go(.true., isum); write(*,*) '12b: ', isum call clk % toc ( '12' ) contains subroutine go ( expand , isum ) logical , intent ( in ) :: expand integer ( ip ), intent ( out ) :: isum integer :: iunit , n_lines , n_unknowns integer ( ip ) :: n_perms character ( len = :), allocatable :: line , pattern type ( string ), dimension (:), allocatable :: vals ! open(newunit=iunit, file='inputs/day12_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day12.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ints = parse_ints ( vals ( 2 )% str ) ! integer list  1,1,3 pattern = vals ( 1 )% str ! the pattern   #.#.### ! will convert the pattern to an array of numbers: ipattern = str_to_int_array_with_mapping ( pattern ,[ '.' , '#' , '?' ],& [ POINT , NUMBER , QUESTION ]) ! 1010111 if ( expand ) then ! brute force it ipattern = [ ipattern , QUESTION , ipattern , QUESTION , & ipattern , QUESTION , ipattern , QUESTION , & ipattern ] ints = [ ints , ints , ints , ints , ints ] end if n_unknowns = count ( ipattern == 2 ) n_valid = 0 ! number of valid permutations n_perms = 2 ** n_unknowns ! number of permutations ipattern_tmp = ipattern ! recursively test all the permutations if ( allocated ( a )) deallocate ( a ) allocate ( a ( n_unknowns )) call test ( 1 , n_unknowns ) isum = isum + n_valid ! write(*,*) iline, 'n_valid = ', n_valid end do end subroutine go recursive subroutine test ( i , n ) !! each ? can be either a . or a # !! check pattern to match the int list integer , intent ( in ) :: i , n integer :: ix integer , dimension ( * ), parameter :: icoeffs = [ POINT , NUMBER ] !! set of coefficients ['.', '#'] ! what we are not doing here is accounting for permutations ! that we know do not match, because the begin with a sequence ! that doesn't match. those need to be skipped... if ( i > n ) then ! so we have an array of 0s and 1s -> replace the 2s in the ipattern with these !     ipattern: 2220111  -> ???.### !            a: 011      -> .## !       result: 0110111  -> .##.### !write(*,'(a,1x,i5,1x, *(I1))') 'test:', iline, ipattern_tmp ipattern_tmp = unpack ( a , mask = ipattern == QUESTION , field = ipattern ) if ( match ( ipattern_tmp , ints )) n_valid = n_valid + 1 else do ix = 1 , 2 a ( i ) = icoeffs ( ix ) call test ( i + 1 , n ) end do end if end subroutine test logical function match ( ipattern , ints ) !! returns true if the pattern is valid for the int list. integer , dimension (:), intent ( in ) :: ipattern integer , dimension (:), intent ( in ) :: ints integer :: i , iacc , int_checked integer , dimension ( 1 ) :: ifirst , iend logical :: accumulating ! .##..###... -> 2,3 ! start and end indices (ignoring leading and trailing spaces) ifirst = findloc ( ipattern , 1 ) iend = findloc ( ipattern , 1 , back = . true .) if ( ifirst ( 1 ) == 0 . or . iend ( 1 ) == 0 ) then ! all blank match = . false .; return end if ! step through the pattern and stop once we find it invalid accumulating = . true . iacc = 0 int_checked = 0 ! the count of ints that have been checked match = . true . ! initialize do i = ifirst ( 1 ), iend ( 1 ) select case ( ipattern ( i )) case ( POINT ) if ( accumulating ) then int_checked = int_checked + 1 ! check the next one if ( int_checked > size ( ints )) then ! too many ints match = . false . return else if ( ints ( int_checked ) /= iacc ) then ! doesn't match match = . false . return end if accumulating = . false . iacc = 0 end if case ( NUMBER ) if ( accumulating ) then iacc = iacc + 1 else ! start of a new number accumulating = . true . iacc = 1 end if if ( i == iend ( 1 )) then ! last number int_checked = int_checked + 1 ! check the next one if ( int_checked /= size ( ints )) then ! not enough ints match = . false . return else if ( ints ( int_checked ) /= iacc ) then ! doesn't match match = . false . return end if end if end select end do end function match end program problem_12","tags":"","loc":"program/problem_12.html"},{"title":"dsm_test – AoC-2023","text":"Uses dsm_module numdiff_kinds_module iso_fortran_env program~~dsm_test~~UsesGraph program~dsm_test dsm_test iso_fortran_env iso_fortran_env program~dsm_test->iso_fortran_env module~dsm_module dsm_module program~dsm_test->module~dsm_module module~numdiff_kinds_module numdiff_kinds_module program~dsm_test->module~numdiff_kinds_module module~dsm_module->module~numdiff_kinds_module module~numdiff_kinds_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. This is a test program for subroutines dsm and fdjs .\n the test data represents a neutron kinetics problem. Reference Argonne National Laboratory. MINPACK Project. July 1983.\n    Thomas F. Coleman, Burton S. Garbow, Jorge J. More Thomas F. Coleman, Burton S. Garbow, Jorge J. More, \"Algorithm 618:\n    FORTRAN subroutines for estimating sparse Jacobian Matrices\",\n    ACM Transactions on Mathematical Software (TOMS),\n    Volume 10 Issue 3, Sept. 1984, Pages 346-347 Calls program~~dsm_test~~CallsGraph program~dsm_test dsm_test proc~dsm dsm_module::dsm program~dsm_test->proc~dsm proc~fcn dsm_test::fcn program~dsm_test->proc~fcn proc~fdjs dsm_module::fdjs program~dsm_test->proc~fdjs proc~degr dsm_module::degr proc~dsm->proc~degr proc~ido dsm_module::ido proc~dsm->proc~ido proc~numsrt dsm_module::numsrt proc~dsm->proc~numsrt proc~seq dsm_module::seq proc~dsm->proc~seq proc~setr dsm_module::setr proc~dsm->proc~setr proc~slo dsm_module::slo proc~dsm->proc~slo proc~srtdat dsm_module::srtdat proc~dsm->proc~srtdat proc~ido->proc~numsrt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: nwrite = output_unit unit for printing integer :: i integer :: info integer :: ip integer :: j integer :: jp integer :: l integer :: m integer :: maxgrp integer :: maxrow integer :: mingrp integer :: minrow integer :: n integer :: nnz integer :: numgrp integer :: indcol (6000) integer :: indrow (6000) integer :: ipntr (1201) integer :: jpntr (1201) integer :: ngrp (1200) logical :: col real(kind=wp) :: dnsm real(kind=wp) :: errij real(kind=wp) :: errmax real(kind=wp) :: fjact real(kind=wp) :: fjactr real(kind=wp) :: sum real(kind=wp) :: d (1200) real(kind=wp) :: fjac (6000) real(kind=wp) :: fjacd (1200) real(kind=wp) :: fvec (1200) real(kind=wp) :: x (1200) real(kind=wp) :: xd (1200) Subroutines subroutine fcn (n, x, Indcol, Ipntr, Fvec) Function subroutine for testing fdjs . Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: x (n) integer :: Indcol (*) integer :: Ipntr (n+1) real(kind=wp) :: Fvec (n) Source Code program dsm_test !! This is a test program for subroutines [[dsm]] and [[fdjs]]. !! the test data represents a neutron kinetics problem. !! !!### Reference !!  * Argonne National Laboratory. MINPACK Project. July 1983. !!    Thomas F. Coleman, Burton S. Garbow, Jorge J. More !!  * Thomas F. Coleman, Burton S. Garbow, Jorge J. More, \"Algorithm 618: !!    FORTRAN subroutines for estimating sparse Jacobian Matrices\", !!    ACM Transactions on Mathematical Software (TOMS), !!    Volume 10 Issue 3, Sept. 1984, Pages 346-347 use dsm_module use iso_fortran_env , only : output_unit use numdiff_kinds_module , only : wp implicit none integer , parameter :: nwrite = output_unit !! unit for printing integer i , info , ip , j , jp , l , m , maxgrp , maxrow , & mingrp , minrow , n , nnz , numgrp integer indcol ( 6000 ) , indrow ( 6000 ) , ipntr ( 1201 ) , jpntr ( 1201 ) , & ngrp ( 1200 ) logical col real ( wp ) :: dnsm , errij , errmax , fjact , fjactr , sum real ( wp ) :: d ( 1200 ) , fjac ( 6000 ) , fjacd ( 1200 ) , fvec ( 1200 ) , x ( 1200 ) , & xd ( 1200 ) col = . true . ! !     TEST FOR DSM AND FDJS. ! write ( nwrite , 99001 ) ! !     FORMAT STATEMENTS. ! 99001 format ( // ' TESTS FOR DSM AND FDJS - NEUTRON KINETICS PROBLEM' // & & ' STATISTICS GENERATED ' // '       N - NUMBER OF COLUMNS ' / & & '     NNZ - NUMBER OF NON-ZERO ELEMENTS' / & & '    DNSM - MATRIX DENSITY (PERCENTAGE)' / & & '  MINROW - MINIMUM NUMBER OF NON-ZEROS IN ANY ROW' / & & '  MAXROW - MAXIMUM NUMBER OF NON-ZEROS IN ANY ROW' / & & '  MINGRP - LOWER BOUND ON NUMBER OF GROUPS' / & & '  MAXGRP - NUMBER OF GROUPS DETERMINED BY DSM' // ) do n = 300 , 1200 , 300 write ( nwrite , 99002 ) 99002 format ( // 3 x , 'N' , 6 x , 'NNZ' , 5 x , 'DNSM' , 5 x , 'MINROW' , 4 x , 'MAXROW' , 4 x ,& & 'MINGRP' , 4 x , 'MAXGRP' // ) ! !        DEFINITION OF SPARSITY PATTERN. ! m = n l = n / 3 nnz = 0 do j = 1 , n nnz = nnz + 1 indrow ( nnz ) = j indcol ( nnz ) = j if ( mod ( j , l ) /= 0 ) then nnz = nnz + 1 indrow ( nnz ) = j + 1 indcol ( nnz ) = j endif if ( j <= 2 * l ) then nnz = nnz + 1 indrow ( nnz ) = j + l indcol ( nnz ) = j if ( mod ( j , l ) /= 1 ) then nnz = nnz + 1 indrow ( nnz ) = j - 1 indcol ( nnz ) = j endif endif nnz = nnz + 1 if ( j > l ) then indrow ( nnz ) = j - l else indrow ( nnz ) = j + 2 * l endif indcol ( nnz ) = j enddo ! !        CALL DSM. ! call dsm ( m , n , nnz , indrow , indcol , ngrp , maxgrp , mingrp , info , ipntr , jpntr ) if ( info <= 0 ) write ( nwrite , 99003 ) info 99003 format ( // ' *** MISTAKE IN INPUT DATA, INFO IS ***' , i6 ) ! !        STATISTICS FOR THE MATRIX. ! maxrow = 0 minrow = n do i = 1 , m maxrow = max ( maxrow , ipntr ( i + 1 ) - ipntr ( i )) minrow = min ( minrow , ipntr ( i + 1 ) - ipntr ( i )) enddo dnsm = real ( 100 * nnz , wp ) / real ( m * n , wp ) write ( nwrite , 99004 ) n , nnz , dnsm , minrow , maxrow , & & mingrp , maxgrp 99004 format ( 2 ( i5 , 3 x ), f6 . 2 , 4 x , 4 ( i5 , 5 x )) ! !        TEST FOR FDJS. ! do j = 1 , n x ( j ) = real ( j , wp ) / real ( n , wp ) enddo call fcn ( n , x , indcol , ipntr , fvec ) ! !        APPROXIMATE THE JACOBIAN MATRIX. ! do numgrp = 1 , maxgrp do j = 1 , n d ( j ) = 0.0_wp if ( ngrp ( j ) == numgrp ) d ( j ) = 1.0e-6_wp !d(j) = 0.001_wp xd ( j ) = x ( j ) + d ( j ) enddo call fcn ( n , xd , indcol , ipntr , fjacd ) do i = 1 , m fjacd ( i ) = fjacd ( i ) - fvec ( i ) enddo if ( col ) then call fdjs ( m , n , col , indrow , jpntr , ngrp , numgrp , d , fjacd , fjac ) else call fdjs ( m , n , col , indcol , ipntr , ngrp , numgrp , d , fjacd , fjac ) endif enddo ! !        TEST THE APPROXIMATION TO THE JACOBIAN. ! errmax = 0.0_wp if ( col ) then ! !           TEST FOR THE COLUMN-ORIENTED DEFINITION OF !           THE SPARSITY PATTERN. ! do j = 1 , n do jp = jpntr ( j ) , jpntr ( j + 1 ) - 1 i = indrow ( jp ) sum = 0.0_wp do ip = ipntr ( i ) , ipntr ( i + 1 ) - 1 sum = sum + x ( indcol ( ip )) enddo sum = sum + x ( i ) fjact = 1.0_wp + 2.0_wp * sum if ( i == j ) fjact = 2.0_wp * fjact errij = fjac ( jp ) - fjact if ( fjact /= 0.0_wp ) errij = errij / fjact errmax = max ( errmax , abs ( errij )) enddo enddo else ! !           TEST FOR THE ROW-ORIENTED DEFINITION OF !           THE SPARSITY PATTERN. ! do i = 1 , m sum = 0.0_wp do ip = ipntr ( i ) , ipntr ( i + 1 ) - 1 sum = sum + x ( indcol ( ip )) enddo sum = sum + x ( i ) fjactr = 1.0_wp + 2.0_wp * sum do ip = ipntr ( i ) , ipntr ( i + 1 ) - 1 j = indcol ( ip ) fjact = fjactr if ( i == j ) fjact = 2.0_wp * fjact errij = fjac ( ip ) - fjact if ( fjact /= 0.0_wp ) errij = errij / fjact errmax = max ( errmax , abs ( errij )) enddo enddo endif write ( nwrite , 99005 ) errmax 99005 format ( // ' LARGEST RELATIVE ERROR OF APPROXIMATION IS' , e10 . 2 ) col = . not . col enddo stop contains subroutine fcn ( n , x , Indcol , Ipntr , Fvec ) !! Function subroutine for testing [[fdjs]]. implicit none integer n integer Indcol ( * ) , Ipntr ( n + 1 ) real ( wp ) :: x ( n ) , Fvec ( n ) integer i , ip real ( wp ) :: sum do i = 1 , n sum = 0.0_wp do ip = Ipntr ( i ) , Ipntr ( i + 1 ) - 1 sum = sum + x ( Indcol ( ip )) enddo sum = sum + x ( i ) Fvec ( i ) = sum * ( 1.0_wp + sum ) + 1.0_wp enddo end subroutine fcn end program dsm_test","tags":"","loc":"program/dsm_test.html"},{"title":"test – AoC-2023","text":"Uses fmin_module program~~test~~UsesGraph program~test test module~fmin_module fmin_module program~test->module~fmin_module iso_fortran_env iso_fortran_env module~fmin_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Tests for fmin_module . Calls program~~test~~CallsGraph program~test test proc~fmin fmin_module::fmin program~test->proc~fmin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial real(kind=wp) :: ax real(kind=wp) :: bx real(kind=wp) :: xmin real(kind=wp) :: xerr real(kind=wp) :: x real(kind=wp), parameter :: pi = acos(-1.0_wp) real(kind=wp), parameter :: tol = 1.0e-8_wp Functions function func (x) result(f) Test function to minimize. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x indep. variable Return Value real(kind=wp) function value f(x) Source Code program test use fmin_module , wp => fmin_rk real ( wp ) :: ax , bx , xmin , xerr , x real ( wp ), parameter :: pi = acos ( - 1.0_wp ) real ( wp ), parameter :: tol = 1.0e-8_wp ax = - 4.0_wp bx = 0.0_wp x = - pi / 2.0_wp ! actual answer xmin = fmin ( func , ax , bx , tol ) xerr = xmin - x ! difference from try value write ( * , * ) 'xmin       = ' , xmin write ( * , * ) 'xmin exact = ' , x write ( * , * ) 'xmin error = ' , xerr if ( abs ( xerr ) > 1 0.0_wp * tol ) then error stop 'test failed' end if contains !***************************************************************************************** !***************************************************************************************** !> !  Test function to minimize. function func ( x ) result ( f ) implicit none real ( wp ), intent ( in ) :: x !! indep. variable real ( wp ) :: f !! function value `f(x)` f = sin ( x ) end function func !***************************************************************************************** !***************************************************************************************** end program test","tags":"","loc":"program/test.html"},{"title":"problem_5 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_5~~UsesGraph program~problem_5 problem_5 iso_fortran_env iso_fortran_env program~problem_5->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_5->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_5~~CallsGraph program~problem_5 problem_5 interface~startswith aoc_utilities::startswith program~problem_5->interface~startswith proc~clock_end aoc_utilities::clock%clock_end program~problem_5->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_5->proc~clock_start proc~in_seed_list problem_5::in_seed_list program~problem_5->proc~in_seed_list proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_5->proc~number_of_lines_in_file proc~parse_ints64 aoc_utilities::parse_ints64 program~problem_5->proc~parse_ints64 proc~populate problem_5::populate program~problem_5->proc~populate proc~read_line aoc_utilities::read_line program~problem_5->proc~read_line proc~traverse problem_5::traverse program~problem_5->proc~traverse proc~startswith_cc aoc_utilities::startswith_cc interface~startswith->proc~startswith_cc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~map problem_5::map proc~traverse->proc~map proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: iunit integer :: n_lines character(len=:), allocatable :: line type( string ), dimension(:), allocatable :: vals integer(kind=ip), dimension(:), allocatable :: seeds_list integer(kind=ip) :: ilocation_min integer(kind=ip) :: ilocation integer(kind=ip) :: iseed integer(kind=ip), dimension(:), allocatable :: ilocation_min_parallel integer, parameter :: NSTAGES = 7 type( mapping ), dimension(NSTAGES) :: mappings integer :: parsing_state Derived Types type :: mapping Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(:), allocatable :: dest_start integer(kind=ip), public, dimension(:), allocatable :: dest_end integer(kind=ip), public, dimension(:), allocatable :: src_start integer(kind=ip), public, dimension(:), allocatable :: src_end Functions function in_seed_list (iseed) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: iseed Return Value logical pure function map (ival, m, reverse) result(idest) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: ival type( mapping ), intent(in) :: m logical, intent(in) :: reverse Return Value integer(kind=ip) pure function traverse (iseed, reverse) result(ilocation) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: iseed logical, intent(in) :: reverse if reverse, then ilocation -> iseed Return Value integer(kind=ip) Subroutines subroutine populate (nums, m) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(3) :: nums type( mapping ), intent(inout) :: m Source Code program problem_5 use iso_fortran_env use aoc_utilities implicit none integer :: i , iunit , n_lines character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals integer ( ip ), dimension (:), allocatable :: seeds_list integer ( ip ) :: ilocation_min , ilocation , iseed integer ( ip ), dimension (:), allocatable :: ilocation_min_parallel type :: mapping ! save the source and destination start and end values integer ( ip ), dimension (:), allocatable :: dest_start , dest_end , src_start , src_end end type mapping integer , parameter :: NSTAGES = 7 type ( mapping ), dimension ( NSTAGES ) :: mappings ! seed_to_soil, soil_to_fertilizer, fertilizer_to_water, water_to_light, ! light_to_temperature, temperature_to_humidity, humidity_to_location integer :: parsing_state ! index in mappings (1 to NSTAGES) call clk % tic () do i = 1 , NSTAGES allocate ( mappings ( i )% dest_start ( 0 ), mappings ( i )% dest_end ( 0 ),& mappings ( i )% src_start ( 0 ), mappings ( i )% src_end ( 0 )) end do ! open(newunit=iunit, file='inputs/day5_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day5.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) parsing_state = 0 do i = 1 , n_lines line = read_line ( iunit ) if ( line == '' ) cycle ! blank line if ( startswith ( line , 'seeds:' )) then ; seeds_list = parse_ints64 ( line ( 7 :)) else if ( index ( line , 'map:' ) > 0 ) then ; parsing_state = parsing_state + 1 ! one of the 7 stages else ! parse the numbers for the given state: call populate ( parse_ints64 ( line ), mappings ( parsing_state )) end if end do close ( iunit ) ! ------------ part 1 ----------------- ilocation_min = huge ( 1 ) do i = 1 , size ( seeds_list ) ilocation = traverse ( seeds_list ( i ),. false .) if ( ilocation < ilocation_min ) ilocation_min = ilocation end do print * , '5a: ' , ilocation_min ! ------------ part 2 ----------------- !  so it doesn't run in the CI !! if (. false .) then ! brute force, openMP version. just run the part a algorithm for all the seeds. ! takes a minute or so on my computer. allocate ( ilocation_min_parallel ( size ( seeds_list ) / 2 )) ilocation_min_parallel = huge ( 1 ) !$OMP PARALLEL DO SHARED(ilocation_min_parallel) PRIVATE(i,iseed,ilocation) do i = 1 , size ( seeds_list ), 2 do iseed = seeds_list ( i ), seeds_list ( i ) + seeds_list ( i + 1 ) - 1 ilocation = traverse ( iseed , . false .) if ( ilocation < ilocation_min_parallel (( i + 1 ) / 2 )) ilocation_min_parallel (( i + 1 ) / 2 ) = ilocation end do end do !$OMP END PARALLEL DO print * , '5b: ' , minval ( ilocation_min_parallel ) end if ! ------------ part 2 ----------------- ! Alternate version, go backwards from the location to the seed ! and see if it is contained in the seed set. ! this one is pretty fast (< 1 sec) do ilocation = minval ( mappings ( 7 )% dest_start ), maxval ( mappings ( 7 )% dest_end ) ! up to the max ilocation value iseed = traverse ( ilocation , reverse = . true .) ! from ilocation to iseed if ( in_seed_list ( iseed )) exit ! found the min end do print * , '5b: ' , ilocation call clk % toc ( '5' ) contains logical function in_seed_list ( iseed ) ! for part b, is the seed in the initial list integer ( ip ), intent ( in ) :: iseed integer :: i do i = 1 , size ( seeds_list ), 2 if ( iseed >= seeds_list ( i ) . and . iseed <= seeds_list ( i ) + seeds_list ( i + 1 ) - 1 ) then in_seed_list = . true . return end if end do in_seed_list = . false . end function in_seed_list subroutine populate ( nums , m ) integer ( ip ), dimension ( 3 ), intent ( in ) :: nums ! the three numbers from the line: ! [dest range start, src range start, range length type ( mapping ), intent ( inout ) :: m ! structure to add this data to associate ( dest => nums ( 1 ), source => nums ( 2 ), range => nums ( 3 ) ) m % dest_start = [ m % dest_start , dest ] m % dest_end = [ m % dest_end , dest + range - 1 ] m % src_start = [ m % src_start , source ] m % src_end = [ m % src_end , source + range - 1 ] end associate end subroutine populate pure function map ( ival , m , reverse ) result ( idest ) integer ( ip ), intent ( in ) :: ival type ( mapping ), intent ( in ) :: m logical , intent ( in ) :: reverse ! if reversed, go from: dest -> src integer ( ip ) :: idest integer :: i if ( reverse ) then do i = 1 , size ( m % src_start ) ! locate ival (dest) in the dest start:end range if ( ival >= m % dest_start ( i ) . and . ival <= m % dest_end ( i )) then ! found it, map to dest idest = m % src_start ( i ) + ( ival - m % dest_start ( i )) ! this is the resultant isource return end if end do else do i = 1 , size ( m % src_start ) ! locate ival (source) in the source start:end range if ( ival >= m % src_start ( i ) . and . ival <= m % src_end ( i )) then ! found it, map to dest idest = m % dest_start ( i ) + ( ival - m % src_start ( i )) return end if end do end if idest = ival ! if not found in any of the sets end function map pure function traverse ( iseed , reverse ) result ( ilocation ) integer ( ip ), intent ( in ) :: iseed logical , intent ( in ) :: reverse !! if reverse, then ilocation -> iseed integer ( ip ) :: ilocation integer :: i ilocation = iseed ! initialize if ( reverse ) then do i = NSTAGES , 1 , - 1 ilocation = map ( ilocation , mappings ( i ), reverse ) ! this is really iseed end do else do i = 1 , NSTAGES ilocation = map ( ilocation , mappings ( i ), reverse ) end do end if end function traverse end program problem_5","tags":"","loc":"program/problem_5.html"},{"title":"problem_12b – AoC-2023","text":"Uses aoc_cache_module iso_fortran_env aoc_utilities program~~problem_12b~~UsesGraph program~problem_12b problem_12b iso_fortran_env iso_fortran_env program~problem_12b->iso_fortran_env module~aoc_cache_module aoc_cache_module program~problem_12b->module~aoc_cache_module module~aoc_utilities aoc_utilities program~problem_12b->module~aoc_utilities module~aoc_cache_module->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. completely reworked solution from part a\nthis one starts with the int list and checks it against the pattern.\nit also employs a function cache to speed it up. Calls program~~problem_12b~~CallsGraph program~problem_12b problem_12b interface~split aoc_utilities::split program~problem_12b->interface~split proc~clock_end aoc_utilities::clock%clock_end program~problem_12b->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_12b->proc~clock_start proc~go problem_12b::go program~problem_12b->proc~go proc~initialize_cache~2 aoc_cache_module::function_cache%initialize_cache program~problem_12b->proc~initialize_cache~2 proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_12b->proc~number_of_lines_in_file proc~parse_ints aoc_utilities::parse_ints program~problem_12b->proc~parse_ints proc~read_line aoc_utilities::read_line program~problem_12b->proc~read_line proc~str_to_int64_array_with_mapping aoc_utilities::str_to_int64_array_with_mapping program~problem_12b->proc~str_to_int64_array_with_mapping proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~go->proc~get_from_cache~2 proc~ipoint problem_12b::ipoint proc~go->proc~ipoint proc~ipound problem_12b::ipound proc~go->proc~ipound proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~go->proc~put_in_cache~2 proc~destroy_cache~2 aoc_cache_module::function_cache%destroy_cache proc~initialize_cache~2->proc~destroy_cache~2 proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 proc~ipoint->proc~go proc~ipound->proc~go ints_tmp ints_tmp proc~ipound->ints_tmp ipattern_tmp ipattern_tmp proc~ipound->ipattern_tmp proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer(kind=ip), parameter :: POINT = -1 integer(kind=ip), parameter :: NUMBER = -2 integer(kind=ip), parameter :: QUESTION = -3 integer :: iunit integer :: n_lines integer :: iline character(len=:), allocatable :: line character(len=:), allocatable :: pattern type( string ), dimension(:), allocatable :: vals integer(kind=ip), dimension(:), allocatable :: ints integer(kind=ip), dimension(:), allocatable :: ipattern integer(kind=ip) :: isum integer(kind=ip) :: ival type( function_cache ) :: cache to cache the go function values Functions recursive function go (ipattern, ints) result(ival) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ipattern integer(kind=ip), intent(in), dimension(:) :: ints Return Value integer(kind=ip) recursive function ipound (ipattern, ints) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ipattern first char is a # integer(kind=ip), intent(in), dimension(:) :: ints Return Value integer(kind=ip) recursive function ipoint (ipattern, ints) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ipattern first char is a . integer(kind=ip), intent(in), dimension(:) :: ints Return Value integer(kind=ip) Source Code program problem_12b !! completely reworked solution from part a !! this one starts with the int list and checks it against the pattern. !! it also employs a function cache to speed it up. use iso_fortran_env use aoc_utilities use aoc_cache_module implicit none ! note: these are negative because we are appending ! them to the pattern for the cache integer ( ip ), parameter :: POINT = - 1 ! . integer ( ip ), parameter :: NUMBER = - 2 ! # integer ( ip ), parameter :: QUESTION = - 3 ! ? ! some global variables integer :: iunit , n_lines , iline character ( len = :), allocatable :: line , pattern type ( string ), dimension (:), allocatable :: vals integer ( ip ), dimension (:), allocatable :: ints , ipattern integer ( ip ) :: isum , ival type ( function_cache ) :: cache !! to cache the [[go]] function values call clk % tic () call cache % initialize ( isize = 10000 , chunk_size = 1000 ) ! open(newunit=iunit, file='inputs/day12_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day12.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ints = parse_ints ( vals ( 2 )% str ) ! integer list pattern = vals ( 1 )% str ! the pattern ! will convert the pattern to an array of numbers: ipattern = str_to_int64_array_with_mapping ( pattern ,[ '.' , '#' , '?' ],& [ POINT , NUMBER , QUESTION ]) ! expand the input ipattern = [ ipattern , QUESTION , ipattern , QUESTION , & ipattern , QUESTION , ipattern , QUESTION , & ipattern ] ints = [ ints , ints , ints , ints , ints ] ival = go ( ipattern , ints ) isum = isum + ival end do write ( * , * ) '12b: ' , isum call clk % toc ( '12b' ) contains recursive function go ( ipattern , ints ) result ( ival ) integer ( ip ), dimension (:), intent ( in ) :: ipattern integer ( ip ), dimension (:), intent ( in ) :: ints integer ( ip ) :: ival integer ( ip ), dimension (:), allocatable :: ival_vec integer ( ip ) :: idx logical :: found ! first check the cache: call cache % get ([ ipattern , ints ], idx , ival_vec , found ) if ( found ) then ival = ival_vec ( 1 ) else if ( size ( ints ) == 0 ) then ! no more ints ival = merge ( 0 , 1 , any ( ipattern == NUMBER )) ! if any more numbers, invalid else if ( size ( ipattern ) == 0 ) then ival = 0 ! too many ints else ! process next element in pattern select case ( ipattern ( 1 )) case ( NUMBER ); ival = ipound ( ipattern , ints ) case ( POINT ); ival = ipoint ( ipattern , ints ) case ( QUESTION ); ival = ipoint ( ipattern , ints ) + ipound ( ipattern , ints ) end select end if ! cache this function call: ival_vec = [ ival ] call cache % put ( idx ,[ ipattern , ints ], ival_vec ) end if end function go recursive integer ( ip ) function ipound ( ipattern , ints ) integer ( ip ), dimension (:), intent ( in ) :: ipattern !! first char is a # integer ( ip ), dimension (:), intent ( in ) :: ints integer ( ip ), dimension (:), allocatable :: this_group ! check for the number of # that correspond to the first group if ( size ( ipattern ) >= ints ( 1 )) then this_group = ipattern ( 1 : ints ( 1 )) where ( this_group == QUESTION ) this_group = NUMBER ! replace ? with # if ( any ( this_group /= NUMBER )) then ! can't fit all the #'s so not valid ipound = 0 return else ! so far so good end if else ! not enough room to hold all the #'s ipound = 0 return end if if ( size ( ipattern ) == ints ( 1 )) then ! if this is the last group, then we are done ipound = merge ( 1 , 0 , size ( ints ) == 1 ) else ! the next character after this number must be a ? or . if ( size ( ipattern ) >= ints ( 1 ) + 1 ) then if ( any ( ipattern ( ints ( 1 ) + 1 ) == [ QUESTION , POINT ])) then block integer ( ip ), dimension (:), allocatable :: ipattern_tmp , ints_tmp ! to handle edge cases ! skip it and process the next group if ( size ( ipattern ) >= ints ( 1 ) + 2 ) then ipattern_tmp = ipattern ( ints ( 1 ) + 2 :) else allocate ( ipattern_tmp ( 0 )) end if if ( size ( ints ) >= 2 ) then ints_tmp = ints ( 2 :) else allocate ( ints_tmp ( 0 )) end if ipound = go ( ipattern_tmp , ints_tmp ) return end block end if end if ! not valid at this point ipound = 0 end if end function ipound recursive integer ( ip ) function ipoint ( ipattern , ints ) integer ( ip ), dimension (:), intent ( in ) :: ipattern !! first char is a . integer ( ip ), dimension (:), intent ( in ) :: ints if ( size ( ipattern ) <= 1 ) then ipoint = go ([ integer ( ip ) :: ], ints ) ! done, pass in empty array else ipoint = go ( ipattern ( 2 :), ints ) ! skip it and go to next one end if end function ipoint end program problem_12b","tags":"","loc":"program/problem_12b.html"},{"title":"problem_8 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_8~~UsesGraph program~problem_8 problem_8 iso_fortran_env iso_fortran_env program~problem_8->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_8->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_8~~CallsGraph program~problem_8 problem_8 proc~clock_end aoc_utilities::clock%clock_end program~problem_8->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_8->proc~clock_start proc~find_node problem_8::find_node program~problem_8->proc~find_node proc~lcm aoc_utilities::lcm program~problem_8->proc~lcm proc~moves problem_8::moves program~problem_8->proc~moves proc~moves_any_z problem_8::moves_any_z program~problem_8->proc~moves_any_z proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_8->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_8->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit integer :: n_lines character(len=:), allocatable :: line character(len=:), allocatable :: instructions type( string ), dimension(:), allocatable :: vals integer(kind=ip) :: i integer(kind=ip) :: j integer(kind=ip) :: idx integer(kind=ip) :: idx_zzz integer(kind=ip) :: imoves integer(kind=ip) :: ias integer(kind=ip) :: izs integer(kind=ip), dimension(:), allocatable :: instructions_ints integer(kind=ip), dimension(:), allocatable :: idx_vec integer(kind=ip), dimension(:), allocatable :: idx_zzz_vec integer(kind=ip), dimension(:), allocatable :: imoves_vec type( node ), dimension(:), allocatable :: nodes Derived Types type :: node Components Type Visibility Attributes Name Initial character(len=3), public :: name = '' character(len=3), public, dimension(2) :: lr integer, public, dimension(2) :: lr_idx Functions pure function moves (istart, iend) result(imoves) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: istart indices for start and end nodes integer(kind=ip), intent(in) :: iend indices for start and end nodes Return Value integer(kind=ip) pure function moves_any_z (istart, iend) result(imoves) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: istart indices for start and end nodes integer(kind=ip), intent(in), dimension(:) :: iend Return Value integer(kind=ip) pure function all_in_set (ivals, iset) returns true if all the elements of ivals are in the set iset Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals integer(kind=ip), intent(in), dimension(:) :: iset Return Value logical pure function find_node (name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value integer(kind=ip) Source Code program problem_8 use iso_fortran_env use aoc_utilities implicit none integer :: iunit , n_lines character ( len = :), allocatable :: line , instructions type ( string ), dimension (:), allocatable :: vals integer ( ip ) :: i , j , idx , idx_zzz , imoves , ias , izs integer ( ip ), dimension (:), allocatable :: instructions_ints integer ( ip ), dimension (:), allocatable :: idx_vec , idx_zzz_vec integer ( ip ), dimension (:), allocatable :: imoves_vec type :: node character ( len = 3 ) :: name = '' character ( len = 3 ), dimension ( 2 ) :: lr integer , dimension ( 2 ) :: lr_idx ! the indices in the nodes array of the l,r nodes end type node type ( node ), dimension (:), allocatable :: nodes call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day8_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day8.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( nodes ( n_lines - 2 )) instructions = read_line ( iunit ) allocate ( instructions_ints ( len ( instructions ))) do i = 1 , len ( instructions ) select case ( instructions ( i : i )) ! make an int array for easier access case ( 'L' ); instructions_ints ( i ) = 1 case ( 'R' ); instructions_ints ( i ) = 2 end select end do do i = 0 , n_lines - 1 line = read_line ( iunit ) if ( line == '' ) cycle read ( line , \"(A3,1X,1X,1X,1X,A3,1X,1X,A3,1X)\" ) nodes ( i )% name , nodes ( i )% lr ( 1 ), nodes ( i )% lr ( 2 ) end do close ( iunit ) ! compute all the lr indices: do i = 1 , size ( nodes ) nodes ( i )% lr_idx ( 1 ) = find_node ( nodes ( i )% lr ( 1 )) nodes ( i )% lr_idx ( 2 ) = find_node ( nodes ( i )% lr ( 2 )) end do !******************************************** imoves = moves ( find_node ( 'AAA' ), find_node ( 'ZZZ' )) write ( * , * ) '8a : number of moves:' , imoves !******************************************** ! get indices of the ones that end in A and Z: allocate ( idx_vec ( 0 ), idx_zzz_vec ( 0 )) do i = 1 , size ( nodes ) if ( nodes ( i )% name ( 3 : 3 ) == 'A' ) idx_vec = [ idx_vec , i ] if ( nodes ( i )% name ( 3 : 3 ) == 'Z' ) idx_zzz_vec = [ idx_zzz_vec , i ] end do if ( size ( idx_vec ) /= size ( idx_zzz_vec )) error stop 'error: they need to be the same size?' allocate ( imoves_vec ( size ( idx_vec ))) ! for EACH start, find the number of moves that it takes to get to ONE of the ends. do i = 1 , size ( idx_vec ) imoves_vec ( i ) = moves_any_z ( idx_vec ( i ), idx_zzz_vec ) end do ! don't know why this works ¯\\_(ツ)_/¯ ! I think it's a feature of the specific data given ! (it's a repeating cycle once it gets to the end) write ( * , * ) '8b : number of moves: ' , lcm ( lcm ( lcm ( lcm ( lcm ( imoves_vec ( 1 ),& imoves_vec ( 2 )),& imoves_vec ( 3 )),& imoves_vec ( 4 )),& imoves_vec ( 5 )),& imoves_vec ( 6 )) ! ! ! ! brute force. run all the moves in parallel until they are all done. ! ! ! i = 0 ! imoves = 0 ! do !     if (all_in_set(idx_vec, idx_zzz_vec)) exit !     imoves = imoves + 1 ! another move !     i = i + 1 !     if (i>len(instructions)) i = 1 !     do concurrent (j = 1 : size(idx_vec)) !         idx_vec(j) = nodes(idx_vec(j))%lr_idx(instructions_ints(i)) !     end do ! end do ! write(*,*) '8b : number of moves:', imoves call clk % toc ( '8' ) contains pure function moves ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart , iend !! indices for start and end nodes integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( idx == iend ) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves pure function moves_any_z ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart !! indices for start and end nodes integer ( ip ), dimension (:), intent ( in ) :: iend integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( any ( idx == iend )) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves_any_z pure logical function all_in_set ( ivals , iset ) !! returns true if all the elements of ivals are in the set iset integer ( ip ), dimension (:), intent ( in ) :: ivals , iset integer :: i all_in_set = . true . do i = 1 , size ( ivals ) if (. not . any ( ivals ( i ) == iset )) then all_in_set = . false . exit end if end do end function all_in_set pure integer ( ip ) function find_node ( name ) character ( len =* ), intent ( in ) :: name integer ( ip ) :: i do i = 1 , size ( nodes ) if ( name == nodes ( i )% name ) then find_node = i return end if end do error stop 'could not find node' end function find_node end program problem_8","tags":"","loc":"program/problem_8.html"},{"title":"test1 – AoC-2023","text":"Uses numerical_differentiation_module numdiff_kinds_module iso_fortran_env program~~test1~~UsesGraph program~test1 test1 iso_fortran_env iso_fortran_env program~test1->iso_fortran_env module~numdiff_kinds_module numdiff_kinds_module program~test1->module~numdiff_kinds_module module~numerical_differentiation_module numerical_differentiation_module program~test1->module~numerical_differentiation_module module~numdiff_kinds_module->iso_fortran_env module~numerical_differentiation_module->iso_fortran_env module~numerical_differentiation_module->module~numdiff_kinds_module module~diff_module diff_module module~numerical_differentiation_module->module~diff_module module~dsm_module dsm_module module~numerical_differentiation_module->module~dsm_module module~numdiff_cache_module numdiff_cache_module module~numerical_differentiation_module->module~numdiff_cache_module module~numdiff_utilities_module numdiff_utilities_module module~numerical_differentiation_module->module~numdiff_utilities_module module~diff_module->module~numdiff_kinds_module module~dsm_module->module~numdiff_kinds_module module~numdiff_cache_module->iso_fortran_env module~numdiff_cache_module->module~numdiff_kinds_module module~numdiff_cache_module->module~numdiff_utilities_module module~numdiff_utilities_module->module~numdiff_kinds_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Test1 for the numerical differentiation module. Calls program~~test1~~CallsGraph program~test1 test1 proc~compute_jacobian numerical_differentiation_module::numdiff_type%compute_jacobian program~test1->proc~compute_jacobian proc~destroy_numdiff_type numerical_differentiation_module::numdiff_type%destroy_numdiff_type program~test1->proc~destroy_numdiff_type proc~failed numerical_differentiation_module::numdiff_type%failed program~test1->proc~failed proc~get_all_methods_in_class numerical_differentiation_module::get_all_methods_in_class program~test1->proc~get_all_methods_in_class proc~get_error_status numerical_differentiation_module::numdiff_type%get_error_status program~test1->proc~get_error_status proc~get_finite_diff_formula numerical_differentiation_module::get_finite_diff_formula program~test1->proc~get_finite_diff_formula proc~get_formula numerical_differentiation_module::finite_diff_method%get_formula program~test1->proc~get_formula proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff program~test1->proc~initialize_numdiff proc~initialize_numdiff_for_diff numerical_differentiation_module::numdiff_type%initialize_numdiff_for_diff program~test1->proc~initialize_numdiff_for_diff proc~print_sparsity_matrix numerical_differentiation_module::numdiff_type%print_sparsity_matrix program~test1->proc~print_sparsity_matrix proc~print_sparsity_pattern numerical_differentiation_module::numdiff_type%print_sparsity_pattern program~test1->proc~print_sparsity_pattern proc~select_finite_diff_method numerical_differentiation_module::numdiff_type%select_finite_diff_method program~test1->proc~select_finite_diff_method proc~compute_perturbation_vector numerical_differentiation_module::numdiff_type%compute_perturbation_vector proc~compute_jacobian->proc~compute_perturbation_vector proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_jacobian->proc~raise_exception proc~get_finite_difference_method numerical_differentiation_module::get_finite_difference_method proc~get_all_methods_in_class->proc~get_finite_difference_method proc~get_finite_diff_formula->proc~get_formula proc~get_finite_diff_formula->proc~get_finite_difference_method proc~integer_to_string numerical_differentiation_module::integer_to_string proc~get_formula->proc~integer_to_string proc~initialize_numdiff->proc~get_all_methods_in_class proc~destroy_cache numdiff_cache_module::function_cache%destroy_cache proc~initialize_numdiff->proc~destroy_cache proc~initialize_numdiff->proc~get_finite_difference_method proc~initialize_cache numdiff_cache_module::function_cache%initialize_cache proc~initialize_numdiff->proc~initialize_cache proc~initialize_numdiff->proc~raise_exception proc~set_numdiff_bounds numerical_differentiation_module::numdiff_type%set_numdiff_bounds proc~initialize_numdiff->proc~set_numdiff_bounds proc~set_sparsity_mode numerical_differentiation_module::numdiff_type%set_sparsity_mode proc~initialize_numdiff->proc~set_sparsity_mode proc~initialize_numdiff_for_diff->proc~destroy_cache proc~initialize_numdiff_for_diff->proc~initialize_cache proc~initialize_numdiff_for_diff->proc~raise_exception proc~initialize_numdiff_for_diff->proc~set_numdiff_bounds proc~initialize_numdiff_for_diff->proc~set_sparsity_mode proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_perturbation_vector->proc~compute_perturb_vector proc~initialize_cache->proc~destroy_cache proc~set_numdiff_bounds->proc~integer_to_string proc~set_numdiff_bounds->proc~raise_exception proc~set_sparsity_mode->proc~raise_exception proc~set_numdiff_sparsity_bounds numerical_differentiation_module::numdiff_type%set_numdiff_sparsity_bounds proc~set_sparsity_mode->proc~set_numdiff_sparsity_bounds proc~compute_perturb_vector->proc~raise_exception proc~set_numdiff_sparsity_bounds->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: n = 10 integer, parameter :: m = 6 real(kind=wp), parameter,               dimension(n) :: x = 1.0_wp real(kind=wp), parameter,               dimension(n) :: xlow = -10.0_wp real(kind=wp), parameter,               dimension(n) :: xhigh = 10.0_wp real(kind=wp), parameter,               dimension(n) :: dpert = 1.0e-5_wp integer, parameter :: perturb_mode = 1 integer, parameter :: cache_size = 0 0 indicates not to use cache integer, parameter :: sparsity_mode = 4 type( numdiff_type ) :: my_prob integer :: i counter integer :: j counter real(kind=wp), dimension(:), allocatable :: jac character(len=:), allocatable :: formula type( finite_diff_method ) :: fd logical :: status_ok type( meth_array ) :: meths integer :: func_evals function evaluation counter integer, dimension(:), allocatable :: methods array of method IDs character(len=:), allocatable :: error_msg error message string Subroutines subroutine my_func (me, x, f, funcs_to_compute) Problem function Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: f integer, intent(in), dimension(:) :: funcs_to_compute Source Code program test1 use iso_fortran_env , only : output_unit , error_unit use numerical_differentiation_module use numdiff_kinds_module , only : wp implicit none integer , parameter :: n = 10 integer , parameter :: m = 6 real ( wp ), dimension ( n ), parameter :: x = 1.0_wp real ( wp ), dimension ( n ), parameter :: xlow = - 1 0.0_wp real ( wp ), dimension ( n ), parameter :: xhigh = 1 0.0_wp real ( wp ), dimension ( n ), parameter :: dpert = 1.0e-5_wp integer , parameter :: perturb_mode = 1 integer , parameter :: cache_size = 0 !! `0` indicates not to use cache integer , parameter :: sparsity_mode = 4 type ( numdiff_type ) :: my_prob integer :: i !! counter integer :: j !! counter real ( wp ), dimension (:), allocatable :: jac character ( len = :), allocatable :: formula type ( finite_diff_method ) :: fd logical :: status_ok type ( meth_array ) :: meths integer :: func_evals !! function evaluation counter integer , dimension (:), allocatable :: methods !! array of method IDs character ( len = :), allocatable :: error_msg !! error message string methods = [( i , i = 1 , 44 )] methods = [ methods , 500 , 600 , 700 , 800 ] ! these only have central diffs do j = 1 , size ( methods ) ! try different finite diff methods i = methods ( j ) call get_finite_diff_formula ( i , formula ) if ( formula == '' ) then write ( output_unit , * ) 'id ' , i , 'not available' cycle end if func_evals = 0 call my_prob % destroy () call my_prob % initialize ( n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func = my_func ,& sparsity_mode = sparsity_mode ,& jacobian_method = i ,& partition_sparsity_pattern = . false .,& cache_size = cache_size ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if if ( i == 1 ) then write ( output_unit , '(A)' ) '' call my_prob % print_sparsity_pattern ( output_unit ) write ( output_unit , '(A)' ) '' call my_prob % print_sparsity_matrix ( output_unit ) write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '--------------------------------------' write ( output_unit , '(A,I4)' ) ' specify method [no partitioning] : ' , i write ( output_unit , '(A)' ) '--------------------------------------' write ( output_unit , '(A)' ) '' end if write ( output_unit , '(A)' ) formula write ( output_unit , '(A)' ) '' write ( output_unit , '(A,1X,*(F27.16,\",\"))' ) 'jac =' , jac write ( output_unit , '(A,1X,I5)' ) 'function evaluations:' , func_evals write ( output_unit , '(A)' ) '' end do do j = 1 , size ( methods ) ! try different finite diff methods i = methods ( j ) call get_finite_diff_formula ( i , formula ) if ( formula == '' ) then write ( output_unit , * ) 'id ' , i , 'not available' cycle end if func_evals = 0 call my_prob % destroy () call my_prob % initialize ( n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func = my_func ,& sparsity_mode = sparsity_mode ,& jacobian_method = i ,& partition_sparsity_pattern = . true .,& cache_size = 1000 ) ! use the cache for these cases if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if if ( i == 1 ) then write ( output_unit , '(A)' ) '' call my_prob % print_sparsity_pattern ( output_unit ) write ( output_unit , '(A)' ) '' call my_prob % print_sparsity_matrix ( output_unit ) write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '--------------------------------------' write ( output_unit , '(A,I4)' ) ' specify method [with partitioning] : ' , i write ( output_unit , '(A)' ) '--------------------------------------' write ( output_unit , '(A)' ) '' end if write ( output_unit , '(A)' ) formula write ( output_unit , '(A)' ) '' write ( output_unit , '(A,1X,*(F27.16,\",\"))' ) 'jac =' , jac write ( output_unit , '(A,1X,I5)' ) 'function evaluations:' , func_evals write ( output_unit , '(A)' ) '' end do meths = get_all_methods_in_class ( 3 ) write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) 'select_finite_diff_method' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) '' call my_prob % select_finite_diff_method ( 0.0_wp , 0.0_wp , 1.0_wp , 0.001_wp , meths , fd , status_ok ) call fd % get_formula ( formula ) write ( output_unit , '(A)' ) formula write ( output_unit , '(A)' ) '' call my_prob % select_finite_diff_method ( 0.9999_wp , 0.0_wp , 1.0_wp , 0.001_wp , meths , fd , status_ok ) call fd % get_formula ( formula ) write ( output_unit , '(A)' ) formula write ( output_unit , '(A)' ) '' do i = 2 , 9 write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A,I2)' ) ' specify class [no partitioning] : ' , i write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) '' func_evals = 0 call my_prob % destroy () call my_prob % initialize ( n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func = my_func ,& sparsity_mode = sparsity_mode ,& class = i ,& cache_size = cache_size ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if write ( output_unit , '(A,1X,*(F27.16,\",\"))' ) 'jac =' , jac write ( output_unit , '(A,1X,I5)' ) 'function evaluations:' , func_evals write ( output_unit , '(A)' ) '' end do do i = 2 , 9 write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A,I2)' ) ' specify class [with partitioning] : ' , i write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) '' func_evals = 0 call my_prob % destroy () call my_prob % initialize ( n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func = my_func ,& sparsity_mode = sparsity_mode ,& class = i , partition_sparsity_pattern = . true .,& cache_size = cache_size ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if write ( output_unit , '(A,1X,*(F27.16,\",\"))' ) 'jac =' , jac write ( output_unit , '(A,1X,I5)' ) 'function evaluations:' , func_evals write ( output_unit , '(A)' ) '' end do write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) ' diff algorithm' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) '' func_evals = 0 call my_prob % diff_initialize ( n , m , xlow , xhigh , my_func , sparsity_mode = 1 ,& ! use a dense method for this one cache_size = cache_size ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if write ( output_unit , '(A,1X,*(F27.16,\",\"))' ) 'jac =' , jac write ( output_unit , '(A,1X,I5)' ) 'function evaluations:' , func_evals write ( output_unit , '(A)' ) '' contains subroutine my_func ( me , x , f , funcs_to_compute ) !! Problem function implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f integer , dimension (:), intent ( in ) :: funcs_to_compute if ( any ( funcs_to_compute == 1 )) f ( 1 ) = x ( 1 ) * x ( 2 ) - x ( 3 ) ** 3 if ( any ( funcs_to_compute == 2 )) f ( 2 ) = x ( 3 ) - 1.0_wp if ( any ( funcs_to_compute == 3 )) f ( 3 ) = x ( 4 ) * x ( 5 ) if ( any ( funcs_to_compute == 4 )) f ( 4 ) = 2.0_wp * x ( 6 ) + sin ( x ( 7 )) if ( any ( funcs_to_compute == 5 )) f ( 5 ) = cos ( x ( 8 )) + sqrt ( abs ( x ( 9 ))) if ( any ( funcs_to_compute == 6 )) f ( 6 ) = 1.0_wp / ( 1.0_wp + exp ( x ( 10 ))) func_evals = func_evals + 1 end subroutine my_func !******************************************************************************* end program test1","tags":"","loc":"program/test1.html"},{"title":"problem_3 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_3~~UsesGraph program~problem_3 problem_3 iso_fortran_env iso_fortran_env program~problem_3->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_3->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_3~~CallsGraph program~problem_3 problem_3 proc~check problem_3::check program~problem_3->proc~check proc~clock_end aoc_utilities::clock%clock_end program~problem_3->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_3->proc~clock_start proc~get_number problem_3::get_number program~problem_3->proc~get_number proc~is_not_number aoc_utilities::is_not_number program~problem_3->proc~is_not_number proc~is_symbol problem_3::is_symbol program~problem_3->proc~is_symbol proc~read_file_to_char_array aoc_utilities::read_file_to_char_array program~problem_3->proc~read_file_to_char_array proc~check->proc~get_number proc~is_number aoc_utilities::is_number proc~check->proc~is_number proc~get_number->proc~is_symbol proc~is_not_number->proc~is_number proc~is_symbol->proc~is_not_number proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: n_lines integer :: i integer :: j integer :: n_cols integer :: jstart integer :: jend logical :: adjacent logical :: tmp integer(kind=ip) :: isum character(len=1), dimension(:,:), allocatable :: array integer(kind=ip), dimension(:), allocatable :: ivals Functions function check (i, j) if the char is part of a number, then get it and append to ivals Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Return Value logical function is_symbol (c) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical function get_number (i, j) get the full number contining the character at i,j Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Return Value integer(kind=ip) Source Code program problem_3 use iso_fortran_env use aoc_utilities implicit none integer :: n_lines , i , j , n_cols , jstart , jend logical :: adjacent , tmp integer ( ip ) :: isum character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:), allocatable :: ivals call clk % tic () ! read file: ! pad around with blanks to simplify logic below array = read_file_to_char_array ( 'inputs/day3.txt' , border = '.' ) n_lines = size ( array , 1 ) n_cols = size ( array , 2 ) !----------------- part 1 ----------------- isum = 0 do i = 1 , n_lines ! is this character adjacent to a symbol? jend = 0 do j = 1 , n_cols if ( is_not_number ( array ( i , j ))) cycle if ( j <= jend ) cycle ! skip the cols that we already have jend = 0 adjacent = is_symbol ( array ( i - 1 , j ) ) . or . & is_symbol ( array ( i - 1 , j - 1 )) . or . & is_symbol ( array ( i - 1 , j + 1 )) . or . & is_symbol ( array ( i , j - 1 ) ) . or . & is_symbol ( array ( i , j + 1 ) ) . or . & is_symbol ( array ( i + 1 , j ) ) . or . & is_symbol ( array ( i + 1 , j - 1 )) . or . & is_symbol ( array ( i + 1 , j + 1 )) if ( adjacent ) isum = isum + get_number ( i , j ) ! note: this sets jend end do end do write ( * , * ) '3a: sum :' , isum !----------------- part 2 ----------------- ! now look for '*' and find adjacent numbers .... isum = 0 do i = 1 , n_lines do j = 1 , n_cols if ( array ( i , j ) == '*' ) then ! look for 2 adjacent numbers. if ( allocated ( ivals )) deallocate ( ivals ); allocate ( ivals ( 0 )) ! above tmp = check ( i - 1 , j ) ! if only one on top if (. not . tmp ) then tmp = check ( i - 1 , j - 1 ) tmp = check ( i - 1 , j + 1 ) end if tmp = check ( i , j - 1 ) ! left and right tmp = check ( i , j + 1 ) ! below tmp = check ( i + 1 , j ) ! if only one below if (. not . tmp ) then tmp = check ( i + 1 , j - 1 ) tmp = check ( i + 1 , j + 1 ) end if if ( size ( ivals ) == 2 ) isum = isum + product ( ivals ) ! sum gear ratio end if end do end do write ( * , * ) '3b: result :' , isum call clk % toc ( '3' ) contains logical function check ( i , j ) !! if the char is part of a number, then get it and append to ivals integer , intent ( in ) :: i , j check = is_number ( array ( i , j )) if ( check ) ivals = [ ivals , get_number ( i , j )] end function check logical function is_symbol ( c ) character ( len = 1 ), intent ( in ) :: c is_symbol = is_not_number ( c ) . and . c /= '.' end function is_symbol integer ( ip ) function get_number ( i , j ) !! get the full number contining the character at i,j integer , intent ( in ) :: i , j jstart = j jend = j do if ( array ( i , jstart - 1 ) == '.' . or . is_symbol ( array ( i , jstart - 1 ))) exit jstart = jstart - 1 end do do if ( array ( i , jend + 1 ) == '.' . or . is_symbol ( array ( i , jend + 1 ))) exit jend = jend + 1 end do get_number = int ( array ( i , jstart : jend )) end function get_number end program problem_3","tags":"","loc":"program/problem_3.html"},{"title":"problem_17 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_17~~UsesGraph program~problem_17 problem_17 iso_fortran_env iso_fortran_env program~problem_17->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_17->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Based on AOC 2021 Day 15: https://github.com/jacobwilliams/AoC-2021/blob/master/test/problem_15.f90\nsee: https://en.wikipedia.org/wiki/Dijkstra's_algorithm#Pseudocode only difference is the constraint that it can move at most three blocks in a single direction Calls program~~problem_17~~CallsGraph program~problem_17 problem_17 proc~add_to_queue problem_17::add_to_queue program~problem_17->proc~add_to_queue proc~check~2 problem_17::check program~problem_17->proc~check~2 proc~clock_end aoc_utilities::clock%clock_end program~problem_17->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_17->proc~clock_start proc~read_file_to_int_array aoc_utilities::read_file_to_int_array program~problem_17->proc~read_file_to_int_array proc~check~2->proc~add_to_queue proc~index_in_queue problem_17::index_in_queue proc~check~2->proc~index_in_queue proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_int_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_int_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: NSTATE = 4 number of state dimensions [i,j,direction,moves_in_that_direction] integer, parameter :: N_DIRECTIONS = 4 integer(kind=ip), parameter :: UP = 1 integer(kind=ip), parameter :: DOWN = -1 integer(kind=ip), parameter :: LEFT = 2 integer(kind=ip), parameter :: RIGHT = -2 integer, parameter :: MAX_MOVES_IN_DIR = 3 type( item ), dimension(:), allocatable :: queue will be expanding integer(kind=ip), dimension(1) :: iloc integer(kind=ip) :: idx integer :: i integer :: j integer :: n_rows integer :: n_cols integer, dimension(:,:), allocatable :: map heat map Derived Types type :: item Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(NSTATE) :: state = 0 state: [i, j, direction, and # of moves] integer(kind=ip), public :: dist = huge(1) distance for this one logical, public :: visited = .false. if this one is done integer(kind=ip), public :: iprev = -1 index in the queue of the previous one Functions function index_in_queue (state) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state Return Value integer(kind=ip) index in the queue. -1 if not present Subroutines subroutine check (idx, idirection) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: idx integer(kind=ip), intent(in) :: idirection direction to move from current subroutine add_to_queue (state, idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state integer(kind=ip), intent(out) :: idx index of the element in the queue Source Code program problem_17 use aoc_utilities use iso_fortran_env !! Based on AOC 2021 Day 15: https://github.com/jacobwilliams/AoC-2021/blob/master/test/problem_15.f90 !! see: https://en.wikipedia.org/wiki/Dijkstra's_algorithm#Pseudocode !! !! only difference is the constraint that it can move at most three blocks in a single direction implicit none integer , parameter :: NSTATE = 4 !! number of state dimensions [i,j,direction,moves_in_that_direction] integer , parameter :: N_DIRECTIONS = 4 ! 1,2,3,4 integer ( ip ), parameter :: UP = 1 ! direction traveling integer ( ip ), parameter :: DOWN = - 1 integer ( ip ), parameter :: LEFT = 2 integer ( ip ), parameter :: RIGHT = - 2 integer , parameter :: MAX_MOVES_IN_DIR = 3 ! queue for the states and distances... rather than constructing the 2d array... ! just create this as we go... type :: item integer ( ip ), dimension ( NSTATE ) :: state = 0 !! state: [i, j, direction, and # of moves] integer ( ip ) :: dist = huge ( 1 ) !! distance for this one logical :: visited = . false . !! if this one is done integer ( ip ) :: iprev = - 1 !! index in the queue of the previous one end type item type ( item ), dimension (:), allocatable :: queue !! will be expanding integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: idx integer :: i , j , n_rows , n_cols integer , dimension (:,:), allocatable :: map !! heat map ! for the CI ! need a faster version ... write ( * , * ) 'it works but takes a few minutes...' stop call clk % tic () ! map = read_file_to_int_array('inputs/day17_test.txt') map = read_file_to_int_array ( 'inputs/day17.txt' ) n_rows = size ( map , 1 ) n_cols = size ( map , 2 ) call add_to_queue ([ 1_ip , 1_ip , 0_ip , 0_ip ], idx ) ! start queue ( idx )% dist = 0 do ! find min distance so far for ones not visited iloc = minloc ( queue % dist , mask = . not . queue % visited ) idx = iloc ( 1 ) ! index in the queue queue ( idx )% visited = . true . !write(*,*) 'visited ', queue(idx)%state(1), queue(idx)%state(2), n_rows, n_cols if ( queue ( idx )% state ( 1 ) == n_rows . and . queue ( idx )% state ( 2 ) == n_cols ) exit ! destination: we are done ! process ajacent ones: call check ( idx , UP ) call check ( idx , DOWN ) call check ( idx , LEFT ) call check ( idx , RIGHT ) end do write ( * , * ) '15a: ' , queue ( idx )% dist ! ...draw the path ! block !     character(len=1),dimension(:,:),allocatable :: char_map !     char_map = int_array_to_char_array(map) !     do !         char_map(queue(idx)%state(1),queue(idx)%state(2)) = '#' !         if (queue(idx)%state(1)==1) then !             write(*,*) queue(idx)%state !         end if !         if (queue(idx)%state(1)==1 .and. queue(idx)%state(2)==1) exit !         idx = queue(idx)%iprev !     end do !     write(*,*) ' path: ' !     do i = 1, n_rows !         write(*,'(*(A1))') char_map(i,:) !     end do ! end block call clk % toc ( '17' ) contains subroutine check ( idx , idirection ) implicit none integer ( ip ), intent ( in ) :: idx ! current item in the queue to process integer ( ip ), intent ( in ) :: idirection !! direction to move from current integer ( ip ) :: alt integer ( ip ), dimension ( 2 ) :: v ! neighbor to move to integer ( ip ) :: imovesv , idxv , distv integer ( ip ), dimension ( NSTATE ) :: istate logical :: in_queue associate ( i => queue ( idx )% state ( 1 ), & j => queue ( idx )% state ( 2 ), & direction => queue ( idx )% state ( 3 ), & n_moves => queue ( idx )% state ( 4 )) if ( direction ==- idirection ) return ! can't reverse ! the one to go to: if ( direction == idirection ) then if ( n_moves == MAX_MOVES_IN_DIR ) return ! can't move in this direction anymore imovesv = n_moves + 1 else imovesv = 1 ! reset on change of direction end if select case ( idirection ) case ( UP ); v = [ i - 1 , j ] case ( DOWN ); v = [ i + 1 , j ] case ( LEFT ); v = [ i , j - 1 ] case ( RIGHT ); v = [ i , j + 1 ] end select if ( v ( 1 ) < 1 . or . v ( 2 ) < 1 . or . v ( 1 ) > n_rows . or . v ( 2 ) > n_cols ) return ! can't go off the board istate = [ v ( 1 ), v ( 2 ), idirection , imovesv ] ! new state idxv = index_in_queue ( istate ) ! is it already in the queue in_queue = idxv > 0 ! if this one is already part of another path if ( in_queue ) then if ( queue ( idxv )% visited ) return ! already visited this one distv = queue ( idxv )% dist ! distance in the queue else !call add_to_queue(istate, idxv) ! add this to the queue for processing ! always add it ?? distv = huge ( 1_ip ) ! not processed yet, so huge number end if !alt = queue(idx)%dist + map(queue(idxv)%state(1), queue(idxv)%state(2)) alt = queue ( idx )% dist + map ( v ( 1 ), v ( 2 )) ! new distance if ( alt < distv ) then ! the new one is better, so replace values in the queue if (. not . in_queue ) call add_to_queue ( istate , idxv ) ! only add it if we accept it ???? ! accept this step queue ( idxv )% dist = alt ! new best dist queue ( idxv )% iprev = idx ! previous end if end associate end subroutine check ! .. need a faster queue... function index_in_queue ( state ) result ( idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ) :: idx !! index in the queue. -1 if not present integer :: i idx = - 1 if (. not . allocated ( queue )) error stop 'error: queue not allocated' do i = 1 , size ( queue ) if ( all ( state == queue ( i )% state )) then idx = i return end if end do end function index_in_queue subroutine add_to_queue ( state , idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ), intent ( out ) :: idx !! index of the element in the queue if ( allocated ( queue )) then queue = [ queue , item ( state = state )] idx = size ( queue ) else queue = [ item ( state = state )] idx = 1 end if end subroutine add_to_queue end program problem_17","tags":"","loc":"program/problem_17.html"},{"title":"problem_13 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_13~~UsesGraph program~problem_13 problem_13 iso_fortran_env iso_fortran_env program~problem_13->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_13->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_13~~CallsGraph program~problem_13 problem_13 proc~clock_end aoc_utilities::clock%clock_end program~problem_13->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_13->proc~clock_start proc~go~2 problem_13::go program~problem_13->proc~go~2 proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_13->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_13->proc~read_line proc~str_to_int_array_with_mapping aoc_utilities::str_to_int_array_with_mapping program~problem_13->proc~str_to_int_array_with_mapping Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: iunit integer :: iline integer :: n_lines integer :: ival integer :: isum integer :: ival2 integer :: isum2 integer :: m integer :: n integer :: nrows integer :: ncols integer :: ileft integer :: iabove integer :: ileft2 integer :: iabove2 type( string ), dimension(:), allocatable :: lines integer, dimension(:,:), allocatable :: puzzle integer, dimension(:,:), allocatable :: puzzle2 character(len=:), allocatable :: line integer, parameter :: ASH = 0 . integer, parameter :: ROCK = 1 Subroutines subroutine go (puzzle, ileft, iskip) compute the number of cols to left of mirror (0 if none)\ncall with transpose(puzzle) to get number of rows above. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: puzzle integer, intent(out) :: ileft integer, intent(in), optional :: iskip don't consider this column Source Code program problem_13 use iso_fortran_env use aoc_utilities implicit none integer :: i , iunit , iline , n_lines , ival , isum , ival2 , isum2 , & m , n , nrows , ncols , ileft , iabove , ileft2 , iabove2 type ( string ), dimension (:), allocatable :: lines integer , dimension (:,:), allocatable :: puzzle , puzzle2 character ( len = :), allocatable :: line integer , parameter :: ASH = 0 !! . integer , parameter :: ROCK = 1 !! # call clk % tic () ! open(newunit=iunit, file='inputs/day13_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day13.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 isum2 = 0 do iline = 1 , n_lines line = read_line ( iunit ) if ( line == '' . or . iline == n_lines ) then ! process this puzzle ! convert the puzzle to a numeric matrix: if ( allocated ( puzzle )) deallocate ( puzzle ) nrows = size ( lines ) ncols = len ( lines ( 1 )% str ) allocate ( puzzle ( nrows , ncols )) do i = 1 , nrows puzzle ( i ,:) = str_to_int_array_with_mapping ( lines ( i )% str , [ '.' , '#' ], [ ASH , ROCK ]) end do ! part 1 call go ( puzzle , ileft ) call go ( transpose ( puzzle ), iabove ) ival = ileft + 100 * iabove isum = isum + ival ! part 2 main : do m = 1 , nrows do n = 1 , ncols ! permute each with a smudge and find the different non-zero value puzzle2 = puzzle if ( puzzle ( m , n ) == ASH ) then puzzle2 ( m , n ) = ROCK else puzzle2 ( m , n ) = ASH end if ! don't consider the one from part a (since that one still may be valid) call go ( puzzle2 , ileft2 , iskip = ileft ) call go ( transpose ( puzzle2 ), iabove2 , iskip = iabove ) if (( ileft2 /= ileft . or . iabove2 /= iabove ) . and . ( ileft2 /= 0 . or . iabove2 /= 0 )) then ival = ileft2 + 100 * iabove2 ! found it exit main end if end do end do main isum2 = isum2 + ival deallocate ( lines ) else ! accumulate this line in the current puzzle if (. not . allocated ( lines )) allocate ( lines ( 0 )) lines = [ lines , string ( line )] end if end do write ( * , * ) '13a: ' , isum write ( * , * ) '13b: ' , isum2 call clk % toc ( '13' ) contains subroutine go ( puzzle , ileft , iskip ) !! compute the number of cols to left of mirror (0 if none) !! call with transpose(puzzle) to get number of rows above. integer , dimension (:,:), intent ( in ) :: puzzle integer , intent ( out ) :: ileft integer , intent ( in ), optional :: iskip !! don't consider this column integer :: nrows , ncols , i , j logical :: mirror nrows = size ( puzzle , 1 ) ncols = size ( puzzle , 2 ) ileft = 0 do i = 1 , ncols - 1 if ( present ( iskip )) then if ( i == iskip ) cycle end if mirror = . true . do j = 1 , min ( i , ncols - i ) if ( any ( puzzle (:, i - j + 1 ) /= puzzle (:, i + j )) ) then mirror = . false . ! no mirror on this line exit end if end do if ( mirror ) then ileft = i exit end if end do end subroutine go end program problem_13","tags":"","loc":"program/problem_13.html"},{"title":"problem_25 – AoC-2023","text":"Uses aoc_utilities dag_module program~~problem_25~~UsesGraph program~problem_25 problem_25 module~aoc_utilities aoc_utilities program~problem_25->module~aoc_utilities module~dag_module dag_module program~problem_25->module~dag_module iso_fortran_env iso_fortran_env module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_25~~CallsGraph program~problem_25 problem_25 interface~split aoc_utilities::split program~problem_25->interface~split interface~unique~2 aoc_utilities::unique program~problem_25->interface~unique~2 proc~clock_end aoc_utilities::clock%clock_end program~problem_25->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_25->proc~clock_start proc~dag_destroy dag_module::dag%dag_destroy program~problem_25->proc~dag_destroy proc~dag_save_digraph dag_module::dag%dag_save_digraph program~problem_25->proc~dag_save_digraph proc~dag_set_edges dag_module::dag%dag_set_edges program~problem_25->proc~dag_set_edges proc~dag_set_vertex_info dag_module::dag%dag_set_vertex_info program~problem_25->proc~dag_set_vertex_info proc~dag_set_vertices dag_module::dag%dag_set_vertices program~problem_25->proc~dag_set_vertices proc~node_index problem_25::node_index program~problem_25->proc~node_index proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_25->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_25->proc~read_line proc~traverse~2 problem_25::traverse program~problem_25->proc~traverse~2 proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~unique32 aoc_utilities::unique32 interface~unique~2->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique~2->proc~unique64 proc~dag_generate_digraph dag_module::dag%dag_generate_digraph proc~dag_save_digraph->proc~dag_generate_digraph none~set_edges dag_module::vertex%set_edges proc~dag_set_edges->none~set_edges proc~integer_to_string~2 dag_module::integer_to_string proc~dag_set_vertex_info->proc~integer_to_string~2 proc~traverse~2->proc~traverse~2 proc~add_edge dag_module::vertex%add_edge none~set_edges->proc~add_edge proc~set_edge_vector dag_module::vertex%set_edge_vector none~set_edges->proc~set_edge_vector proc~dag_generate_digraph->proc~integer_to_string~2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 proc~set_edge_vector->proc~add_edge interface~swap~2 aoc_utilities::swap proc~sort_ascending->interface~swap~2 proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap~2->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap~2->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap~2->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit integer :: n_lines integer :: i integer :: j integer :: n_nodes integer :: inode integer :: inode2 character(len=:), allocatable :: line type( string ), dimension(:), allocatable :: vals type( string ), dimension(:), allocatable :: vals2 character(len=3) :: node1 character(len=3) :: node2 character(len=3), dimension(:), allocatable :: nodes integer, dimension(:), allocatable :: inodedep integer, dimension(:), allocatable :: icounts character(len=*), parameter :: filetype = 'pdf' type( dag ) :: d type( node_t ), dimension(:), allocatable :: graph index is the node number logical, dimension(:), allocatable :: visited Derived Types type :: node_t Components Type Visibility Attributes Name Initial integer, public, dimension(:), allocatable :: connections the ones connected to this one Functions pure function node_index (node) find the node number for this name Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: node Return Value integer Subroutines recursive subroutine traverse (i) travere the graph and visit all the connected nodes Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Source Code program problem_25 use aoc_utilities use dag_module implicit none integer :: iunit , n_lines , i , j , n_nodes , inode , inode2 character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals , vals2 character ( len = 3 ) :: node1 , node2 character ( len = 3 ), dimension (:), allocatable :: nodes integer , dimension (:), allocatable :: inodedep , icounts character ( len =* ), parameter :: filetype = 'pdf' type ( dag ) :: d type :: node_t !character(len=3) :: name = '' integer , dimension (:), allocatable :: connections !! the ones connected to this one end type node_t type ( node_t ), dimension (:), allocatable :: graph !! index is the node number logical , dimension (:), allocatable :: visited call clk % tic () ! read the data: ! open(newunit=iunit, file='inputs/day25_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day25.txt' , status = 'OLD' ) allocate ( nodes ( 0 )) n_lines = number_of_lines_in_file ( iunit ) do i = 1 , n_lines line = read_line ( iunit ) ! for starters, get a list of all the nodes vals = split ( line , ': ' ) node1 = vals ( 1 )% str if (. not . any ( nodes == node1 )) nodes = [ nodes , node1 ] vals2 = split ( vals ( 2 )% str , ' ' ) do j = 1 , size ( vals2 ) node2 = vals2 ( j )% str if (. not . any ( nodes == node2 )) nodes = [ nodes , node2 ] end do end do rewind ( iunit ) n_nodes = size ( nodes ) ! create a dag: call d % set_vertices ( n_nodes ) allocate ( graph ( n_nodes )) !... do i = 1 , n_nodes allocate ( graph ( i )% connections ( 0 )) ! initialize end do do i = 1 , n_lines line = read_line ( iunit ) ! for starters, get a list of all the nodes vals = split ( line , ': ' ) node1 = vals ( 1 )% str inode = node_index ( node1 ) !inode = findloc(nodes,node1) if (. not . any ( nodes == node1 )) nodes = [ nodes , node1 ] vals2 = split ( vals ( 2 )% str , ' ' ) if ( allocated ( inodedep )) deallocate ( inodedep ) allocate ( inodedep ( 0 )) do j = 1 , size ( vals2 ) node2 = vals2 ( j )% str inode2 = node_index ( node2 ) !-------------------------------------------- ! prune the ones by inspection by looking at the graph, opening in Inkscape, ! coloring the 3 lines and finding the nodes that connect them if ( ( node1 == 'ljm' . and . node2 == 'sfd' ) . or . ( node2 == 'ljm' . and . node1 == 'sfd' ) ) cycle if ( ( node1 == 'gst' . and . node2 == 'rph' ) . or . ( node2 == 'gst' . and . node1 == 'rph' ) ) cycle if ( ( node1 == 'jkn' . and . node2 == 'cfn' ) . or . ( node2 == 'jkn' . and . node1 == 'cfn' ) ) cycle !-------------------------------------------- ! accumulate the graph: ! connection between inode <--> inodedep graph ( inode )% connections = [ graph ( inode )% connections , inode2 ] graph ( inode2 )% connections = [ graph ( inode2 )% connections , inode ] ! for the plot: inodedep = [ inodedep , inode2 ] end do call d % set_edges ( inode , inodedep ) end do ! define some styles for the GraphViz output: do i = 1 , n_nodes call d % set_vertex_info ( i , label = nodes ( i )) end do ! generate the GraphViz output: call d % save_digraph ( 'problem25.dot' , rankdir = 'TB' , dpi = 300 ) call d % destroy () call execute_command_line ( 'dot -Tpdf -o problem25.pdf problem25.dot' ) ! add to dot file:  !todo add this to daglib ... ! mindist=10 ! ranksep=20 ! count the ones connected to each node and get the unique two we need allocate ( visited ( n_nodes )) allocate ( icounts ( 0 )) do i = 1 , n_lines visited = . false . call traverse ( i ) icounts = unique ([ icounts , count ( visited )]) write ( * , * ) i , icounts end do write ( * , * ) '25a:' , product ( icounts ) call clk % toc ( '25' ) contains pure integer function node_index ( node ) !! find the node number for this name character ( len =* ), intent ( in ) :: node integer , dimension ( 1 ) :: idx idx = findloc ( nodes , node ) node_index = idx ( 1 ) end function node_index recursive subroutine traverse ( i ) !! travere the graph and visit all the connected nodes integer , intent ( in ) :: i integer :: j if ( visited ( i )) return visited ( i ) = . true . do j = 1 , size ( graph ( i )% connections ) call traverse ( graph ( i )% connections ( j )) end do end subroutine traverse end program problem_25","tags":"","loc":"program/problem_25.html"},{"title":"problem_7 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_7~~UsesGraph program~problem_7 problem_7 iso_fortran_env iso_fortran_env program~problem_7->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_7->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_7~~CallsGraph program~problem_7 problem_7 interface~split aoc_utilities::split program~problem_7->interface~split proc~beats problem_7::beats program~problem_7->proc~beats proc~clock_end aoc_utilities::clock%clock_end program~problem_7->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_7->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_7->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_7->proc~read_line proc~str_to_array aoc_utilities::str_to_array program~problem_7->proc~str_to_array proc~swap_hands problem_7::swap_hands program~problem_7->proc~swap_hands proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~hand_type problem_7::hand_type proc~beats->proc~hand_type proc~index_in_cards problem_7::index_in_cards proc~beats->proc~index_in_cards interface~unique~2 aoc_utilities::unique proc~hand_type->interface~unique~2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 proc~unique32 aoc_utilities::unique32 interface~unique~2->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique~2->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap~2 aoc_utilities::swap proc~sort_ascending->interface~swap~2 proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap~2->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap~2->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap~2->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: iunit integer :: n_lines integer :: icase character(len=:), allocatable :: line type( string ), dimension(:), allocatable :: vals logical :: done type( hand ), dimension(:), allocatable :: hands array of hands character(len=1), parameter,               dimension(2) :: cases = ['a', 'b'] character(len=1), parameter,               dimension(*) :: cards = ['A', 'K', 'Q', 'J', 'T', '9', '8', '7', '6', '5', '4', '3', '2'] character(len=1), parameter,               dimension(*) :: cards_with_joker = ['A', 'K', 'Q', 'T', '9', '8', '7', '6', '5', '4', '3', '2', 'J'] integer, parameter :: FIVE_OF_A_KIND = 1 integer, parameter :: FOUR_OF_A_KIND = 2 integer, parameter :: FULL_HOUSE = 3 integer, parameter :: THREE_OF_A_KIND = 4 integer, parameter :: TWO_PAIR = 5 integer, parameter :: ONE_PAIR = 6 integer, parameter :: HIGH_CARD = 7 Derived Types type :: hand Components Type Visibility Attributes Name Initial character(len=1), public, dimension(5) :: cards the cards in a hand integer(kind=ip), public :: bid = 0 integer, public :: type = 0 Functions function hand_type (me, with_jokers) returns the type of hand Arguments Type Intent Optional Attributes Name class( hand ), intent(in) :: me logical, intent(in) :: with_jokers if considering jokers Return Value integer function beats (hand1, hand2, with_jokers) return true if hand1 beats hand2 (has a higher score) Arguments Type Intent Optional Attributes Name class( hand ), intent(inout) :: hand1 class( hand ), intent(inout) :: hand2 logical, intent(in) :: with_jokers if considering jokers Return Value logical function index_in_cards (c, with_jokers) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c logical, intent(in) :: with_jokers if considering jokers Return Value integer Subroutines pure elemental subroutine swap_hands (i1, i2) swap function for hand type Arguments Type Intent Optional Attributes Name type( hand ), intent(inout) :: i1 type( hand ), intent(inout) :: i2 Source Code program problem_7 use iso_fortran_env use aoc_utilities implicit none integer :: i , iunit , n_lines , icase character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals logical :: done type :: hand character ( len = 1 ), dimension ( 5 ) :: cards !! the cards in a hand integer ( ip ) :: bid = 0 ! the bit for the hand integer :: type = 0 ! the hand type end type hand type ( hand ), dimension (:), allocatable :: hands !! array of hands character ( len = 1 ), dimension ( 2 ), parameter :: cases = [ 'a' , 'b' ] character ( len = 1 ), dimension ( * ), parameter :: cards = [ 'A' , 'K' , 'Q' , 'J' , 'T' , & '9' , '8' , '7' , '6' , '5' , & '4' , '3' , '2' ] character ( len = 1 ), dimension ( * ), parameter :: cards_with_joker = [ 'A' , 'K' , 'Q' , 'T' , & '9' , '8' , '7' , '6' , '5' , & '4' , '3' , '2' , 'J' ] integer , parameter :: FIVE_OF_A_KIND = 1 ! the hand types integer , parameter :: FOUR_OF_A_KIND = 2 integer , parameter :: FULL_HOUSE = 3 integer , parameter :: THREE_OF_A_KIND = 4 integer , parameter :: TWO_PAIR = 5 integer , parameter :: ONE_PAIR = 6 integer , parameter :: HIGH_CARD = 7 call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day7_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day7.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( hands ( n_lines )) do i = 1 , n_lines line = read_line ( iunit ); vals = split ( line , ' ' ) hands ( i )% cards = str_to_array ( vals ( 1 )% str ) hands ( i )% bid = int ( vals ( 2 )) end do close ( iunit ) do icase = 1 , 2 ! first time normally, second time processing the jokers ! sort the list from worst to best to determinte the rank of each hand hands % type = 0 ! reinitialize since they need to be recomputed do ! bubble sort ! done = . true . do i = 1 , n_lines - 1 if ( beats ( hands ( i ), hands ( i + 1 ), icase == 2 )) then call swap_hands ( hands ( i ), hands ( i + 1 )); done = . false . end if end do if ( done ) exit end do write ( * , * ) '7' // cases ( icase ) // ':' , sum ( hands % bid * [( i , i = 1 , n_lines )]) end do call clk % toc ( '7' ) contains integer function hand_type ( me , with_jokers ) !! returns the type of hand class ( hand ), intent ( in ) :: me logical , intent ( in ) :: with_jokers !! if considering jokers integer , dimension ( 5 ) :: i integer , dimension (:), allocatable :: u integer :: n_jokers , n_unique character ( len = 1 ), dimension ( 5 ) :: h h = me % cards i = ichar ( h ) ! convert to code u = unique ( i ) ! unique elements n_unique = size ( u ) if ( with_jokers . and . any ( h == 'J' )) then ! have to pick best hand for all jokers ! just do it by inspection n_jokers = count ( h == 'J' ) select case ( n_jokers ) case ( 5 ) hand_type = FIVE_OF_A_KIND !jjjjj case ( 4 ) hand_type = FIVE_OF_A_KIND !jjjja case ( 3 ) ! can always turn to 4 or 5 of a kind if ( n_unique == 2 ) then !jjjaa hand_type = FIVE_OF_A_KIND else ! jjjab hand_type = FOUR_OF_A_KIND end if case ( 2 ) if ( n_unique == 2 ) then !jjaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then !jjaab hand_type = FOUR_OF_A_KIND else !jjabc hand_type = THREE_OF_A_KIND end if case ( 1 ) if ( n_unique == 2 ) then !jaaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then if ( any ([ count ( i == u ( 1 )) == 3 , & count ( i == u ( 2 )) == 3 , & count ( i == u ( 3 )) == 3 ]) ) then !jaaab hand_type = FOUR_OF_A_KIND elseif ( ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 ) . or . & ( count ( i == u ( 2 )) == 2 . and . count ( i == u ( 2 )) == 2 ) ) then !jaabb hand_type = FULL_HOUSE end if else if ( n_unique == 4 ) then !jaabc hand_type = THREE_OF_A_KIND else if ( n_unique == 5 ) then !jabcd hand_type = ONE_PAIR end if end select else !Every hand is exactly one type. From strongest to weakest, they are: select case ( n_unique ) case ( 1 ) ! aaaaa hand_type = FIVE_OF_A_KIND case ( 2 ) ! aaaab, aaabb if (( count ( i == u ( 1 )) == 4 . and . count ( i == u ( 2 )) == 1 ) . or . & ( count ( i == u ( 1 )) == 1 . and . count ( i == u ( 2 )) == 4 ) ) then hand_type = FOUR_OF_A_KIND else if (( count ( i == u ( 1 )) == 3 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 3 ) ) then hand_type = FULL_HOUSE end if case ( 3 ) ! aaabc, aabcc if ( any ([ count ( i == u ( 1 )) == 3 , count ( i == u ( 2 )) == 3 , count ( i == u ( 3 )) == 3 ]) ) then hand_type = THREE_OF_A_KIND else if ( any ([ count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 , & count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 , & count ( i == u ( 2 )) == 2 . and . count ( i == u ( 3 )) == 2 ]) ) then hand_type = TWO_PAIR end if case ( 4 ) !aabcd hand_type = ONE_PAIR case ( 5 ) !abcde hand_type = HIGH_CARD ! High card, where all cards' labels are distinct: 23456 end select end if end function hand_type logical function beats ( hand1 , hand2 , with_jokers ) !! return true if hand1 beats hand2 (has a higher score) class ( hand ), intent ( inout ) :: hand1 , hand2 logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i associate ( h1 => hand1 % cards , h2 => hand2 % cards ) ! recompute type if it hasn't already been computed if ( hand1 % type == 0 ) hand1 % type = hand_type ( hand1 , with_jokers ) if ( hand2 % type == 0 ) hand2 % type = hand_type ( hand2 , with_jokers ) if ( hand1 % type == hand2 % type ) then ! lower index is stronger do i = 1 , 5 if ( h1 ( i ) /= h2 ( i )) then beats = index_in_cards ( h1 ( i ), with_jokers ) < & index_in_cards ( h2 ( i ), with_jokers ) ! lower is stronger return end if end do else ! one hand beat the other beats = hand1 % type < hand2 % type ! lower score is better (1-7) end if end associate end function beats integer function index_in_cards ( c , with_jokers ) character ( len = 1 ), intent ( in ) :: c logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i do i = 1 , size ( cards_with_joker ) if ( with_jokers ) then if ( c == cards_with_joker ( i )) then index_in_cards = i return end if else if ( c == cards ( i )) then index_in_cards = i return end if end if end do error stop 'card not found' end function index_in_cards pure elemental subroutine swap_hands ( i1 , i2 ) !! swap function for hand type type ( hand ), intent ( inout ) :: i1 type ( hand ), intent ( inout ) :: i2 type ( hand ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_hands end program problem_7","tags":"","loc":"program/problem_7.html"},{"title":"problem_2 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_2~~UsesGraph program~problem_2 problem_2 iso_fortran_env iso_fortran_env program~problem_2->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_2->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_2~~CallsGraph program~problem_2 problem_2 interface~split aoc_utilities::split program~problem_2->interface~split proc~clock_end aoc_utilities::clock%clock_end program~problem_2->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_2->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_2->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_2->proc~read_line proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit logical :: status_ok logical :: game_possible character(len=:), allocatable :: line character(len=:), allocatable :: color integer :: n_lines integer :: id integer :: j integer :: k integer :: ipossible integer :: inum integer :: min_red integer :: min_green integer :: min_blue integer :: power type( string ), dimension(:), allocatable :: vals type( string ), dimension(:), allocatable :: trys type( string ), dimension(:), allocatable :: cubes type( string ), dimension(:), allocatable :: num_color integer, parameter :: n_red = 12 integer, parameter :: n_green = 13 integer, parameter :: n_blue = 14 Source Code program problem_2 use iso_fortran_env use aoc_utilities implicit none integer :: iunit logical :: status_ok , game_possible character ( len = :), allocatable :: line , color integer :: n_lines , id , j , k , ipossible , inum , min_red , min_green , min_blue , power type ( string ), dimension (:), allocatable :: vals , trys , cubes , num_color integer , parameter :: n_red = 12 integer , parameter :: n_green = 13 integer , parameter :: n_blue = 14 call clk % tic () !example: Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green open ( newunit = iunit , file = 'inputs/day2.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) ! will parse the line with successive splits ipossible = 0 power = 0 main : do id = 1 , n_lines game_possible = . true . min_red = 0 ; min_green = 0 ; min_blue = 0 line = read_line ( iunit , status_ok ) vals = split ( line , ': ' ) trys = split ( vals ( 2 ), '; ' ) do j = 1 , size ( trys ) cubes = split ( trys ( j ), ', ' ) do k = 1 , size ( cubes ) num_color = split ( cubes ( k ), ' ' ) inum = int ( num_color ( 1 )% str ) color = num_color ( 2 )% str select case ( color ) case ( 'red' ) if ( inum > n_red ) game_possible = . false . if ( inum > min_red ) min_red = inum case ( 'green' ) if ( inum > n_green ) game_possible = . false . if ( inum > min_green ) min_green = inum case ( 'blue' ) if ( inum > n_blue ) game_possible = . false . if ( inum > min_blue ) min_blue = inum end select end do end do power = power + ( min_red * min_green * min_blue ) if ( game_possible ) ipossible = ipossible + id end do main write ( * , * ) '2a: result   :' , ipossible write ( * , * ) '2b: power sum:' , power close ( iunit ) call clk % toc ( '2' ) end program problem_2","tags":"","loc":"program/problem_2.html"},{"title":"problem_18 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_18~~UsesGraph program~problem_18 problem_18 iso_fortran_env iso_fortran_env program~problem_18->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_18->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_18~~CallsGraph program~problem_18 problem_18 proc~clock_end aoc_utilities::clock%clock_end program~problem_18->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_18->proc~clock_start proc~go~3 problem_18::go program~problem_18->proc~go~3 interface~split aoc_utilities::split proc~go~3->interface~split proc~destination problem_18::destination proc~go~3->proc~destination proc~hex2int aoc_utilities::hex2int proc~go~3->proc~hex2int proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~go~3->proc~number_of_lines_in_file proc~parea aoc_utilities::parea proc~go~3->proc~parea proc~read_line aoc_utilities::read_line proc~go~3->proc~read_line proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer(kind=ip) :: iresult Functions pure function destination (initial, direction, steps) result(final) get destination point Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(2) :: initial character(len=1), intent(in) :: direction integer(kind=ip), intent(in) :: steps Return Value integer(kind=ip), dimension(2) x,y of desination point Subroutines subroutine go (partb, iresult) Arguments Type Intent Optional Attributes Name logical, intent(in) :: partb if solving part b integer(kind=ip), intent(out) :: iresult Source Code program problem_18 use aoc_utilities use iso_fortran_env implicit none integer ( ip ) :: iresult call clk % tic () call go (. false ., iresult ); write ( * , * ) '18a:' , iresult call go (. true ., iresult ); write ( * , * ) '18b:' , iresult call clk % toc ( '18' ) contains subroutine go ( partb , iresult ) logical , intent ( in ) :: partb !! if solving part b integer ( ip ), intent ( out ) :: iresult integer :: iunit , iline , n_lines , n character ( len = :), allocatable :: line , hex type ( string ), dimension (:), allocatable :: vals character ( len = 1 ) :: direction integer ( ip ), dimension ( 2 ) :: iloc , iloc2 integer ( ip ) :: ival , isteps real ( wp ), dimension (:), allocatable :: xvec , yvec character ( len = 1 ), dimension ( 0 : 3 ) :: direction_str = [ 'R' , 'D' , 'L' , 'U' ] ! directions for part b : 0,1,2,3 ! open(newunit=iunit, file='inputs/day18_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day18.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) iloc = [ 0 , 0 ] ! where to start isteps = 0 xvec = [ 0 ]; yvec = [ 0 ] do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ! direction, number, (hex) if ( partb ) then ! values encoded in hex hex = vals ( 3 )% str ival = hex2int ( hex ( 3 : 7 )) direction = direction_str ( int ( hex ( 8 : 8 ))) else direction = vals ( 1 )% str ival = int ( vals ( 2 )% str ) end if isteps = isteps + ival ! keep track of the total perimeter size iloc2 = destination ( iloc , direction , ival ) ! destination oint xvec = [ xvec , real ( iloc2 ( 1 ), wp )] ! save the points of the polygon yvec = [ yvec , real ( iloc2 ( 2 ), wp )] ! iloc = iloc2 ! update for next move end do close ( iunit ) ! the area including the boundary = area + 1/2 the perimeter + 1 ! using NSWC parea function! n = size ( xvec ) iresult = int ( abs ( parea ( yvec , xvec , n )) + real ( isteps , wp ) / 2_ip + 1_ip , ip ) end subroutine go pure function destination ( initial , direction , steps ) result ( final ) !! get destination point integer ( ip ), dimension ( 2 ), intent ( in ) :: initial character ( len = 1 ), intent ( in ) :: direction integer ( ip ), intent ( in ) :: steps integer ( ip ), dimension ( 2 ) :: final !! x,y of desination point select case ( direction ) case ( 'R' ); final = [ initial ( 1 ), initial ( 2 ) + steps ] case ( 'L' ); final = [ initial ( 1 ), initial ( 2 ) - steps ] case ( 'D' ); final = [ initial ( 1 ) + steps , initial ( 2 )] case ( 'U' ); final = [ initial ( 1 ) - steps , initial ( 2 )] end select end function destination end program problem_18","tags":"","loc":"program/problem_18.html"},{"title":"problem_11 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_11~~UsesGraph program~problem_11 problem_11 iso_fortran_env iso_fortran_env program~problem_11->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_11->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_11~~CallsGraph program~problem_11 problem_11 proc~clock_end aoc_utilities::clock%clock_end program~problem_11->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_11->proc~clock_start proc~go~7 problem_11::go program~problem_11->proc~go~7 interface~manhatten_distance aoc_utilities::manhatten_distance proc~go~7->interface~manhatten_distance proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~go~7->proc~read_file_to_char_array proc~manhatten_distance_64 aoc_utilities::manhatten_distance_64 interface~manhatten_distance->proc~manhatten_distance_64 proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Functions function go (expansion_factor) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: expansion_factor Return Value integer(kind=ip) Source Code program problem_11 use iso_fortran_env use aoc_utilities implicit none call clk % tic () write ( * , * ) '11a: ' , go ( 2_ip ) write ( * , * ) '11b: ' , go ( 1000000_ip ) call clk % toc ( '11' ) contains integer ( ip ) function go ( expansion_factor ) integer ( ip ), intent ( in ) :: expansion_factor integer :: i , j , nrows , ncols , n_galaxies , n , k character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:,:), allocatable :: idists integer ( ip ), dimension (:), allocatable :: igal , jgal integer ( ip ), dimension (:,:), allocatable :: ix , iy ! array = read_file_to_char_array('inputs/day11_test.txt') array = read_file_to_char_array ( 'inputs/day11.txt' ) nrows = size ( array , 1 ); ncols = size ( array , 2 ) n_galaxies = count ( array == '#' ) ! track the real indices after expansion ix = transpose ( spread ([( i , i = 1 , ncols )], 1 , nrows )) ! row indices iy = spread ([( i , i = 1 , nrows )], 1 , ncols ) ! col indices igal = pack ( ix , array == '#' ) ! indices of galaxies jgal = pack ( iy , array == '#' ) ! expand the array, keeping track of the new row indices do i = 1 , nrows ! add rows if necessary if ( all ( array ( i ,:) == '.' )) ix ( i :,:) = ix ( i :,:) + expansion_factor - 1 ! new row end do do j = 1 , ncols ! add cols if necessary if ( all ( array (:, j ) == '.' )) iy (:, j :) = iy (:, j :) + expansion_factor - 1 ! new column end do ! now compute all the distances: allocate ( idists ( n_galaxies , n_galaxies )); idists = 0 do i = 1 , n_galaxies do j = 1 , n_galaxies if ( j <= i ) cycle ! only need the lower diagonal idists ( i , j ) = manhatten_distance ( ix ( igal ( i ), jgal ( i )), iy ( igal ( i ), jgal ( i )),& ix ( igal ( j ), jgal ( j )), iy ( igal ( j ), jgal ( j ))) end do end do go = sum ( idists ) end function go end program problem_11","tags":"","loc":"program/problem_11.html"},{"title":"test2 – AoC-2023","text":"Uses numerical_differentiation_module numdiff_kinds_module iso_fortran_env pyplot_module program~~test2~~UsesGraph program~test2 test2 iso_fortran_env iso_fortran_env program~test2->iso_fortran_env module~numdiff_kinds_module numdiff_kinds_module program~test2->module~numdiff_kinds_module module~numerical_differentiation_module numerical_differentiation_module program~test2->module~numerical_differentiation_module pyplot_module pyplot_module program~test2->pyplot_module module~numdiff_kinds_module->iso_fortran_env module~numerical_differentiation_module->iso_fortran_env module~numerical_differentiation_module->module~numdiff_kinds_module module~diff_module diff_module module~numerical_differentiation_module->module~diff_module module~dsm_module dsm_module module~numerical_differentiation_module->module~dsm_module module~numdiff_cache_module numdiff_cache_module module~numerical_differentiation_module->module~numdiff_cache_module module~numdiff_utilities_module numdiff_utilities_module module~numerical_differentiation_module->module~numdiff_utilities_module module~diff_module->module~numdiff_kinds_module module~dsm_module->module~numdiff_kinds_module module~numdiff_cache_module->iso_fortran_env module~numdiff_cache_module->module~numdiff_kinds_module module~numdiff_cache_module->module~numdiff_utilities_module module~numdiff_utilities_module->module~numdiff_kinds_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Test2 for the numerical differentiation module.\nMakes a plot of the errors using different methods and step sizes. Calls program~~test2~~CallsGraph program~test2 test2 add_plot add_plot program~test2->add_plot initialize initialize program~test2->initialize proc~compute_jacobian numerical_differentiation_module::numdiff_type%compute_jacobian program~test2->proc~compute_jacobian proc~deriv test2::deriv program~test2->proc~deriv proc~destroy_numdiff_type numerical_differentiation_module::numdiff_type%destroy_numdiff_type program~test2->proc~destroy_numdiff_type proc~failed numerical_differentiation_module::numdiff_type%failed program~test2->proc~failed proc~get_error_status numerical_differentiation_module::numdiff_type%get_error_status program~test2->proc~get_error_status proc~get_finite_diff_formula numerical_differentiation_module::get_finite_diff_formula program~test2->proc~get_finite_diff_formula savefig savefig program~test2->savefig proc~compute_perturbation_vector numerical_differentiation_module::numdiff_type%compute_perturbation_vector proc~compute_jacobian->proc~compute_perturbation_vector proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_jacobian->proc~raise_exception proc~get_finite_difference_method numerical_differentiation_module::get_finite_difference_method proc~get_finite_diff_formula->proc~get_finite_difference_method proc~get_formula numerical_differentiation_module::finite_diff_method%get_formula proc~get_finite_diff_formula->proc~get_formula proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_perturbation_vector->proc~compute_perturb_vector proc~integer_to_string numerical_differentiation_module::integer_to_string proc~get_formula->proc~integer_to_string proc~compute_perturb_vector->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: n = 1 number of variables integer, parameter :: m = 1 number of functions real(kind=wp), parameter,               dimension(n) :: x = 1.0_wp point at which to compute the derivative real(kind=wp), parameter,               dimension(n) :: xlow = -100000.0_wp bounds not really needed real(kind=wp), parameter,               dimension(n) :: xhigh = 100000.0_wp integer, parameter :: perturb_mode = 1 absolute step integer, parameter :: cache_size = 0 0 indicates not to use cache integer, parameter :: sparsity_mode = 1 assume dense integer, parameter,               dimension(*) :: methods = [1, 3, 10, 21, 36, 500, 600, 700, 800] array of method IDs:\n[1,3,10,21,36,500,600,700,800]\nforward + all the central diff ones integer, parameter :: exp_star = -ceiling(log10(epsilon(1.0_wp))) exponent to start with integer, parameter :: exp_stop = -2 exponent to end with integer, parameter :: exp_step = -1 ecponent step integer, parameter :: exp_scale = 5 number of substeps from one to the next type( numdiff_type ) :: my_prob main class to compute the derivatives integer :: i method counter integer :: j counter real(kind=wp), dimension(:), allocatable :: jac jacobian integer :: func_evals function evaluation counter character(len=:), allocatable :: error_msg error message string real(kind=wp), dimension(n) :: dpert perturbation step size integer :: ipert perturbation step size counter real(kind=wp) :: error diff from true derivative integer :: num_dperts number of dperts to test integer :: num_methods number of methods to test real(kind=wp), dimension(:), allocatable :: results_dpert results array - dpert real(kind=wp), dimension(:), allocatable :: results_errors results array - errors type(pyplot) :: plt for plotting the results character(len=:), allocatable :: formula finite diff formula for the plot legend character(len=:), allocatable :: name finite diff name for the plot legend integer :: idx index in results arrays character(len=:), allocatable :: real_kind_str real kind for the plot title real(kind=wp), dimension(3) :: color line color array real(kind=wp), dimension(2) :: ylim plot y limit array Functions function func (x) Problem function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) function deriv (x) Problem function true derivative Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) Subroutines subroutine my_func (me, x, f, funcs_to_compute) Problem function interface for numdiff Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: f integer, intent(in), dimension(:) :: funcs_to_compute Source Code program test2 use iso_fortran_env use numerical_differentiation_module use numdiff_kinds_module , only : wp use pyplot_module implicit none integer , parameter :: n = 1 !! number of variables integer , parameter :: m = 1 !! number of functions real ( wp ), dimension ( n ), parameter :: x = 1.0_wp !! point at which to compute the derivative real ( wp ), dimension ( n ), parameter :: xlow = - 10000 0.0_wp !! bounds not really needed real ( wp ), dimension ( n ), parameter :: xhigh = 10000 0.0_wp !! integer , parameter :: perturb_mode = 1 !! absolute step integer , parameter :: cache_size = 0 !! `0` indicates not to use cache integer , parameter :: sparsity_mode = 1 !! assume dense integer , dimension ( * ), parameter :: methods = [ 1 , 3 , 10 , 21 , 36 , 500 , 600 , 700 , 800 ] !! array of method IDs: !! [1,3,10,21,36,500,600,700,800] !! forward + all the central diff ones integer , parameter :: exp_star = - ceiling ( log10 ( epsilon ( 1.0_wp ))) !! exponent to start with integer , parameter :: exp_stop = - 2 !! exponent to end with integer , parameter :: exp_step = - 1 !! ecponent step integer , parameter :: exp_scale = 5 !! number of substeps from one to the next type ( numdiff_type ) :: my_prob !! main class to compute the derivatives integer :: i !! method counter integer :: j !! counter real ( wp ), dimension (:), allocatable :: jac !! jacobian integer :: func_evals !! function evaluation counter character ( len = :), allocatable :: error_msg !! error message string real ( wp ), dimension ( n ) :: dpert !! perturbation step size integer :: ipert !! perturbation step size counter real ( wp ) :: error !! diff from true derivative integer :: num_dperts !! number of dperts to test integer :: num_methods !! number of methods to test real ( wp ), dimension (:), allocatable :: results_dpert !! results array - dpert real ( wp ), dimension (:), allocatable :: results_errors !! results array - errors type ( pyplot ) :: plt !! for plotting the results character ( len = :), allocatable :: formula !! finite diff formula for the plot legend character ( len = :), allocatable :: name !! finite diff name for the plot legend integer :: idx !! index in results arrays character ( len = :), allocatable :: real_kind_str !! real kind for the plot title real ( wp ), dimension ( 3 ) :: color !! line color array real ( wp ), dimension ( 2 ) :: ylim !! plot y limit array ! size the arrays: num_methods = size ( methods ) num_dperts = size ([( i , i = exp_star * exp_scale , exp_stop * exp_scale , exp_step )]) allocate ( results_errors ( num_dperts )); results_errors = - huge ( 1.0_wp ) ! for plot title: select case ( wp ) case ( REAL32 ); real_kind_str = '[Single Precision]' case ( REAL64 ); real_kind_str = '[Double Precision]' case ( REAL128 ); real_kind_str = '[Quad Precision]' case default ; error stop 'Invalid real kind' end select ! initialize the plot: call plt % initialize ( grid = . true .,& figsize = [ 20 , 10 ],& axes_labelsize = 30 , & xtick_labelsize = 30 , & ytick_labelsize = 30 , & font_size = 30 , & xlabel = 'Finite Difference Perturbation Step Size $h$' ,& ylabel = 'Finite Difference Derivative Error' ,& title = 'Derivative of $x + \\sin(x)$ at $x=1$ ' // real_kind_str ,& legend = . true ., & legend_fontsize = 10 ,& usetex = . true .) ! try different finite diff methods do j = 1 , size ( methods ) idx = 0 i = methods ( j ) ! method id call get_finite_diff_formula ( i , formula , name ) ! cycle through perturbation step sizes: do ipert = exp_star * exp_scale , exp_stop * exp_scale , exp_step idx = idx + 1 ! index for arrays dpert = 1 0.0_wp ** ( - ipert / real ( exp_scale , wp )) ! compute perturbation step size if ( j == 1 ) then if (. not . allocated ( results_dpert )) allocate ( results_dpert ( 0 )) results_dpert = [ results_dpert , dpert ( 1 )] ! save dpert end if func_evals = 0 call my_prob % destroy () call my_prob % initialize ( n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func = my_func ,& sparsity_mode = sparsity_mode ,& jacobian_method = i ,& partition_sparsity_pattern = . false .,& cache_size = cache_size ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) error stop error_msg end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) error stop error_msg end if error = abs ( deriv ( x ( 1 )) - jac ( 1 )) !write(output_unit,'(I5,1X,*(F27.16))') i , dpert, error if ( error <= epsilon ( 1.0_wp )) error = 0.0_wp results_errors ( idx ) = error ! save result end do ! line color for the plot: select case ( j ) case ( 1 ); color = [ 1.0_wp , 0.0_wp , 0.0_wp ] ! red case ( 2 ); color = [ 0.0_wp , 1.0_wp , 0.0_wp ] ! green case default ! blue gradient for the others color = [ real ( j - 2 , wp ) / num_methods , & real ( j - 2 , wp ) / num_methods , & 0.9_wp ] end select ylim = [ 1 0.0_wp ** ( ceiling ( log10 ( epsilon ( 1.0_wp )))), 1.0_wp ] ! plot for this method: call plt % add_plot ( results_dpert , results_errors ,& xscale = 'log' , yscale = 'log' ,& label = formula , linestyle = '.-' , markersize = 5 , linewidth = 2 , & color = color ,& xlim = ylim ,& ylim = ylim ) end do ! save plot: call plt % savefig ( 'results ' // real_kind_str // '.pdf' , pyfile = 'results.py' ) contains function func ( x ) !! Problem function real ( wp ), intent ( in ) :: x real ( wp ) :: func func = x + sin ( x ) end function func function deriv ( x ) !! Problem function true derivative real ( wp ), intent ( in ) :: x real ( wp ) :: deriv deriv = 1.0_wp + cos ( x ) end function deriv subroutine my_func ( me , x , f , funcs_to_compute ) !! Problem function interface for numdiff class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f integer , dimension (:), intent ( in ) :: funcs_to_compute if ( any ( funcs_to_compute == 1 )) f ( 1 ) = func ( x ( 1 )) func_evals = func_evals + 1 end subroutine my_func !******************************************************************************* end program test2","tags":"","loc":"program/test2.html"},{"title":"problem_6 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_6~~UsesGraph program~problem_6 problem_6 iso_fortran_env iso_fortran_env program~problem_6->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_6->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_6~~CallsGraph program~problem_6 problem_6 proc~clock_end aoc_utilities::clock%clock_end program~problem_6->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_6->proc~clock_start proc~go~8 problem_6::go program~problem_6->proc~go~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer(kind=ip), parameter,               dimension(*) :: time_a = [60, 94, 78, 82] integer(kind=ip), parameter,               dimension(*) :: distance_a = [475, 2138, 1015, 1650] integer(kind=ip), parameter,               dimension(*) :: time_b = [60947882_ip] integer(kind=ip), parameter,               dimension(*) :: distance_b = [475213810151650_ip] Functions function go (time, distance) result(iproduct) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: time integer(kind=ip), intent(in), dimension(:) :: distance Return Value integer(kind=ip) Source Code program problem_6 use iso_fortran_env use aoc_utilities implicit none ! just copy and paste the inputs here: ! a integer ( ip ), dimension ( * ), parameter :: time_a = [ 60 , 94 , 78 , 82 ] integer ( ip ), dimension ( * ), parameter :: distance_a = [ 475 , 2138 , 1015 , 1650 ] ! b integer ( ip ), dimension ( * ), parameter :: time_b = [ 60947882_ip ] integer ( ip ), dimension ( * ), parameter :: distance_b = [ 475213810151650_ip ] call clk % tic () print * , '6a: ways to win:' , go ( time_a , distance_a ) print * , '6b: ways to win:' , go ( time_b , distance_b ) call clk % toc ( '6' ) contains function go ( time , distance ) result ( iproduct ) integer ( ip ), dimension (:), intent ( in ) :: time integer ( ip ), dimension (:), intent ( in ) :: distance integer ( ip ) :: iproduct integer ( ip ) :: i , ihold , iways , idistance iproduct = 1 do i = 1 , size ( time ) iways = 0 do ihold = 1 , time ( i ) ! time to hold the button idistance = ihold * ( time ( i ) - ihold ) if ( idistance > distance ( i )) iways = iways + 1 end do iproduct = iproduct * iways end do end function go end program problem_6","tags":"","loc":"program/problem_6.html"},{"title":"problem_16 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_16~~UsesGraph program~problem_16 problem_16 iso_fortran_env iso_fortran_env program~problem_16->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_16->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_16~~CallsGraph program~problem_16 problem_16 proc~clock_end aoc_utilities::clock%clock_end program~problem_16->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_16->proc~clock_start proc~go~4 problem_16::go program~problem_16->proc~go~4 proc~read_file_to_char_array aoc_utilities::read_file_to_char_array program~problem_16->proc~read_file_to_char_array proc~go~4->proc~go~4 proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: j integer :: nrows integer :: ncols integer :: max_count integer :: icount integer :: icase character(len=1), dimension(:,:), allocatable :: array logical, dimension(:,:,:), allocatable :: visited integer, parameter :: TOP = 1 integer, parameter :: BOTTOM = 2 integer, parameter :: LEFT = 3 integer, parameter :: RIGHT = 4 Subroutines recursive subroutine go (i, j, direction_from) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i grid coordinate integer, intent(in) :: j grid coordinate integer, intent(in) :: direction_from direction coming from (TOP,BOTTOM,LEFT,RIGHT Source Code program problem_16 use iso_fortran_env use aoc_utilities implicit none integer :: i , j , nrows , ncols , max_count , icount , icase character ( len = 1 ), dimension (:,:), allocatable :: array logical , dimension (:,:,:), allocatable :: visited ! top,bottom,left,right integer , parameter :: TOP = 1 ! direction traveling FROM integer , parameter :: BOTTOM = 2 integer , parameter :: LEFT = 3 integer , parameter :: RIGHT = 4 call clk % tic () ! read the data file: ! array = read_file_to_char_array('inputs/day16_test.txt') ! pad with wall around the array array = read_file_to_char_array ( 'inputs/day16.txt' ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) ! track if we have already done this case, to avoid unnecessary duplication, ! otherwise it may loop indefinitly? allocate ( visited ( 4 , nrows , ncols )) ! part 1: visited = . false . call go ( 1 , 1 , LEFT ) write ( * , * ) '16a: ' , count ( visited ( 1 ,:,:) . or . & visited ( 2 ,:,:) . or . & visited ( 3 ,:,:) . or . & visited ( 4 ,:,:)) ! part 2, just do all the cases: max_count = 0 do icase = 1 , 2 ! first and last col do i = 1 , nrows visited = . false . if ( icase == 1 ) then ; call go ( i , 1 , LEFT ) else ; call go ( i , ncols , RIGHT ) end if icount = count ( visited ( 1 ,:,:) . or . & visited ( 2 ,:,:) . or . & visited ( 3 ,:,:) . or . & visited ( 4 ,:,:)) if ( icount > max_count ) max_count = icount end do end do do icase = 1 , 2 ! first and last row do j = 1 , ncols visited = . false . if ( icase == 1 ) then ; call go ( 1 , j , TOP ) else ; call go ( nrows , j , BOTTOM ) end if icount = count ( visited ( 1 ,:,:) . or . & visited ( 2 ,:,:) . or . & visited ( 3 ,:,:) . or . & visited ( 4 ,:,:)) if ( icount > max_count ) max_count = icount end do end do write ( * , * ) '16b: ' , max_count call clk % toc ( '16' ) contains recursive subroutine go ( i , j , direction_from ) integer , intent ( in ) :: i , j !! grid coordinate integer , intent ( in ) :: direction_from !! direction coming from (TOP,BOTTOM,LEFT,RIGHT integer :: k if ( i > nrows . or . i < 1 . or . j > ncols . or . j < 1 ) return ! off the board if ( visited ( direction_from , i , j )) return ! this case has already been done visited ( direction_from , i , j ) = . true . ! mark this one as visited in this direction associate ( c => array ( i , j )) select case ( c ) case ( '.' ) ! continue in same direction k = 1 do ! loop until we hit something else ! (to avoid unnecessary recursion) select case ( direction_from ) case ( TOP ) ! V if (( i + k ) > nrows ) return if ( array ( i + k , j ) /= '.' ) then call go ( i + k , j , direction_from ) return end if visited ( direction_from , i + k , j ) = . true . case ( BOTTOM ) ! &#94; if (( i - k ) < 1 ) return if ( array ( i - k , j ) /= '.' ) then call go ( i - k , j , direction_from ) return end if visited ( direction_from , i - k , j ) = . true . case ( LEFT ) ! --> if (( j + k ) > ncols ) return if ( array ( i , j + k ) /= '.' ) then call go ( i , j + k , direction_from ) return end if visited ( direction_from , i , j + k ) = . true . case ( RIGHT ) ! <-- if (( j - k ) < 1 ) return if ( array ( i , j - k ) /= '.' ) then call go ( i , j - k , direction_from ) return end if visited ( direction_from , i , j - k ) = . true . end select k = k + 1 end do case ( '-' ) select case ( direction_from ) case ( TOP , BOTTOM ) ! V, &#94; call go ( i , j + 1 , LEFT ) ! split call go ( i , j - 1 , RIGHT ) case ( LEFT ) ! --> call go ( i , j + 1 , LEFT ) case ( RIGHT ) ! <-- call go ( i , j - 1 , RIGHT ) end select case ( '|' ) select case ( direction_from ) case ( TOP ) ! V call go ( i + 1 , j , TOP ) case ( BOTTOM ) ! &#94; call go ( i - 1 , j , BOTTOM ) case ( LEFT , RIGHT ) ! -->, <-- call go ( i + 1 , j , TOP ) call go ( i - 1 , j , BOTTOM ) end select case ( '/' ) select case ( direction_from ) case ( TOP ) ! V call go ( i , j - 1 , RIGHT ) case ( BOTTOM ) ! &#94; call go ( i , j + 1 , LEFT ) case ( LEFT ) ! --> call go ( i - 1 , j , BOTTOM ) case ( RIGHT ) ! <-- call go ( i + 1 , j , TOP ) end select case ( '\\' ) select case ( direction_from ) case ( TOP ) ! V call go ( i , j + 1 , LEFT ) case ( BOTTOM ) ! &#94; call go ( i , j - 1 , RIGHT ) case ( LEFT ) ! --> call go ( i + 1 , j , TOP ) case ( RIGHT ) ! <-- call go ( i - 1 , j , BOTTOM ) end select end select end associate end subroutine go end program problem_16","tags":"","loc":"program/problem_16.html"},{"title":"nlesolver_test_1 – AoC-2023","text":"Uses nlesolver_module program~~nlesolver_test_1~~UsesGraph program~nlesolver_test_1 nlesolver_test_1 module~nlesolver_module nlesolver_module program~nlesolver_test_1->module~nlesolver_module iso_fortran_env iso_fortran_env module~nlesolver_module->iso_fortran_env module~fmin_module fmin_module module~nlesolver_module->module~fmin_module module~fmin_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Test of a small, square ( n=m ) problem. Calls program~~nlesolver_test_1~~CallsGraph program~nlesolver_test_1 nlesolver_test_1 proc~get_status nlesolver_module::nlesolver_type%get_status program~nlesolver_test_1->proc~get_status proc~initialize_nlesolver_variables nlesolver_module::nlesolver_type%initialize_nlesolver_variables program~nlesolver_test_1->proc~initialize_nlesolver_variables proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver program~nlesolver_test_1->proc~nlesolver_solver proc~set_status nlesolver_module::nlesolver_type%set_status proc~initialize_nlesolver_variables->proc~set_status proc~linear_solver nlesolver_module::linear_solver proc~nlesolver_solver->proc~linear_solver proc~nlesolver_solver->proc~set_status Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: n = 2 integer, parameter :: m = 2 integer, parameter :: max_iter = 100 real(kind=wp), parameter :: tol = 1.0e-8_wp logical, parameter :: verbose = .false. type( nlesolver_type ) :: solver real(kind=wp) :: alpha logical :: use_broyden integer :: step_mode integer :: n_intervals integer :: istat Integer status code. character(len=:), allocatable :: message Text status message real(kind=wp), dimension(n) :: x integer :: f_evals integer :: i character(len=:), allocatable :: description real(kind=wp) :: fmin_tol Subroutines subroutine func (me, x, f) compute the function Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: f subroutine grad (me, x, g) compute the gradient of the function (Jacobian): Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:,:) :: g subroutine export (me, x, f, iter) export an iteration: Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: f integer, intent(in) :: iter iteration number Source Code program nlesolver_test_1 use nlesolver_module , wp => nlesolver_rk implicit none integer , parameter :: n = 2 integer , parameter :: m = 2 integer , parameter :: max_iter = 100 real ( wp ), parameter :: tol = 1.0e-8_wp logical , parameter :: verbose = . false . type ( nlesolver_type ) :: solver real ( wp ) :: alpha logical :: use_broyden integer :: step_mode integer :: n_intervals integer :: istat !! Integer status code. character ( len = :), allocatable :: message !! Text status message real ( wp ), dimension ( n ) :: x integer :: f_evals integer :: i character ( len = :), allocatable :: description real ( wp ) :: fmin_tol fmin_tol = 1.0e-2_wp ! don't need a tight tol for this n_intervals = 2 alpha = 1.0_wp write ( * , * ) '' do i = 1 , 8 select case ( i ) case ( 1 ) step_mode = 1 use_broyden = . false . f_evals = 0 description = 'Constant alpha' case ( 2 ) step_mode = 1 use_broyden = . true . f_evals = 0 description = 'Constant alpha + broyden' case ( 3 ) step_mode = 2 use_broyden = . false . f_evals = 0 description = 'Backtracking line search' case ( 4 ) step_mode = 2 use_broyden = . true . f_evals = 0 description = 'Backtracking line search + broyden' case ( 5 ) step_mode = 3 use_broyden = . false . f_evals = 0 description = 'Exact line search' case ( 6 ) step_mode = 3 use_broyden = . true . f_evals = 0 description = 'Exact line search + broyden' case ( 7 ) step_mode = 4 use_broyden = . false . f_evals = 0 description = 'Fixed point search' case ( 8 ) step_mode = 4 use_broyden = . true . f_evals = 0 description = 'Fixed point search + broyden' case default error stop 'invalid case' end select write ( * , * ) '-------------------------------------------------------' write ( * , '(A,I3,A,A)' ) 'Case ' , i , ' : ' , description write ( * , * ) '' call solver % initialize ( n = n , & m = m , & max_iter = max_iter , & tol = tol , & func = func , & grad = grad , & step_mode = step_mode ,& use_broyden = use_broyden ,& export_iteration = export ,& n_intervals = n_intervals , & fmin_tol = fmin_tol , & verbose = verbose ) call solver % status ( istat , message ) write ( * , '(I3,1X,A)' ) istat , message if ( istat /= 0 ) error stop x = [ 1.0_wp , 2.0_wp ] call solver % solve ( x ) call solver % status ( istat , message ) write ( * , '(I3,1X,A)' ) istat , message write ( * , * ) '' end do contains subroutine func ( me , x , f ) !! compute the function implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f f_evals = f_evals + 1 f ( 1 ) = x ( 1 ) ** 2 + x ( 2 ) - 0.1_wp f ( 2 ) = x ( 2 ) + 0.2_wp ! root is 5.477226E-01  -2.000000E-01 end subroutine func subroutine grad ( me , x , g ) !! compute the gradient of the function (Jacobian): implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:,:), intent ( out ) :: g f_evals = f_evals + 2 ! to approximate forward diff derivatives g ( 1 , 1 ) = 2.0_wp * x ( 1 ) !df(1)/dx g ( 2 , 1 ) = 0.0_wp !df(2)/dx g ( 1 , 2 ) = 1.0_wp !df(1)/dy g ( 2 , 2 ) = 1.0_wp !df(2)/dy end subroutine grad subroutine export ( me , x , f , iter ) !! export an iteration: implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: f integer , intent ( in ) :: iter !! iteration number write ( * , '(1P,I3,1X,A,I3,A,*(E15.6))' ) iter , '(' , f_evals , ')' , x , norm2 ( f ) end subroutine export !****************************************************************************************************** end program nlesolver_test_1","tags":"","loc":"program/nlesolver_test_1.html"},{"title":"problem_23 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_23~~UsesGraph program~problem_23 problem_23 iso_fortran_env iso_fortran_env program~problem_23->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_23->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. alternate one... collapse the maze into a graph Calls program~~problem_23~~CallsGraph program~problem_23 problem_23 proc~clock_end aoc_utilities::clock%clock_end program~problem_23->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_23->proc~clock_start proc~go~5 problem_23::go program~problem_23->proc~go~5 proc~build_graph problem_23::build_graph proc~go~5->proc~build_graph proc~count_adjacent problem_23::count_adjacent proc~go~5->proc~count_adjacent proc~dijkstra problem_23::dijkstra proc~go~5->proc~dijkstra proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~go~5->proc~read_file_to_char_array proc~traverse~3 problem_23::traverse proc~go~5->proc~traverse~3 proc~build_graph->proc~build_graph proc~add_edge~2 problem_23::add_edge proc~build_graph->proc~add_edge~2 proc~get_cell problem_23::get_cell proc~build_graph->proc~get_cell proc~node_number problem_23::node_number proc~build_graph->proc~node_number proc~not_tree problem_23::not_tree proc~count_adjacent->proc~not_tree proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line proc~traverse~3->proc~traverse~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( node ), dimension(:), allocatable :: nodes the list of nodes logical :: slopes a=true, b=false logical, dimension(:,:), allocatable :: visited logical, dimension(:), allocatable :: nodes_visited integer(kind=ip), dimension(:), allocatable :: inodes node coordinates integer(kind=ip), dimension(:), allocatable :: jnodes node coordinates integer(kind=ip) :: max_dist integer(kind=ip) :: total_nodes integer(kind=ip) :: nrows integer(kind=ip) :: ncols character(len=1), dimension(:,:), allocatable :: array integer(kind=ip), dimension(:), allocatable :: node_dist integer(kind=ip), dimension(:), allocatable :: node_prev Derived Types type :: node Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(:), allocatable :: inext the node connected to this one integer(kind=ip), public, dimension(:), allocatable :: idist distance to inext nodes Functions pure function is_node (i, j) returns true if a node is at these coordinates Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value logical pure function node_number (i, j) returns the index of these coordinates in\nthe list of nodes (0 if it is not a node) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value integer(kind=ip) pure function count_adjacent (i, j) result(icount) count the number of adjacent cells not a tree Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value integer(kind=ip) pure function get_cell (i, j) result(a) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i coordinates integer(kind=ip), intent(in) :: j coordinates Return Value character(len=1) pure function not_tree (i, j) returns true if the cell isn't a tree Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i coordinates integer(kind=ip), intent(in) :: j coordinates Return Value logical Subroutines subroutine go (case, filename, parta) solve the case Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: case case name for printing character(len=*), intent(in) :: filename input file to read logical, intent(in) :: parta if this is part a, then consider the slopes subroutine dijkstra (u, inext) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: u integer(kind=ip), intent(in) :: inext recursive subroutine build_graph (node_num, i, j, idist, visited) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: node_num current node number integer(kind=ip), intent(in) :: i current position integer(kind=ip), intent(in) :: j current position integer(kind=ip), intent(in) :: idist current distance (number of steps) logical, intent(in), dimension(:,:) :: visited elements visited in this path (not counting this one) recursive subroutine traverse (node_num, idist, nodes_visited) traverse the graph until we get to the end and check the max distance Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: node_num current node integer(kind=ip), intent(in) :: idist distance to get here logical, intent(in), dimension(:) :: nodes_visited subroutine add_edge (inode, ichild, idist) add an edge to this node (path to another node with the specified distance) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: inode integer(kind=ip), intent(in) :: ichild integer(kind=ip), intent(in) :: idist Source Code program problem_23 !! alternate one... collapse the maze into a graph ! Process: !   1. locate the start and end nodes (top and bottom) !   2. find all the cells that have 3 or 4 adjacent cells: ! !      1    2    3    4 !     ###  #.#  ###  #.# !-->  #.#  #.#  ...  ... !     #.#  #.#  #.#  #.# ! !     those are the nodes, and the paths between them are the edges !   3. compute the edges between each node combination and construct the graph !   4. DFS all paths to find the longest. use iso_fortran_env use aoc_utilities implicit none type :: node integer ( ip ), dimension (:), allocatable :: inext !! the node connected to this one integer ( ip ), dimension (:), allocatable :: idist !! distance to inext nodes end type node type ( node ), dimension (:), allocatable :: nodes !! the list of nodes logical :: slopes !! a=true, b=false logical , dimension (:,:), allocatable :: visited logical , dimension (:), allocatable :: nodes_visited integer ( ip ), dimension (:), allocatable :: inodes , jnodes !! node coordinates integer ( ip ) :: max_dist , total_nodes , nrows , ncols character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:), allocatable :: node_dist integer ( ip ), dimension (:), allocatable :: node_prev call clk % tic () ! call go('23a', 'inputs/day23_test.txt', .true. ) ! call go('23b', 'inputs/day23_test.txt', .false.) call go ( '23a' , 'inputs/day23.txt' , . true . ) call go ( '23b' , 'inputs/day23.txt' , . false .) call clk % toc ( '23' ) contains subroutine go ( case , filename , parta ) !! solve the case character ( len =* ), intent ( in ) :: case !! case name for printing character ( len =* ), intent ( in ) :: filename !! input file to read logical , intent ( in ) :: parta !! if this is part a, then consider the slopes integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: istart , iend , idist , i , j logical , parameter :: use_dijkstra = . false . !.... doesn't work yet .... don't know why ....... ! initialize: max_dist = 0 slopes = parta if ( allocated ( nodes )) deallocate ( nodes ) if ( allocated ( visited )) deallocate ( visited ) if ( allocated ( nodes_visited )) deallocate ( nodes_visited ) if ( allocated ( inodes )) deallocate ( inodes ) if ( allocated ( jnodes )) deallocate ( jnodes ) if ( allocated ( node_dist )) deallocate ( node_dist ) if ( allocated ( node_prev )) deallocate ( node_prev ) ! read the data file: array = read_file_to_char_array ( filename ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) iloc = findloc ( array ( 1 ,:), '.' ); istart = iloc ( 1 ) ! get start and end columns iloc = findloc ( array ( nrows ,:), '.' ); iend = iloc ( 1 ) ! ! identify the coordinates of all the nodes: inodes = [ 1 ] ! start node jnodes = [ istart ] do i = 1 , nrows do j = 1 , ncols if ( count_adjacent ( i , j ) >= 3 ) then inodes = [ inodes , i ] jnodes = [ jnodes , j ] end if end do end do inodes = [ inodes , nrows ] ! end node jnodes = [ jnodes , iend ] total_nodes = size ( inodes ) ! for each node, find the other nodes they are ! connected to and the distances between them (the edges) allocate ( nodes ( total_nodes )) allocate ( visited ( nrows , ncols )) do i = 1 , total_nodes visited = . false . idist = 0 call build_graph ( i , inodes ( i ), jnodes ( i ), idist , visited ) end do if ( use_dijkstra ) then !write(*,*) 'hello use_dijkstra'         ! ... something wrong here... don't get the right answer ! based on AOC 2021, Problem 15 allocate ( node_dist ( total_nodes )); node_dist = - 1 ; node_dist ( 1 ) = 0 allocate ( node_prev ( total_nodes )); node_prev = - 1 allocate ( nodes_visited ( total_nodes )); nodes_visited = . false . do iloc = maxloc ( node_dist , mask = . not . nodes_visited ) i = iloc ( 1 ) nodes_visited ( i ) = . true . if ( i == total_nodes ) exit ! we are done! !write(*,*) 'visited ', i if ( allocated ( nodes ( i )% inext )) then do j = 1 , size ( nodes ( i )% inext ) ! adjacent nodes to this one call dijkstra ( i , j ) end do end if !if (all(nodes_visited)) exit ! done end do !write(*,*) case, node_dist(size(node_dist)) ! result for this case (last node) !write(*,*) nodes_visited !write(*,*) node_dist else ! start at first, and find the longest that gets to the last. ! recursively traverse the graph. visited = . false . allocate ( nodes_visited ( total_nodes )); nodes_visited = . false . call traverse ( 1_ip , 0_ip , nodes_visited ) write ( * , * ) case , max_dist ! result for this case end if end subroutine go subroutine dijkstra ( u , inext ) integer ( ip ), intent ( in ) :: u ! current integer ( ip ), intent ( in ) :: inext ! index in inext array of the next node integer ( ip ) :: idist associate ( next_node => nodes ( u )% inext ( inext ), & distance_to_next_node => nodes ( u )% idist ( inext )) if ( nodes_visited ( next_node )) return ! already visited this one idist = node_dist ( u ) + distance_to_next_node ! add distance from u to v if ( idist > node_dist ( next_node )) then !write(*,*) 'highest so far: ', idist node_dist ( next_node ) = idist node_prev ( next_node ) = u end if end associate end subroutine dijkstra recursive subroutine build_graph ( node_num , i , j , idist , visited ) integer ( ip ), intent ( in ) :: node_num !! current node number integer ( ip ), intent ( in ) :: i , j !! current position integer ( ip ), intent ( in ) :: idist !! current distance (number of steps) logical , dimension (:,:), intent ( in ) :: visited !! elements visited in this path (not counting this one) logical , dimension (:,:), allocatable :: tmp_visited integer ( ip ) :: child_node_num if ( i < 1 . or . i > nrows . or . j < 1 . or . j > ncols ) return if ( visited ( i , j )) return if ( array ( i , j ) == '#' ) return ! can't continue from here ! go until we hit another node child_node_num = node_number ( i , j ) if ( child_node_num > 0 . and . child_node_num /= node_num ) then ! we have reached another node call add_edge ( node_num , child_node_num , idist ) else ! continue processing this edge tmp_visited = visited !make a copy and mark this one tmp_visited ( i , j ) = . true . ! we are here now associate ( a => get_cell ( i , j )) ! paths (.), forest (#), and steep slopes (&#94;, >, v, and <). select case ( a ) case ( '.' ) ! path call build_graph ( node_num , i - 1 , j , idist + 1 , tmp_visited ) call build_graph ( node_num , i + 1 , j , idist + 1 , tmp_visited ) call build_graph ( node_num , i , j + 1 , idist + 1 , tmp_visited ) call build_graph ( node_num , i , j - 1 , idist + 1 , tmp_visited ) ! these don't have a choice, must go in these directions: case ( '&#94;' ); call build_graph ( node_num , i - 1 , j , idist + 1 , tmp_visited ) case ( 'v' ); call build_graph ( node_num , i + 1 , j , idist + 1 , tmp_visited ) case ( '>' ); call build_graph ( node_num , i , j + 1 , idist + 1 , tmp_visited ) case ( '<' ); call build_graph ( node_num , i , j - 1 , idist + 1 , tmp_visited ) end select end associate end if end subroutine build_graph recursive subroutine traverse ( node_num , idist , nodes_visited ) !! traverse the graph until we get to the end and check the max distance integer ( ip ), intent ( in ) :: node_num !! current node integer ( ip ), intent ( in ) :: idist !! distance to get here logical , dimension (:), intent ( in ) :: nodes_visited logical , dimension (:), allocatable :: tmp_nodes_visited integer :: i if ( nodes_visited ( node_num )) return ! already visited this node if ( node_num == total_nodes ) then ! reached the destination if ( idist > max_dist ) max_dist = idist ! best so far else ! are their child nodes? if ( allocated ( nodes ( node_num )% inext )) then tmp_nodes_visited = nodes_visited tmp_nodes_visited ( node_num ) = . true . ! mark this node do i = 1 , size ( nodes ( node_num )% inext ) call traverse ( nodes ( node_num )% inext ( i ), idist + nodes ( node_num )% idist ( i ), tmp_nodes_visited ) end do end if end if end subroutine traverse pure logical function is_node ( i , j ) !! returns true if a node is at these coordinates integer ( ip ), intent ( in ) :: i , j is_node = any ( inodes == i . and . jnodes == j ) end function is_node subroutine add_edge ( inode , ichild , idist ) !! add an edge to this node (path to another node with the specified distance) integer ( ip ), intent ( in ) :: inode , ichild , idist if (. not . allocated ( nodes ( inode )% inext )) then allocate ( nodes ( inode )% inext ( 0 )) allocate ( nodes ( inode )% idist ( 0 )) end if nodes ( inode )% inext = [ nodes ( inode )% inext , ichild ] nodes ( inode )% idist = [ nodes ( inode )% idist , idist ] end subroutine add_edge pure integer ( ip ) function node_number ( i , j ) !! returns the index of these coordinates in !! the list of nodes (0 if it is not a node) integer ( ip ), intent ( in ) :: i , j integer ( ip ), dimension ( 1 ) :: iloc iloc = findloc ( inodes == i . and . jnodes == j , . true .) node_number = iloc ( 1 ) end function node_number pure function count_adjacent ( i , j ) result ( icount ) !! count the number of adjacent cells not a tree integer ( ip ), intent ( in ) :: i , j integer ( ip ) :: icount icount = 0 if ( i >= 1 ) icount = icount + count ([ not_tree ( i - 1 , j )]) if ( i <= nrows ) icount = icount + count ([ not_tree ( i + 1 , j )]) if ( j <= ncols ) icount = icount + count ([ not_tree ( i , j + 1 )]) if ( j >= 1 ) icount = icount + count ([ not_tree ( i , j - 1 )]) end function count_adjacent pure function get_cell ( i , j ) result ( a ) integer ( ip ), intent ( in ) :: i , j !! coordinates character ( len = 1 ) :: a if ( slopes ) then a = array ( i , j ) else a = '.' ! ignore the slopes for part b end if end function get_cell pure logical function not_tree ( i , j ) !! returns true if the cell isn't a tree integer ( ip ), intent ( in ) :: i , j !! coordinates if ( i < 1 . or . i > nrows . or . j < 1 . or . j > ncols ) then not_tree = . false . ! off the board, call it a tree else not_tree = array ( i , j ) /= '#' end if end function not_tree end program problem_23","tags":"","loc":"program/problem_23.html"},{"title":"problem_17 – AoC-2023","text":"Uses aoc_cache_module iso_fortran_env aoc_utilities program~~problem_17~2~~UsesGraph program~problem_17~2 problem_17 iso_fortran_env iso_fortran_env program~problem_17~2->iso_fortran_env module~aoc_cache_module aoc_cache_module program~problem_17~2->module~aoc_cache_module module~aoc_utilities aoc_utilities program~problem_17~2->module~aoc_utilities module~aoc_cache_module->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. part b Calls program~~problem_17~2~~CallsGraph program~problem_17~2 problem_17 proc~add_to_queue~2 problem_17::add_to_queue program~problem_17~2->proc~add_to_queue~2 proc~check~3 problem_17::check program~problem_17~2->proc~check~3 proc~clock_end aoc_utilities::clock%clock_end program~problem_17~2->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_17~2->proc~clock_start proc~initialize_cache~2 aoc_cache_module::function_cache%initialize_cache program~problem_17~2->proc~initialize_cache~2 proc~read_file_to_int_array aoc_utilities::read_file_to_int_array program~problem_17~2->proc~read_file_to_int_array proc~expand_queue problem_17::expand_queue proc~add_to_queue~2->proc~expand_queue proc~check~3->proc~add_to_queue~2 proc~index_in_queue~2 problem_17::index_in_queue proc~check~3->proc~index_in_queue~2 proc~destroy_cache~2 aoc_cache_module::function_cache%destroy_cache proc~initialize_cache~2->proc~destroy_cache~2 proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_int_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_int_array->proc~read_line proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~index_in_queue~2->proc~get_from_cache~2 proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~index_in_queue~2->proc~put_in_cache~2 proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: NSTATE = 4 number of state dimensions [i,j,direction,moves_in_that_direction] integer, parameter :: N_DIRECTIONS = 4 integer(kind=ip), parameter :: UP = 1 integer(kind=ip), parameter :: DOWN = -1 integer(kind=ip), parameter :: LEFT = 2 integer(kind=ip), parameter :: RIGHT = -2 integer, parameter :: MAX_MOVES_IN_DIR = 10 type( function_cache ) :: cache to cache the queue access ... to try to speed things up !!! type( item ), dimension(:), allocatable :: queue will be expanding integer(kind=ip), dimension(1) :: iloc integer(kind=ip) :: idx integer :: i integer :: j integer :: n_rows integer :: n_cols integer, dimension(:,:), allocatable :: map heat map integer(kind=ip) :: queue_size Derived Types type :: item Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(NSTATE) :: state = 0 state: [i, j, direction, and # of moves] integer(kind=ip), public :: dist = huge(1) distance for this one logical, public :: visited = .false. if this one is done integer(kind=ip), public :: iprev = -1 index in the queue of the previous one Functions function index_in_queue (state) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state Return Value integer(kind=ip) index in the queue. -1 if not present Subroutines subroutine check (idx, idirection) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: idx integer(kind=ip), intent(in) :: idirection direction to move from current subroutine add_to_queue (state, idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state integer(kind=ip), intent(out) :: idx index of the element in the queue pure subroutine expand_queue (vec, n, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name type( item ), intent(inout), dimension(:), allocatable :: vec integer(kind=ip), intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call type( item ), intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) Source Code program problem_17 !! part b use aoc_utilities use iso_fortran_env use aoc_cache_module implicit none integer , parameter :: NSTATE = 4 !! number of state dimensions [i,j,direction,moves_in_that_direction] integer , parameter :: N_DIRECTIONS = 4 ! 1,2,3,4 integer ( ip ), parameter :: UP = 1 ! direction traveling integer ( ip ), parameter :: DOWN = - 1 integer ( ip ), parameter :: LEFT = 2 integer ( ip ), parameter :: RIGHT = - 2 integer , parameter :: MAX_MOVES_IN_DIR = 10 !3 type ( function_cache ) :: cache !! to cache the queue access ... to try to speed things up !!! ! queue for the states and distances... rather than constructing the 2d array... ! just create this as we go... type :: item integer ( ip ), dimension ( NSTATE ) :: state = 0 !! state: [i, j, direction, and # of moves] integer ( ip ) :: dist = huge ( 1 ) !! distance for this one logical :: visited = . false . !! if this one is done integer ( ip ) :: iprev = - 1 !! index in the queue of the previous one end type item type ( item ), dimension (:), allocatable :: queue !! will be expanding integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: idx integer :: i , j , n_rows , n_cols integer , dimension (:,:), allocatable :: map !! heat map integer ( ip ) :: queue_size ! for the CI ! need a faster version ... write ( * , * ) 'it works but takes a few minutes...' stop call clk % tic () call cache % initialize ( isize = 10000 , chunk_size = 1000 ) ! map = read_file_to_int_array('inputs/day17_test.txt') map = read_file_to_int_array ( 'inputs/day17.txt' ) n_rows = size ( map , 1 ) n_cols = size ( map , 2 ) queue_size = 0 call add_to_queue ([ 1_ip , 1_ip , 0_ip , 0_ip ], idx ) ! start queue ( idx )% dist = 0 do ! find min distance so far for ones not visited iloc = minloc ( queue ( 1 : queue_size )% dist , mask = . not . queue ( 1 : queue_size )% visited ) idx = iloc ( 1 ) ! index in the queue queue ( idx )% visited = . true . if ( queue ( idx )% state ( 1 ) == n_rows . and . queue ( idx )% state ( 2 ) == n_cols ) exit ! destination: we are done ! process ajacent ones: call check ( idx , UP ) call check ( idx , DOWN ) call check ( idx , LEFT ) call check ( idx , RIGHT ) end do write ( * , * ) '17b: ' , queue ( idx )% dist call clk % toc ( '17' ) contains subroutine check ( idx , idirection ) implicit none integer ( ip ), intent ( in ) :: idx ! current item in the queue to process integer ( ip ), intent ( in ) :: idirection !! direction to move from current integer ( ip ) :: alt integer ( ip ), dimension ( 2 ) :: v ! neighbor to move to integer ( ip ) :: imovesv , idxv , distv integer ( ip ), dimension ( NSTATE ) :: istate logical :: in_queue associate ( i => queue ( idx )% state ( 1 ), & j => queue ( idx )% state ( 2 ), & direction => queue ( idx )% state ( 3 ), & n_moves => queue ( idx )% state ( 4 )) if ( direction ==- idirection ) return ! can't reverse ! the one to go to: if ( direction == idirection ) then if ( n_moves == MAX_MOVES_IN_DIR ) return ! can't move in this direction anymore imovesv = n_moves + 1 else if ( n_moves /= 0 . and . n_moves < 4 ) return ! must move at last 4 before a turn! imovesv = 1 ! reset on change of direction end if select case ( idirection ) case ( UP ); v = [ i - 1 , j ] case ( DOWN ); v = [ i + 1 , j ] case ( LEFT ); v = [ i , j - 1 ] case ( RIGHT ); v = [ i , j + 1 ] end select if ( v ( 1 ) < 1 . or . v ( 2 ) < 1 . or . v ( 1 ) > n_rows . or . v ( 2 ) > n_cols ) return ! can't go off the board if ( v ( 1 ) == n_rows . and . v ( 2 ) == n_cols . and . imovesv < 4 ) return ! require at least 4 to end istate = [ v ( 1 ), v ( 2 ), idirection , imovesv ] ! new state idxv = index_in_queue ( istate ) ! is it already in the queue in_queue = idxv > 0 ! if this one is already part of another path if ( in_queue ) then if ( queue ( idxv )% visited ) return ! already visited this one distv = queue ( idxv )% dist ! distance in the queue else !call add_to_queue(istate, idxv) ! add this to the queue for processing ! always add it ?? distv = huge ( 1_ip ) ! not processed yet, so huge number end if !alt = queue(idx)%dist + map(queue(idxv)%state(1), queue(idxv)%state(2)) alt = queue ( idx )% dist + map ( v ( 1 ), v ( 2 )) ! new distance if ( alt < distv ) then ! the new one is better, so replace values in the queue if (. not . in_queue ) call add_to_queue ( istate , idxv ) ! only add it if we accept it ???? ! accept this step queue ( idxv )% dist = alt ! new best dist queue ( idxv )% iprev = idx ! previous end if end associate end subroutine check ! .. need a faster queue... function index_in_queue ( state ) result ( idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ) :: idx !! index in the queue. -1 if not present integer ( ip ) :: i logical :: found integer ( ip ) :: cache_idx integer ( ip ), dimension (:), allocatable :: cache_ival call cache % get ( state , cache_idx , cache_ival , found ) if ( found ) then idx = cache_ival ( 1 ) else idx = - 1 if (. not . allocated ( queue )) error stop 'error: queue not allocated' do i = 1 , queue_size if ( all ( state == queue ( i )% state )) then idx = i exit end if end do if ( idx /= - 1 ) call cache % put ( cache_idx , state ,[ idx ]) end if end function index_in_queue subroutine add_to_queue ( state , idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ), intent ( out ) :: idx !! index of the element in the queue if ( allocated ( queue )) then call expand_queue ( queue , queue_size , item ( state = state )) idx = queue_size else queue = [ item ( state = state )] queue_size = 1 idx = 1 end if end subroutine add_to_queue !**************************************************************** !> !  Add elements to the integer vector in chunks. pure subroutine expand_queue ( vec , n , val , finished ) integer ( ip ), parameter :: chunk_size = 1000 type ( item ), dimension (:), allocatable , intent ( inout ) :: vec integer ( ip ), intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call type ( item ), intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) type ( item ), dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_queue !**************************************************************** end program problem_17","tags":"","loc":"program/problem_17~2.html"},{"title":"problem_22 – AoC-2023","text":"Uses aoc_cache_module iso_fortran_env aoc_utilities program~~problem_22~~UsesGraph program~problem_22 problem_22 iso_fortran_env iso_fortran_env program~problem_22->iso_fortran_env module~aoc_cache_module aoc_cache_module program~problem_22->module~aoc_cache_module module~aoc_utilities aoc_utilities program~problem_22->module~aoc_utilities module~aoc_cache_module->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_22~~CallsGraph program~problem_22 problem_22 proc~clock_end aoc_utilities::clock%clock_end program~problem_22->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_22->proc~clock_start proc~get_all_pieces_above problem_22::get_all_pieces_above program~problem_22->proc~get_all_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below program~problem_22->proc~get_all_pieces_below proc~get_pieces_above problem_22::get_pieces_above program~problem_22->proc~get_pieces_above proc~get_pieces_below problem_22::get_pieces_below program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_all_pieces_above->proc~get_pieces_above interface~unique~2 aoc_utilities::unique proc~get_all_pieces_above->interface~unique~2 proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~get_all_pieces_above->proc~get_from_cache~2 proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~get_all_pieces_above->proc~put_in_cache~2 proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_all_pieces_below->interface~unique~2 proc~get_all_pieces_below->proc~get_from_cache~2 proc~get_all_pieces_below->proc~put_in_cache~2 proc~get_pieces_above->interface~unique~2 proc~get_pieces_below->interface~unique~2 interface~split aoc_utilities::split proc~initialize->interface~split proc~drop problem_22::drop proc~initialize->proc~drop proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~initialize->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~initialize->proc~read_line proc~update_array problem_22::update_array proc~initialize->proc~update_array proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~unique32 aoc_utilities::unique32 interface~unique~2->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique~2->proc~unique64 proc~move_piece_down problem_22::move_piece_down proc~drop->proc~move_piece_down proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 proc~move_piece_down->proc~get_pieces_below proc~move_piece_down->proc~update_array proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap~2 aoc_utilities::swap proc~sort_ascending->interface~swap~2 proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap~2->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap~2->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap~2->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit integer :: n_lines integer(kind=ip) :: i integer(kind=ip) :: j integer(kind=ip) :: k character(len=:), allocatable :: line type( string ), dimension(:), allocatable :: start_end type( string ), dimension(:), allocatable :: starts type( string ), dimension(:), allocatable :: ends integer(kind=ip), dimension(:,:), allocatable :: istart_array integer(kind=ip), dimension(:,:), allocatable :: iend_array integer(kind=ip), dimension(:,:,:), allocatable :: array integer(kind=ip), dimension(:), allocatable :: ipieces_above integer(kind=ip), dimension(:), allocatable :: ipieces_below integer(kind=ip) :: ok_to_disintegrate integer(kind=ip) :: isum integer(kind=ip) :: isum_total logical :: ok_tmp type( function_cache ) :: above_cache type( function_cache ) :: below_cache Functions recursive function get_all_pieces_above (i) result(ipieces) reursively get a list of all pieces above piece i Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i Return Value integer(kind=ip), dimension(:), allocatable recursive function get_all_pieces_below (i, iskip) result(ipieces) reursively get a list of all pieces below piece i Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: iskip skip this one and it's children Return Value integer(kind=ip), dimension(:), allocatable function get_pieces_above (i) result(ipieces) get set of pieces directly above piece i Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i Return Value integer(kind=ip), dimension(:), allocatable function get_pieces_below (i) result(ipieces) get set of pieces directly below piece i Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i Return Value integer(kind=ip), dimension(:), allocatable Subroutines subroutine initialize () read the data Arguments None subroutine drop () continue forward in time until all the bricks settle. Arguments None subroutine update_array () populate the array using the start/end indices Arguments None subroutine move_piece_down (i, moved) move a piece down (fall one square) if it can be moved Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i piece number logical, intent(out) :: moved if it was actually movec Source Code program problem_22 use iso_fortran_env use aoc_utilities use aoc_cache_module implicit none integer :: iunit , n_lines integer ( ip ) :: i , j , k character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: start_end , starts , ends integer ( ip ), dimension (:,:), allocatable :: istart_array integer ( ip ), dimension (:,:), allocatable :: iend_array integer ( ip ), dimension (:,:,:), allocatable :: array integer ( ip ), dimension (:), allocatable :: ipieces_above , ipieces_below integer ( ip ) :: ok_to_disintegrate , isum , isum_total logical :: ok_tmp type ( function_cache ) :: above_cache , below_cache call clk % tic () !find the ones we can remove without any other falling: !  to do that, look to see if any above it are not otherwise held up by another piece call initialize () ok_to_disintegrate = 0 do i = 1 , n_lines ipieces_above = get_pieces_above ( i ) if ( size ( ipieces_above ) == 0 ) then ! nothing above, it so ok to remove ok_to_disintegrate = ok_to_disintegrate + 1 else ok_tmp = . true . do j = 1 , size ( ipieces_above ) ! check all the pieces above. if ALL have other supporters then OK to remove ipieces_below = get_pieces_below ( ipieces_above ( j )) if ( all ( ipieces_below == i )) then ! only supported by i , so can't remove i ok_tmp = . false . exit end if end do if ( ok_tmp ) ok_to_disintegrate = ok_to_disintegrate + 1 end if end do write ( * , * ) '22a: ' , ok_to_disintegrate ! for part 2, we need to find all the nodes in the tree ! that are only supportd by ones below that in the tree ! !  777  44444 ! 66111222  9 !88 333333333   <--- deleting 3 will cause 1, 2, 4, 9 to fall, but not 6,7,8 ! just use a cache to save the ones above/below a given piece ! since there is a lot of duplication in that calculation call above_cache % initialize ( isize = 1000 , chunk_size = 1000 ) call below_cache % initialize ( isize = 1000 , chunk_size = 1000 ) call initialize () isum_total = 0 do i = 1 , n_lines ! try remove piece i ipieces_above = get_all_pieces_above ( i ) isum = size ( ipieces_above ) ! start out assuming they will all fall if ( isum > 0 ) then main : do j = 1 , size ( ipieces_above ) ! for all the ones, see if there are any below that are not in the above set. ! is so, then it will not fall. ipieces_below = get_all_pieces_below ( ipieces_above ( j ), iskip = i ) ipieces_below = pack ( ipieces_below , ipieces_below /= i ) ! remove i if present (the one being removed) do k = 1 , size ( ipieces_below ) if (. not . any ( ipieces_below ( k ) == [ ipieces_above ])) then isum = isum - 1 ! this one will not fall, so remove it from total cycle main end if end do end do main end if isum_total = isum_total + isum end do write ( * , * ) '22b: ' , isum_total call clk % toc ( '22' ) contains subroutine initialize () !! read the data ! open(newunit=iunit, file='inputs/day22_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day22.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) if ( allocated ( istart_array )) deallocate ( istart_array ); allocate ( istart_array ( n_lines , 3 )) if ( allocated ( iend_array )) deallocate ( iend_array ); allocate ( iend_array ( n_lines , 3 )) do i = 1 , n_lines line = read_line ( iunit ); start_end = split ( line , '~' ) starts = split ( start_end ( 1 )% str , ',' ) ends = split ( start_end ( 2 )% str , ',' ) istart_array ( i ,:) = [( int ( starts ( j )% str ), j = 1 , 3 )] iend_array ( i ,:) = [( int ( ends ( j )% str ), j = 1 , 3 )] end do close ( iunit ) ! create the array to hold all the pieces: if ( allocated ( array )) deallocate ( array ) allocate ( array ( 0 : maxval ([ istart_array (:, 1 ), iend_array (:, 1 )]),& 0 : maxval ([ istart_array (:, 2 ), iend_array (:, 2 )]),& 0 : maxval ([ istart_array (:, 3 ), iend_array (:, 3 )]))) call update_array () ! set array values from the start/end arrays call drop () ! continue forward in time until all the bricks settle. end subroutine initialize subroutine drop () !! continue forward in time until all the bricks settle. logical :: moved , tmp_moved integer ( ip ) :: i do moved = . false . do i = 1 , n_lines call move_piece_down ( i , tmp_moved ) if ( tmp_moved ) moved = . true . ! at least one was moved end do if (. not . moved ) exit ! done moving all the pieces end do end subroutine drop recursive function get_all_pieces_above ( i ) result ( ipieces ) !! reursively get a list of all pieces above piece i integer ( ip ), intent ( in ) :: i integer ( ip ), dimension (:), allocatable :: ipieces integer :: j !! counter logical :: found integer ( ip ) :: idx call above_cache % get ([ i ], idx , ipieces , found ) if (. not . found ) then allocate ( ipieces ( 0 )) associate ( tmp => get_pieces_above ( i )) if ( size ( tmp ) > 0 ) then ipieces = [ ipieces , tmp ] ! ones directly above do j = 1 , size ( tmp ) ! go up the tree ipieces = [ ipieces , get_all_pieces_above ( tmp ( j ))] end do ipieces = unique ( ipieces ) end if end associate call above_cache % put ( idx ,[ i ], ipieces ) end if end function get_all_pieces_above recursive function get_all_pieces_below ( i , iskip ) result ( ipieces ) !! reursively get a list of all pieces below piece i integer ( ip ), intent ( in ) :: i integer ( ip ), intent ( in ) :: iskip !! skip this one and it's children integer ( ip ), dimension (:), allocatable :: ipieces integer :: j !! counter logical :: found integer ( ip ) :: idx integer ( ip ), dimension (:), allocatable :: tmp call below_cache % get ([ i , iskip ], idx , ipieces , found ) if (. not . found ) then allocate ( ipieces ( 0 )) if ( i == iskip ) return tmp = get_pieces_below ( i ) if ( size ( tmp ) > 0 ) then tmp = pack ( tmp , tmp /= iskip ) ! remove the skipped one ipieces = [ ipieces , tmp ] ! ones directly below do j = 1 , size ( tmp ) ! go down the tree ipieces = [ ipieces , get_all_pieces_below ( tmp ( j ), iskip = iskip )] end do ipieces = unique ( ipieces ) end if call below_cache % put ( idx ,[ i , iskip ], ipieces ) end if end function get_all_pieces_below subroutine update_array () !! populate the array using the start/end indices integer :: i array = 0 do i = 1 , n_lines array ( istart_array ( i , 1 ): iend_array ( i , 1 ),& istart_array ( i , 2 ): iend_array ( i , 2 ),& istart_array ( i , 3 ): iend_array ( i , 3 )) = i end do end subroutine update_array function get_pieces_above ( i ) result ( ipieces ) !! get set of pieces directly above piece i integer ( ip ), intent ( in ) :: i integer ( ip ), dimension (:), allocatable :: ipieces integer ( ip ) :: x , y , z !! counter allocate ( ipieces ( 0 )) do x = istart_array ( i , 1 ), iend_array ( i , 1 ) do y = istart_array ( i , 2 ), iend_array ( i , 2 ) do z = istart_array ( i , 3 ), iend_array ( i , 3 ) if ( z + 1 <= ubound ( array , 3 )) then if ( array ( x , y , z + 1 ) /= 0 ) ipieces = [ ipieces , array ( x , y , z + 1 )] ! above this one end if end do end do end do ipieces = unique ( pack ( ipieces , ipieces /= i )) ! exclude the ones in this piece end function get_pieces_above function get_pieces_below ( i ) result ( ipieces ) !! get set of pieces directly below piece i integer ( ip ), intent ( in ) :: i integer ( ip ), dimension (:), allocatable :: ipieces integer ( ip ) :: x , y , z !! counter allocate ( ipieces ( 0 )) do x = istart_array ( i , 1 ), iend_array ( i , 1 ) do y = istart_array ( i , 2 ), iend_array ( i , 2 ) do z = istart_array ( i , 3 ), iend_array ( i , 3 ) if ( z - 1 > 0 ) then ! 0 is the floor if ( array ( x , y , z - 1 ) /= 0 ) ipieces = [ ipieces , array ( x , y , z - 1 )] ! below this one end if end do end do end do ipieces = unique ( pack ( ipieces , ipieces /= i )) ! exclude the ones in this piece end function get_pieces_below subroutine move_piece_down ( i , moved ) !! move a piece down (fall one square) if it can be moved integer ( ip ), intent ( in ) :: i !! piece number logical , intent ( out ) :: moved !! if it was actually movec moved = . false . if ( size ( get_pieces_below ( i )) == 0 ) then ! can only move if nothing below if ( istart_array ( i , 3 ) > 1 . and . iend_array ( i , 3 ) > 1 ) then istart_array ( i , 3 ) = istart_array ( i , 3 ) - 1 iend_array ( i , 3 ) = iend_array ( i , 3 ) - 1 moved = . true . call update_array () end if end if end subroutine move_piece_down end program problem_22","tags":"","loc":"program/problem_22.html"},{"title":"problem_19 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_19~~UsesGraph program~problem_19 problem_19 iso_fortran_env iso_fortran_env program~problem_19->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_19->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_19~~CallsGraph program~problem_19 problem_19 interface~split aoc_utilities::split program~problem_19->interface~split proc~clock_end aoc_utilities::clock%clock_end program~problem_19->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_19->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_19->proc~number_of_lines_in_file proc~parse_rule problem_19::parse_rule program~problem_19->proc~parse_rule proc~process problem_19::process program~problem_19->proc~process proc~rating problem_19::rating program~problem_19->proc~rating proc~read_line aoc_utilities::read_line program~problem_19->proc~read_line proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~parse_rule->interface~split proc~workflow_name_to_index problem_19::workflow_name_to_index proc~process->proc~workflow_name_to_index proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit integer :: n_lines integer :: iline integer :: i character(len=:), allocatable :: line type( string ), dimension(:), allocatable :: vals logical :: accepted integer(kind=ip) :: total_accepted type( part ), dimension(:), allocatable :: parts type( workflow ), dimension(:), allocatable :: workflows type( workflow ), allocatable :: w Derived Types type :: part Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(4) :: xmas type :: rule Components Type Visibility Attributes Name Initial logical, public :: accept = .false. logical, public :: reject = .false. integer, public :: operator = 0 integer, public :: operator_arg = 0 integer, public :: operator_val = 0 character(len=:), public, allocatable :: goto type :: workflow Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name type( rule ), public, dimension(:), allocatable :: rules Functions pure function rating (p) Arguments Type Intent Optional Attributes Name type( part ), intent(in) :: p Return Value integer(kind=ip) function process (p) result(accepted) process this part through all the workflows. Arguments Type Intent Optional Attributes Name type( part ), intent(in) :: p Return Value logical function workflow_name_to_index (name) result(idx) get the index of this workflow in the array Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value integer function parse_rule (s) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value type( rule ) Source Code program problem_19 use aoc_utilities use iso_fortran_env implicit none integer :: iunit , n_lines , iline , i character ( len = :), allocatable :: line !, name type ( string ), dimension (:), allocatable :: vals logical :: accepted integer ( ip ) :: total_accepted type :: part integer ( ip ), dimension ( 4 ) :: xmas ! [x,m,a,s] end type part type ( part ), dimension (:), allocatable :: parts type :: rule logical :: accept = . false . logical :: reject = . false . integer :: operator = 0 ! 1:<, 2:> integer :: operator_arg = 0 ! 1:x, 2:m, 3:a, 4:s integer :: operator_val = 0 ! value to compare to character ( len = :), allocatable :: goto ! where to next (workflow name) end type rule type :: workflow character ( len = :), allocatable :: name type ( rule ), dimension (:), allocatable :: rules end type workflow type ( workflow ), dimension (:), allocatable :: workflows type ( workflow ), allocatable :: w call clk % tic () ! open(newunit=iunit, file='inputs/day19_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day19.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( workflows ( 0 )) do iline = 1 , n_lines line = read_line ( iunit ) if ( line == '' ) then !now parse part ratings allocate ( parts ( 0 )) end if if ( allocated ( parts )) then ! parsing parts if ( line == '' ) cycle ! {x=787,m=2655,a=1222,s=2876} vals = split ( line , ',' ) parts = [ parts , part ( xmas = [ int ( vals ( 1 )% str ( 4 :)), & int ( vals ( 2 )% str ( 3 :)), & int ( vals ( 3 )% str ( 3 :)), & int ( vals ( 4 )% str ( 3 : len ( vals ( 4 )% str ) - 1 ))])] else ! parsing workflows : qqz{s>2770:qs,m<1801:hdj,R} if ( allocated ( w )) deallocate ( w ); allocate ( w ) ! blank one vals = split ( line , '{' ) w % name = vals ( 1 )% str ! workflow name !write(*,*) '--->'//w%name//'<-----' vals ( 2 )% str = vals ( 2 )% str ( 1 : len ( vals ( 2 )% str ) - 1 ) ! remove last bracket vals = split ( vals ( 2 )% str , ',' ) ! workflow rules ! add each rule to the workflow allocate ( w % rules ( 0 )) do i = 1 , size ( vals ) w % rules = [ w % rules , parse_rule ( vals ( i )% str )] end do workflows = [ workflows , w ] end if end do total_accepted = 0 do i = 1 , size ( parts ) accepted = process ( parts ( i )) !write(*,*) parts(i), accepted if ( accepted ) then total_accepted = total_accepted + rating ( parts ( i )) end if end do write ( * , * ) '19a: ' , total_accepted call clk % toc ( '19' ) contains pure integer ( ip ) function rating ( p ) type ( part ), intent ( in ) :: p rating = sum ( p % xmas ) end function rating function process ( p ) result ( accepted ) !! process this part through all the workflows. type ( part ), intent ( in ) :: p logical :: accepted integer :: i , irule i = workflow_name_to_index ( 'in' ) ! start at the first workflow irule = 1 ! first rule do associate ( r => workflows ( i )% rules ( irule ) ) ! check if we are done if ( r % accept ) then ; accepted = . true .; return ; end if if ( r % reject ) then ; accepted = . false .; return ; end if if ( r % operator > 0 ) then ! process the operator select case ( r % operator ) case ( 1 ) ! < if ( p % xmas ( r % operator_arg ) < r % operator_val ) then ! check if done if ( r % goto == 'A' ) then ; accepted = . true .; return ; end if if ( r % goto == 'R' ) then ; accepted = . false .; return ; end if ! go to next workflow: i = workflow_name_to_index ( r % goto ) !write(*,*) 'goto '//r%goto irule = 1 ! start at first rule of new workflow else irule = irule + 1 ! next rule end if case ( 2 ) ! > if ( p % xmas ( r % operator_arg ) > r % operator_val ) then ! check if done if ( r % goto == 'A' ) then ; accepted = . true .; return ; end if if ( r % goto == 'R' ) then ; accepted = . false .; return ; end if ! go to next workflow: i = workflow_name_to_index ( r % goto ) irule = 1 ! start at first rule of new workflow else irule = irule + 1 ! next rule end if end select else ! goto another workflow i = workflow_name_to_index ( r % goto ) irule = 1 ! start at first rule of new workflow end if end associate end do end function process function workflow_name_to_index ( name ) result ( idx ) !! get the index of this workflow in the array character ( len =* ), intent ( in ) :: name integer :: idx do idx = 1 , size ( workflows ) if ( name == workflows ( idx )% name ) return ! found it end do if ( idx > size ( workflows )) error stop 'workflow not found: ' // name end function workflow_name_to_index function parse_rule ( s ) result ( r ) character ( len =* ), intent ( in ) :: s type ( rule ) :: r type ( string ), dimension (:), allocatable :: v character ( len =* ), parameter :: xmas = 'xmas' ! 1,2,3,4 if ( s == 'A' ) then r % accept = . true . else if ( s == 'R' ) then r % reject = . true . else if ( index ( s , '>' ) > 0 ) then v = split ( s ( 3 :), ':' ) ! example: a<2006:qkq r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 2 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else if ( index ( s , '<' ) > 0 ) then v = split ( s ( 3 :), ':' ) r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 1 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else r % goto = s ! it's a workflow name end if end if end function parse_rule end program problem_19","tags":"","loc":"program/problem_19.html"},{"title":"problem_19b – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_19b~~UsesGraph program~problem_19b problem_19b iso_fortran_env iso_fortran_env program~problem_19b->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_19b->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. reformulated to operate on ranges of the x,m,a,s ratings Calls program~~problem_19b~~CallsGraph program~problem_19b problem_19b interface~split aoc_utilities::split program~problem_19b->interface~split proc~clock_end aoc_utilities::clock%clock_end program~problem_19b->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_19b->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_19b->proc~number_of_lines_in_file proc~parse_rule~2 problem_19b::parse_rule program~problem_19b->proc~parse_rule~2 proc~process~2 problem_19b::process program~problem_19b->proc~process~2 proc~read_line aoc_utilities::read_line program~problem_19b->proc~read_line proc~workflow_name_to_index~2 problem_19b::workflow_name_to_index program~problem_19b->proc~workflow_name_to_index~2 proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~parse_rule~2->interface~split proc~process~2->proc~process~2 proc~process~2->proc~workflow_name_to_index~2 proc~get_accepted problem_19b::get_accepted proc~process~2->proc~get_accepted proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit integer :: n_lines integer :: iline integer :: i character(len=:), allocatable :: line type( string ), dimension(:), allocatable :: vals logical :: accepted integer(kind=ip) :: total_accepted type( part ) :: parts type( workflow ), dimension(:), allocatable :: workflows type( workflow ), allocatable :: w Derived Types type :: interval Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(2) :: v [start, end] of the interval type :: part Components Type Visibility Attributes Name Initial type( interval ), public, dimension(4) :: xmas type :: rule Components Type Visibility Attributes Name Initial logical, public :: accept = .false. logical, public :: reject = .false. integer, public :: operator = 0 integer, public :: operator_arg = 0 integer, public :: operator_val = 0 character(len=:), public, allocatable :: goto type :: workflow Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name type( rule ), public, dimension(:), allocatable :: rules Functions recursive function process (iworkflow, irule, p) result(iaccepted) process this part range starting with irule Arguments Type Intent Optional Attributes Name integer, intent(in) :: iworkflow integer, intent(in) :: irule type( part ), intent(in) :: p Return Value integer(kind=ip) function get_accepted (p) count of all the parts in the set Arguments Type Intent Optional Attributes Name type( part ), intent(in) :: p Return Value integer(kind=ip) function workflow_name_to_index (name) result(idx) get the index of this workflow in the array Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value integer function parse_rule (s) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value type( rule ) Source Code program problem_19b !! reformulated to operate on ranges of the x,m,a,s ratings use aoc_utilities use iso_fortran_env implicit none integer :: iunit , n_lines , iline , i character ( len = :), allocatable :: line !, name type ( string ), dimension (:), allocatable :: vals logical :: accepted integer ( ip ) :: total_accepted type :: interval integer ( ip ), dimension ( 2 ) :: v !! [start, end] of the interval end type interval type :: part type ( interval ), dimension ( 4 ) :: xmas ! [x,m,a,s] ranges end type part type ( part ) :: parts type :: rule logical :: accept = . false . logical :: reject = . false . integer :: operator = 0 ! 1:<, 2:> integer :: operator_arg = 0 ! 1:x, 2:m, 3:a, 4:s integer :: operator_val = 0 ! value to compare to character ( len = :), allocatable :: goto ! where to next (workflow name) end type rule type :: workflow character ( len = :), allocatable :: name type ( rule ), dimension (:), allocatable :: rules end type workflow type ( workflow ), dimension (:), allocatable :: workflows type ( workflow ), allocatable :: w call clk % tic () ! open(newunit=iunit, file='inputs/day19_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day19.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( workflows ( 0 )) do iline = 1 , n_lines line = read_line ( iunit ) if ( line == '' ) exit ! done - dont need the parts list for part b ! parsing workflows : qqz{s>2770:qs,m<1801:hdj,R} if ( allocated ( w )) deallocate ( w ); allocate ( w ) ! blank one vals = split ( line , '{' ) w % name = vals ( 1 )% str ! workflow name !write(*,*) '--->'//w%name//'<-----' vals ( 2 )% str = vals ( 2 )% str ( 1 : len ( vals ( 2 )% str ) - 1 ) ! remove last bracket vals = split ( vals ( 2 )% str , ',' ) ! workflow rules ! add each rule to the workflow allocate ( w % rules ( 0 )) do i = 1 , size ( vals ) w % rules = [ w % rules , parse_rule ( vals ( i )% str )] end do workflows = [ workflows , w ] end do parts = part ( xmas = [ interval ([ 1 , 4000 ]), & interval ([ 1 , 4000 ]), & interval ([ 1 , 4000 ]),& interval ([ 1 , 4000 ])]) i = workflow_name_to_index ( 'in' ) ! start at the first workflow total_accepted = process ( i , 1 , parts ) write ( * , * ) '19b: ' , total_accepted call clk % toc ( '19b' ) contains recursive function process ( iworkflow , irule , p ) result ( iaccepted ) !! process this part range starting with irule integer , intent ( in ) :: iworkflow integer , intent ( in ) :: irule type ( part ), intent ( in ) :: p integer ( ip ) :: iaccepted integer ( ip ), dimension (:), allocatable :: itmp , itmp_t , itmp_f integer ( ip ) :: i type ( part ) :: pt , pf iaccepted = 0 associate ( r => workflows ( iworkflow )% rules ( irule ) ) ! check if we are done if ( r % accept ) then iaccepted = get_accepted ( p ) return else if ( r % reject ) then iaccepted = 0 return end if ! process recursively, by splitting up the intervals when necessary if ( r % operator > 0 ) then ! process the operator select case ( r % operator ) case ( 1 ) ! < ! always create the two sets and process the two cases below ! [note that some sets maybe empty] ! ! example: ![1,200]   < 10   ==> [1,9]    TRUE !                     [10,200] FALSE itmp = [( i , i = p % xmas ( r % operator_arg )% v ( 1 ), p % xmas ( r % operator_arg )% v ( 2 ))] itmp_t = pack ( itmp , mask = itmp < r % operator_val ) !true itmp_f = pack ( itmp , mask = itmp >= r % operator_val ) !false if ( size ( itmp_t ) > 0 ) then ! some are true pt = p pt % xmas ( r % operator_arg )% v = [ itmp_t ( 1 ), itmp_t ( size ( itmp_t ))] if ( r % goto == 'A' ) then iaccepted = iaccepted + get_accepted ( pt ) else if ( r % goto /= 'R' ) then ! go to next workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , pt ) end if end if if ( size ( itmp_f ) > 0 ) then ! some are false pf = p pf % xmas ( r % operator_arg )% v = [ itmp_f ( 1 ), itmp_f ( size ( itmp_f ))] iaccepted = iaccepted + process ( iworkflow , irule + 1 , pf ) ! next rule end if case ( 2 ) ! > itmp = [( i , i = p % xmas ( r % operator_arg )% v ( 1 ), p % xmas ( r % operator_arg )% v ( 2 ))] itmp_t = pack ( itmp , mask = itmp > r % operator_val ) !true itmp_f = pack ( itmp , mask = itmp <= r % operator_val ) !false if ( size ( itmp_t ) > 0 ) then ! some are true pt = p pt % xmas ( r % operator_arg )% v = [ itmp_t ( 1 ), itmp_t ( size ( itmp_t ))] if ( r % goto == 'A' ) then iaccepted = iaccepted + get_accepted ( pt ) else if ( r % goto /= 'R' ) then ! go to next workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , pt ) end if end if if ( size ( itmp_f ) > 0 ) then ! some are false pf = p pf % xmas ( r % operator_arg )% v = [ itmp_f ( 1 ), itmp_f ( size ( itmp_f ))] iaccepted = iaccepted + process ( iworkflow , irule + 1 , pf ) ! next rule end if end select else ! goto another workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , p ) end if end associate !end do end function process integer ( ip ) function get_accepted ( p ) !! count of all the parts in the set type ( part ), intent ( in ) :: p get_accepted = ( 1 + ( p % xmas ( 1 )% v ( 2 ) - p % xmas ( 1 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 2 )% v ( 2 ) - p % xmas ( 2 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 3 )% v ( 2 ) - p % xmas ( 3 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 4 )% v ( 2 ) - p % xmas ( 4 )% v ( 1 ))) end function get_accepted function workflow_name_to_index ( name ) result ( idx ) !! get the index of this workflow in the array character ( len =* ), intent ( in ) :: name integer :: idx do idx = 1 , size ( workflows ) if ( name == workflows ( idx )% name ) return ! found it end do if ( idx > size ( workflows )) error stop 'workflow not found: ' // name end function workflow_name_to_index function parse_rule ( s ) result ( r ) character ( len =* ), intent ( in ) :: s type ( rule ) :: r type ( string ), dimension (:), allocatable :: v character ( len =* ), parameter :: xmas = 'xmas' ! 1,2,3,4 if ( s == 'A' ) then r % accept = . true . else if ( s == 'R' ) then r % reject = . true . else if ( index ( s , '>' ) > 0 ) then v = split ( s ( 3 :), ':' ) ! example: a<2006:qkq r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 2 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else if ( index ( s , '<' ) > 0 ) then v = split ( s ( 3 :), ':' ) r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 1 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else r % goto = s ! it's a workflow name end if end if end function parse_rule end program problem_19b","tags":"","loc":"program/problem_19b.html"},{"title":"problem_01.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_01.f90~~EfferentGraph sourcefile~problem_01.f90 problem_01.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_01.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_1 use iso_fortran_env use aoc_utilities implicit none integer :: iunit logical :: status_ok character ( len = :), allocatable :: line integer :: n_lines integer :: i , j , k , n , isum , ifirst , ilast , idxfirst , idxlast character ( len =* ), dimension ( 9 ), parameter :: ichars = [ & 'one  ' , & 'two  ' , & 'three' , & 'four ' , & 'five ' , & 'six  ' , & 'seven' , & 'eight' , & 'nine ' ] call clk % tic () isum = 0 open ( newunit = iunit , file = 'inputs/day1.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) do i = 1 , n_lines ! remove all the chars before the first and after the last number line = read_line ( iunit , status_ok ) n = len ( line ) do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) exit ! done line ( j : j ) = ' ' end do do j = n , 1 , - 1 if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) exit ! done line ( j : j ) = ' ' end do line = trim ( adjustl ( line )) n = len ( line ) isum = isum + 10 * int ( line ( 1 : 1 )) + int ( line ( n : n )) end do write ( * , * ) '1a: sum:' , isum close ( iunit ) ! -------- part 2 ----------- open ( newunit = iunit , file = 'inputs/day1.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do i = 1 , n_lines line = read_line ( iunit , status_ok ) n = len ( line ) ! keep track of the index of the first and last number (digit or string) ifirst = huge ( 1 ) idxfirst = huge ( 1 ) do j = 1 , size ( ichars ) k = min ( index ( line , trim ( ichars ( j ))), index ( line , trim ( ichars ( j )), back = . true .) ) ! accounts for duplicates if ( k > 0 . and . k <= idxfirst ) then ifirst = j idxfirst = k end if end do do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) then if ( j <= idxfirst ) then ifirst = int ( line ( j : j )) idxfirst = j end if end if end do ilast = 0 idxlast = 0 do j = 1 , size ( ichars ) k = max ( index ( line , trim ( ichars ( j ))), index ( line , trim ( ichars ( j )), back = . true .) ) ! accounts for duplicates if ( k > 0 . and . k >= idxlast ) then ilast = j idxlast = k end if end do do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) then if ( j >= idxlast ) then ilast = int ( line ( j : j )) idxlast = j end if end if end do isum = isum + 10 * ifirst + ilast end do write ( * , * ) '1b: sum:' , isum call clk % toc ( '1' ) end program problem_1","tags":"","loc":"sourcefile/problem_01.f90.html"},{"title":"problem_10.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_10.f90~~EfferentGraph sourcefile~problem_10.f90 problem_10.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_10.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_10 use iso_fortran_env use aoc_utilities implicit none integer :: i , j , nrows , ncols , imove , l , m logical , dimension (:,:), allocatable :: icounts character ( len = 1 ), dimension (:,:), allocatable :: array integer , dimension (:,:), allocatable :: distance , distance_reverse logical , dimension (:,:), allocatable :: visited real ( wp ), dimension (:), allocatable :: x , y !! path cooidinates integer , dimension ( 2 ) :: Sij !! i,j of the S char in array call clk % tic () array = read_file_to_char_array ( 'inputs/day10.txt' , '.' ) ! pad with . to simplify edge logic nrows = size ( array , 1 ) ncols = size ( array , 2 ) allocate ( distance ( nrows , ncols )); distance = - 1 allocate ( distance_reverse ( nrows , ncols )); distance_reverse = - 1 allocate ( visited ( nrows , ncols )) ! start at the S coordinate: Sij = findloc ( array , 'S' ) x = [ Sij ( 1 )] ! to store the path for part b y = [ Sij ( 2 )] ! traverse the maze: visited = . false .; visited ( Sij ( 1 ), Sij ( 2 )) = . true .; distance ( Sij ( 1 ), Sij ( 2 )) = 0 do imove = 1 , 4 call move ( Sij ( 1 ), Sij ( 2 ), imove , distance , . true .) end do ! traverse the maze again in reverse: visited = . false .; visited ( Sij ( 1 ), Sij ( 2 )) = . true .; distance_reverse ( Sij ( 1 ), Sij ( 2 )) = 0 do imove = 4 , 1 , - 1 call move ( Sij ( 1 ), Sij ( 2 ), imove , distance_reverse , . false .) end do ! where they match is the distance furthest away from the start write ( * , * ) '10a: ' , pack ( distance , mask = ( distance == distance_reverse . and . distance > 0 )) ! for part b, use locpt to test all the points ! allow openmp to be used here to do each row in parallel allocate ( icounts ( nrows , ncols )); icounts = . false . !$OMP PARALLEL DO SHARED(icounts,x,y) PRIVATE(i,j,l,m) do i = 2 , nrows - 1 ! we can skip the padding do j = 2 , ncols - 1 if ( any ( i == x . and . j == y )) cycle ! skip if on path call locpt ( real ( i , wp ), real ( j , wp ), x , y , size ( x ), l , m ) if ( l == 1 ) icounts ( i , j ) = . true . ! if (i,j) is inside the polygonal path end do end do !$OMP END PARALLEL DO write ( * , * ) '10b: ' , count ( icounts ) call clk % toc ( '10' ) contains recursive subroutine move ( i , j , direction , distance , save_path ) integer , intent ( in ) :: i , j , direction integer , dimension (:,:), intent ( inout ) :: distance logical , intent ( in ) :: save_path !! to save the path coordinates integer :: inew , jnew , imove logical :: valid_move select case ( direction ) case ( 1 ); inew = i - 1 ; jnew = j ! north case ( 2 ); inew = i + 1 ; jnew = j ! south case ( 3 ); inew = i ; jnew = j + 1 ! east case ( 4 ); inew = i ; jnew = j - 1 ! west end select if ( visited ( inew , jnew ) . or . array ( inew , jnew ) == '.' ) return ! can we move in this direction? valid_move = . false . associate ( current_pipe => array ( i , j ), & current_distance => distance ( i , j ), & move_to => array ( inew , jnew ) ) select case ( current_pipe ) case ( 'S' ) ! don't know what the first pip is, so have to try them all select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '|' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south end select case ( '-' ) select case ( direction ) case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'L' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select case ( 'J' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '7' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'F' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select end select if ( valid_move ) then distance ( inew , jnew ) = current_distance + 1 visited ( inew , jnew ) = . true . do imove = 1 , 4 call move ( inew , jnew , imove , distance , save_path ) end do if ( save_path ) then x = [ x , real ( inew , wp )] ! save cordinates of point on the path y = [ y , real ( jnew , wp )] end if end if end associate end subroutine move pure character ( len = 2 ) function pipe_info ( p ) character ( len = 1 ), intent ( in ) :: p select case ( p ) case ( '|' ); pipe_info = 'NS' ! | is a vertical pipe connecting north and south. case ( '-' ); pipe_info = 'EW' ! - is a horizontal pipe connecting east and west. case ( 'L' ); pipe_info = 'NE' ! L is a 90-degree bend connecting north and east. case ( 'J' ); pipe_info = 'NW' ! J is a 90-degree bend connecting north and west. case ( '7' ); pipe_info = 'SW' ! 7 is a 90-degree bend connecting south and west. case ( 'F' ); pipe_info = 'SE' ! F is a 90-degree bend connecting south and east. end select end function pipe_info end program problem_10","tags":"","loc":"sourcefile/problem_10.f90.html"},{"title":"numerical_differentiation_module.f90 – AoC-2023","text":"This file depends on sourcefile~~numerical_differentiation_module.f90~~EfferentGraph sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~cache_module.f90 cache_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~cache_module.f90 sourcefile~diff_module.f90 diff_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~diff_module.f90 sourcefile~dsm_module.f90 dsm_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~dsm_module.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~numerical_differentiation_module.f90->sourcefile~kinds_module.f90 sourcefile~utilities_module.f90 utilities_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~utilities_module.f90 sourcefile~cache_module.f90->sourcefile~kinds_module.f90 sourcefile~cache_module.f90->sourcefile~utilities_module.f90 sourcefile~diff_module.f90->sourcefile~kinds_module.f90 sourcefile~dsm_module.f90->sourcefile~kinds_module.f90 sourcefile~utilities_module.f90->sourcefile~kinds_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~numerical_differentiation_module.f90~~AfferentGraph sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~numerical_differentiation_module.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~numerical_differentiation_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> author: Jacob Williams !  date: October 29, 2016 ! !  Numerical differentiation module for computing the Jacobian matrix !  (the derivative matrix of `m` functions w.r.t. `n` variables) using !  finite differences. module numerical_differentiation_module use numdiff_kinds_module use numdiff_utilities_module use iso_fortran_env , only : error_unit use dsm_module , only : dsm use diff_module , only : diff_func use numdiff_cache_module , only : function_cache implicit none private real ( wp ), parameter :: zero = 0.0_wp type , public :: finite_diff_method !! defines the finite difference method !! used to compute the Jacobian. !! !! See: [[get_finite_difference_method]] !! for the different methods. private integer :: id = 0 !! unique ID for the method character ( len = :), allocatable :: name !! the name of the method integer :: class = 0 !! 2=backward diffs, 3=central diffs, etc... real ( wp ), dimension (:), allocatable :: dx_factors !! multiplicative factors for `dx` perturbation real ( wp ), dimension (:), allocatable :: df_factors !! multiplicative factors for accumulating function evaluations real ( wp ) :: df_den_factor = zero !! denominator factor for finite difference equation (times `dx`) contains private procedure , public :: get_formula procedure , public :: print => print_finite_difference_method end type finite_diff_method interface finite_diff_method !! constructor module procedure initialize_finite_difference_method end interface type , public :: meth_array !! to store an array of [[finite_diff_method]] types !! this is used when the `mode=2` option is used !! in [[numdiff_type]] private type ( finite_diff_method ), dimension (:), allocatable :: meth end type meth_array type , public :: sparsity_pattern !! A sparsity pattern private logical :: sparsity_computed = . false . !! has the sparsity pattern already been computed? integer :: num_nonzero_elements = 0 !! number of nonzero elements in the jacobian !! (will be the dimension of `irow` and `icol`) integer , dimension (:), allocatable :: irow !! sparsity pattern - rows of non-zero elements integer , dimension (:), allocatable :: icol !! sparsity pattern - columns of non-zero elements logical :: linear_sparsity_computed = . false . !! if the linear pattern has been populated integer :: num_nonzero_linear_elements = 0 !! number of constant elements in the jacobian integer , dimension (:), allocatable :: linear_irow !! linear sparsity pattern - rows of non-zero elements integer , dimension (:), allocatable :: linear_icol !! linear sparsity pattern - columns of non-zero elements real ( wp ), dimension (:), allocatable :: linear_vals !! linear elements of the jacobian integer , dimension (:), allocatable :: indices !! index vector !! `[1,2,...,num_nonzero_elements]` !! for putting `df` into `jac` integer :: maxgrp = 0 !! the number of groups in the partition !! of the columns of `a`. integer , dimension (:), allocatable :: ngrp !! specifies the partition of the columns of `a`. !! column `jcol` belongs to group `ngrp(jcol)`. !! `size(n)` contains private procedure :: dsm_wrapper procedure :: compute_indices procedure , public :: destroy => destroy_sparsity procedure , public :: print => print_sparsity procedure , public :: columns_in_partition_group end type sparsity_pattern type , public :: numdiff_type !! base type for sparsity and Jacobian computations. private logical :: exception_raised = . false . !! if true, an exception has been raised integer :: istat = 0 !! a non-zero value will cause all routine to exit. !! this can be set to `-1` by calling [[terminate]]. character ( len = :), allocatable :: error_msg !! error message (if `istat/=0`) integer :: n = 0 !! number of `x` variables integer :: m = 0 !! number of `f` functions real ( wp ), dimension (:), allocatable :: xlow !! lower bounds on `x` real ( wp ), dimension (:), allocatable :: xhigh !! upper bounds on `x` logical :: print_messages = . true . !! if true, warning messages are printed !! to the `error_unit` for any errors. integer :: chunk_size = 100 !! chuck size for allocating the arrays (>0) integer :: perturb_mode = 1 !! perturbation mode: !! !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` real ( wp ), dimension (:), allocatable :: dpert !! perturbation vector for `x` logical :: partition_sparsity_pattern = . false . !! to partition the sparsity pattern using [[dsm]] type ( sparsity_pattern ) :: sparsity !! the sparsity pattern real ( wp ), dimension (:), allocatable :: xlow_for_sparsity !! lower bounds on `x` for computing sparsity (optional) real ( wp ), dimension (:), allocatable :: xhigh_for_sparsity !! upper bounds on `x` for computing sparsity (optional) real ( wp ), dimension (:), allocatable :: dpert_for_sparsity !! perturbation vector for `x` when computing !! sparsity for `sparsity_mode=4` integer :: num_sparsity_points = 3 !! for `sparsity_mode=4`, the number of jacobian !! evaluations used to estimate the sparsity pattern. !! See [[compute_sparsity_random_2]] integer :: sparsity_perturb_mode = 1 !! perturbation mode (if `sparsity_mode=4`): !! !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` ! if computing the sparsity pattern, we also have an option to ! compute the linear pattern, which indicates constant elements ! of the jacobian. these elements don't need to be computed again. logical :: compute_linear_sparsity_pattern = . false . !! to also compute the linear sparsity pattern real ( wp ) :: linear_sparsity_tol = epsilon ( 1.0_wp ) !! the equality tolerance for derivatives to !! indicate a constant jacobian element (linear sparsity) real ( wp ) :: function_precision_tol = epsilon ( 1.0_wp ) !! the function precision. two functions values !! that are the within this tolerance are !! considered the same value. This is used !! when estimating the sparsity pattern when !! `sparsity_mode=2` in [[compute_sparsity_random]] integer :: mode = 1 !! **1** = use `meth` (specified methods), !! **2** = use `class` (specified class, method is selected on-the-fly). type ( finite_diff_method ), dimension (:), allocatable :: meth !! the finite difference method to use !! compute the `n`th column of the Jacobian !! `size(n)`.  Either this or `class` is used integer , dimension (:), allocatable :: class !! the class of method to use to !! compute the `n`th column of the Jacobian !! `size(n)`. Either this or `meth` is used type ( meth_array ), dimension (:), allocatable :: class_meths !! array of methods for the specified classes. !! used with `class` when `mode=2` ! parameters when using diff: real ( wp ) :: eps = 1.0e-9_wp !! tolerance parameter for [[diff]] real ( wp ) :: acc = 0.0_wp !! tolerance parameter for [[diff]] type ( function_cache ) :: cache !! if using the function cache logical :: use_diff = . false . !! if we are using the Neville's process method, !! rather than finite differences procedure ( func ), pointer :: problem_func => null () !! the user-defined function ! these are required to be defined by the user: procedure ( func ), pointer :: compute_function => null () !! compute the user-defined function !! this can point to the `problem_func` or, if using !! the cache, it points to [[compute_function_with_cache]]. procedure ( spars_f ), pointer :: compute_sparsity => null () !! for computing the sparsity pattern procedure ( info_f ), pointer :: info_function => null () !! an optional function the user can define !! which is called when each column of the jacobian is computed. !! It can be used to perform any setup operations. procedure ( jacobian_f ), pointer :: jacobian_function => null () !! the low-level function called by [[compute_jacobian]] !! that actually computes the jacobian. contains private procedure , public :: initialize => initialize_numdiff !! initialize the class procedure , public :: diff_initialize => initialize_numdiff_for_diff !! initialize the class procedure , public :: compute_jacobian !! main routine to compute the Jacobian !! using the selected options. It !! returns the sparse (vector) form. procedure , public :: compute_jacobian_dense !! return the dense `size(m,n)` !! matrix form of the Jacobian. procedure , public :: compute_jacobian_times_vector !! returns the product of the Jacobian !! matrix and an input vector procedure , public :: destroy => destroy_numdiff_type !! destroy the class procedure , public :: print_sparsity_pattern !! print the sparsity pattern in vector form to a file procedure , public :: print_sparsity_matrix !! print the sparsity pattern in matrix form to a file procedure , public :: set_sparsity_pattern !! manually set the sparsity pattern procedure , public :: select_finite_diff_method !! select a method in a specified class so !! that the variable bounds are not violated !! when by the perturbations. procedure , public :: select_finite_diff_method_for_partition_group !! version of [[select_finite_diff_method]] !! for partitioned sparsity pattern. procedure , public :: set_numdiff_bounds !! can be called to change the variable bounds. procedure , public :: compute_sparsity_pattern !! if the user needs to compute the sparsity pattern manually. !! (otherwise it will be done the first time the Jacobian is computed) procedure , public :: get_sparsity_pattern !! returns the sparsity pattern (if it is allocated) procedure , public :: terminate !! can be called by user to stop the computation procedure , public :: failed !! to check if an exception was raised. procedure , public :: get_error_status !! the status of error condition ! internal routines: procedure :: destroy_sparsity_pattern !! destroy the sparsity pattern procedure :: compute_perturb_vector procedure :: compute_perturbation_vector !! computes the variable perturbation factor procedure :: compute_sparsity_perturbation_vector procedure :: perturb_x_and_compute_f procedure :: perturb_x_and_compute_f_partitioned procedure :: set_numdiff_sparsity_bounds procedure :: set_sparsity_mode procedure :: generate_dense_sparsity_partition procedure :: compute_jacobian_for_sparsity procedure :: resize_sparsity_vectors procedure :: raise_exception procedure :: clear_exceptions end type numdiff_type abstract interface subroutine func ( me , x , f , funcs_to_compute ) !! The function (vector array of output functions `f`, computed !! from a vector of input variables `x`). !! This must be defined for all computations. import :: numdiff_type , wp implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! array of variables (size `n`) real ( wp ), dimension (:), intent ( out ) :: f !! array of functions (size `m`) integer , dimension (:), intent ( in ) :: funcs_to_compute !! the elements of the !! function vector that need !! to be computed (the other !! are ignored) end subroutine func subroutine spars_f ( me , x ) !! The function to compute the sparsity pattern. !! It populates the `irow` and `icol` variables in the class. import :: numdiff_type , wp implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) end subroutine spars_f subroutine info_f ( me , column , i , x ) !! User-defined info function (optional). !! Informs user what is being done during Jacobian computation. !! It can be used to perform any setup operations that need to !! done on the user's end. import :: numdiff_type , wp implicit none class ( numdiff_type ), intent ( inout ) :: me integer , dimension (:), intent ( in ) :: column !! the columns being computed. integer , intent ( in ) :: i !! perturbing these columns for the `i`th time (1,2,...) real ( wp ), dimension (:), intent ( in ) :: x !! the nominal variable vector end subroutine info_f subroutine jacobian_f ( me , x , dx , jac ) !! Actual function for computing the Jacobian !! called by [[compute_jacobian]]. import :: numdiff_type , wp implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector (size `num_nonzero_elements`) end subroutine jacobian_f end interface ! other: public :: get_finite_diff_formula public :: get_all_methods_in_class contains !******************************************************************************* !******************************************************************************* !> !  Constructor for a [[finite_diff_method]]. ! !@note factors are input as integers for convenience, but are converted !      to reals for the actual computations. (note: this means we can't !      currently define methods that have non-integer factors). function initialize_finite_difference_method ( id , name , class , dx_factors ,& df_factors , df_den_factor ) result ( me ) implicit none type ( finite_diff_method ) :: me integer , intent ( in ) :: id !! unique ID for the method character ( len =* ), intent ( in ) :: name !! the name of the method integer , intent ( in ) :: class !! 2=backward diffs, 3=central diffs, etc... integer , dimension (:), intent ( in ) :: dx_factors !! multiplicative factors for dx perturbation integer , dimension (:), intent ( in ) :: df_factors !! multiplicative factors for accumulating function evaluations integer , intent ( in ) :: df_den_factor !! denominator factor for finite difference equation (times dx) if ( size ( dx_factors ) /= size ( df_factors )) then error stop 'Error in initialize_finite_difference_method: ' // & 'dx_factors and df_factors arrays must be the same size.' else me % id = id me % name = trim ( name ) me % class = class ! the following is not strictly necessary if the ! compiler fully supports auto-LHS allocation: allocate ( me % dx_factors ( size ( dx_factors ))) allocate ( me % df_factors ( size ( df_factors ))) me % dx_factors = real ( dx_factors , wp ) me % df_factors = real ( df_factors , wp ) me % df_den_factor = real ( df_den_factor , wp ) end if end function initialize_finite_difference_method !******************************************************************************* !******************************************************************************* !> !  Print the contents of a [[finite_diff_method]]. Used for debugging. subroutine print_finite_difference_method ( me , iunit ) implicit none class ( finite_diff_method ), intent ( in ) :: me integer , intent ( in ) :: iunit !! file unit for printing !! (assumed to be opened) write ( iunit , '(A,1X,I5)' ) 'id            :' , me % id write ( iunit , '(A,1X,A)' ) 'name          :' , me % name write ( iunit , '(A,1X,I5)' ) 'class         :' , me % class write ( iunit , '(A,1X,*(I5,\",\"))' ) 'dx_factors    :' , int ( me % dx_factors ) write ( iunit , '(A,1X,*(I5,\",\"))' ) 'df_factors    :' , int ( me % df_factors ) write ( iunit , '(A,1X,I5)' ) 'df_den_factor :' , int ( me % df_den_factor ) end subroutine print_finite_difference_method !******************************************************************************* !******************************************************************************* !> !  Wrapper for computing the function, using the cache. subroutine compute_function_with_cache ( me , x , f , funcs_to_compute ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! array of variables (size `n`) real ( wp ), dimension (:), intent ( out ) :: f !! array of functions (size `m`) integer , dimension (:), intent ( in ) :: funcs_to_compute !! the elements of the !! function vector that need !! to be computed (the other !! are ignored) integer :: i !! index in the cache logical , dimension ( size ( funcs_to_compute )) :: ffound !! functions found in the cache logical :: xfound !! if `x` was found in the cache if ( me % exception_raised ) return ! check for exceptions call me % cache % get ( x , funcs_to_compute , i , f , xfound , ffound ) if ( xfound . and . any ( ffound )) then ! at least one of the functions was found if ( all ( ffound )) return ! all were found ! compute the ones that weren't found, ! and add them to the cache: call me % problem_func ( x , f , pack ( funcs_to_compute , mask = (. not . ffound ))) call me % cache % put ( i , x , f , pack ( funcs_to_compute , mask = (. not . ffound ))) else ! compute the function and add it to the cache: call me % problem_func ( x , f , funcs_to_compute ) call me % cache % put ( i , x , f , funcs_to_compute ) end if end subroutine compute_function_with_cache !******************************************************************************* !******************************************************************************* !> !  Return a string with the finite difference formula. ! !### Example !  * For 3-point backward: `dfdx = (f(x-2h)-4f(x-h)+3f(x)) / (2h)` subroutine get_formula ( me , formula ) class ( finite_diff_method ), intent ( in ) :: me character ( len = :), allocatable , intent ( out ) :: formula integer :: i !! counter character ( len = :), allocatable :: x !! temp variable for integer to string conversion character ( len = :), allocatable :: f !! temp variable for integer to string conversion if ( allocated ( me % dx_factors ) . and . allocated ( me % df_factors )) then formula = 'dfdx = (' do i = 1 , size ( me % dx_factors ) if ( int ( me % df_factors ( i )) == 1 ) then if ( i == 1 ) then formula = formula // 'f(' else formula = formula // '+f(' end if elseif ( int ( me % df_factors ( i )) ==- 1 ) then formula = formula // '-f(' else if ( i == 1 ) then f = integer_to_string ( int ( me % df_factors ( i ))) else f = integer_to_string ( int ( me % df_factors ( i )), with_sign = . true .) end if formula = formula // trim ( adjustl ( f )) // 'f(' end if if ( int ( me % dx_factors ( i )) == 0 ) then formula = formula // 'x' elseif ( int ( me % dx_factors ( i )) == 1 ) then formula = formula // 'x+h' elseif ( int ( me % dx_factors ( i )) ==- 1 ) then formula = formula // 'x-h' else x = integer_to_string ( int ( me % dx_factors ( i )), with_sign = . true .) formula = formula // 'x' // trim ( adjustl ( x )) // 'h' end if formula = formula // ')' end do f = integer_to_string ( int ( me % df_den_factor )) if ( int ( me % df_den_factor ) == 1 ) then formula = formula // ') / h' else formula = formula // ') / (' // trim ( adjustl ( f )) // 'h)' end if else formula = '' end if end subroutine get_formula !******************************************************************************* !******************************************************************************* !> !  Return a string with the finite difference formula. !  Input is the method `id` code. ! !###See also: !  * [[get_formula]] subroutine get_finite_diff_formula ( id , formula , name ) implicit none integer , intent ( in ) :: id !! the id code for the method character ( len = :), allocatable , intent ( out ) :: formula !! the formula string character ( len = :), allocatable , intent ( out ), optional :: name type ( finite_diff_method ) :: fd logical :: found call get_finite_difference_method ( id , fd , found ) if ( found . and . fd % id /= 0 ) then call get_formula ( fd , formula ) if ( present ( name )) name = fd % name else formula = '' if ( present ( name )) name = '' end if end subroutine get_finite_diff_formula !******************************************************************************* !******************************************************************************* !> !  Return a [[finite_diff_method]] given the `id` code. !  (the `id` codes begin at 1, are sequential, and uniquely define the method). ! !### Available methods ! !   *  (f(x+h)-f(x)) / h  !   *  (f(x)-f(x-h)) / h  !   *  (f(x+h)-f(x-h)) / (2h)  !   *  (-3f(x)+4f(x+h)-f(x+2h)) / (2h)  !   *  (f(x-2h)-4f(x-h)+3f(x)) / (2h)  !   *  (-2f(x-h)-3f(x)+6f(x+h)-f(x+2h)) / (6h)  !   *  (f(x-2h)-6f(x-h)+3f(x)+2f(x+h)) / (6h)  !   *  (-11f(x)+18f(x+h)-9f(x+2h)+2f(x+3h)) / (6h)  !   *  (-2f(x-3h)+9f(x-2h)-18f(x-h)+11f(x)) / (6h)  !   *  (f(x-2h)-8f(x-h)+8f(x+h)-f(x+2h)) / (12h)  !   *  (-3f(x-h)-10f(x)+18f(x+h)-6f(x+2h)+f(x+3h)) / (12h)  !   *  (-f(x-3h)+6f(x-2h)-18f(x-h)+10f(x)+3f(x+h)) / (12h)  !   *  (-25f(x)+48f(x+h)-36f(x+2h)+16f(x+3h)-3f(x+4h)) / (12h)  !   *  (3f(x-4h)-16f(x-3h)+36f(x-2h)-48f(x-h)+25f(x)) / (12h)  !   *  (3f(x-2h)-30f(x-h)-20f(x)+60f(x+h)-15f(x+2h)+2f(x+3h)) / (60h)  !   *  (-2f(x-3h)+15f(x-2h)-60f(x-h)+20f(x)+30f(x+h)-3f(x+2h)) / (60h)  !   *  (-12f(x-h)-65f(x)+120f(x+h)-60f(x+2h)+20f(x+3h)-3f(x+4h)) / (60h)  !   *  (3f(x-4h)-20f(x-3h)+60f(x-2h)-120f(x-h)+65f(x)+12f(x+h)) / (60h)  !   *  (-137f(x)+300f(x+h)-300f(x+2h)+200f(x+3h)-75f(x+4h)+12f(x+5h)) / (60h)  !   *  (-12f(x-5h)+75f(x-4h)-200f(x-3h)+300f(x-2h)-300f(x-h)+137f(x)) / (60h)  !   *  (-f(x-3h)+9f(x-2h)-45f(x-h)+45f(x+h)-9f(x+2h)+f(x+3h)) / (60h)  !   *  (2f(x-2h)-24f(x-h)-35f(x)+80f(x+h)-30f(x+2h)+8f(x+3h)-f(x+4h)) / (60h)  !   *  (f(x-4h)-8f(x-3h)+30f(x-2h)-80f(x-h)+35f(x)+24f(x+h)-2f(x+2h)) / (60h)  !   *  (-10f(x-h)-77f(x)+150f(x+h)-100f(x+2h)+50f(x+3h)-15f(x+4h)+2f(x+5h)) / (60h)  !   *  (-2f(x-5h)+15f(x-4h)-50f(x-3h)+100f(x-2h)-150f(x-h)+77f(x)+10f(x+h)) / (60h)  !   *  (-147f(x)+360f(x+h)-450f(x+2h)+400f(x+3h)-225f(x+4h)+72f(x+5h)-10f(x+6h)) / (60h)  !   *  (10f(x-6h)-72f(x-5h)+225f(x-4h)-400f(x-3h)+450f(x-2h)-360f(x-h)+147f(x)) / (60h)  !   *  (-4f(x-3h)+42f(x-2h)-252f(x-h)-105f(x)+420f(x+h)-126f(x+2h)+28f(x+3h)-3f(x+4h)) / (420h)  !   *  (3f(x-4h)-28f(x-3h)+126f(x-2h)-420f(x-h)+105f(x)+252f(x+h)-42f(x+2h)+4f(x+3h)) / (420h)  !   *  (10f(x-2h)-140f(x-h)-329f(x)+700f(x+h)-350f(x+2h)+140f(x+3h)-35f(x+4h)+4f(x+5h)) / (420h)  !   *  (-4f(x-5h)+35f(x-4h)-140f(x-3h)+350f(x-2h)-700f(x-h)+329f(x)+140f(x+h)-10f(x+2h)) / (420h)  !   *  (-60f(x-h)-609f(x)+1260f(x+h)-1050f(x+2h)+700f(x+3h)-315f(x+4h)+84f(x+5h)-10f(x+6h)) / (420h)  !   *  (10f(x-6h)-84f(x-5h)+315f(x-4h)-700f(x-3h)+1050f(x-2h)-1260f(x-h)+609f(x)+60f(x+h)) / (420h)  !   *  (-1089f(x)+2940f(x+h)-4410f(x+2h)+4900f(x+3h)-3675f(x+4h)+1764f(x+5h)-490f(x+6h)+60f(x+7h)) / (420h)  !   *  (-60f(x-7h)+490f(x-6h)-1764f(x-5h)+3675f(x-4h)-4900f(x-3h)+4410f(x-2h)-2940f(x-h)+1089f(x)) / (420h)  !   *  (3f(x-4h)-32f(x-3h)+168f(x-2h)-672f(x-h)+672f(x+h)-168f(x+2h)+32f(x+3h)-3f(x+4h)) / (840h)  !   *  (-5f(x-3h)+60f(x-2h)-420f(x-h)-378f(x)+1050f(x+h)-420f(x+2h)+140f(x+3h)-30f(x+4h)+3f(x+5h)) / (840h)  !   *  (-3f(x-5h)+30f(x-4h)-140f(x-3h)+420f(x-2h)-1050f(x-h)+378f(x)+420f(x+h)-60f(x+2h)+5f(x+3h)) / (840h)  !   *  (15f(x-2h)-240f(x-h)-798f(x)+1680f(x+h)-1050f(x+2h)+560f(x+3h)-210f(x+4h)+48f(x+5h)-5f(x+6h)) / (840h)  !   *  (5f(x-6h)-48f(x-5h)+210f(x-4h)-560f(x-3h)+1050f(x-2h)-1680f(x-h)+798f(x)+240f(x+h)-15f(x+2h)) / (840h)  !   *  (-105f(x-h)-1338f(x)+2940f(x+h)-2940f(x+2h)+2450f(x+3h)-1470f(x+4h)+588f(x+5h)-140f(x+6h)+15f(x+7h)) / (840h)  !   *  (-15f(x-7h)+140f(x-6h)-588f(x-5h)+1470f(x-4h)-2450f(x-3h)+2940f(x-2h)-2940f(x-h)+1338f(x)+105f(x+h)) / (840h)  !   *  (-2283f(x)+6720f(x+h)-11760f(x+2h)+15680f(x+3h)-14700f(x+4h)+9408f(x+5h)-3920f(x+6h)+960f(x+7h)-105f(x+8h)) / (840h)  !   *  (105f(x-8h)-960f(x-7h)+3920f(x-6h)-9408f(x-5h)+14700f(x-4h)-15680f(x-3h)+11760f(x-2h)-6720f(x-h)+2283f(x)) / (840h)  !   *  (-2f(x-5h)+25f(x-4h)-150f(x-3h)+600f(x-2h)-2100f(x-h)+2100f(x+h)-600f(x+2h)+150f(x+3h)-25f(x+4h)+2f(x+5h)) / (2520h)  !   *  (5f(x-6h)-72f(x-5h)+495f(x-4h)-2200f(x-3h)+7425f(x-2h)-23760f(x-h)+23760f(x+h)-7425f(x+2h)+2200f(x+3h)-495f(x+4h)+ !        72f(x+5h)-5f(x+6h)) / (27720h)  !   *  (-15f(x-7h)+245f(x-6h)-1911f(x-5h)+9555f(x-4h)-35035f(x-3h)+105105f(x-2h)-315315f(x-h)+315315f(x+h)-105105f(x+2h)+ !        35035f(x+3h)-9555f(x+4h)+1911f(x+5h)-245f(x+6h)+15f(x+7h)) / (360360h)  !   *  (7f(x-8h)-128f(x-7h)+1120f(x-6h)-6272f(x-5h)+25480f(x-4h)-81536f(x-3h)+224224f(x-2h)-640640f(x-h)+640640f(x+h)- !        224224f(x+2h)+81536f(x+3h)-25480f(x+4h)+6272f(x+5h)-1120f(x+6h)+128f(x+7h)-7f(x+8h)) / (720720h)  ! !  Where f(x) is the user-defined function of x !  and h is a \"small\" perturbation. ! !### References !  * G. E. Mullges, F. Uhlig, \"Numerical Algorithms with Fortran\", Springer, 1996. !  * G. W. Griffiths, \"Numerical Analysis Using R\", Cambridge University Press, 2016. ! !@note This is the only routine that has to be changed if a new !      finite difference method is added. ! !@note The order within a class is assumed to be the order that we would prefer !      to use them (e.g., central diffs are first, etc.) This is used in !      the [[select_finite_diff_method]] routine. subroutine get_finite_difference_method ( id , fd , found ) implicit none integer , intent ( in ) :: id !! the id code for the method type ( finite_diff_method ), intent ( out ) :: fd !! this method (can be used !! in [[compute_jacobian]]) logical , intent ( out ) :: found !! true if it was found found = . true . select case ( id ) ! 2 point methods case ( 1 ) ! (f(x+h)-f(x)) / h fd = finite_diff_method ( id , '2-point forward 1' , 2 ,[ 1 , 0 ],[ 1 , - 1 ], 1 ) case ( 2 ) ! (f(x)-f(x-h)) / h fd = finite_diff_method ( id , '2-point backward 1' , 2 ,[ 0 , - 1 ],[ 1 , - 1 ], 1 ) ! 3 point methods case ( 3 ) ! (f(x+h)-f(x-h)) / (2h) fd = finite_diff_method ( id , '3-point central' , 3 ,[ 1 , - 1 ],[ 1 , - 1 ], 2 ) case ( 4 ) ! (-3f(x)+4f(x+h)-f(x+2h)) / (2h) fd = finite_diff_method ( id , '3-point forward 2' , 3 ,[ 0 , 1 , 2 ],[ - 3 , 4 , - 1 ], 2 ) case ( 5 ) ! (f(x-2h)-4f(x-h)+3f(x)) / (2h) fd = finite_diff_method ( id , '3-point backward 2' , 3 ,[ - 2 , - 1 , 0 ],[ 1 , - 4 , 3 ], 2 ) ! 4 point methods case ( 6 ) ! (-2f(x-h)-3f(x)+6f(x+h)-f(x+2h)) / (6h) fd = finite_diff_method ( id , '4-point forward 2' , 4 ,[ - 1 , 0 , 1 , 2 ],[ - 2 , - 3 , 6 , - 1 ], 6 ) case ( 7 ) ! (f(x-2h)-6f(x-h)+3f(x)+2f(x+h)) / (6h) fd = finite_diff_method ( id , '4-point backward 2' , 4 ,[ - 2 , - 1 , 0 , 1 ],[ 1 , - 6 , 3 , 2 ], 6 ) case ( 8 ) ! (-11f(x)+18f(x+h)-9f(x+2h)+2f(x+3h)) / (6h) fd = finite_diff_method ( id , '4-point forward 3' , 4 ,[ 0 , 1 , 2 , 3 ],[ - 11 , 18 , - 9 , 2 ], 6 ) case ( 9 ) ! (-2f(x-3h)+9f(x-2h)-18f(x-h)+11f(x)) / (6h) fd = finite_diff_method ( id , '4-point backward 3' , 4 ,[ - 3 , - 2 , - 1 , 0 ],[ - 2 , 9 , - 18 , 11 ], 6 ) ! 5 point methods case ( 10 ) ! (f(x-2h)-8f(x-h)+8f(x+h)-f(x+2h)) / (12h) fd = finite_diff_method ( id , '5-point central' , 5 ,[ - 2 , - 1 , 1 , 2 ],[ 1 , - 8 , 8 , - 1 ], 12 ) case ( 11 ) ! (-3f(x-h)-10f(x)+18f(x+h)-6f(x+2h)+f(x+3h)) / (12h) fd = finite_diff_method ( id , '5-point forward 3' , 5 ,[ - 1 , 0 , 1 , 2 , 3 ],[ - 3 , - 10 , 18 , - 6 , 1 ], 12 ) case ( 12 ) ! (-f(x-3h)+6f(x-2h)-18f(x-h)+10f(x)+3f(x+h)) / (12h) fd = finite_diff_method ( id , '5-point backward 3' , 5 ,[ - 3 , - 2 , - 1 , 0 , 1 ],[ - 1 , 6 , - 18 , 10 , 3 ], 12 ) case ( 13 ) ! (-25f(x)+48f(x+h)-36f(x+2h)+16f(x+3h)-3f(x+4h)) / (12h) fd = finite_diff_method ( id , '5-point forward 4' , 5 ,[ 0 , 1 , 2 , 3 , 4 ],[ - 25 , 48 , - 36 , 16 , - 3 ], 12 ) case ( 14 ) ! (3f(x-4h)-16f(x-3h)+36f(x-2h)-48f(x-h)+25f(x)) / (12h) fd = finite_diff_method ( id , '5-point backward 4' , 5 ,[ - 4 , - 3 , - 2 , - 1 , 0 ],[ 3 , - 16 , 36 , - 48 , 25 ], 12 ) ! 6 point methods case ( 15 ) ! (3f(x-2h)-30f(x-h)-20f(x)+60f(x+h)-15f(x+2h)+2f(x+3h)) / (60h) fd = finite_diff_method ( id , '6-point forward 3' , 6 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 ],[ 3 , - 30 , - 20 , 60 , - 15 , 2 ], 60 ) case ( 16 ) ! (-2f(x-3h)+15f(x-2h)-60f(x-h)+20f(x)+30f(x+h)-3f(x+2h)) / (60h) fd = finite_diff_method ( id , '6-point backward 3' , 6 ,[ - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ - 2 , 15 , - 60 , 20 , 30 , - 3 ], 60 ) case ( 17 ) ! (-12f(x-h)-65f(x)+120f(x+h)-60f(x+2h)+20f(x+3h)-3f(x+4h)) / (60h) fd = finite_diff_method ( id , '6-point forward 4' , 6 ,[ - 1 , 0 , 1 , 2 , 3 , 4 ],[ - 12 , - 65 , 120 , - 60 , 20 , - 3 ], 60 ) case ( 18 ) ! (3f(x-4h)-20f(x-3h)+60f(x-2h)-120f(x-h)+65f(x)+12f(x+h)) / (60h) fd = finite_diff_method ( id , '6-point backward 4' , 6 ,[ - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ 3 , - 20 , 60 , - 120 , 65 , 12 ], 60 ) case ( 19 ) ! (-137f(x)+300f(x+h)-300f(x+2h)+200f(x+3h)-75f(x+4h)+12f(x+5h)) / (60h) fd = finite_diff_method ( id , '6-point forward 5' , 6 ,[ 0 , 1 , 2 , 3 , 4 , 5 ],[ - 137 , 300 , - 300 , 200 , - 75 , 12 ], 60 ) case ( 20 ) ! (-12f(x-5h)+75f(x-4h)-200f(x-3h)+300f(x-2h)-300f(x-h)+137f(x)) / (60h) fd = finite_diff_method ( id , '6-point backward 5' , 6 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ - 12 , 75 , - 200 , 300 , - 300 , 137 ], 60 ) ! 7 point methods case ( 21 ) ! (-f(x-3h)+9f(x-2h)-45f(x-h)+45f(x+h)-9f(x+2h)+f(x+3h)) / (60h) fd = finite_diff_method ( id , '7-point central' , 7 ,[ - 3 , - 2 , - 1 , 1 , 2 , 3 ],[ - 1 , 9 , - 45 , 45 , - 9 , 1 ], 60 ) case ( 22 ) ! (2f(x-2h)-24f(x-h)-35f(x)+80f(x+h)-30f(x+2h)+8f(x+3h)-f(x+4h)) / (60h) fd = finite_diff_method ( id , '7-point forward 4' , 7 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 , 4 ],[ 2 , - 24 , - 35 , 80 , - 30 , 8 , - 1 ], 60 ) case ( 23 ) ! (f(x-4h)-8f(x-3h)+30f(x-2h)-80f(x-h)+35f(x)+24f(x+h)-2f(x+2h)) / (60h) fd = finite_diff_method ( id , '7-point backward 4' , 7 ,[ - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ 1 , - 8 , 30 , - 80 , 35 , 24 , - 2 ], 60 ) case ( 24 ) ! (-10f(x-h)-77f(x)+150f(x+h)-100f(x+2h)+50f(x+3h)-15f(x+4h)+2f(x+5h)) / (60h) fd = finite_diff_method ( id , '7-point forward 5' , 7 ,[ - 1 , 0 , 1 , 2 , 3 , 4 , 5 ],[ - 10 , - 77 , 150 , - 100 , 50 , - 15 , 2 ], 60 ) case ( 25 ) ! (-2f(x-5h)+15f(x-4h)-50f(x-3h)+100f(x-2h)-150f(x-h)+77f(x)+10f(x+h)) / (60h) fd = finite_diff_method ( id , '7-point backward 5' , 7 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ - 2 , 15 , - 50 , 100 , - 150 , 77 , 10 ], 60 ) case ( 26 ) ! (-147f(x)+360f(x+h)-450f(x+2h)+400f(x+3h)-225f(x+4h)+72f(x+5h)-10f(x+6h)) / (60h) fd = finite_diff_method ( id , '7-point forward 6' , 7 ,[ 0 , 1 , 2 , 3 , 4 , 5 , 6 ],[ - 147 , 360 , - 450 , 400 , - 225 , 72 , - 10 ], 60 ) case ( 27 ) ! (10f(x-6h)-72f(x-5h)+225f(x-4h)-400f(x-3h)+450f(x-2h)-360f(x-h)+147f(x)) / (60h) fd = finite_diff_method ( id , '7-point backward 6' , 7 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ 10 , - 72 , 225 , - 400 , 450 , - 360 , 147 ], 60 ) ! 8 point methods case ( 28 ) ! (-4f(x-3h)+42f(x-2h)-252f(x-h)-105f(x)+420f(x+h)-126f(x+2h)+28f(x+3h)-3f(x+4h)) / (420h) fd = finite_diff_method ( id , '8-point forward 4' , 8 ,[ - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 , 4 ],[ - 4 , 42 , - 252 , - 105 , 420 , - 126 , 28 , - 3 ], 420 ) case ( 29 ) ! (3f(x-4h)-28f(x-3h)+126f(x-2h)-420f(x-h)+105f(x)+252f(x+h)-42f(x+2h)+4f(x+3h)) / (420h) fd = finite_diff_method ( id , '8-point backward 4' , 8 ,[ - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 ],[ 3 , - 28 , 126 , - 420 , 105 , 252 , - 42 , 4 ], 420 ) case ( 30 ) ! (10f(x-2h)-140f(x-h)-329f(x)+700f(x+h)-350f(x+2h)+140f(x+3h)-35f(x+4h)+4f(x+5h)) / (420h) fd = finite_diff_method ( id , '8-point forward 5' , 8 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 ],[ 10 , - 140 , - 329 , 700 , - 350 , 140 , - 35 , 4 ], 420 ) case ( 31 ) ! (-4f(x-5h)+35f(x-4h)-140f(x-3h)+350f(x-2h)-700f(x-h)+329f(x)+140f(x+h)-10f(x+2h)) / (420h) fd = finite_diff_method ( id , '8-point backward 5' , 8 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ - 4 , 35 , - 140 , 350 , - 700 , 329 , 140 , - 10 ], 420 ) case ( 32 ) ! (-60f(x-h)-609f(x)+1260f(x+h)-1050f(x+2h)+700f(x+3h)-315f(x+4h)+84f(x+5h)-10f(x+6h)) / (420h) fd = finite_diff_method ( id , '8-point forward 6' , 8 ,[ - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 ],[ - 60 , - 609 , 1260 , - 1050 , 700 , - 315 , 84 , - 10 ], 420 ) case ( 33 ) ! (10f(x-6h)-84f(x-5h)+315f(x-4h)-700f(x-3h)+1050f(x-2h)-1260f(x-h)+609f(x)+60f(x+h)) / (420h) fd = finite_diff_method ( id , '8-point backward 6' , 8 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ 10 , - 84 , 315 , - 700 , 1050 , - 1260 , 609 , 60 ], 420 ) case ( 34 ) ! (-1089f(x)+2940f(x+h)-4410f(x+2h)+4900f(x+3h)-3675f(x+4h)+1764f(x+5h)-490f(x+6h)+60f(x+7h)) / (420h) fd = finite_diff_method ( id , '8-point forward 7' , 8 ,[ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ],[ - 1089 , 2940 , - 4410 , 4900 , - 3675 , 1764 , - 490 , 60 ], 420 ) case ( 35 ) ! (-60f(x-7h)+490f(x-6h)-1764f(x-5h)+3675f(x-4h)-4900f(x-3h)+4410f(x-2h)-2940f(x-h)+1089f(x)) / (420h) fd = finite_diff_method ( id , '8-point backward 7' , 8 ,[ - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ - 60 , 490 , - 1764 , 3675 , - 4900 , 4410 , - 2940 , 1089 ], 420 ) ! 9 point methods case ( 36 ) ! (3f(x-4h)-32f(x-3h)+168f(x-2h)-672f(x-h)+672f(x+h)-168f(x+2h)+32f(x+3h)-3f(x+4h)) / (840h) fd = finite_diff_method ( id , '9-point central' , & 9 ,[ - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 ],[ 3 , - 32 , 168 , - 672 , 672 , - 168 , 32 , - 3 ], 840 ) case ( 37 ) ! (-5f(x-3h)+60f(x-2h)-420f(x-h)-378f(x)+1050f(x+h)-420f(x+2h)+140f(x+3h)-30f(x+4h)+3f(x+5h)) / (840h) fd = finite_diff_method ( id , '9-point forward 5' , & 9 ,[ - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 ],[ - 5 , 60 , - 420 , - 378 , 1050 , - 420 , 140 , - 30 , 3 ], 840 ) case ( 38 ) ! (-3f(x-5h)+30f(x-4h)-140f(x-3h)+420f(x-2h)-1050f(x-h)+378f(x)+420f(x+h)-60f(x+2h)+5f(x+3h)) / (840h) fd = finite_diff_method ( id , '9-point backward 5' , & 9 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 ],[ - 3 , 30 , - 140 , 420 , - 1050 , 378 , 420 , - 60 , 5 ], 840 ) case ( 39 ) ! (15f(x-2h)-240f(x-h)-798f(x)+1680f(x+h)-1050f(x+2h)+560f(x+3h)-210f(x+4h)+48f(x+5h)-5f(x+6h)) / (840h) fd = finite_diff_method ( id , '9-point forward 6' , & 9 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 ],[ 15 , - 240 , - 798 , 1680 , - 1050 , 560 , - 210 , 48 , - 5 ], 840 ) case ( 40 ) ! (5f(x-6h)-48f(x-5h)+210f(x-4h)-560f(x-3h)+1050f(x-2h)-1680f(x-h)+798f(x)+240f(x+h)-15f(x+2h)) / (840h) fd = finite_diff_method ( id , '9-point backward 6' , & 9 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ 5 , - 48 , 210 , - 560 , 1050 , - 1680 , 798 , 240 , - 15 ], 840 ) case ( 41 ) ! (-105f(x-h)-1338f(x)+2940f(x+h)-2940f(x+2h)+2450f(x+3h)-1470f(x+4h)+588f(x+5h)-140f(x+6h)+15f(x+7h)) / (840h) fd = finite_diff_method ( id , '9-point forward 7' , & 9 ,[ - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ],[ - 105 , - 1338 , 2940 , - 2940 , 2450 , - 1470 , 588 , - 140 , 15 ], 840 ) case ( 42 ) ! (-15f(x-7h)+140f(x-6h)-588f(x-5h)+1470f(x-4h)-2450f(x-3h)+2940f(x-2h)-2940f(x-h)+1338f(x)+105f(x+h)) / (840h) fd = finite_diff_method ( id , '9-point backward 7' , & 9 ,[ - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ - 15 , 140 , - 588 , 1470 , - 2450 , 2940 , - 2940 , 1338 , 105 ], 840 ) case ( 43 ) ! (-2283f(x)+6720f(x+h)-11760f(x+2h)+15680f(x+3h)-14700f(x+4h)+9408f(x+5h)-3920f(x+6h)+960f(x+7h)-105f(x+8h)) / (840h) fd = finite_diff_method ( id , '9-point forward 8' , & 9 ,[ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ],[ - 2283 , 6720 , - 11760 , 15680 , - 14700 , 9408 , - 3920 , 960 , - 105 ], 840 ) case ( 44 ) ! (105f(x-8h)-960f(x-7h)+3920f(x-6h)-9408f(x-5h)+14700f(x-4h)-15680f(x-3h)+11760f(x-2h)-6720f(x-h)+2283f(x)) / (840h) fd = finite_diff_method ( id , '9-point backward 8' , & 9 ,[ - 8 , - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ 105 , - 960 , 3920 , - 9408 , 14700 , - 15680 , 11760 , - 6720 , 2283 ], 840 ) ! 11 point methods case ( 500 ) ! (-2f(x-5h)+25f(x-4h)-150f(x-3h)+600f(x-2h)-2100f(x-h)+2100f(x+h)-600f(x+2h)+150f(x+3h)-25f(x+4h)+2f(x+5h)) / (2520h) fd = finite_diff_method ( id , '11-point central' , & 11 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 ],[ - 2 , 25 , - 150 , 600 , - 2100 , 2100 , - 600 , 150 , - 25 , 2 ], 2520 ) ! 13 point methods case ( 600 ) ! (5f(x-6h)-72f(x-5h)+495f(x-4h)-2200f(x-3h)+7425f(x-2h)-23760f(x-h)+23760f(x+h)-7425f(x+2h)+2200f(x+3h)-495f(x+4h)+72f(x+5h)-5f(x+6h)) / (27720h) fd = finite_diff_method ( id , '13-point central' , & 13 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 , 6 ],& [ 5 , - 72 , 495 , - 2200 , 7425 , - 23760 , 23760 , - 7425 , 2200 , - 495 , 72 , - 5 ], 27720 ) ! 15 point methods case ( 700 ) ! (-15f(x-7h)+245f(x-6h)-1911f(x-5h)+9555f(x-4h)-35035f(x-3h)+105105f(x-2h)-315315f(x-h)+315315f(x+h)-105105f(x+2h)+35035f(x+3h)-9555f(x+4h)+1911f(x+5h)-245f(x+6h)+15f(x+7h)) / (360360h) fd = finite_diff_method ( id , '15-point central' , & 15 ,[ - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ],& [ - 15 , 245 , - 1911 , 9555 , - 35035 , 105105 , - 315315 , 315315 , - 105105 , 35035 , - 9555 , 1911 , - 245 , 15 ], 360360 ) ! 17 point methods case ( 800 ) ! (7f(x-8h)-128f(x-7h)+1120f(x-6h)-6272f(x-5h)+25480f(x-4h)-81536f(x-3h)+224224f(x-2h)-640640f(x-h)+640640f(x+h)-224224f(x+2h)+81536f(x+3h)-25480f(x+4h)+6272f(x+5h)-1120f(x+6h)+128f(x+7h)-7f(x+8h)) / (720720h) fd = finite_diff_method ( id , '17-point central' , & 17 ,[ - 8 , - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ],& [ 7 , - 128 , 1120 , - 6272 , 25480 , - 81536 , 224224 , - 640640 , 640640 , - 224224 , 81536 , - 25480 , 6272 , - 1120 , 128 , - 7 ], 720720 ) case default found = . false . end select end subroutine get_finite_difference_method !******************************************************************************* !******************************************************************************* !> !  Returns all the methods with the given `class` !  (i.e., number of points in the formula). function get_all_methods_in_class ( class ) result ( list_of_methods ) implicit none integer , intent ( in ) :: class !! the `class` is the number of points in the !! finite different computation type ( meth_array ) :: list_of_methods !! all the methods with the specified `class` type ( finite_diff_method ) :: fd !! temp variable for getting a !! method from [[get_finite_difference_method]] integer :: id !! method id counter logical :: found !! status flag integer :: n !! temp size variable type ( finite_diff_method ), dimension (:), allocatable :: tmp !! for resizing `meth` array ! currently, the only way to do this is to call the ! get_finite_difference_method routine and see if there ! is one available. id = 0 do id = id + 1 call get_finite_difference_method ( id , fd , found ) if ( found ) then if ( fd % class == class ) then if ( allocated ( list_of_methods % meth )) then ! add to the list n = size ( list_of_methods % meth ) allocate ( tmp ( n + 1 )) tmp ( 1 : n ) = list_of_methods % meth tmp ( n + 1 ) = fd call move_alloc ( tmp , list_of_methods % meth ) ! ... this doesn't appear to work on Intel compiler ... !list_of_methods%meth = [list_of_methods%meth,fd]  ! add to the list else ! first element: allocate ( list_of_methods % meth ( 1 )) list_of_methods % meth = fd end if elseif ( fd % class > class ) then ! we assume they are in increasing order exit end if else exit ! done end if end do end function get_all_methods_in_class !******************************************************************************* !******************************************************************************* !> !  Select a finite diff method of a given `class` so that the perturbations !  of `x` will not violate the variable bounds. subroutine select_finite_diff_method ( me , x , xlow , xhigh , dx , list_of_methods , fd , status_ok ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x !! the variable value real ( wp ), intent ( in ) :: xlow !! the variable lower bound real ( wp ), intent ( in ) :: xhigh !! the variable upper bound real ( wp ), intent ( in ) :: dx !! the perturbation value (>0) type ( meth_array ), intent ( in ) :: list_of_methods !! list of available methods to choose from type ( finite_diff_method ), intent ( out ) :: fd !! this method can be used logical , intent ( out ) :: status_ok !! true if it really doesn't violate the bounds !! (say, the bounds are very close to each other) !! if `status_ok=False`, then the first method in !! the given class is returned in `fd`. integer :: i !! counter integer :: j !! counter real ( wp ) :: xs !! if `x` is outside the bounds, this is the value !! on the nearest bound. otherwise equal to `x`. real ( wp ) :: xp !! perturbed `x` value ! initialize: status_ok = . false . if ( me % exception_raised ) return ! check for exceptions ! make sure it is within the bounds xs = min ( xhigh , max ( xlow , x )) ! try all the methods in the class: do i = 1 , size ( list_of_methods % meth ) status_ok = . true . ! will be set to false if any ! perturbation violates the bounds ! check each of the perturbations: do j = 1 , size ( list_of_methods % meth ( i )% dx_factors ) xp = xs + list_of_methods % meth ( i )% dx_factors ( j ) * dx if ( xp < xlow . or . xp > xhigh ) then status_ok = . false . exit end if end do if ( status_ok ) then ! this one is OK to use fd = list_of_methods % meth ( i ) exit end if end do if (. not . status_ok ) then ! no method was found that doesn't violate the bounds, ! so just return the first one in the list. fd = list_of_methods % meth ( 1 ) end if end subroutine select_finite_diff_method !******************************************************************************* !******************************************************************************* !> !  Select a finite diff method of a given `class` so that the perturbations !  of `x` will not violate the variable bounds for any variable in the group. ! !  The `x` vector are only the variables in a group (not the full variable vector) subroutine select_finite_diff_method_for_partition_group ( me , x , xlow , xhigh , dx ,& list_of_methods , fd , status_ok ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! the variable values real ( wp ), dimension (:), intent ( in ) :: xlow !! the variable lower bounds real ( wp ), dimension (:), intent ( in ) :: xhigh !! the variable upper bounds real ( wp ), dimension (:), intent ( in ) :: dx !! the perturbation values (>0) type ( meth_array ), intent ( in ) :: list_of_methods !! list of available methods to choose from type ( finite_diff_method ), intent ( out ) :: fd !! this method can be used logical , intent ( out ) :: status_ok !! true if it really doesn't violate the bounds !! (say, the bounds are very close to each other) !! if `status_ok=False`, then the first method in !! the given class is returned in `fd`. integer :: i !! counter integer :: j !! counter real ( wp ), dimension ( size ( x )) :: xp !! perturbed `x` values real ( wp ), dimension ( size ( x )) :: xs !! if `x` is outside the bounds, this is the value !! on the nearest bound. otherwise equal to `x`. ! initialize: status_ok = . false . if ( me % exception_raised ) return ! check for exceptions ! make sure they are within the bounds xs = min ( xhigh , max ( xlow , x )) ! try all the methods in the class: do i = 1 , size ( list_of_methods % meth ) status_ok = . true . ! will be set to false if any ! perturbation violates the bounds ! check each of the perturbations: do j = 1 , size ( list_of_methods % meth ( i )% dx_factors ) xp = xs + list_of_methods % meth ( i )% dx_factors ( j ) * dx if ( any ( xp < xlow ) . or . any ( xp > xhigh )) then status_ok = . false . exit end if end do if ( status_ok ) then ! this one is OK to use fd = list_of_methods % meth ( i ) exit end if end do if (. not . status_ok ) then ! no method was found that doesn't violate the bounds, ! so just return the first one in the list. fd = list_of_methods % meth ( 1 ) end if end subroutine select_finite_diff_method_for_partition_group !******************************************************************************* !******************************************************************************* !> !  Alternate version of [[initialize_numdiff]] routine when !  using [[diff]] to compute the Jacobian. subroutine initialize_numdiff_for_diff ( me , n , m , xlow , xhigh ,& problem_func , sparsity_mode , info ,& chunk_size , eps , acc , cache_size ,& xlow_for_sparsity , xhigh_for_sparsity ,& dpert_for_sparsity , sparsity_perturb_mode ,& linear_sparsity_tol , function_precision_tol ,& num_sparsity_points , print_messages ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of `x` variables integer , intent ( in ) :: m !! number of `f` functions real ( wp ), dimension ( n ), intent ( in ) :: xlow !! lower bounds on `x` real ( wp ), dimension ( n ), intent ( in ) :: xhigh !! upper bounds on `x` procedure ( func ) :: problem_func !! the user function that defines the problem !! (returns `m` functions) integer , intent ( in ) :: sparsity_mode !! the sparsity computation method: !! !! **1** - assume dense, !! **2** - three-point simple method, !! **3** - will be specified by the user in !! a subsequent call to [[set_sparsity_pattern]]. !! **4** - computes a two-point jacobian !! at `num_sparsity_points` points. procedure ( info_f ), optional :: info !! a function the user can define !! which is called when each column !! of the jacobian is computed. !! It can be used to perform any !! setup operations. integer , intent ( in ), optional :: chunk_size !! chunk size for allocating the arrays !! (must be >0) [default is 100] real ( wp ), intent ( in ), optional :: eps !! tolerance parameter for [[diff]] !! if not present, default is `1.0e-9_wp` real ( wp ), intent ( in ), optional :: acc !! tolerance parameter for [[diff]] !! if not present, default is `0.0_wp` integer , intent ( in ), optional :: cache_size !! if present, this is the cache size !! for the function cache !! (default is not to enable cache) real ( wp ), dimension ( n ), intent ( in ), optional :: xlow_for_sparsity !! lower bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xlow` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: xhigh_for_sparsity !! upper bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xhigh` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: dpert_for_sparsity !! required if `sparsity_mode=4` integer , intent ( in ), optional :: sparsity_perturb_mode !! perturbation mode (required if `sparsity_mode=4`): !! !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` integer , intent ( in ), optional :: num_sparsity_points !! for `sparsity_mode=4`, the number of jacobian !! evaluations used to estimate the sparsity pattern. real ( wp ), intent ( in ), optional :: linear_sparsity_tol !! the equality tolerance for derivatives to !! indicate a constant jacobian element (linear sparsity) real ( wp ), intent ( in ), optional :: function_precision_tol !! the function precision. two functions values !! that are the within this tolerance are !! considered the same value. This is used !! when estimating the sparsity pattern when !! `sparsity_mode=2` in [[compute_sparsity_random]] logical , intent ( in ), optional :: print_messages !! if true, print error messages to `error_unit`. !! default is True. logical :: cache !! if the cache is to be used me % use_diff = . true . ! cache: cache = present ( cache_size ) if ( cache ) cache = cache_size > 0 if ( cache ) then me % compute_function => compute_function_with_cache call me % cache % initialize ( cache_size , n , m ) else me % compute_function => problem_func call me % cache % destroy () end if ! functions: me % problem_func => problem_func me % jacobian_function => compute_jacobian_with_diff ! size of the problem: me % n = n me % m = m ! input variable bounds: call me % set_numdiff_bounds ( xlow , xhigh ) ! set the sparsity function call me % set_sparsity_mode ( sparsity_mode , xlow_for_sparsity , xhigh_for_sparsity ) if ( sparsity_mode == 4 ) then ! these must be present, since we don't have a dpert and perturb mode for the gradients: if ( present ( dpert_for_sparsity ) . and . present ( sparsity_perturb_mode )) then me % dpert_for_sparsity = abs ( dpert_for_sparsity ) ! perturbation options: select case ( sparsity_perturb_mode ) case ( 1 : 3 ) me % sparsity_perturb_mode = sparsity_perturb_mode case default call me % raise_exception ( 1 , 'initialize_numdiff_for_diff' ,& 'sparsity_perturb_mode must be 1, 2, or 3.' ) return end select else call me % raise_exception ( 2 , 'initialize_numdiff_for_diff' ,& 'missing required inputs for sparsity mode 4' ) return end if end if ! if these aren't present, they will just keep the defaults: if ( present ( linear_sparsity_tol )) me % linear_sparsity_tol = linear_sparsity_tol if ( present ( function_precision_tol )) me % function_precision_tol = function_precision_tol if ( present ( num_sparsity_points )) me % num_sparsity_points = num_sparsity_points ! optional: if ( present ( chunk_size )) me % chunk_size = abs ( chunk_size ) if ( present ( eps )) me % eps = eps if ( present ( acc )) me % acc = acc if ( present ( info )) me % info_function => info if ( present ( print_messages )) me % print_messages = print_messages end subroutine initialize_numdiff_for_diff !******************************************************************************* !******************************************************************************* !> !  Change the variable bounds in a [[numdiff_type]]. ! !### See also !  * [[set_numdiff_sparsity_bounds]] ! !@note The bounds must be set when the class is initialized, !      but this routine can be used to change them later if required. subroutine set_numdiff_bounds ( me , xlow , xhigh ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: xlow !! lower bounds on `x` real ( wp ), dimension (:), intent ( in ) :: xhigh !! upper bounds on `x` integer :: i !! counter for error print character ( len = :), allocatable :: error_info !! error message info character ( len = :), allocatable :: istr !! for integer to string character ( len = 30 ) :: xlow_str , xhigh_str !! for real to string if ( me % exception_raised ) return ! check for exceptions if ( allocated ( me % xlow )) deallocate ( me % xlow ) if ( allocated ( me % xhigh )) deallocate ( me % xhigh ) if ( size ( xlow ) /= me % n . or . size ( xhigh ) /= me % n ) then call me % raise_exception ( 3 , 'set_numdiff_bounds' ,& 'invalid size of xlow or xhigh' ) return else if ( any ( xlow >= xhigh )) then error_info = 'all xlow must be < xhigh' do i = 1 , size ( xlow ) if ( xlow ( i ) >= xhigh ( i )) then istr = integer_to_string ( i ) write ( xlow_str , '(F30.16)' ) xlow ( i ) write ( xhigh_str , '(F30.16)' ) xhigh ( i ) error_info = error_info // new_line ( '' ) // '  Error for optimization variable ' // trim ( adjustl ( istr )) // & ': xlow=' // trim ( adjustl ( xlow_str )) // & ' >= xhigh=' // trim ( adjustl ( xhigh_str )) end if end do call me % raise_exception ( 4 , 'set_numdiff_bounds' , error_info ) return else allocate ( me % xlow ( me % n )) allocate ( me % xhigh ( me % n )) me % xlow = xlow me % xhigh = xhigh end if end subroutine set_numdiff_bounds !******************************************************************************* !******************************************************************************* !> !  Set sparsity mode. subroutine set_sparsity_mode ( me , sparsity_mode , xlow_for_sparsity , xhigh_for_sparsity ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: sparsity_mode !! the sparsity computation method: !! **1** - assume dense, !! **2** - three-point simple method, !! **3** - will be specified by the user in !! a subsequent call to [[set_sparsity_pattern]]. !! **4** - computes a two-point jacobian !! at `num_sparsity_points` points. real ( wp ), dimension (:), intent ( in ), optional :: xlow_for_sparsity !! lower bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xlow` is used. real ( wp ), dimension (:), intent ( in ), optional :: xhigh_for_sparsity !! upper bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xhigh` is used. if ( me % exception_raised ) return ! check for exceptions ! set the sparsity function select case ( sparsity_mode ) case ( 1 ) ! dense me % compute_sparsity => compute_sparsity_dense case ( 3 ) ! user defined me % compute_sparsity => null () case ( 2 ) ! three-point simple method me % compute_sparsity => compute_sparsity_random ! in this case, we have the option of specifying ! separate bounds for computing the sparsity: call me % set_numdiff_sparsity_bounds ( xlow_for_sparsity , xhigh_for_sparsity ) case ( 4 ) ! compute 2-point jacobian in specified number of points me % compute_sparsity => compute_sparsity_random_2 ! in this case, we have the option of specifying ! separate bounds for computing the sparsity: call me % set_numdiff_sparsity_bounds ( xlow_for_sparsity , xhigh_for_sparsity ) case default call me % raise_exception ( 5 , 'set_sparsity_mode' ,& 'sparsity_mode must be 1, 2, 3, or 4.' ) return end select end subroutine set_sparsity_mode !******************************************************************************* !******************************************************************************* !> !  Sets the variable bounds for sparsity in a [[numdiff_type]]. !  These are only used for `sparsity_mode=2`. ! !### See also !  * [[set_numdiff_bounds]] ! !@note This routine assumes that `xlow` and `xhigh` have already !      been set in the class. subroutine set_numdiff_sparsity_bounds ( me , xlow , xhigh ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ), optional :: xlow !! lower bounds on `x` to be used for !! sparsity computation. If not present, !! then then `xlow` values in the class are used. real ( wp ), dimension (:), intent ( in ), optional :: xhigh !! upper bounds on `x` to be used for !! sparsity computation. If not present, !! then then `xhigh` values in the class are used. if ( me % exception_raised ) return ! check for exceptions if ( allocated ( me % xlow_for_sparsity )) deallocate ( me % xlow_for_sparsity ) if ( allocated ( me % xhigh_for_sparsity )) deallocate ( me % xhigh_for_sparsity ) if (. not . present ( xlow )) then allocate ( me % xlow_for_sparsity ( size ( me % xlow ))) me % xlow_for_sparsity = me % xlow else allocate ( me % xlow_for_sparsity ( size ( xlow ))) me % xlow_for_sparsity = xlow end if if (. not . present ( xhigh )) then allocate ( me % xhigh_for_sparsity ( size ( me % xhigh ))) me % xhigh_for_sparsity = me % xhigh else allocate ( me % xhigh_for_sparsity ( size ( xhigh ))) me % xhigh_for_sparsity = xhigh end if ! error checks: if ( size ( me % xlow_for_sparsity ) /= me % n . or . size ( me % xhigh_for_sparsity ) /= me % n ) then call me % raise_exception ( 6 , 'set_numdiff_sparsity_bounds' ,& 'invalid size of xlow or xhigh' ) else if ( any ( me % xlow_for_sparsity >= me % xhigh_for_sparsity )) then call me % raise_exception ( 7 , 'set_numdiff_sparsity_bounds' ,& 'all xlow must be < xhigh' ) end if end subroutine set_numdiff_sparsity_bounds !******************************************************************************* !******************************************************************************* !> !  Initialize a [[numdiff_type]] class. This must be called first. ! !@note Only one of the following inputs can be used: `jacobian_method`, !      `jacobian_methods`, `class`, or `classes`. subroutine initialize_numdiff ( me , n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func , sparsity_mode , jacobian_method , jacobian_methods ,& class , classes , info , chunk_size , partition_sparsity_pattern ,& cache_size , xlow_for_sparsity , xhigh_for_sparsity ,& dpert_for_sparsity , sparsity_perturb_mode ,& linear_sparsity_tol , function_precision_tol ,& num_sparsity_points ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of `x` variables integer , intent ( in ) :: m !! number of `f` functions real ( wp ), dimension ( n ), intent ( in ) :: xlow !! lower bounds on `x` real ( wp ), dimension ( n ), intent ( in ) :: xhigh !! upper bounds on `x` integer , intent ( in ) :: perturb_mode !! perturbation mode: !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` real ( wp ), dimension ( n ), intent ( in ) :: dpert !! perturbation vector for `x` procedure ( func ) :: problem_func !! the user function that defines the problem !! (returns `m` functions) integer , intent ( in ) :: sparsity_mode !! the sparsity computation method: !! **1** - assume dense, !! **2** - three-point simple method, !! **3** - will be specified by the user in !! a subsequent call to [[set_sparsity_pattern]]. !! **4** - computes a two-point jacobian !! at `num_sparsity_points` points. integer , intent ( in ), optional :: jacobian_method !! `id` code for the finite difference method !! to use for all `n` variables. !! see [[get_finite_difference_method]] integer , dimension ( n ), intent ( in ), optional :: jacobian_methods !! `id` codes for the finite difference method !! to use for each variable. !! see [[get_finite_difference_method]] integer , intent ( in ), optional :: class !! method class for the finite difference method !! to use for all `n` variables. !! see [[get_finite_difference_method]] integer , dimension ( n ), intent ( in ), optional :: classes !! method class for the finite difference methods !! to use for each variable. !! see [[get_finite_difference_method]] procedure ( info_f ), optional :: info !! a function the user can define !! which is called when each column !! of the jacobian is computed. !! It can be used to perform any !! setup operations. integer , intent ( in ), optional :: chunk_size !! chunk size for allocating the arrays !! (must be >0) [default is 100] logical , intent ( in ), optional :: partition_sparsity_pattern !! if the sparisty pattern is to !! be partitioned using [[DSM]] !! [default is False] integer , intent ( in ), optional :: cache_size !! if present, this is the cache size !! for the function cache !! (default is not to enable cache) real ( wp ), dimension ( n ), intent ( in ), optional :: xlow_for_sparsity !! lower bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xlow` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: xhigh_for_sparsity !! upper bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xhigh` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: dpert_for_sparsity !! for `sparsity_mode=4`, the perturbation integer , intent ( in ), optional :: sparsity_perturb_mode !! perturbation mode (required if `sparsity_mode=4`): !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` real ( wp ), intent ( in ), optional :: linear_sparsity_tol !! the equality tolerance for derivatives to !! indicate a constant jacobian element (linear sparsity) real ( wp ), intent ( in ), optional :: function_precision_tol !! the function precision. two functions values !! that are the within this tolerance are !! considered the same value. This is used !! when estimating the sparsity pattern when !! `sparsity_mode=2` in [[compute_sparsity_random]] integer , intent ( in ), optional :: num_sparsity_points !! for `sparsity_mode=4`, the number of jacobian !! evaluations used to estimate the sparsity pattern. integer :: i !! counter logical :: found !! flag for [[get_finite_difference_method]] logical :: cache !! if the cache is to be used me % use_diff = . false . ! cache: cache = present ( cache_size ) if ( cache ) cache = cache_size > 0 if ( cache ) then me % compute_function => compute_function_with_cache call me % cache % initialize ( cache_size , n , m ) else me % compute_function => problem_func call me % cache % destroy () end if ! functions: me % problem_func => problem_func if ( present ( partition_sparsity_pattern )) then me % partition_sparsity_pattern = partition_sparsity_pattern else me % partition_sparsity_pattern = . false . end if ! method: if ( allocated ( me % meth )) deallocate ( me % meth ) if ( allocated ( me % class )) deallocate ( me % class ) if ( allocated ( me % class_meths )) deallocate ( me % class_meths ) if ( present ( jacobian_method ) . and . . not . present ( jacobian_methods ) . and . & . not . present ( class ) . and . . not . present ( classes )) then ! use the same for all variable me % mode = 1 allocate ( me % meth ( n )) do i = 1 , n call get_finite_difference_method ( jacobian_method , me % meth ( i ), found ) if (. not . found ) then call me % raise_exception ( 8 , 'initialize_numdiff' ,& 'invalid jacobian_method' ) return end if end do elseif (. not . present ( jacobian_method ) . and . present ( jacobian_methods ) . and . & . not . present ( class ) . and . . not . present ( classes )) then ! specify a separate method for each variable me % mode = 1 allocate ( me % meth ( n )) do i = 1 , n call get_finite_difference_method ( jacobian_methods ( i ), me % meth ( i ), found ) if (. not . found ) then call me % raise_exception ( 9 , 'initialize_numdiff' ,& 'invalid jacobian_methods' ) return end if end do if ( me % partition_sparsity_pattern ) then call me % raise_exception ( 10 , 'initialize_numdiff' ,& 'when using partitioned sparsity pattern, ' // & 'all columns must use the same ' // & 'finite diff method.' ) return end if elseif (. not . present ( jacobian_method ) . and . . not . present ( jacobian_methods ) . and . & present ( class ) . and . . not . present ( classes )) then ! use the class for all variables me % mode = 2 allocate ( me % class ( n )) me % class = class allocate ( me % class_meths ( n )) me % class_meths ( 1 ) = get_all_methods_in_class ( class ) if ( n > 1 ) me % class_meths ( 2 : n ) = me % class_meths ( 1 ) ! just copy them over elseif (. not . present ( jacobian_method ) . and . . not . present ( jacobian_methods ) . and . & . not . present ( class ) . and . present ( classes )) then ! specify a separate class for each variable me % mode = 2 me % class = classes allocate ( me % class_meths ( n )) do i = 1 , n me % class_meths ( i ) = get_all_methods_in_class ( me % class ( i )) end do if ( me % partition_sparsity_pattern ) then call me % raise_exception ( 11 , 'initialize_numdiff' ,& 'when using partitioned sparsity pattern, ' // & 'all columns must use the same ' // & 'finite diff method.' ) end if else call me % raise_exception ( 12 , 'initialize_numdiff' ,& 'must specify one of either ' // & 'jacobian_method, jacobian_methods, class, or classes.' ) end if ! size of the problem: me % n = n me % m = m ! input variable bounds: call me % set_numdiff_bounds ( xlow , xhigh ) ! perturbation options: select case ( perturb_mode ) case ( 1 : 3 ) me % perturb_mode = perturb_mode case default call me % raise_exception ( 13 , 'initialize_numdiff' ,& 'perturb_mode must be 1, 2, or 3.' ) return end select if ( allocated ( me % dpert )) deallocate ( me % dpert ) allocate ( me % dpert ( n )) me % dpert = abs ( dpert ) ! optional: if ( present ( info )) me % info_function => info if ( present ( chunk_size )) me % chunk_size = abs ( chunk_size ) ! set the jacobian function, depending on the options: if ( me % partition_sparsity_pattern ) then me % jacobian_function => compute_jacobian_partitioned else me % jacobian_function => compute_jacobian_standard end if ! set the sparsity function call me % set_sparsity_mode ( sparsity_mode , xlow_for_sparsity , xhigh_for_sparsity ) if ( present ( linear_sparsity_tol )) me % linear_sparsity_tol = linear_sparsity_tol if ( present ( function_precision_tol )) me % function_precision_tol = function_precision_tol if ( present ( num_sparsity_points )) me % num_sparsity_points = num_sparsity_points if ( present ( dpert_for_sparsity )) then me % dpert_for_sparsity = abs ( dpert_for_sparsity ) else me % dpert_for_sparsity = dpert ! use the same dpert as the jacobian end if if ( present ( sparsity_perturb_mode )) then select case ( sparsity_perturb_mode ) case ( 1 : 3 ) me % sparsity_perturb_mode = sparsity_perturb_mode case default call me % raise_exception ( 14 , 'initialize_numdiff' ,& 'sparsity_perturb_mode must be 1, 2, or 3.' ) return end select else me % sparsity_perturb_mode = perturb_mode ! use the same perturb mode as the jacobian end if end subroutine initialize_numdiff !******************************************************************************* !******************************************************************************* !> !  destroy the [[numdiff_type]] class. subroutine destroy_numdiff_type ( me ) implicit none class ( numdiff_type ), intent ( out ) :: me end subroutine destroy_numdiff_type !******************************************************************************* !******************************************************************************* !> !  destroy a [[sparsity_pattern]] type. subroutine destroy_sparsity ( me ) implicit none class ( sparsity_pattern ), intent ( out ) :: me end subroutine destroy_sparsity !******************************************************************************* !******************************************************************************* !> !  Wrapper for [[dsm]] to compute the sparsity pattern partition. subroutine dsm_wrapper ( me , n , m , info ) implicit none class ( sparsity_pattern ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of columns of jacobian matrix integer , intent ( in ) :: m !! number of rows of jacobian matrix integer , intent ( out ) :: info !! status output from [[dsm]] integer :: mingrp !! for call to [[dsm]] integer , dimension (:), allocatable :: ipntr !! for call to [[dsm]] integer , dimension (:), allocatable :: jpntr !! for call to [[dsm]] integer , dimension (:), allocatable :: irow !! for call to [[dsm]] !! (temp copy since [[dsm]] !! will modify it) integer , dimension (:), allocatable :: icol !! for call to [[dsm]] !! (temp copy since [[dsm]] !! will modify it) allocate ( ipntr ( m + 1 )) allocate ( jpntr ( n + 1 )) allocate ( me % ngrp ( n )) irow = me % irow icol = me % icol call dsm ( m , n , me % num_nonzero_elements ,& irow , icol ,& me % ngrp , me % maxgrp ,& mingrp , info , ipntr , jpntr ) end subroutine dsm_wrapper !******************************************************************************* !******************************************************************************* !> !  Returns the columns in a sparsity partition group. ! !@note This is just a wrapper to get data from `ngrp`. subroutine columns_in_partition_group ( me , igroup , n_cols , cols , nonzero_rows , indices , status_ok ) implicit none class ( sparsity_pattern ), intent ( in ) :: me integer , intent ( in ) :: igroup !! group number. Should be `>0` and `<=me%mxgrp` integer , intent ( out ) :: n_cols !! number of columns in the `igroup` group. integer , dimension (:), allocatable , intent ( out ) :: cols !! the column numbers in the `igroup` group. !! (if none, then it is not allocated) integer , dimension (:), allocatable , intent ( out ) :: nonzero_rows !! the row numbers of all the nonzero !! Jacobian elements in this group integer , dimension (:), allocatable , intent ( out ) :: indices !! nonzero indices in `jac` for a group logical , intent ( out ) :: status_ok !! true if the partition is valid integer :: i !! counter integer :: num_nonzero_elements_in_col !! number of nonzero elements in a column integer :: num_nonzero_elements_in_group !! number of nonzero elements in a group integer , dimension (:), allocatable :: col_indices !! nonzero indices in `jac` for a column if ( me % maxgrp > 0 . and . allocated ( me % ngrp )) then status_ok = . true . n_cols = count ( me % ngrp == igroup ) if ( n_cols > 0 ) then allocate ( cols ( n_cols )) cols = pack ([( i , i = 1 , size ( me % ngrp ))], mask = me % ngrp == igroup ) end if ! get all the non-zero elements in each column: num_nonzero_elements_in_group = 0 ! initialize do i = 1 , n_cols num_nonzero_elements_in_col = count ( me % icol == cols ( i )) if ( num_nonzero_elements_in_col /= 0 ) then ! there are functions to ! compute in this column num_nonzero_elements_in_group = num_nonzero_elements_in_group + & num_nonzero_elements_in_col if ( allocated ( col_indices )) deallocate ( col_indices ) allocate ( col_indices ( num_nonzero_elements_in_col )) col_indices = pack ( me % indices , mask = me % icol == cols ( i )) if ( allocated ( nonzero_rows )) then nonzero_rows = [ nonzero_rows , me % irow ( col_indices )] indices = [ indices , col_indices ] else nonzero_rows = me % irow ( col_indices ) indices = col_indices end if end if end do else status_ok = . false . end if end subroutine columns_in_partition_group !******************************************************************************* !******************************************************************************* !> !  Destroy the sparsity pattern in the class. subroutine destroy_sparsity_pattern ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me call me % sparsity % destroy () end subroutine destroy_sparsity_pattern !******************************************************************************* !******************************************************************************* !> !  Computes the `indices` vector in the class. subroutine compute_indices ( me ) implicit none class ( sparsity_pattern ), intent ( inout ) :: me integer :: i !! counter allocate ( me % indices ( me % num_nonzero_elements )) me % indices = [( i , i = 1 , me % num_nonzero_elements )] end subroutine compute_indices !******************************************************************************* !******************************************************************************* !> !  To specify the sparsity pattern directly if it is already known. ! !@note If specifying the linear pattern, all three optional arguments !      must be present. subroutine set_sparsity_pattern ( me , irow , icol , linear_irow , linear_icol , linear_vals , maxgrp , ngrp ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , dimension (:), intent ( in ) :: irow !! sparsity pattern nonzero elements row indices integer , dimension (:), intent ( in ) :: icol !! sparsity pattern nonzero elements column indices integer , dimension (:), intent ( in ), optional :: linear_irow !! linear sparsity pattern nonzero elements row indices integer , dimension (:), intent ( in ), optional :: linear_icol !! linear sparsity pattern nonzero elements column indices real ( wp ), dimension (:), intent ( in ), optional :: linear_vals !! linear sparsity values (constant elements of the Jacobian) integer , intent ( in ), optional :: maxgrp !! DSM sparsity partition !! [only used if `me%partition_sparsity_pattern=True`] integer , dimension (:), intent ( in ), optional :: ngrp !! DSM sparsity partition (size `n`) !! [only used if `me%partition_sparsity_pattern=True`] integer :: info !! status output form [[dsm]] call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions if ( size ( irow ) /= size ( icol ) . or . any ( irow > me % m ) . or . any ( icol > me % n )) then call me % raise_exception ( 15 , 'set_sparsity_pattern' ,& 'invalid inputs' ) return else me % sparsity % sparsity_computed = . true . me % sparsity % num_nonzero_elements = size ( irow ) me % sparsity % irow = irow me % sparsity % icol = icol call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) then if ( present ( maxgrp ) . and . present ( ngrp )) then ! use the user-input partition: if ( maxgrp > 0 . and . all ( ngrp >= 1 . and . ngrp <= maxgrp ) . and . size ( ngrp ) == me % n ) then me % sparsity % maxgrp = maxgrp me % sparsity % ngrp = ngrp else call me % raise_exception ( 28 , 'set_sparsity_pattern' ,& 'invalid sparsity partition inputs.' ) return end if else call me % sparsity % dsm_wrapper ( me % n , me % m , info ) if ( info /= 1 ) then call me % raise_exception ( 16 , 'set_sparsity_pattern' ,& 'error partitioning sparsity pattern.' ) return end if end if end if end if ! linear pattern: if ( present ( linear_irow ) . and . present ( linear_icol ) . and . present ( linear_vals )) then if ( size ( linear_irow ) /= size ( linear_icol ) . or . & size ( linear_vals ) /= size ( linear_icol ) . or . & any ( linear_irow > me % m ) . or . & any ( linear_icol > me % n )) then call me % raise_exception ( 17 , 'set_sparsity_pattern' ,& 'invalid linear sparsity pattern' ) return else me % sparsity % linear_irow = linear_irow me % sparsity % linear_icol = linear_icol me % sparsity % linear_vals = linear_vals me % sparsity % linear_sparsity_computed = . true . me % sparsity % num_nonzero_linear_elements = size ( linear_irow ) end if end if end subroutine set_sparsity_pattern !******************************************************************************* !******************************************************************************* !> !  assume all elements of Jacobian are non-zero. subroutine compute_sparsity_dense ( me , x ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) integer :: i !! counter integer :: r !! row counter integer :: c !! column counter call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions me % sparsity % num_nonzero_elements = me % m * me % n allocate ( me % sparsity % irow ( me % sparsity % num_nonzero_elements )) allocate ( me % sparsity % icol ( me % sparsity % num_nonzero_elements )) call me % sparsity % compute_indices () ! create the dense matrix: i = 0 do c = 1 , me % n do r = 1 , me % m i = i + 1 me % sparsity % irow ( i ) = r me % sparsity % icol ( i ) = c end do end do ! No real need for this, since it can't be partitioned (all elements are true) if ( me % partition_sparsity_pattern ) call me % generate_dense_sparsity_partition () me % sparsity % sparsity_computed = . true . end subroutine compute_sparsity_dense !******************************************************************************* !******************************************************************************* !> !  Generate a \"dense\" sparsity partition. subroutine generate_dense_sparsity_partition ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer :: i !! counter if ( me % exception_raised ) return ! check for exceptions me % sparsity % maxgrp = me % n allocate ( me % sparsity % ngrp ( me % n )) me % sparsity % ngrp = [( i , i = 1 , me % n )] end subroutine generate_dense_sparsity_partition !******************************************************************************* !******************************************************************************* !> !  Compute the sparsity pattern by computing the function at three !  \"random\" points in the [`xlow_for_sparsity`, `xhigh_for_sparsity`] interval !  and checking if the function values are the same. subroutine compute_sparsity_random ( me , x ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) !! (not used here) integer :: i !! column counter integer :: j !! row counter integer :: n_icol !! `icol` size counter integer :: n_irow !! `irow` size counter integer :: n_linear_icol !! `linear_icol` size counter integer :: n_linear_irow !! `linear_irow` size counter integer :: n_linear_vals !! `linear_vals` size counter integer , dimension ( me % m ) :: idx !! indices to compute `[1,2,...,m]` real ( wp ), dimension ( me % n ) :: x1 !! perturbed variable vector real ( wp ), dimension ( me % n ) :: x2 !! perturbed variable vector real ( wp ), dimension ( me % n ) :: x3 !! perturbed variable vector real ( wp ), dimension ( me % n ) :: x4 !! perturbed variable vector real ( wp ), dimension ( me % m ) :: f1 !! function evaluation real ( wp ), dimension ( me % m ) :: f2 !! function evaluation real ( wp ), dimension ( me % m ) :: f3 !! function evaluation real ( wp ), dimension ( me % m ) :: f4 !! function evaluation real ( wp ) :: dfdx1 !! for linear sparsity estimation real ( wp ) :: dfdx2 !! for linear sparsity estimation real ( wp ) :: dfdx3 !! for linear sparsity estimation real ( wp ) :: dfdx !! for linear sparsity estimation integer :: info !! status output form [[dsm]] real ( wp ), dimension ( 4 ), parameter :: coeffs = [ 0.20123456787654321_wp ,& 0.40123456787654321_wp ,& 0.60123456787654321_wp ,& 0.80123456787654321_wp ] !! Pick three pseudo-random points roughly equally spaced. !! (add some noise in attempt to avoid freak zeros) !!```` !! xlow---|----|--x--|---xhigh !!        1    2     3 !!```` !! !! Also using an extra point to estimate the !! constant elements of the Jacobian. ! initialize: call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions ! error check: if (. not . allocated ( me % xlow_for_sparsity ) . or . . not . allocated ( me % xhigh_for_sparsity )) then call me % raise_exception ( 18 , 'compute_sparsity_random' ,& 'the x bounds have not been set.' ) return end if associate ( xlow => me % xlow_for_sparsity , xhigh => me % xhigh_for_sparsity ) ! we will compute all the functions: idx = [( i , i = 1 , me % m )] n_icol = 0 ! initialize vector size counters n_irow = 0 n_linear_icol = 0 n_linear_irow = 0 n_linear_vals = 0 ! define a nominal point roughly in the middle: x2 = xlow + ( xhigh - xlow ) * coeffs ( 2 ) call me % compute_function ( x2 , f2 , idx ) if ( me % exception_raised ) return ! check for exceptions if ( me % compute_linear_sparsity_pattern ) then ! we need another point where we perturb all the variables ! to check to make sure it is linear in only one variable. x4 = xlow + ( xhigh - xlow ) * coeffs ( 4 ) call me % compute_function ( x4 , f4 , idx ) if ( me % exception_raised ) return ! check for exceptions end if do i = 1 , me % n ! columns of Jacobian ! restore nominal: x1 = x2 x3 = x2 x1 ( i ) = xlow ( i ) + ( xhigh ( i ) - xlow ( i )) * coeffs ( 1 ) x3 ( i ) = xlow ( i ) + ( xhigh ( i ) - xlow ( i )) * coeffs ( 3 ) call me % compute_function ( x1 , f1 , idx ) if ( me % exception_raised ) return ! check for exceptions call me % compute_function ( x3 , f3 , idx ) if ( me % exception_raised ) return ! check for exceptions do j = 1 , me % m ! each function (rows of Jacobian) if ( equal_within_tol ([ f1 ( j ), f2 ( j ), f3 ( j )], me % function_precision_tol )) then ! no change in the function, so no sparsity element here. cycle else if ( me % compute_linear_sparsity_pattern ) then ! if computing the linear pattern separately. ! do the three points lie on a line? (x1,f1) -> (x2, f2), -> (x3,f3) ! [check that the slopes are equal within a tolerance] dfdx1 = ( f1 ( j ) - f2 ( j )) / ( x1 ( i ) - x2 ( i )) ! slope of line from 1->2 dfdx2 = ( f1 ( j ) - f3 ( j )) / ( x1 ( i ) - x3 ( i )) ! slope of line from 1->3 dfdx3 = ( f1 ( j ) - f4 ( j )) / ( x1 ( i ) - x4 ( i )) ! slope of line from 1->4 if ( equal_within_tol ([ dfdx1 , dfdx2 , dfdx3 ], me % linear_sparsity_tol )) then ! this is a linear element (constant value) dfdx = ( dfdx1 + dfdx2 + dfdx3 ) / 3.0_wp ! just take the average and use that call expand_vector ( me % sparsity % linear_icol , n_linear_icol , me % chunk_size , val = i ) call expand_vector ( me % sparsity % linear_irow , n_linear_irow , me % chunk_size , val = j ) call expand_vector ( me % sparsity % linear_vals , n_linear_vals , me % chunk_size , val = dfdx ) cycle ! this element will not be added to the nonlinear pattern end if end if ! otherwise, add it to the nonlinear pattern: call expand_vector ( me % sparsity % icol , n_icol , me % chunk_size , val = i ) call expand_vector ( me % sparsity % irow , n_irow , me % chunk_size , val = j ) end if end do end do ! resize to correct size: call me % resize_sparsity_vectors ( n_icol , n_irow , n_linear_icol ,& n_linear_irow , n_linear_vals ) end associate call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) then call me % sparsity % dsm_wrapper ( me % n , me % m , info ) if ( info /= 1 ) then call me % raise_exception ( 19 , 'compute_sparsity_random' ,& 'error partitioning sparsity pattern.' ) return end if end if ! finished: me % sparsity % sparsity_computed = . true . end subroutine compute_sparsity_random !******************************************************************************* !******************************************************************************* !> !  Resize the sparsity arrays after accumulating them. subroutine resize_sparsity_vectors ( me , n_icol , n_irow , n_linear_icol ,& n_linear_irow , n_linear_vals ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( inout ) :: n_icol integer , intent ( inout ) :: n_irow integer , intent ( inout ) :: n_linear_icol integer , intent ( inout ) :: n_linear_irow integer , intent ( inout ) :: n_linear_vals if ( me % exception_raised ) return ! check for exceptions ! resize to correct size: if ( allocated ( me % sparsity % icol )) then call expand_vector ( me % sparsity % icol , n_icol , me % chunk_size , finished = . true .) call expand_vector ( me % sparsity % irow , n_irow , me % chunk_size , finished = . true .) me % sparsity % num_nonzero_elements = size ( me % sparsity % irow ) else me % sparsity % num_nonzero_elements = 0 end if ! linear pattern (note: there may be no linear elements): me % sparsity % linear_sparsity_computed = me % compute_linear_sparsity_pattern . and . & allocated ( me % sparsity % linear_vals ) if ( me % sparsity % linear_sparsity_computed ) then call expand_vector ( me % sparsity % linear_icol , n_linear_icol , me % chunk_size , finished = . true .) call expand_vector ( me % sparsity % linear_irow , n_linear_irow , me % chunk_size , finished = . true .) call expand_vector ( me % sparsity % linear_vals , n_linear_vals , me % chunk_size , finished = . true .) me % sparsity % num_nonzero_linear_elements = n_linear_vals else me % sparsity % num_nonzero_linear_elements = 0 end if end subroutine resize_sparsity_vectors !******************************************************************************* !******************************************************************************* !> !  Compute the sparsity pattern by computing a 2-point jacobian at a specified !  number of \"random\" points (`num_sparsity_points`) in the !  [`xlow_for_sparsity`, `xhigh_for_sparsity`] interval and checking if !  they are the same. subroutine compute_sparsity_random_2 ( me , x ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) !! (not used here) type :: jac_type !! so we can define an array of jacobian columns real ( wp ), dimension (:), allocatable :: jac !! a column of the jacobian end type jac_type real ( wp ), dimension (:), allocatable :: coeffs !! coefficients for computing `xp` real ( wp ), dimension (:,:), allocatable :: xp !! perturbed `x` array (size `n,num_sparsity_points`) type ( jac_type ), dimension (:), allocatable :: jac_array !! array of jacobian columns type ( sparsity_pattern ) :: tmp_sparsity_pattern !! will accumulate the pattern here !! and copy it into the class when !! finished. integer :: i !! counter for the number of points integer :: j !! counter integer :: icol !! column counter integer :: irow !! row counter real ( wp ) :: dfdx !! value of a jacobian element integer :: n_icol !! `icol` size counter integer :: n_irow !! `irow` size counter integer :: n_linear_icol !! `linear_icol` size counter integer :: n_linear_irow !! `linear_irow` size counter integer :: n_linear_vals !! `linear_vals` size counter type ( meth_array ) :: class_meths !! set of finite diff methods to use real ( wp ), dimension (:), allocatable :: jac !! array of jacobian element values integer :: info !! status output form [[dsm]] ! initialize: call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions ! error check: if (. not . allocated ( me % xlow_for_sparsity ) . or . . not . allocated ( me % xhigh_for_sparsity )) then call me % raise_exception ( 20 , 'compute_sparsity_random_2' ,& 'the x bounds have not been set.' ) return end if ! compute the coefficients: coeffs = divide_interval ( me % num_sparsity_points ) ! save the initial settings: tmp_sparsity_pattern = me % sparsity ! we create a provisional sparsity pattern here, ! to compute one row at a time: me % sparsity % irow = [( irow , irow = 1 , me % m )] me % sparsity % sparsity_computed = . true . me % sparsity % num_nonzero_elements = me % m call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) call me % generate_dense_sparsity_partition () n_icol = 0 n_irow = 0 n_linear_icol = 0 n_linear_irow = 0 n_linear_vals = 0 allocate ( jac ( me % num_sparsity_points )) ! the idea here is to compute the (dense) jacobian ! one column at at time, and keep a running track of ! the ones that have changed. ! first precompute the perturbation arrays for each point: allocate ( xp ( me % n , me % num_sparsity_points )) do i = 1 , me % num_sparsity_points xp (:, i ) = me % xlow_for_sparsity + ( me % xhigh_for_sparsity - me % xlow_for_sparsity ) * coeffs ( i ) end do ! we will use 2-point methods (simple differences): class_meths = get_all_methods_in_class ( 2 ) do icol = 1 , me % n ! column loop ! size the array: if ( allocated ( jac_array )) deallocate ( jac_array ) allocate ( jac_array ( me % num_sparsity_points )) ! compute the ith column of the jacobian: me % sparsity % icol = [( icol , j = 1 , me % m )] do i = 1 , me % num_sparsity_points call me % compute_jacobian_for_sparsity ( icol , class_meths , xp (:, i ), jac_array ( i )% jac ) if ( me % exception_raised ) return ! check for exceptions end do ! check each row: do irow = 1 , me % m ! get the jacobian values for this row,col for all the points: do j = 1 , me % num_sparsity_points jac ( j ) = jac_array ( j )% jac ( irow ) end do ! put the results into the tmp_sparsity_pattern if ( equal_within_tol ([ 0.0_wp , jac ], me % linear_sparsity_tol )) then ! they are all zero cycle else if ( me % compute_linear_sparsity_pattern ) then if ( equal_within_tol ( jac , me % linear_sparsity_tol )) then ! this is a linear element (constant value) dfdx = sum ( jac ) / me % num_sparsity_points ! just take the average and use that call expand_vector ( tmp_sparsity_pattern % linear_icol , n_linear_icol , me % chunk_size , val = icol ) call expand_vector ( tmp_sparsity_pattern % linear_irow , n_linear_irow , me % chunk_size , val = irow ) call expand_vector ( tmp_sparsity_pattern % linear_vals , n_linear_vals , me % chunk_size , val = dfdx ) cycle ! this element will not be added to the nonlinear pattern end if end if ! otherwise, add it to the nonlinear pattern: call expand_vector ( tmp_sparsity_pattern % icol , n_icol , me % chunk_size , val = icol ) call expand_vector ( tmp_sparsity_pattern % irow , n_irow , me % chunk_size , val = irow ) end if end do end do ! copy over the computed pattern: me % sparsity = tmp_sparsity_pattern ! resize to correct size: call me % resize_sparsity_vectors ( n_icol , n_irow , n_linear_icol ,& n_linear_irow , n_linear_vals ) call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) then call me % sparsity % dsm_wrapper ( me % n , me % m , info ) if ( info /= 1 ) then call me % raise_exception ( 21 , 'compute_sparsity_random_2' ,& 'error partitioning sparsity pattern.' ) return end if end if me % sparsity % sparsity_computed = . true . end subroutine compute_sparsity_random_2 !******************************************************************************* !******************************************************************************* !> !  Computes the sparsity pattern and return it. !  Uses the settings currently in the class. subroutine compute_sparsity_pattern ( me , x , irow , icol , linear_irow , linear_icol , linear_vals ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) integer , dimension (:), allocatable , intent ( out ) :: irow !! sparsity pattern nonzero elements row indices integer , dimension (:), allocatable , intent ( out ) :: icol !! sparsity pattern nonzero elements column indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_irow !! linear sparsity pattern !! nonzero elements row indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_icol !! linear sparsity pattern nonzero !! elements column indices real ( wp ), dimension (:), allocatable , intent ( out ), optional :: linear_vals !! linear sparsity values (constant !! elements of the Jacobian) if ( me % exception_raised ) return ! check for exceptions if ( associated ( me % compute_sparsity )) then call me % compute_sparsity ( x ) if ( me % exception_raised ) return ! check for exceptions call me % get_sparsity_pattern ( irow , icol , linear_irow , linear_icol , linear_vals ) end if end subroutine compute_sparsity_pattern !******************************************************************************* !******************************************************************************* !> !  Returns the sparsity pattern from the class. !  If it hasn't been computed, the output arrays will not be allocated. subroutine get_sparsity_pattern ( me , irow , icol ,& linear_irow , linear_icol , linear_vals ,& maxgrp , ngrp ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , dimension (:), allocatable , intent ( out ) :: irow !! sparsity pattern nonzero elements row indices integer , dimension (:), allocatable , intent ( out ) :: icol !! sparsity pattern nonzero elements column indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_irow !! linear sparsity pattern !! nonzero elements row indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_icol !! linear sparsity pattern nonzero !! elements column indices real ( wp ), dimension (:), allocatable , intent ( out ), optional :: linear_vals !! linear sparsity values (constant !! elements of the Jacobian) integer , intent ( out ), optional :: maxgrp !! DSM sparsity partition integer , dimension (:), allocatable , intent ( out ), optional :: ngrp !! DSM sparsity partition if ( me % exception_raised ) return ! check for exceptions if ( allocated ( me % sparsity % irow ) . and . allocated ( me % sparsity % icol )) then irow = me % sparsity % irow icol = me % sparsity % icol end if ! optional linear pattern output: if ( present ( linear_irow )) then if ( allocated ( me % sparsity % linear_irow )) linear_irow = me % sparsity % linear_irow end if if ( present ( linear_icol )) then if ( allocated ( me % sparsity % linear_icol )) linear_icol = me % sparsity % linear_icol end if if ( present ( linear_vals )) then if ( allocated ( me % sparsity % linear_vals )) linear_vals = me % sparsity % linear_vals end if ! optional DSM partition: if ( present ( ngrp ) . and . allocated ( me % sparsity % ngrp )) ngrp = me % sparsity % ngrp if ( present ( maxgrp )) maxgrp = me % sparsity % maxgrp end subroutine get_sparsity_pattern !******************************************************************************* !******************************************************************************* !> !  just a wrapper for [[compute_jacobian]], that returns a dense (`m x n`) matrix. ! !@note This one will include the constant elements if the linear pattern is available. subroutine compute_jacobian_dense ( me , x , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:,:), allocatable , intent ( out ) :: jac !! the jacobian matrix real ( wp ), dimension (:), allocatable :: jac_vec !! sparse jacobian representation integer :: i !! counter if ( me % exception_raised ) return ! check for exceptions ! size output matrix: allocate ( jac ( me % m , me % n )) ! convert to dense form: jac = zero ! compute sparse form of jacobian: call me % compute_jacobian ( x , jac_vec ) if ( me % exception_raised ) return ! check for exceptions if ( allocated ( jac_vec )) then ! add the nonlinear elements: do i = 1 , me % sparsity % num_nonzero_elements jac ( me % sparsity % irow ( i ), me % sparsity % icol ( i )) = jac_vec ( i ) end do deallocate ( jac_vec ) end if ! add the constant elements if necessary: do i = 1 , me % sparsity % num_nonzero_linear_elements jac ( me % sparsity % linear_irow ( i ), me % sparsity % linear_icol ( i )) = me % sparsity % linear_vals ( i ) end do end subroutine compute_jacobian_dense !******************************************************************************* !******************************************************************************* !> !  Perturb the specified optimization variable, and compute the function. !  This routine is designed so that `df` is accumulated as each function !  evaluation is done, to avoid having to allocate more temporary storage. subroutine perturb_x_and_compute_f ( me , x , dx_factor , dx ,& df_factor , column , idx , df ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! nominal variable vector real ( wp ), intent ( in ) :: dx_factor !! factor to multiply `dx` real ( wp ), dimension (:), intent ( in ) :: dx !! the perturbation value for this column real ( wp ), intent ( in ) :: df_factor !! factor to multiply function value integer , intent ( in ) :: column !! the variable to perturb integer , dimension (:), intent ( in ) :: idx !! the elements in this !! column of the Jacobian !! to compute (passed to function) real ( wp ), dimension ( me % m ), intent ( inout ) :: df !! the accumulated function value !! note: for the first call, this !! should be set to zero real ( wp ), dimension ( me % n ) :: xp !! the perturbed variable vector real ( wp ), dimension ( me % m ) :: f !! function evaluation if ( me % exception_raised ) return ! check for exceptions xp = x if ( dx_factor /= zero ) xp ( column ) = xp ( column ) + dx_factor * dx ( column ) call me % compute_function ( xp , f , idx ) if ( me % exception_raised ) return ! check for exceptions df ( idx ) = df ( idx ) + df_factor * f ( idx ) end subroutine perturb_x_and_compute_f !******************************************************************************* !******************************************************************************* !> !  Returns the product `J*v`, where `J` is the `m x n` Jacobian matrix !  and `v` is an `n x 1` vector. ! !@note This one will include the constant elements if the linear pattern is available. subroutine compute_jacobian_times_vector ( me , x , v , z ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:), intent ( in ) :: v !! vector (size `n`) real ( wp ), dimension (:), intent ( out ) :: z !! The product `J*v` (size `m`) real ( wp ), dimension (:), allocatable :: jac !! sparse jacobian vector integer :: i !! counter integer :: r !! row number in full jacobian integer :: c !! column number in full jacobian if ( me % exception_raised ) return ! check for exceptions ! first compute the jacobian in sparse vector form: call me % compute_jacobian ( x , jac ) if ( me % exception_raised ) return ! check for exceptions ! initialize output vector: z = 0.0_wp if ( allocated ( jac )) then !   J    v   z !  ---   -   - !  X0X   X   X !  0X0 * X = X !  00X   X   X !  00X       X ! multiplication by input v: do i = 1 , me % sparsity % num_nonzero_elements r = me % sparsity % irow ( i ) c = me % sparsity % icol ( i ) z ( r ) = z ( r ) + jac ( i ) * v ( c ) end do deallocate ( jac ) end if ! linear elements if available: do i = 1 , me % sparsity % num_nonzero_linear_elements r = me % sparsity % linear_irow ( i ) c = me % sparsity % linear_icol ( i ) z ( r ) = z ( r ) + me % sparsity % linear_vals ( i ) * v ( c ) end do end subroutine compute_jacobian_times_vector !******************************************************************************* !******************************************************************************* !> !  Compute the Jacobian. ! !@note The output `jac` only includes the elements of the nonlinear Jacobian. !      If the constant elements are being handled separately (if the linear !      pattern is available), then those elements can be obtained by !      calling `get_sparsity_pattern` if required. subroutine compute_jacobian ( me , x , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:), allocatable , intent ( out ) :: jac !! sparse jacobian vector real ( wp ), dimension ( me % n ) :: dx !! absolute perturbation (>0) for each variable if ( me % exception_raised ) return ! check for exceptions ! if we don't have a sparsity pattern yet then compute it: ! [also computes the indices vector] if (. not . me % sparsity % sparsity_computed ) call me % compute_sparsity ( x ) if ( me % sparsity % num_nonzero_elements == 0 ) return ! size the jacobian vector: allocate ( jac ( me % sparsity % num_nonzero_elements )) ! compute dx vector: if (. not . me % use_diff ) then ! only need this for the finite difference methods (not diff) call me % compute_perturbation_vector ( x , dx ) if ( me % exception_raised ) return ! check for exceptions end if ! compute the jacobian: if ( associated ( me % jacobian_function )) then call me % jacobian_function ( x , dx , jac ) else call me % raise_exception ( 22 , 'compute_jacobian' ,& 'jacobian_function has not been associated.' ) return end if end subroutine compute_jacobian !******************************************************************************* !******************************************************************************* !> !  A separate version of [[compute_jacobian]] to be used only when !  computing the sparsity pattern in [[compute_sparsity_random_2]]. !  It uses `class_meths` and the sparsity dperts and bounds. ! !@note Based on [[compute_jacobian]]. The index manipulation here could be !      greatly simplified, since we realdy know we are computed all the !      elements in one column. subroutine compute_jacobian_for_sparsity ( me , i , class_meths , x , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: i !! the column being computed type ( meth_array ), intent ( in ) :: class_meths !! set of finite diff methods to use real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:), allocatable , intent ( out ) :: jac !! sparse jacobian vector real ( wp ), dimension ( me % n ) :: dx !! absolute perturbation (>0) for each variable integer , dimension (:), allocatable :: nonzero_elements_in_col !! the indices of the !! nonzero Jacobian !! elements in a column integer :: j !! function evaluation counter real ( wp ), dimension ( me % m ) :: df !! accumulated function type ( finite_diff_method ) :: fd !! a finite different method (when !! specifying class rather than the method) logical :: status_ok !! error flag integer :: num_nonzero_elements_in_col !! number of nonzero elements in a column if ( me % exception_raised ) return ! check for exceptions ! Note that a sparsity pattern has already been set ! size the jacobian vector: allocate ( jac ( me % sparsity % num_nonzero_elements )) ! compute the perturbation vector (really we only need dx(i)): call me % compute_sparsity_perturbation_vector ( x , dx ) if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero ! determine functions to compute for this column: num_nonzero_elements_in_col = count ( me % sparsity % icol == i ) if ( num_nonzero_elements_in_col /= 0 ) then ! there are functions to compute nonzero_elements_in_col = pack ( me % sparsity % irow , mask = me % sparsity % icol == i ) call me % select_finite_diff_method ( x ( i ), me % xlow_for_sparsity ( i ), me % xhigh_for_sparsity ( i ),& dx ( i ), class_meths , fd , status_ok ) if (. not . status_ok ) then if ( me % print_messages ) then write ( error_unit , '(A,1X,I5)' ) & 'Error in compute_jacobian_for_sparsity: variable bounds violated for column: ' , i end if end if ! compute this column of the Jacobian: df = zero do j = 1 , size ( fd % dx_factors ) if ( associated ( me % info_function )) call me % info_function ([ i ], j , x ) call me % perturb_x_and_compute_f ( x , fd % dx_factors ( j ),& dx , fd % df_factors ( j ),& i , nonzero_elements_in_col , df ) if ( me % exception_raised ) return ! check for exceptions end do df ( nonzero_elements_in_col ) = df ( nonzero_elements_in_col ) / & ( fd % df_den_factor * dx ( i )) ! put result into the output vector: jac ( pack ( me % sparsity % indices , mask = me % sparsity % icol == i )) = & df ( nonzero_elements_in_col ) end if end subroutine compute_jacobian_for_sparsity !******************************************************************************* !******************************************************************************* !> !  Compute the Jacobian using finite differences. !  (one column at a time) subroutine compute_jacobian_standard ( me , x , dx , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) !! for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector (size !! `num_nonzero_elements`) integer , dimension (:), allocatable :: nonzero_elements_in_col !! the indices of the !! nonzero Jacobian !! elements in a column integer :: i !! column counter integer :: j !! function evaluation counter real ( wp ), dimension ( me % m ) :: df !! accumulated function type ( finite_diff_method ) :: fd !! a finite different method (when !! specifying class rather than the method) logical :: status_ok !! error flag integer :: num_nonzero_elements_in_col !! number of nonzero elements in a column if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero ! compute Jacobian matrix column-by-column: do i = 1 , me % n ! determine functions to compute for this column: num_nonzero_elements_in_col = count ( me % sparsity % icol == i ) if ( num_nonzero_elements_in_col /= 0 ) then ! there are functions to compute nonzero_elements_in_col = pack ( me % sparsity % irow , mask = me % sparsity % icol == i ) select case ( me % mode ) case ( 1 ) ! use the specified methods ! compute this column of the Jacobian: df = zero do j = 1 , size ( me % meth ( i )% dx_factors ) if ( associated ( me % info_function )) call me % info_function ([ i ], j , x ) call me % perturb_x_and_compute_f ( x , me % meth ( i )% dx_factors ( j ),& dx , me % meth ( i )% df_factors ( j ),& i , nonzero_elements_in_col , df ) if ( me % exception_raised ) return ! check for exceptions end do df ( nonzero_elements_in_col ) = df ( nonzero_elements_in_col ) / & ( me % meth ( i )% df_den_factor * dx ( i )) case ( 2 ) ! select the method from the class so as not to violate the bounds call me % select_finite_diff_method ( x ( i ), me % xlow ( i ), me % xhigh ( i ),& dx ( i ), me % class_meths ( i ), fd , status_ok ) if (. not . status_ok ) then if ( me % print_messages ) then write ( error_unit , '(A,1X,I5)' ) & 'Error in compute_jacobian_standard: variable bounds violated for column: ' , i end if end if ! compute this column of the Jacobian: df = zero do j = 1 , size ( fd % dx_factors ) if ( associated ( me % info_function )) call me % info_function ([ i ], j , x ) call me % perturb_x_and_compute_f ( x , fd % dx_factors ( j ),& dx , fd % df_factors ( j ),& i , nonzero_elements_in_col , df ) if ( me % exception_raised ) return ! check for exceptions end do df ( nonzero_elements_in_col ) = df ( nonzero_elements_in_col ) / & ( fd % df_den_factor * dx ( i )) case default call me % raise_exception ( 23 , 'compute_jacobian_standard' ,& 'invalid mode' ) return end select ! put result into the output vector: jac ( pack ( me % sparsity % indices , mask = me % sparsity % icol == i )) = & df ( nonzero_elements_in_col ) end if end do end subroutine compute_jacobian_standard !******************************************************************************* !******************************************************************************* !> !  Compute the Jacobian one element at a time using the Neville's process !  algorithm [[diff]]. This takes a very large number of function evaluations, !  but should give a very accurate answer. subroutine compute_jacobian_with_diff ( me , x , dx , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) !! for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector (size !! `num_nonzero_elements`) integer , parameter :: iord = 1 !! tells [[diff]] to compute first derivative integer :: i !! counter for nonzero elements of jacobian type ( diff_func ) :: d !! the [[diff]] class to use real ( wp ) :: x0 !! value of ith variable for [[diff]] real ( wp ) :: xmin !! ith variable lower bound real ( wp ) :: xmax !! ith variable upper bound real ( wp ) :: deriv !! derivative value df/dx from [[diff]] real ( wp ) :: error !! estimated error from [[diff]] integer :: ifail !! [[diff]] error flag real ( wp ), dimension ( me % n ) :: xp !! used by [[dfunc]]. real ( wp ), dimension ( me % m ) :: fvec !! used by [[dfunc]]. integer :: ir !! row index of next non-zero element integer :: ic !! column index of next non-zero element integer :: ic_prev !! previous column perturbed integer :: icount !! count of number of times a column has been perturbed logical :: use_info !! if we are reporting to the user if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero use_info = associated ( me % info_function ) if ( use_info ) ic_prev = - 1 ! set the function for diff: call d % set_function ( dfunc ) ! each element is computed one by one do i = 1 , me % sparsity % num_nonzero_elements ir = me % sparsity % irow ( i ) ic = me % sparsity % icol ( i ) x0 = x ( ic ) xmin = me % xlow ( ic ) xmax = me % xhigh ( ic ) ! if reporting to the user, have to keep track ! of which column is being perturbed, and how ! many times: if ( use_info ) then if ( ic /= ic_prev ) icount = 0 end if call d % compute_derivative ( iord , x0 , xmin , xmax , me % eps , me % acc , deriv , error , ifail ) if ( ifail == 0 . or . ifail == 1 ) then jac ( i ) = deriv else if ( ifail == - 1 ) then ! this indicates an exception was ! already raised, so just return. return else call me % raise_exception ( 24 , 'compute_jacobian_with_diff' ,& 'error computing derivative with DIFF.' ) return end if if ( use_info ) ic_prev = ic end do contains function dfunc ( this , xval ) result ( fx ) !! interface to user function for [[diff]] routine. implicit none class ( diff_func ), intent ( inout ) :: this real ( wp ), intent ( in ) :: xval !! input variable (`ic` variable) real ( wp ) :: fx !! derivative of `ir` function !! w.r.t. `xval` variable if ( use_info ) then icount = icount + 1 call me % info_function ([ ic ], icount , x ) end if xp = x xp ( ic ) = xval call me % compute_function ( xp , fvec , funcs_to_compute = [ ir ]) if ( me % exception_raised ) then ! check for exceptions fx = 0.0_wp call me % terminate () else fx = fvec ( ir ) end if end function dfunc end subroutine compute_jacobian_with_diff !******************************************************************************* !******************************************************************************* !> !  Compute the Jacobian using finite differences, !  (using the partitioned sparsity pattern to compute multiple columns !  at a time). subroutine compute_jacobian_partitioned ( me , x , dx , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector integer :: i !! column counter integer :: j !! function evaluation counter integer :: igroup !! group number counter integer :: n_cols !! number of columns in a group integer , dimension (:), allocatable :: cols !! array of column indices in a group integer , dimension (:), allocatable :: nonzero_rows !! the indices of the nonzero Jacobian !! elementes (row numbers) in a group integer , dimension (:), allocatable :: indices !! nonzero indices in `jac` for a group integer , dimension (:), allocatable :: col_indices !! nonzero indices in `jac` for a column real ( wp ), dimension ( me % m ) :: df !! accumulated function type ( finite_diff_method ) :: fd !! a finite different method (when !! specifying class rather than the method) logical :: status_ok !! error flag integer :: num_nonzero_elements_in_col if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero ! compute by group: do igroup = 1 , me % sparsity % maxgrp ! get the columns in this group: call me % sparsity % columns_in_partition_group ( igroup , n_cols , cols ,& nonzero_rows , indices , status_ok ) if (. not . status_ok ) then call me % raise_exception ( 25 , 'compute_jacobian_partitioned' ,& 'the partition has not been computed.' ) return end if if ( n_cols > 0 ) then if ( allocated ( nonzero_rows )) then select case ( me % mode ) case ( 1 ) ! use the specified methods ! note: all the methods must be the same within a group ! compute the columns of the Jacobian in this group: df = zero do j = 1 , size ( me % meth ( 1 )% dx_factors ) if ( associated ( me % info_function )) call me % info_function ( cols , j , x ) call me % perturb_x_and_compute_f_partitioned ( x , me % meth ( 1 )% dx_factors ( j ),& dx , me % meth ( 1 )% df_factors ( j ),& cols , nonzero_rows , df ) if ( me % exception_raised ) return ! check for exceptions end do ! divide by the denominator, which can be different for each column: do i = 1 , n_cols num_nonzero_elements_in_col = count ( me % sparsity % icol == cols ( i )) if ( allocated ( col_indices )) deallocate ( col_indices ) allocate ( col_indices ( num_nonzero_elements_in_col )) col_indices = pack ( me % sparsity % indices , mask = me % sparsity % icol == cols ( i )) df ( me % sparsity % irow ( col_indices )) = df ( me % sparsity % irow ( col_indices )) / & ( me % meth ( 1 )% df_den_factor * dx ( cols ( i ))) end do case ( 2 ) ! select the method from the class so as not to violate ! the bounds on *any* of the variables in the group ! note: all the classes must be the same within a group call me % select_finite_diff_method_for_partition_group ( & x ( cols ), me % xlow ( cols ), me % xhigh ( cols ),& dx ( cols ), me % class_meths ( 1 ), fd , status_ok ) if (. not . status_ok ) then if ( me % print_messages ) then ! will not consider this a fatal error for now: write ( error_unit , '(A,1X,I5,1X,A,1X,*(I5,1X))' ) & 'Error in compute_jacobian_partitioned: ' // & 'variable bounds violated for group: ' ,& igroup , '. columns: ' , cols end if end if ! compute the columns of the Jacobian in this group: df = zero do j = 1 , size ( fd % dx_factors ) if ( associated ( me % info_function )) call me % info_function ( cols , j , x ) call me % perturb_x_and_compute_f_partitioned ( x , fd % dx_factors ( j ),& dx , fd % df_factors ( j ),& cols , nonzero_rows , df ) if ( me % exception_raised ) return ! check for exceptions end do ! divide by the denominator, which can be different for each column: do i = 1 , n_cols num_nonzero_elements_in_col = count ( me % sparsity % icol == cols ( i )) if ( allocated ( col_indices )) deallocate ( col_indices ) allocate ( col_indices ( num_nonzero_elements_in_col )) col_indices = pack ( me % sparsity % indices , mask = me % sparsity % icol == cols ( i )) df ( me % sparsity % irow ( col_indices )) = df ( me % sparsity % irow ( col_indices )) / & ( fd % df_den_factor * dx ( cols ( i ))) end do case default call me % raise_exception ( 26 , 'compute_jacobian_partitioned' , 'invalid mode' ) return end select ! put result into the output vector: jac ( indices ) = df ( nonzero_rows ) end if end if end do end subroutine compute_jacobian_partitioned !******************************************************************************* !******************************************************************************* !> !  Perturb the specified optimization variable, and compute the function. !  This routine is designed so that `df` is accumulated as each function !  evaluation is done, to avoid having to allocate more temporary storage. subroutine perturb_x_and_compute_f_partitioned ( me , x , dx_factor , dx ,& df_factor , columns , idx , df ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! nominal variable vector real ( wp ), intent ( in ) :: dx_factor !! factor to multiply `dx` real ( wp ), dimension (:), intent ( in ) :: dx !! the perturbation value for this column real ( wp ), intent ( in ) :: df_factor !! factor to multiply function value integer , dimension (:), intent ( in ) :: columns !! the variables to perturb integer , dimension (:), intent ( in ) :: idx !! the elements in this !! column of the Jacobian !! to compute (passed to function) real ( wp ), dimension ( me % m ), intent ( inout ) :: df !! the accumulated function value !! note: for the first call, this !! should be set to zero real ( wp ), dimension ( me % n ) :: xp !! the perturbed variable vector real ( wp ), dimension ( me % m ) :: f !! function evaluation if ( me % exception_raised ) return ! check for exceptions xp = x if ( dx_factor /= zero ) xp ( columns ) = xp ( columns ) + dx_factor * dx ( columns ) call me % compute_function ( xp , f , idx ) if ( me % exception_raised ) return ! check for exceptions df ( idx ) = df ( idx ) + df_factor * f ( idx ) end subroutine perturb_x_and_compute_f_partitioned !******************************************************************************* !******************************************************************************* !> !  Compute `dx`, the perturbation vector for `x` subroutine compute_perturb_vector ( me , x , dpert , perturb_mode , dx ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dpert integer , intent ( in ) :: perturb_mode real ( wp ), dimension ( me % n ), intent ( out ) :: dx !! absolute perturbation (>0) !! for each variable real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) !! the smallest allowed absolute step if ( me % exception_raised ) return ! check for exceptions select case ( perturb_mode ) case ( 1 ) dx = abs ( dpert ) case ( 2 ) dx = abs ( dpert * x ) case ( 3 ) dx = abs ( dpert ) * ( 1.0_wp + abs ( x )) case default call me % raise_exception ( 27 , 'compute_perturb_vector' ,& 'invalid value for perturb_mode (must be 1, 2, or 3)' ) return end select ! make sure none are too small: where ( dx < eps ) dx = eps end where end subroutine compute_perturb_vector !******************************************************************************* !******************************************************************************* !> !  Compute `dx`, the perturbation vector for `x` used !  when computing the gradients. subroutine compute_perturbation_vector ( me , x , dx ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( out ) :: dx !! absolute perturbation (>0) !! for each variable if ( me % exception_raised ) return ! check for exceptions call me % compute_perturb_vector ( x , me % dpert , me % perturb_mode , dx ) end subroutine compute_perturbation_vector !******************************************************************************* !******************************************************************************* !> !  Compute `dx`, the perturbation vector for `x` used !  when computing the sparsity pattern. subroutine compute_sparsity_perturbation_vector ( me , x , dx ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( out ) :: dx !! absolute perturbation (>0) !! for each variable if ( me % exception_raised ) return ! check for exceptions call me % compute_perturb_vector ( x , me % dpert_for_sparsity , me % sparsity_perturb_mode , dx ) end subroutine compute_sparsity_perturbation_vector !******************************************************************************* !******************************************************************************* !> !  Print the sparsity pattern. subroutine print_sparsity ( me , n , m , iunit , dense ) implicit none class ( sparsity_pattern ), intent ( in ) :: me integer , intent ( in ) :: n !! number of variables (columns of jacobian) integer , intent ( in ) :: m !! number of functions (rows of jacobian) integer , intent ( in ) :: iunit !! file unit to write to. !! (assumed to be already opened) logical , intent ( in ), optional :: dense !! if present and true, the matrix form !! of the sparsity pattern is printed !! (default is vector form) logical :: print_matrix !! if the matrix form is to be printed integer :: r !! row counter character ( len = 1 ), dimension ( n ) :: row !! a row of the sparsity matrix if ( present ( dense )) then print_matrix = dense else print_matrix = . false . ! default end if write ( iunit , '(A)' ) '---Sparsity pattern---' if ( allocated ( me % irow ) . and . allocated ( me % icol )) then if ( print_matrix ) then do r = 1 , m ! print by row row = '0' row ( pack ( me % icol , mask = me % irow == r )) = 'X' write ( iunit , '(*(A1))' ) row end do else write ( iunit , '(A,1X,*(I3,\",\"))' ) 'irow:' , me % irow write ( iunit , '(A,1X,*(I3,\",\"))' ) 'icol:' , me % icol end if if ( allocated ( me % ngrp )) then write ( iunit , '(A)' ) '' write ( iunit , '(A)' ) '---Sparsity partition---' write ( iunit , '(A,1x,I5)' ) 'Number of groups:' , me % maxgrp write ( iunit , '(A,1x,*(I5,1X))' ) 'Group array:     ' , me % ngrp end if end if write ( iunit , '(A)' ) '' ! print linear pattern if available if ( me % linear_sparsity_computed ) then write ( iunit , '(A)' ) '---Linear sparsity pattern---' if ( allocated ( me % linear_icol ) . and . allocated ( me % linear_irow )) then if ( print_matrix ) then do r = 1 , m ! print by row row = '0' row ( pack ( me % linear_icol , mask = me % linear_irow == r )) = 'X' write ( iunit , '(*(A1))' ) row end do else write ( iunit , '(A,1X,*(I3,\",\"))' ) 'irow:' , me % linear_irow write ( iunit , '(A,1X,*(I3,\",\"))' ) 'icol:' , me % linear_icol write ( iunit , '(A,1X,*(E30.16,\",\"))' ) 'vals:' , me % linear_vals end if end if write ( iunit , '(A)' ) '' end if end subroutine print_sparsity !******************************************************************************* !******************************************************************************* !> !  Print the sparsity pattern in vector form (`irow`, `icol`). subroutine print_sparsity_pattern ( me , iunit ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: iunit !! file unit to write to. !! (assumed to be already opened) call me % sparsity % print ( me % n , me % m , iunit , dense = . false .) end subroutine print_sparsity_pattern !******************************************************************************* !******************************************************************************* !> !  Print the sparsity pattern in matrix form. subroutine print_sparsity_matrix ( me , iunit ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: iunit !! file unit to write to. !! (assumed to be already opened) call me % sparsity % print ( me % n , me % m , iunit , dense = . true .) end subroutine print_sparsity_matrix !******************************************************************************* !******************************************************************************* !> !  A user-callable routine. When called, it will terminate !  all computations and return. The `istat` return code will be !  set to `-1`. This can be called in the function or the info function. subroutine terminate ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me if ( me % exception_raised ) return ! check for existing exceptions me % istat = - 1 me % error_msg = 'Terminated by the user' me % exception_raised = . true . end subroutine terminate !******************************************************************************* !******************************************************************************* !> !  Raise an exception. subroutine raise_exception ( me , istat , routine , error_msg ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: istat !! error code. character ( len =* ), intent ( in ) :: routine !! the routine where the error was raised. character ( len =* ), intent ( in ) :: error_msg !! error message string. me % istat = istat me % error_msg = 'Error in ' // trim ( routine ) // ' : ' // trim ( error_msg ) me % exception_raised = . true . end subroutine raise_exception !******************************************************************************* !******************************************************************************* !> !  Clear all exceptions. subroutine clear_exceptions ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me me % istat = 0 if ( allocated ( me % error_msg )) deallocate ( me % error_msg ) me % exception_raised = . false . end subroutine clear_exceptions !******************************************************************************* !******************************************************************************* !> !  Returns True if an exception has been raised. pure logical function failed ( me ) implicit none class ( numdiff_type ), intent ( in ) :: me failed = me % exception_raised end function failed !******************************************************************************* !******************************************************************************* !> !  Returns the current error code and message. subroutine get_error_status ( me , istat , error_msg ) implicit none class ( numdiff_type ), intent ( in ) :: me integer , intent ( out ), optional :: istat !! error code (`istat=0` means no errors). character ( len = :), allocatable , intent ( out ), optional :: error_msg !! error message string. if ( present ( istat )) istat = me % istat if ( present ( error_msg )) then if ( allocated ( me % error_msg )) then error_msg = me % error_msg else error_msg = '' end if end if end subroutine get_error_status !******************************************************************************* !******************************************************************************* !> !  Convert an integer to a string. function integer_to_string ( i , with_sign ) result ( str ) implicit none integer , intent ( in ) :: i !! the integer logical , intent ( in ), optional :: with_sign !! also include the sign (default is False) character ( len = :), allocatable :: str !! integer converted to a string integer :: istat !! `iostat` code for write statement character ( len = 100 ) :: tmp !! logical :: sgn !! local copy of `with_sign` if ( present ( with_sign )) then sgn = with_sign else sgn = . false . end if if ( sgn ) then write ( tmp , '(SP,I100)' , iostat = istat ) i else write ( tmp , '(I100)' , iostat = istat ) i end if if ( istat == 0 ) then str = trim ( adjustl ( tmp )) else str = '****' end if end function integer_to_string !******************************************************************************* !******************************************************************************* end module numerical_differentiation_module !*******************************************************************************","tags":"","loc":"sourcefile/numerical_differentiation_module.f90.html"},{"title":"problem_15.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_15.f90~~EfferentGraph sourcefile~problem_15.f90 problem_15.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_15.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !********************************************************************************* !> !  A module for problem 15, part 2. module problem_15_module use iso_fortran_env use aoc_utilities implicit none type :: lens character ( len = :), allocatable :: label integer ( ip ) :: focal_length = 0 end type lens type :: box type ( lens ), dimension (:), allocatable :: lenses !! the lenses in the box contains procedure :: add_lens procedure :: remove_lens end type box contains subroutine add_lens ( me , l ) ! = class ( box ), intent ( inout ) :: me type ( lens ), intent ( in ) :: l !! lense to add integer :: i !! counter if ( allocated ( me % lenses )) then do i = 1 , size ( me % lenses ) if ( me % lenses ( i )% label == l % label ) then me % lenses ( i ) = l ! replace with this one return end if end do me % lenses = [ me % lenses , l ] ! if not found, add to end else me % lenses = [ l ] ! first one in the box end if end subroutine add_lens subroutine remove_lens ( me , label ) ! - !! remove the lens with the label (if present) class ( box ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: label integer :: i type ( lens ), dimension (:), allocatable :: tmp if ( allocated ( me % lenses )) then allocate ( tmp ( 0 )) do i = 1 , size ( me % lenses ) if ( me % lenses ( i )% label /= label ) tmp = [ tmp , me % lenses ( i )] end do call move_alloc ( tmp , me % lenses ) end if end subroutine remove_lens end module problem_15_module !********************************************************************************* program problem_15 use iso_fortran_env use aoc_utilities use problem_15_module implicit none integer :: i , iunit , j type ( string ), dimension (:), allocatable :: vals , vals2 integer ( ip ), dimension (:), allocatable :: ivals type ( box ), dimension ( 0 : 255 ) :: boxes ! for part 2 integer ( ip ) :: ibox ! 0-255 character ( len = :), allocatable :: label integer ( ip ) :: ival , focusing_power , lens_focusing_power call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day15_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day15.txt' , status = 'OLD' ) vals = split ( read_line ( iunit ), ',' ) close ( iunit ) allocate ( ivals ( size ( vals ))) do i = 1 , size ( vals ) ! part 1: ivals ( i ) = hash ( vals ( i )% str ) ! part 2: if ( index ( vals ( i )% str , '=' ) > 0 ) then vals2 = split ( vals ( i )% str , '=' ) label = vals2 ( 1 )% str ibox = hash ( label ) ival = int ( vals2 ( 2 )% str ) ! focal length call boxes ( ibox )% add_lens ( lens ( label , ival )) else if ( index ( vals ( i )% str , '-' ) > 0 ) then vals2 = split ( vals ( i )% str , '-' ) label = vals2 ( 1 )% str ibox = hash ( label ) call boxes ( ibox )% remove_lens ( label ) end if end do write ( * , * ) '15a: ' , sum ( ivals ) focusing_power = 0 do i = 0 , 255 ! all the boxes if ( allocated ( boxes ( i )% lenses )) then do j = 1 , size ( boxes ( i )% lenses ) ! all the lenses in the box lens_focusing_power = ( i + 1 ) * ( j ) * ( boxes ( i )% lenses ( j )% focal_length ) focusing_power = focusing_power + lens_focusing_power end do end if end do write ( * , * ) '15b: ' , focusing_power call clk % toc ( '15' ) contains pure elemental integer ( ip ) function hash ( s ) !! Determine the ASCII code for the current character of the string. character ( len =* ), intent ( in ) :: s integer :: i hash = 0 do i = 1 , len ( s ) hash = modulo ( 17_ip * ( hash + iachar ( s ( i : i ))), 256_ip ) end do end function hash end program problem_15","tags":"","loc":"sourcefile/problem_15.f90.html"},{"title":"diff_module.f90 – AoC-2023","text":"This file depends on sourcefile~~diff_module.f90~~EfferentGraph sourcefile~diff_module.f90 diff_module.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~diff_module.f90->sourcefile~kinds_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~diff_module.f90~~AfferentGraph sourcefile~diff_module.f90 diff_module.f90 sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~diff_module.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~numerical_differentiation_module.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~numerical_differentiation_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  Numerical differentiation of a 1D function `f(x)` using Neville's process. ! !## Authors !   * J. Oliver, \"An algorithm for numerical differentiation of a function !     of one real variable\", Journal of Computational and Applied Mathematics !     6 (2) (1980) 145–160. [Algol 60 source in original paper] !   * David Kahaner, Fortran 77 code from !     [NIST](ftp://math.nist.gov/pub/repository/diff/src/DIFF) !   * Jacob Williams : 2/17/2013 : Converted to modern Fortran. !     Some refactoring, addition of test cases. module diff_module use numdiff_kinds_module implicit none private type , public :: diff_func !! class to define the function for [[diff]] private logical :: stop = . false . procedure ( func ), pointer :: f => null () contains private procedure :: faccur procedure , public :: set_function procedure , public :: compute_derivative => diff procedure , public :: terminate end type diff_func abstract interface function func ( me , x ) result ( fx ) !! interface to function for [[diff]] import :: diff_func , wp implicit none class ( diff_func ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ) :: fx end function func end interface contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date:  12/27/2015 ! !  Set the function in a [[diff_func]]. !  Must be called before [[diff]]. subroutine set_function ( me , f ) implicit none class ( diff_func ), intent ( inout ) :: me procedure ( func ) :: f me % f => f end subroutine set_function !***************************************************************************************** !***************************************************************************************** !> !  Can be called by the user in the function to terminate the computation. !  This will set `ifail=-1`. subroutine terminate ( me ) implicit none class ( diff_func ), intent ( inout ) :: me me % stop = . true . end subroutine terminate !***************************************************************************************** !***************************************************************************************** !> !  the procedure `diff` calculates the first, second or !  third order derivative of a function by using neville's process to !  extrapolate from a sequence of simple polynomial approximations based on !  interpolating points distributed symmetrically about `x0` (or lying only on !  one side of `x0` should this be necessary).  if the specified tolerance is !  non-zero then the procedure attempts to satisfy this absolute or relative !  accuracy requirement, while if it is unsuccessful or if the tolerance is !  set to zero then the result having the minimum achievable estimated error !  is returned instead. subroutine diff ( me , iord , x0 , xmin , xmax , eps , accr , deriv , error , ifail ) implicit none class ( diff_func ), intent ( inout ) :: me integer , intent ( in ) :: iord !! 1, 2 or 3 specifies that the first, second or third order !! derivative,respectively, is required. real ( wp ), intent ( in ) :: x0 !! the point at which the derivative of the function is to be calculated. real ( wp ), intent ( in ) :: xmin !! `xmin`, `xmax` restrict the interpolating points to lie in [`xmin`, `xmax`], which !! should be the largest interval including `x0` in which the function is !! calculable and continuous. real ( wp ), intent ( in ) :: xmax !! `xmin`, `xmax` restrict the interpolating points to lie in [`xmin`, `xmax`], which !! should be the largest interval including `x0` in which the function is !! calculable and continuous. real ( wp ), intent ( in ) :: eps !! denotes the tolerance, either absolute or relative. `eps=0` specifies that !! the error is to be minimised, while `eps>0` or `eps<0` specifies that the !! absolute or relative error, respectively, must not exceed `abs(eps)` if !! possible.  the accuracy requirement should not be made stricter than !! necessary, since the amount of computation tends to increase as !! the magnitude of `eps` decreases, and is particularly high when `eps=0`. real ( wp ), intent ( in ) :: accr !! denotes that the absolute (`accr>0`) or relative (`accr<0`) errors in the !! computed values of the function are most unlikely to exceed `abs(accr)`, which !! should be as small as possible.  if the user cannot estimate `accr` with !! complete confidence, then it should be set to zero. real ( wp ), intent ( out ) :: deriv !! the calculated value of the derivative real ( wp ), intent ( out ) :: error !! an estimated upper bound on the magnitude of the absolute error in !! the calculated result.  it should always be examined, since in extreme case !! may indicate that there are no correct significant digits in the value !! returned for derivative. integer , intent ( out ) :: ifail !! will have one of the following values on exit: !!  *0* the procedure was successful. !!  *1* the estimated error in the result exceeds the (non-zero) requested !!      error, but the most accurate result possible has been returned. !!  *2* input data incorrect (derivative and error will be undefined). !!  *3* the interval [`xmin`, `xmax`] is too small (derivative and error will be !!      undefined). !!  *-1* stopped by the user. real ( wp ) :: acc , beta , beta4 , h , h0 , h1 , h2 , & newh1 , newh2 , heval , hprev , baseh , hacc1 , hacc2 , nhacc1 , & nhacc2 , minh , maxh , maxh1 , maxh2 , tderiv , f0 , twof0 , f1 , f2 , f3 , f4 , fmax , & maxfun , pmaxf , df1 , deltaf , pdelta , z , zpower , c0f0 , c1 , c2 , c3 , dnew , dprev , & re , te , newerr , temerr , newacc , pacc1 , pacc2 , facc1 , facc2 , acc0 , & acc1 , acc2 , relacc , twoinf , twosup , s , & d ( 10 ), denom ( 10 ), e ( 10 ), minerr ( 10 ), maxf ( 0 : 10 ), save ( 0 : 13 ), storef ( - 45 : 45 ), factor integer :: i , j , k , n , nmax , method , signh , fcount , init logical :: ignore ( 10 ), contin , saved real ( wp ) :: dummy1 , dummy2 integer , parameter :: eta = digits ( 1.0_wp ) - 1 !! minimum number of significant binary digits (apart from the !! sign digit) used to represent the mantissa of real(wp) numbers. it should !! be decreased by one if the computer truncates rather than rounds. integer , parameter :: inf = - minexponent ( 1.0_wp ) - 2 !! the largest possible positive integers subject to !! 2**(-inf) and -2**(-inf) being representable real(wp) numbers. integer , parameter :: sup = maxexponent ( 1.0_wp ) - 1 !! the largest possible positive integers subject to !! 2**sup and -2**sup being representable real(wp) numbers. real ( wp ), parameter :: sqrt2 = sqrt ( 2.0_wp ) !!  \\sqrt(2)  real ( wp ), parameter :: sqrt3 = sqrt ( 3.0_wp ) !!  \\sqrt(3)  me % stop = . false . ! execution commences with examination of input parameters if ( iord < 1 . or . iord > 3 . or . xmax <= xmin . or . & x0 > xmax . or . x0 < xmin . or . . not . associated ( me % f )) then ifail = 2 else acc = accr twoinf = 2.0_wp ** ( - inf ) twosup = 2.0_wp ** sup factor = 2.0_wp ** ( real (( inf + sup ), wp ) / 3 0.0_wp ) if ( factor < 25 6.0_wp ) factor = 25 6.0_wp maxh1 = xmax - x0 signh = 1 if ( x0 - xmin <= maxh1 ) then maxh2 = x0 - xmin else maxh2 = maxh1 maxh1 = x0 - xmin signh = - 1 end if relacc = 2.0_wp ** ( 1.0_wp - eta ) maxh1 = ( 1.0_wp - relacc ) * maxh1 maxh2 = ( 1.0_wp - relacc ) * maxh2 s = 12 8.0_wp * twoinf if ( abs ( x0 ) > 12 8.0_wp * twoinf * 2.0_wp ** eta ) s = abs ( x0 ) * 2.0_wp ** ( - eta ) if ( maxh1 < s ) then ! interval too small ifail = 3 return end if if ( acc < 0.0_wp ) then if ( - acc > relacc ) relacc = - acc acc = 0.0_wp end if ! determine the smallest spacing at which the calculated ! function values are unequal near x0. f0 = me % f ( x0 ) if ( me % stop ) then ifail = - 1 return end if twof0 = f0 + f0 if ( abs ( x0 ) > twoinf * 2.0_wp ** eta ) then h = abs ( x0 ) * 2.0_wp ** ( - eta ) z = 2.0_wp else h = twoinf z = 6 4.0_wp end if df1 = me % f ( x0 + signh * h ) - f0 if ( me % stop ) then ifail = - 1 return end if do if ( df1 /= 0.0_wp . or . z * h > maxh1 ) exit h = z * h df1 = me % f ( x0 + signh * h ) - f0 if ( me % stop ) then ifail = - 1 return end if if ( z /= 2.0_wp ) then if ( df1 /= 0.0_wp ) then h = h / z z = 2.0_wp df1 = 0.0_wp else if ( z * h > maxh1 ) z = 2.0_wp end if end if end do if ( df1 == 0.0_wp ) then ! constant function deriv = 0.0_wp error = 0.0_wp ifail = 0 return end if if ( h > maxh1 / 12 8.0_wp ) then ! minimum h too large ifail = 3 return end if h = 8.0_wp * h h1 = signh * h h0 = h1 h2 = - h1 minh = 2.0_wp ** ( - min ( inf , sup ) / iord ) if ( minh < h ) minh = h select case ( iord ) case ( 1 ) s = 8.0_wp case ( 2 ) s = 9.0_wp * sqrt3 case ( 3 ) s = 2 7.0_wp end select if ( minh > maxh1 / s ) then ifail = 3 return end if if ( minh > maxh2 / s . or . maxh2 < 12 8.0_wp * twoinf ) then method = 1 else method = 2 end if ! method 1 uses 1-sided formulae, and method 2 symmetric. ! now estimate accuracy of calculated function values. if ( method /= 2 . or . iord == 2 ) then if ( x0 /= 0.0_wp ) then dummy1 = 0.0_wp dummy2 = - h1 call me % faccur ( dummy1 , dummy2 , acc0 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return else acc0 = 0.0_wp end if end if if ( abs ( h1 ) > twosup / 12 8.0_wp ) then hacc1 = twosup else hacc1 = 12 8.0_wp * h1 end if if ( abs ( hacc1 ) / 4.0_wp < minh ) then hacc1 = 4.0_wp * signh * minh else if ( abs ( hacc1 ) > maxh1 ) then hacc1 = signh * maxh1 end if f1 = me % f ( x0 + hacc1 ) if ( me % stop ) then ifail = - 1 return end if call me % faccur ( hacc1 , h1 , acc1 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return if ( method == 2 ) then hacc2 = - hacc1 if ( abs ( hacc2 ) > maxh2 ) hacc2 = - signh * maxh2 f1 = me % f ( x0 + hacc2 ) if ( me % stop ) then ifail = - 1 return end if call me % faccur ( hacc2 , h2 , acc2 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return end if nmax = 8 if ( eta > 36 ) nmax = 10 n = - 1 fcount = 0 deriv = 0.0_wp error = twosup init = 3 contin = . true . do n = n + 1 if (. not . contin ) exit if ( init == 3 ) then ! calculate coefficients for differentiation ! formulae and neville extrapolation algorithm if ( iord == 1 ) then beta = 2.0_wp else if ( method == 2 ) then beta = sqrt2 else beta = sqrt3 end if beta4 = beta ** 4 z = beta if ( method == 2 ) z = z ** 2 zpower = 1.0_wp do k = 1 , nmax zpower = z * zpower denom ( k ) = zpower - 1 end do if ( method == 2 . and . iord == 1 ) then e ( 1 ) = 5.0_wp e ( 2 ) = 6.3_wp do i = 3 , nmax e ( i ) = 6.81_wp end do else if (( method /= 2 . and . iord == 1 ) . or . & ( method == 2 . and . iord == 2 )) then e ( 1 ) = 1 0.0_wp e ( 2 ) = 1 6.0_wp e ( 3 ) = 2 0.36_wp e ( 4 ) = 2 3.0_wp e ( 5 ) = 2 4.46_wp do i = 6 , nmax e ( i ) = 2 6.0_wp end do if ( method == 2 . and . iord == 2 ) then do i = 1 , nmax e ( i ) = 2.0_wp * e ( i ) end do end if else if ( method /= 2 . and . iord == 2 ) then e ( 1 ) = 1 7.78_wp e ( 2 ) = 3 0.06_wp e ( 3 ) = 3 9.66_wp e ( 4 ) = 4 6.16_wp e ( 5 ) = 5 0.26_wp do i = 6 , nmax e ( i ) = 5 5.0_wp end do else if ( method == 2 . and . iord == 3 ) then e ( 1 ) = 2 5.97_wp e ( 2 ) = 4 1.22_wp e ( 3 ) = 5 0.95_wp e ( 4 ) = 5 6.4_wp e ( 5 ) = 5 9.3_wp do i = 6 , nmax e ( i ) = 6 2.0_wp end do else e ( 1 ) = 2 4.5_wp e ( 2 ) = 4 0.4_wp e ( 3 ) = 5 2.78_wp e ( 4 ) = 6 1.2_wp e ( 5 ) = 6 6.55_wp do i = 6 , nmax e ( i ) = 7 3.0_wp end do c0f0 = - twof0 / ( 3.0_wp * beta ) c1 = 3.0_wp / ( 3.0_wp * beta - 1.0_wp ) c2 = - 1.0_wp / ( 3.0_wp * ( beta - 1.0_wp )) c3 = 1.0_wp / ( 3.0_wp * beta * ( 5.0_wp - 2.0_wp * beta )) end if end if if ( init >= 2 ) then ! initialization of steplengths, accuracy and other parameters heval = signh * minh h = heval baseh = heval maxh = maxh2 if ( method == 1 ) maxh = maxh1 do k = 1 , nmax minerr ( k ) = twosup ignore ( k ) = . false . end do if ( method == 1 ) newacc = acc1 if ( method == - 1 ) newacc = acc2 if ( method == 2 ) newacc = ( acc1 + acc2 ) / 2.0_wp if ( newacc < acc ) newacc = acc if (( method /= 2 . or . iord == 2 ) . and . newacc < acc0 ) newacc = acc0 if ( method /= - 1 ) then facc1 = acc1 nhacc1 = hacc1 newh1 = h1 end if if ( method /= 1 ) then facc2 = acc2 nhacc2 = hacc2 newh2 = h2 else facc2 = 0.0_wp nhacc2 = 0.0_wp end if init = 1 j = 0 saved = . false . end if ! calculate new or initial function values if ( init == 1 . and . ( n == 0 . or . iord == 1 ) . and . & . not .( method == 2 . and . fcount >= 45 )) then if ( method == 2 ) then fcount = fcount + 1 f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if storef ( fcount ) = f1 f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if storef ( - fcount ) = f2 else j = j + 1 if ( j <= fcount ) then f1 = storef ( j * method ) else f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if end if end if else f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if if ( method == 2 ) then f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if end if end if if ( n == 0 ) then if ( method == 2 . and . iord == 3 ) then pdelta = f1 - f2 pmaxf = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp heval = beta * heval f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if deltaf = f1 - f2 maxfun = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp heval = beta * heval f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if else if ( method /= 2 . and . iord >= 2 ) then if ( iord == 2 ) then f3 = f1 else f4 = f1 heval = beta * heval f3 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if end if heval = beta * heval f2 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if heval = beta * heval f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if end if end if ! evaluate a new approximation dnew to the derivative if ( n > nmax ) then n = nmax do i = 1 , n maxf ( i - 1 ) = maxf ( i ) end do end if if ( method == 2 ) then maxf ( n ) = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp if ( iord == 1 ) then dnew = ( f1 - f2 ) / 2.0_wp else if ( iord == 2 ) then dnew = f1 + f2 - twof0 else dnew = - pdelta pdelta = deltaf deltaf = f1 - f2 dnew = dnew + 0.5_wp * deltaf if ( maxf ( n ) < pmaxf ) maxf ( n ) = pmaxf pmaxf = maxfun maxfun = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp end if else maxf ( n ) = abs ( f1 ) if ( iord == 1 ) then dnew = f1 - f0 else if ( iord == 2 ) then dnew = ( twof0 - 3.0_wp * f3 + f1 ) / 3.0_wp if ( maxf ( n ) < abs ( f3 )) maxf ( n ) = abs ( f3 ) f3 = f2 f2 = f1 else dnew = c3 * f1 + c2 * f2 + c1 * f4 + c0f0 if ( maxf ( n ) < abs ( f2 )) maxf ( n ) = abs ( f2 ) if ( maxf ( n ) < abs ( f4 )) maxf ( n ) = abs ( f4 ) f4 = f3 f3 = f2 f2 = f1 end if end if if ( abs ( h ) > 1 ) then dnew = dnew / h ** iord else if ( 12 8.0_wp * abs ( dnew ) > twosup * abs ( h ) ** iord ) then dnew = twosup / 12 8.0_wp else dnew = dnew / h ** iord end if end if if ( init == 0 ) then ! update estimated accuracy of function values newacc = acc if (( method /= 2 . or . iord == 2 ) . and . newacc < acc0 ) newacc = acc0 if ( method /= - 1 . and . abs ( nhacc1 ) <= 1.125_wp * abs ( heval ) / beta4 ) then nhacc1 = heval pacc1 = facc1 call me % faccur ( nhacc1 , newh1 , facc1 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return if ( facc1 < pacc1 ) facc1 = ( 3.0_wp * facc1 + pacc1 ) / 4.0_wp end if if ( method /= 1 . and . abs ( nhacc2 ) <= 1.125_wp * abs ( heval ) / beta4 ) then if ( method == 2 ) then f1 = f2 nhacc2 = - heval else nhacc2 = heval end if pacc2 = facc2 call me % faccur ( nhacc2 , newh2 , facc2 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return if ( facc2 < pacc2 ) facc2 = ( 3.0_wp * facc2 + pacc2 ) / 4.0_wp end if if ( method == 1 . and . newacc < facc1 ) newacc = facc1 if ( method == - 1 . and . newacc < facc2 ) newacc = facc2 if ( method == 2 . and . newacc < ( facc1 + facc2 ) / 2.0_wp ) & newacc = ( facc1 + facc2 ) / 2.0_wp end if ! evaluate successive elements of the current row in the neville ! array, estimating and examining the truncation and rounding ! errors in each contin = n < nmax hprev = abs ( h ) fmax = maxf ( n ) if (( method /= 2 . or . iord == 2 ) . and . fmax < abs ( f0 )) fmax = abs ( f0 ) do k = 1 , n dprev = d ( k ) d ( k ) = dnew dnew = dprev + ( dprev - dnew ) / denom ( k ) te = abs ( dnew - d ( k )) if ( fmax < maxf ( n - k )) fmax = maxf ( n - k ) hprev = hprev / beta if ( newacc >= relacc * fmax ) then re = newacc * e ( k ) else re = relacc * fmax * e ( k ) end if if ( re /= 0.0_wp ) then if ( hprev > 1 ) then re = re / hprev ** iord else if ( 2.0_wp * re > twosup * hprev ** iord ) then re = twosup / 2.0_wp else re = re / hprev ** iord end if end if newerr = te + re if ( te > re ) newerr = 1.25_wp * newerr if (. not . ignore ( k )) then if (( init == 0 . or . ( k == 2 . and . . not . ignore ( 1 ))) & . and . newerr < error ) then deriv = d ( k ) error = newerr end if if ( init == 1 . and . n == 1 ) then tderiv = d ( 1 ) temerr = newerr end if if ( minerr ( k ) < twosup / 4.0_wp ) then s = 4.0_wp * minerr ( k ) else s = twosup end if if ( te > re . or . newerr > s ) then ignore ( k ) = . true . else contin = . true . end if if ( newerr < minerr ( k )) minerr ( k ) = newerr if ( init == 1 . and . n == 2 . and . k == 1 . and . . not . ignore ( 1 )) then if ( newerr < temerr ) then tderiv = d ( 1 ) temerr = newerr end if if ( temerr < error ) then deriv = tderiv error = temerr end if end if end if end do if ( n < nmax ) d ( n + 1 ) = dnew if ( eps < 0.0_wp ) then s = abs ( eps * deriv ) else s = eps end if if ( error <= s ) then contin = . false . else if ( init == 1 . and . ( n == 2 . or . ignore ( 1 ))) then if (( ignore ( 1 ) . or . ignore ( 2 )) . and . saved ) then saved = . false . n = 2 h = beta * save ( 0 ) heval = beta * save ( 1 ) maxf ( 0 ) = save ( 2 ) maxf ( 1 ) = save ( 3 ) maxf ( 2 ) = save ( 4 ) d ( 1 ) = save ( 5 ) d ( 2 ) = save ( 6 ) d ( 3 ) = save ( 7 ) minerr ( 1 ) = save ( 8 ) minerr ( 2 ) = save ( 9 ) if ( method == 2 . and . iord == 3 ) then pdelta = save ( 10 ) deltaf = save ( 11 ) pmaxf = save ( 12 ) maxfun = save ( 13 ) else if ( method /= 2 . and . iord >= 2 ) then f2 = save ( 10 ) f3 = save ( 11 ) if ( iord == 3 ) f4 = save ( 12 ) end if init = 0 ignore ( 1 ) = . false . ignore ( 2 ) = . false . else if (. not . ( ignore ( 1 ) . or . ignore ( 2 )) . and . n == 2 & . and . beta4 * factor * abs ( heval ) <= maxh ) then ! save all current values in case of return to current point saved = . true . save ( 0 ) = h save ( 1 ) = heval save ( 2 ) = maxf ( 0 ) save ( 3 ) = maxf ( 1 ) save ( 4 ) = maxf ( 2 ) save ( 5 ) = d ( 1 ) save ( 6 ) = d ( 2 ) save ( 7 ) = d ( 3 ) save ( 8 ) = minerr ( 1 ) save ( 9 ) = minerr ( 2 ) if ( method == 2 . and . iord == 3 ) then save ( 10 ) = pdelta save ( 11 ) = deltaf save ( 12 ) = pmaxf save ( 13 ) = maxfun else if ( method /= 2 . and . iord >= 2 ) then save ( 10 ) = f2 save ( 11 ) = f3 if ( iord == 3 ) save ( 12 ) = f4 end if h = factor * baseh heval = h baseh = h n = - 1 else init = 0 h = beta * h heval = beta * heval end if else if ( contin . and . beta * abs ( heval ) <= maxh ) then h = beta * h heval = beta * heval else if ( method /= 1 ) then contin = . true . if ( method == 2 ) then init = 3 method = - 1 if ( iord /= 2 ) then if ( x0 /= 0.0_wp ) then dummy1 = 0.0_wp dummy2 = - h0 call me % faccur ( dummy1 , dummy2 , acc0 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return else acc0 = 0.0_wp end if end if else init = 2 method = 1 end if n = - 1 signh = - signh else contin = . false . end if end do if ( eps < 0.0_wp ) then s = abs ( eps * deriv ) else s = eps end if ifail = 0 if ( eps /= 0.0_wp . and . error > s ) ifail = 1 end if end subroutine diff !***************************************************************************************** !***************************************************************************************** !> ! This procedure attempts to estimate the level of rounding errors in ! the calculated function values near the point `x0+h0` by fitting a ! least-squares straight-line approximation to the function at the ! six points `x0+h0-j*h1`, (`j = 0,1,3,5,7,9`), and then setting `facc` to ! twice the largest deviation of the function values from this line. ! `hi` is adjusted if necessary so that it is approximately 8 times the ! smallest spacing at which the function values are unequal near `x0+h0`. subroutine faccur ( me , h0 , h1 , facc , x0 , twoinf , f0 , f1 , ifail ) implicit none class ( diff_func ), intent ( inout ) :: me real ( wp ), intent ( inout ) :: h0 real ( wp ), intent ( inout ) :: h1 real ( wp ), intent ( out ) :: facc real ( wp ), intent ( in ) :: x0 real ( wp ), intent ( in ) :: twoinf real ( wp ), intent ( in ) :: f0 real ( wp ), intent ( in ) :: f1 integer , intent ( out ) :: ifail !! 0 if no error, -1 if user termination. real ( wp ) :: a0 , a1 , f00 , f001 , f2 , deltaf , t0 , t1 , df ( 5 ) integer :: j ifail = 0 t0 = 0.0_wp t1 = 0.0_wp if ( h0 /= 0.0_wp ) then if ( x0 + h0 /= 0.0_wp ) then f00 = f1 else h0 = 0.875_wp * h0 f00 = me % f ( x0 + h0 ) if ( me % stop ) then ifail = - 1 return end if end if if ( abs ( h1 ) >= 3 2.0_wp * twoinf ) h1 = h1 / 8.0_wp if ( 1 6.0_wp * abs ( h1 ) > abs ( h0 )) h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp f001 = me % f ( x0 + h0 - h1 ) if ( me % stop ) then ifail = - 1 return end if if ( f001 == f00 ) then if ( 25 6.0_wp * abs ( h1 ) <= abs ( h0 )) then h1 = 2.0_wp * h1 do f001 = me % f ( x0 + h0 - h1 ) if ( me % stop ) then ifail = - 1 return end if if ( f001 /= f00 . or . 25 6.0_wp * abs ( h1 ) > abs ( h0 )) exit h1 = 2.0_wp * h1 end do h1 = 8.0_wp * h1 else h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp end if else if ( 25 6.0_wp * twoinf <= abs ( h0 )) then do f001 = me % f ( x0 + h0 - h1 / 2.0_wp ) if ( me % stop ) then ifail = - 1 return end if if ( f001 == f00 . or . abs ( h1 ) < 4.0_wp * twoinf ) exit h1 = h1 / 2.0_wp end do h1 = 8.0_wp * h1 if ( 1 6.0_wp * abs ( h1 ) > abs ( h0 )) h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp else h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp end if end if else f00 = f0 end if do j = 1 , 5 f2 = me % f ( x0 + h0 - real ( 2 * j - 1 , wp ) * h1 ) if ( me % stop ) then ifail = - 1 return end if df ( j ) = f2 - f00 t0 = t0 + df ( j ) t1 = t1 + real ( 2 * j - 1 , wp ) * df ( j ) end do a0 = ( 3 3.0_wp * t0 - 5.0_wp * t1 ) / 7 3.0_wp a1 = ( - 5.0_wp * t0 + 1.2_wp * t1 ) / 7 3.0_wp facc = abs ( a0 ) do j = 1 , 5 deltaf = abs ( df ( j ) - ( a0 + real ( 2 * j - 1 , wp ) * a1 )) if ( facc < deltaf ) facc = deltaf end do facc = 2.0_wp * facc end subroutine faccur !***************************************************************************************** !***************************************************************************************** end module diff_module !*****************************************************************************************","tags":"","loc":"sourcefile/diff_module.f90.html"},{"title":"problem_24.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_24.f90~~EfferentGraph sourcefile~problem_24.f90 problem_24.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_24.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_24 use iso_fortran_env , only : wp => real64 , ip => int64 ! use long ints use aoc_utilities implicit none integer :: iunit , n_lines , i , j character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals , rvals , vvals integer ( ip ), dimension (:), allocatable :: xvec , yvec , zvec , vxvec , vyvec , vzvec integer ( ip ) :: n_intersections real ( wp ), dimension ( 2 ) :: tvec real ( wp ), dimension ( 2 ) :: xy_inter integer ( ip ) :: min_val , max_val call clk % tic () ! read the data: ! open(newunit=iunit, file='inputs/day24_test.txt', status='OLD'); min_val=7_ip; max_val = 27_ip open ( newunit = iunit , file = 'inputs/day24.txt' , status = 'OLD' ); min_val = 20000000000000 0.0_wp ; max_val = 40000000000000 0.0_wp n_lines = number_of_lines_in_file ( iunit ) allocate ( xvec ( 0 ), yvec ( 0 ), zvec ( 0 ), vxvec ( 0 ), vyvec ( 0 ), vzvec ( 0 )) do i = 1 , n_lines line = read_line ( iunit ) vals = split ( line , '@' ) rvals = split ( trim ( vals ( 1 )% str ), ',' ) xvec = [ xvec , rvals ( 1 )% to_int_64 ()] yvec = [ yvec , rvals ( 2 )% to_int_64 ()] zvec = [ zvec , rvals ( 3 )% to_int_64 ()] vvals = split ( trim ( vals ( 2 )% str ), ',' ) vxvec = [ vxvec , vvals ( 1 )% to_int_64 ()] vyvec = [ vyvec , vvals ( 2 )% to_int_64 ()] vzvec = [ vzvec , vvals ( 3 )% to_int_64 ()] end do close ( iunit ) n_intersections = 0 do i = 1 , n_lines do j = 1 , i - 1 associate ( x => xvec ( i ), y => yvec ( i ), & dx => vxvec ( i ), dy => vyvec ( i ), & u => xvec ( j ), v => yvec ( j ), & du => vxvec ( j ), dv => vyvec ( j ) ) if ( dy * du /= dv * dx ) then tvec = [( dv * ( x - u ) - du * ( y - v )) / ( dy * du - dx * dv ), & ( dy * ( u - x ) - dx * ( v - y )) / ( dv * dx - du * dy ) ] xy_inter = [ x + tvec ( 1 ) * dx , y + tvec ( 1 ) * dy ] if ( all ( tvec > 0.0_wp ) . and . & all ([ xy_inter >= min_val . and . xy_inter <= max_val ])) then n_intersections = n_intersections + 1 end if end if end associate end do end do write ( * , * ) '21a : ' , n_intersections call clk % toc ( '24' ) end program problem_24","tags":"","loc":"sourcefile/problem_24.f90.html"},{"title":"fmin_module.F90 – AoC-2023","text":"Files dependent on this one sourcefile~~fmin_module.f90~~AfferentGraph sourcefile~fmin_module.f90 fmin_module.F90 sourcefile~nlesolver_module.f90 nlesolver_module.F90 sourcefile~nlesolver_module.f90->sourcefile~fmin_module.f90 sourcefile~test.f90 test.f90 sourcefile~test.f90->sourcefile~fmin_module.f90 sourcefile~nlesolver_test_1.f90 nlesolver_test_1.f90 sourcefile~nlesolver_test_1.f90->sourcefile~nlesolver_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  Module for [[fmin]] 1D derative-free function minimizer. ! !### License !  * [BSD-3](https://github.com/jacobwilliams/fmin/blob/master/LICENSE) ! !@note The default real kind (`wp`) can be !      changed using optional preprocessor flags. !      This library was built with real kind: #ifdef REAL32 !      `real(kind=real32)` [4 bytes] #elif REAL64 !      `real(kind=real64)` [8 bytes] #elif REAL128 !      `real(kind=real128)` [16 bytes] #else !      `real(kind=real64)` [8 bytes] #endif module fmin_module use iso_fortran_env implicit none private #ifdef REAL32 integer , parameter , public :: fmin_rk = real32 !! real kind used by this module [4 bytes] #elif REAL64 integer , parameter , public :: fmin_rk = real64 !! real kind used by this module [8 bytes] #elif REAL128 integer , parameter , public :: fmin_rk = real128 !! real kind used by this module [16 bytes] #else integer , parameter , public :: fmin_rk = real64 !! real kind used by this module [8 bytes] #endif integer , parameter :: wp = fmin_rk !! local copy of `fmin_rk` with a shorter name abstract interface function func ( x ) result ( f ) !! interface for user function import :: wp implicit none real ( wp ), intent ( in ) :: x !! indep. variable real ( wp ) :: f !! function value `f(x)` end function func end interface public :: fmin contains !***************************************************************************************** !***************************************************************************************** !> !  An approximation x to the point where `f` attains a minimum on !  the interval `(ax,bx)` is determined. ! !  the method used is a combination of golden section search and !  successive parabolic interpolation. convergence is never much slower !  than that for a fibonacci search. if `f` has a continuous second !  derivative which is positive at the minimum (which is not at `ax` or !  `bx`), then convergence is superlinear, and usually of the order of !  about 1.324. ! !  the function `f` is never evaluated at two points closer together !  than `eps*abs(fmin) + (tol/3)`, where `eps` is approximately the square !  root of the relative machine precision. if `f` is a unimodal !  function and the computed values of `f` are always unimodal when !  separated by at least `eps*abs(x) + (tol/3)`, then fmin approximates !  the abcissa of the global minimum of `f` on the interval `ax,bx` with !  an error less than `3*eps*abs(fmin) + tol`. if `f` is not unimodal, !  then `fmin` may approximate a local, but perhaps non-global, minimum to !  the same accuracy. ! !### Reference !  * Richard brent, \"algorithms for minimization without derivatives\", !    prentice - hall, inc. (1973). ! !### See also !  * [fmin from Netlib](http://www.netlib.org/fmm/fmin.f) function fmin ( f , ax , bx , tol ) result ( xmin ) implicit none procedure ( func ) :: f !! the function to minimize real ( wp ), intent ( in ) :: ax !! left endpoint of initial interval real ( wp ), intent ( in ) :: bx !! right endpoint of initial interval real ( wp ), intent ( in ) :: tol !! desired length of the interval of !! uncertainty of the final result (>=0) real ( wp ) :: xmin !! abcissa approximating the point where !! f attains a minimum real ( wp ) :: a , b , d , e , xm , p , q , r , tol1 , tol2 , u , v , w real ( wp ) :: fu , fv , fw , fx , x real ( wp ) :: abs , sqrt , sign real ( wp ), parameter :: c = ( 3.0_wp - sqrt ( 5.0_wp )) / 2.0_wp !! squared inverse of golden ratio real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: sqrteps = sqrt ( epsilon ( 1.0_wp )) ! initialization a = ax b = bx v = a + c * ( b - a ) w = v x = v e = 0.0_wp fx = f ( x ) fv = fx fw = fx do !  main loop starts here xm = half * ( a + b ) tol1 = sqrteps * abs ( x ) + tol / 3.0_wp tol2 = 2.0_wp * tol1 !  check stopping criterion if ( abs ( x - xm ) <= ( tol2 - half * ( b - a ))) then ! write(*,*) 'x             = ', x ! write(*,*) 'xm            = ', xm ! write(*,*) 'abs(x - xm)   = ', abs(x - xm) ! write(*,*) 'tol2          = ', tol2 ! write(*,*) 'half*(b - a)  = ', half*(b - a) exit end if ! is golden-section necessary if ( abs ( e ) <= tol1 ) then !  a golden-section step if ( x >= xm ) then e = a - x else e = b - x end if d = c * e else !  fit parabola r = ( x - w ) * ( fx - fv ) q = ( x - v ) * ( fx - fw ) p = ( x - v ) * q - ( x - w ) * r q = 2.0_wp * ( q - r ) if ( q > 0.0_wp ) p = - p q = abs ( q ) r = e e = d !  is parabola acceptable if (( abs ( p ) >= abs ( half * q * r )) . or . ( p <= q * ( a - x )) . or . ( p >= q * ( b - x ))) then !  a golden-section step if ( x >= xm ) then e = a - x else e = b - x end if d = c * e else !  a parabolic interpolation step d = p / q u = x + d !  f must not be evaluated too close to ax or bx if ((( u - a ) < tol2 ) . or . (( b - u ) < tol2 )) d = sign ( tol1 , xm - x ) end if end if !  f must not be evaluated too close to x if ( abs ( d ) >= tol1 ) then u = x + d else u = x + sign ( tol1 , d ) end if fu = f ( u ) !  update a, b, v, w, and x if ( fu <= fx ) then if ( u >= x ) a = x if ( u < x ) b = x v = w fv = fw w = x fw = fx x = u fx = fu else if ( u < x ) a = u if ( u >= x ) b = u if ( fu <= fw . or . w == x ) then v = w fv = fw w = u fw = fu else if ( fu <= fv . or . v == x . or . v == w ) then v = u fv = fu end if end if end do !  end of main loop xmin = x end function fmin !***************************************************************************************** !***************************************************************************************** end module fmin_module !*****************************************************************************************","tags":"","loc":"sourcefile/fmin_module.f90.html"},{"title":"problem_21.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_21.f90~~EfferentGraph sourcefile~problem_21.f90 problem_21.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_21.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_21 use aoc_utilities use iso_fortran_env implicit none character ( len = 1 ), dimension (:,:), allocatable :: array integer :: nrows , ncols , i , j integer , dimension ( 2 ) :: iloc integer , dimension (:,:), allocatable :: icount call clk % tic () ! array = read_file_to_char_array('inputs/day21_test.txt', border='#') array = read_file_to_char_array ( 'inputs/day21.txt' , border = '.' ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) allocate ( icount ( nrows , ncols )); icount = 0 iloc = findloc ( array , 'S' ) ! find starting point i = iloc ( 1 ) j = iloc ( 2 ) array ( i , j ) = 'O' ! starting here do i = 1 , 64 call step ( array ) end do write ( * , * ) '21a: ' , count ( array == 'O' ) call clk % toc ( '21' ) contains recursive subroutine step ( array ) !! take all valid steps from any # elements in array character ( len = 1 ), dimension (:,:), intent ( inout ), allocatable :: array integer :: i , j logical :: steped character ( len = 1 ), dimension (:,:), allocatable :: tmp tmp = array do i = 1 , nrows do j = 1 , ncols if ( array ( i , j ) == 'O' ) then steped = . false . ! try a step in each direction: if ( array ( i - 1 , j ) == '.' ) then tmp ( i - 1 , j ) = 'O' ; steped = . true . end if if ( array ( i + 1 , j ) == '.' ) then tmp ( i + 1 , j ) = 'O' ; steped = . true . end if if ( array ( i , j - 1 ) == '.' ) then tmp ( i , j - 1 ) = 'O' ; steped = . true . end if if ( array ( i , j + 1 ) == '.' ) then tmp ( i , j + 1 ) = 'O' ; steped = . true . end if if ( steped ) tmp ( i , j ) = '.' end if end do end do call move_alloc ( tmp , array ) end subroutine step end program problem_21","tags":"","loc":"sourcefile/problem_21.f90.html"},{"title":"problem_09.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_09.f90~~EfferentGraph sourcefile~problem_09.f90 problem_09.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_09.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_9 use iso_fortran_env use aoc_utilities implicit none integer :: i , iunit , n_lines integer ( ip ) :: isum call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day9_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day9.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = sum ([( extrapolate ( parse ( read_line ( iunit ))), i = 1 , n_lines )]) close ( iunit ) write ( * , * ) '9a: sum: ' , isum open ( newunit = iunit , file = 'inputs/day9.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = sum ([( extrapolate ( reverse ( parse ( read_line ( iunit )))), i = 1 , n_lines )]) close ( iunit ) write ( * , * ) '9b: sum: ' , isum call clk % toc ( '9' ) contains pure function extrapolate ( ivals ) result ( iextrap ) !! extrapolate the next value in the sequence using !! a difference table. Straightfoward implemention: !! create the full table, and then evaluate it. integer ( ip ), dimension (:), intent ( in ) :: ivals integer ( ip ) :: iextrap integer :: i , n type ( int64_vec ), dimension (:), allocatable :: diff_table !! difference table (vector of vectors) ! create the difference table: diff_table = [ int64_vec ( ivals )]; n = 1 do n = n + 1 diff_table = [ diff_table , int64_vec ( diff ( diff_table ( n - 1 )% vals ))] ! next line is diff of previous line if ( all ( diff_table ( n )% vals == 0 )) exit end do ! extrapolate iextrap = 0 do i = n - 1 , 1 , - 1 associate ( ilast => diff_table ( i )% vals ( size ( diff_table ( i )% vals )) ) iextrap = iextrap + ilast end associate end do end function extrapolate end program problem_9","tags":"","loc":"sourcefile/problem_09.f90.html"},{"title":"utilities_module.f90 – AoC-2023","text":"This file depends on sourcefile~~utilities_module.f90~~EfferentGraph sourcefile~utilities_module.f90 utilities_module.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~utilities_module.f90->sourcefile~kinds_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~utilities_module.f90~~AfferentGraph sourcefile~utilities_module.f90 utilities_module.f90 sourcefile~cache_module.f90 cache_module.f90 sourcefile~cache_module.f90->sourcefile~utilities_module.f90 sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~utilities_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~cache_module.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~numerical_differentiation_module.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~numerical_differentiation_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> author: Jacob Williams ! !  Utility routines. module numdiff_utilities_module use numdiff_kinds_module integer , parameter :: max_size_for_insertion_sort = 20 !! max size for using insertion sort. private interface expand_vector module procedure :: expand_vector_int , expand_vector_real end interface expand_vector public :: expand_vector interface unique module procedure :: unique_int , unique_real end interface unique public :: unique interface sort_ascending module procedure :: sort_ascending_int , sort_ascending_real end interface sort_ascending public :: sort_ascending interface swap module procedure :: swap_int , swap_real end interface swap public :: equal_within_tol public :: divide_interval contains !******************************************************************************* !******************************************************************************* !> !  Add elements to the integer vector in chunks. pure subroutine expand_vector_int ( vec , n , chunk_size , val , finished ) implicit none integer , dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ) :: chunk_size !! allocate `vec` in blocks of this size (>0) integer , intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) integer , dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector_int !******************************************************************************* !******************************************************************************* !> !  Add elements to the real vector in chunks. pure subroutine expand_vector_real ( vec , n , chunk_size , val , finished ) implicit none real ( wp ), dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ) :: chunk_size !! allocate `vec` in blocks of this size (>0) real ( wp ), intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) real ( wp ), dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector_real !******************************************************************************* !******************************************************************************* !> !  Returns only the unique elements of the vector (sorted in ascending order). function unique_int ( vec , chunk_size ) result ( ivec_unique ) implicit none integer , dimension (:), intent ( in ) :: vec !! a vector of integers integer , intent ( in ) :: chunk_size !! chunk size for adding to arrays integer , dimension (:), allocatable :: ivec_unique !! unique elements of `ivec` integer , dimension ( size ( vec )) :: ivec !! temp copy of vec integer :: i !! counter integer :: n !! number of unique elements ! first we sort it: ivec = vec ! make a copy call sort_ascending ( ivec ) ! add the first element: n = 1 ivec_unique = [ ivec ( 1 )] ! walk through array and get the unique ones: if ( size ( ivec ) > 1 ) then do i = 2 , size ( ivec ) if ( ivec ( i ) /= ivec ( i - 1 )) then call expand_vector ( ivec_unique , n , chunk_size , val = ivec ( i )) end if end do call expand_vector ( ivec_unique , n , chunk_size , finished = . true .) end if end function unique_int !******************************************************************************* !******************************************************************************* !> !  Returns only the unique elements of the vector (sorted in ascending order). function unique_real ( vec , chunk_size ) result ( ivec_unique ) implicit none real ( wp ), dimension (:), intent ( in ) :: vec !! a vector of integers integer , intent ( in ) :: chunk_size !! chunk size for adding to arrays real ( wp ), dimension (:), allocatable :: ivec_unique !! unique elements of `ivec` real ( wp ), dimension ( size ( vec )) :: ivec !! temp copy of vec integer :: i !! counter integer :: n !! number of unique elements ! first we sort it: ivec = vec ! make a copy call sort_ascending ( ivec ) ! add the first element: n = 1 ivec_unique = [ ivec ( 1 )] ! walk through array and get the unique ones: if ( size ( ivec ) > 1 ) then do i = 2 , size ( ivec ) if ( ivec ( i ) /= ivec ( i - 1 )) then call expand_vector ( ivec_unique , n , chunk_size , val = ivec ( i )) end if end do call expand_vector ( ivec_unique , n , chunk_size , finished = . true .) end if end function unique_real !******************************************************************************* !******************************************************************************* !> !  Sorts an integer array `ivec` in increasing order. !  Uses a basic recursive quicksort !  (with insertion sort for partitions with \\le 20 elements). subroutine sort_ascending_int ( ivec ) implicit none integer , dimension (:), intent ( inout ) :: ivec call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending_int !******************************************************************************* !******************************************************************************* !> !  Sorts a real array `ivec` in increasing order. !  Uses a basic recursive quicksort !  (with insertion sort for partitions with \\le 20 elements). subroutine sort_ascending_real ( ivec ) implicit none real ( wp ), dimension (:), intent ( inout ) :: ivec call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending_real !******************************************************************************* !******************************************************************************* !> !  Swap two integer values. pure elemental subroutine swap_int ( i1 , i2 ) implicit none integer , intent ( inout ) :: i1 integer , intent ( inout ) :: i2 integer :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_int !******************************************************************************* !******************************************************************************* !> !  Swap two integer values. pure elemental subroutine swap_real ( i1 , i2 ) implicit none real ( wp ), intent ( inout ) :: i1 real ( wp ), intent ( inout ) :: i2 real ( wp ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_real !******************************************************************************* !******************************************************************************* !> !  Returns true if the values in the array are the same !  (to within the specified absolute tolerance). pure function equal_within_tol ( vals , tol ) result ( equal ) implicit none real ( wp ), dimension (:), intent ( in ) :: vals !! a set of values real ( wp ), intent ( in ) :: tol !! a positive tolerance value logical :: equal !! true if they are equal !! within the tolerance equal = all ( abs ( vals - vals ( 1 )) <= abs ( tol ) ) end function equal_within_tol !******************************************************************************* !******************************************************************************* !> !  Returns a set of slightly randomized equally-spaced !  points that divide an interval. ! !### Example: ! !  for `num_points` = 3: !``` !     o---|---|---|---o !         1   2   3 !``` !  returns: `[0.25308641972530865, 0.5061728394506173, 0.759259259175926]`. function divide_interval ( num_points ) result ( points ) implicit none integer , intent ( in ) :: num_points !! the number of points in the interval real ( wp ), dimension (:), allocatable :: points !! the resultant vector real ( wp ), parameter :: noise = 1.012345678901234567_wp !! a noise value. Not a round number !! so as to avoid freak zeros in the !! jacobian real ( wp ), parameter :: min_val = 1 0.0_wp * epsilon ( 1.0_wp ) !! the minimize distance from the lower bound real ( wp ), parameter :: max_val = 1.0_wp - min_val !! the minimize distance from the upper bound integer :: i !! counter real ( wp ) :: delta !! step size real ( wp ), dimension (:), allocatable :: tmp !! a temp array to hold the values delta = 1.0_wp / ( num_points + 1 ) allocate ( tmp ( num_points )) do i = 1 , num_points tmp ( i ) = min ( max ( min_val , delta * i * noise ), max_val ) end do ! this is to protect for the min/max case if there ! are enough points so that some are duplicated near ! the bounds: points = unique ( tmp , chunk_size = 10 ) end function divide_interval !******************************************************************************* !******************************************************************************* end module numdiff_utilities_module !*******************************************************************************","tags":"","loc":"sourcefile/utilities_module.f90.html"},{"title":"dag_example.f90 – AoC-2023","text":"This file depends on sourcefile~~dag_example.f90~~EfferentGraph sourcefile~dag_example.f90 dag_example.f90 sourcefile~dag_module.f90 dag_module.f90 sourcefile~dag_example.f90->sourcefile~dag_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> !  DAG module test program. program dag_example use dag_module implicit none type ( dag ) :: d integer , dimension (:), allocatable :: order integer :: istat integer :: i , r , c logical , dimension (:,:), allocatable :: mat !! dependency matrix integer , parameter :: n_nodes = 6 character ( len =* ), parameter :: filetype = 'pdf' !! filetype for output plot ('pdf', png', etc.) ! TODO combine set_edges and set_vertex_info into one routine maybe. call d % set_vertices ( n_nodes ) call d % set_edges ( 2 ,[ 1 ]) !2 depends on 1 call d % set_edges ( 3 ,[ 5 , 1 ]) !3 depends on 5 and 1 call d % set_edges ( 4 ,[ 5 ]) !4 depends on 5 call d % set_edges ( 5 ,[ 2 ]) !5 depends on 2 call d % set_edges ( 6 ,[ 2 , 4 ]) !6 depends on 2 and 4 call d % toposort ( order , istat ) write ( * , * ) '' write ( * , * ) 'istat=' , istat write ( * , * ) 'order=' , order ! prints 1,2,5,3,4 do i = 1 , n_nodes if ( i == 3 . or . i == 6 ) then call d % set_vertex_info ( i , attributes = 'shape=square,fillcolor=\"SlateGray1\",style=filled' ) else call d % set_vertex_info ( i , attributes = 'shape=circle,fillcolor=\"cornsilk\",style=filled' ) end if end do write ( * , * ) '' write ( * , * ) 'diagraph:' write ( * , * ) '' call d % save_digraph ( 'test.dot' , 'RL' , 300 ) call execute_command_line ( 'cat test.dot' ) call execute_command_line ( 'dot -T' // filetype // ' -o test.' // filetype // ' test.dot' ) write ( * , * ) '' write ( * , * ) 'dependency matrix:' write ( * , * ) '' call d % generate_dependency_matrix ( mat ) do r = 1 , n_nodes do c = 1 , n_nodes if ( mat ( r , c )) then write ( * , '(A)' , advance = 'NO' ) 'X' else write ( * , '(A)' , advance = 'NO' ) 'O' end if end do write ( * , '(A)' ) '' end do ! cleanup: call d % destroy () end program dag_example !*******************************************************************************","tags":"","loc":"sourcefile/dag_example.f90.html"},{"title":"problem_04.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_04.f90~~EfferentGraph sourcefile~problem_04.f90 problem_04.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_04.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_4 use iso_fortran_env use aoc_utilities implicit none integer :: iunit , n_lines , i , points , j , iwin type ( string ), dimension (:), allocatable :: vals , vals2 integer , dimension (:), allocatable :: iwinning , ihave , n_matches character ( len = :), allocatable :: line integer , dimension (:,:), allocatable :: card_matrix call clk % tic () ! open(newunit=iunit, file='inputs/day4_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day4.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( n_matches ( n_lines )) ! for part 2 allocate ( card_matrix ( 0 : n_lines , n_lines )) ! for part 2 ! Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53 points = 0 do i = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ': ' ) vals2 = split ( vals ( 2 ), ' | ' ) iwinning = parse_ints ( vals2 ( 1 )% str ) ! winning list ihave = parse_ints ( vals2 ( 2 )% str ) ! ones you have ! count the number of ones you have in the winning set: iwin = 0 do j = 1 , size ( ihave ) iwin = iwin + count ( ihave ( j ) == iwinning ) end do n_matches ( i ) = iwin points = points + 2 ** ( iwin - 1 ) end do close ( iunit ) write ( * , * ) '4a : points : ' , points card_matrix = 0 card_matrix ( 0 ,:) = 1 ! start with one card each do i = 1 , n_lines associate ( n => n_matches ( i )) if ( n > 0 ) card_matrix ( i , i + 1 : i + n ) = sum ( card_matrix (:, i )) end associate end do write ( * , * ) '4b : scratchcards :' , sum ( card_matrix ) call clk % toc ( '4' ) end program problem_4","tags":"","loc":"sourcefile/problem_04.f90.html"},{"title":"dsm_module.f90 – AoC-2023","text":"This file depends on sourcefile~~dsm_module.f90~~EfferentGraph sourcefile~dsm_module.f90 dsm_module.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~dsm_module.f90->sourcefile~kinds_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~dsm_module.f90~~AfferentGraph sourcefile~dsm_module.f90 dsm_module.f90 sourcefile~dsm_test.f90 dsm_test.f90 sourcefile~dsm_test.f90->sourcefile~dsm_module.f90 sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~dsm_module.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~numerical_differentiation_module.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~numerical_differentiation_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> !  Jacobian partitioning using the DSM algorithm. ! !### Reference !  * Argonne National Laboratory. MINPACK Project. July 1983. !    Thomas F. Coleman, Burton S. Garbow, Jorge J. More !  * Thomas F. Coleman, Burton S. Garbow, Jorge J. More, \"Algorithm 618: !    FORTRAN subroutines for estimating sparse Jacobian Matrices\", !    ACM Transactions on Mathematical Software (TOMS), !    Volume 10 Issue 3, Sept. 1984, Pages 346-347 ! !### History !  * Jacob Williams, Nov. 2016, extensive refactoring into modern Fortran. module dsm_module use numdiff_kinds_module implicit none private public :: dsm public :: fdjs contains !******************************************************************************* !******************************************************************************* !> !  The purpose of `dsm` is to determine an optimal or near- !  optimal consistent partition of the columns of a sparse !  `m` by `n` matrix `a`. ! !  the sparsity pattern of the matrix `a` is specified by !  the arrays `indrow` and `indcol`. on input the indices !  for the non-zero elements of `a` are ! !  `indrow(k),indcol(k), k = 1,2,...,npairs`. ! !  the (`indrow`,`indcol`) pairs may be specified in any order. !  duplicate input pairs are permitted, but the subroutine !  eliminates them. ! !  the subroutine partitions the columns of `a` into groups !  such that columns in the same group do not have a !  non-zero in the same row position. a partition of the !  columns of `a` with this property is consistent with the !  direct determination of `a`. subroutine dsm ( m , n , Npairs , Indrow , Indcol , Ngrp , Maxgrp , Mingrp , Info , Ipntr , Jpntr ) implicit none integer , intent ( in ) :: m !! number of rows of `a` (>0) integer , intent ( in ) :: n !! number of columns of `a` (>0) integer , intent ( in ) :: npairs !! number of (`indrow`,`indcol`) pairs used !! to describe the sparsity pattern of `a` (>0) integer , intent ( out ) :: maxgrp !! the number of groups in the partition !! of the columns of `a`. integer , intent ( out ) :: mingrp !! a lower bound for the number of groups !! in any consistent partition of the !! columns of `a`. integer , intent ( out ) :: info !! for normal termination `info = 1`. !! if `m`, `n`, or `npairs` is not positive, !! then `info = 0`. if the k-th element of !! `indrow` is not an integer between !! 1 and m or the k-th element of `indcol` !! is not an integer between 1 and n, !! then `info = -k`. integer , dimension ( npairs ), intent ( inout ) :: indrow !! an integer array of length `npairs`. on input `indrow` !! must contain the row indices of the non-zero elements of `a`. !! on output `indrow` is permuted so that the corresponding !! column indices are in non-decreasing order. the column !! indices can be recovered from the array `jpntr`. integer , dimension ( npairs ), intent ( inout ) :: indcol !! an integer array of length `npairs`. on input `indcol` !! must contain the column indices of the non-zero elements of !! `a`. on output `indcol` is permuted so that the corresponding !! row indices are in non-decreasing order. the row indices !! can be recovered from the array `ipntr`. integer , dimension ( n ), intent ( out ) :: ngrp !! specifies the partition of the columns of `a`. !! column `jcol` belongs to group `ngrp(jcol)`. integer , dimension ( m + 1 ), intent ( out ) :: ipntr !! an integer output array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! note that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n + 1 ), intent ( out ) :: jpntr !! jpntr is an integer output array of length n + 1 which !! specifies the locations of the row indices in indrow. !! the row indices for column j are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! note that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( max ( m , 6 * n )) :: iwa !! an integer work array integer :: i , ir , j , jp , k , maxclq , nnz , numgrp !  check the input data. Info = 0 if ( m < 1 . or . n < 1 . or . Npairs < 1 ) return do k = 1 , Npairs Info = - k if ( Indrow ( k ) < 1 . or . Indrow ( k ) > m . or . Indcol ( k ) < 1 . or . Indcol ( k ) > n ) return enddo Info = 1 !  sort the data structure by columns. call srtdat ( n , Npairs , Indrow , Indcol , Jpntr , Iwa ) !  compress the data and determine the number of !  non-zero elements of a. do i = 1 , m Iwa ( i ) = 0 enddo nnz = 1 do j = 1 , n k = nnz do jp = Jpntr ( j ) , Jpntr ( j + 1 ) - 1 ir = Indrow ( jp ) if ( Iwa ( ir ) /= j ) then Indrow ( nnz ) = ir nnz = nnz + 1 Iwa ( ir ) = j endif enddo Jpntr ( j ) = k enddo Jpntr ( n + 1 ) = nnz !  extend the data structure to rows. call setr ( m , n , Indrow , Jpntr , Indcol , Ipntr , Iwa ) !  determine a lower bound for the number of groups. Mingrp = 0 do i = 1 , m Mingrp = max ( Mingrp , Ipntr ( i + 1 ) - Ipntr ( i )) enddo !  determine the degree sequence for the intersection !  graph of the columns of a. call degr ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 5 * n + 1 ), Iwa ( n + 1 )) !  color the intersection graph of the columns of a !  with the smallest-last (sl) ordering. call slo ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 5 * n + 1 ), Iwa ( 4 * n + 1 ), maxclq ,& Iwa ( 1 ), Iwa ( n + 1 ), Iwa ( 2 * n + 1 ), Iwa ( 3 * n + 1 )) call seq ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 4 * n + 1 ), Ngrp , Maxgrp , & Iwa ( n + 1 )) Mingrp = max ( Mingrp , maxclq ) !  exit if the smallest-last ordering is optimal. if ( Maxgrp == Mingrp ) return !  color the intersection graph of the columns of a !  with the incidence-degree (id) ordering. call ido ( m , n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 5 * n + 1 ), Iwa ( 4 * n + 1 ), & maxclq , Iwa ( 1 ), Iwa ( n + 1 ), Iwa ( 2 * n + 1 ), Iwa ( 3 * n + 1 )) call seq ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 4 * n + 1 ), Iwa ( 1 ), numgrp , & Iwa ( n + 1 )) Mingrp = max ( Mingrp , maxclq ) !  retain the better of the two orderings so far. if ( numgrp < Maxgrp ) then Maxgrp = numgrp do j = 1 , n Ngrp ( j ) = Iwa ( j ) enddo !  exit if the incidence-degree ordering is optimal. if ( Maxgrp == Mingrp ) return endif !  color the intersection graph of the columns of a !  with the largest-first (lf) ordering. call numsrt ( n , n - 1 , Iwa ( 5 * n + 1 ), - 1 , Iwa ( 4 * n + 1 ), Iwa ( 2 * n + 1 ), Iwa ( n + 1 )) call seq ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 4 * n + 1 ), Iwa ( 1 ), numgrp , & Iwa ( n + 1 )) !  retain the best of the three orderings and exit. if ( numgrp < Maxgrp ) then Maxgrp = numgrp do j = 1 , n Ngrp ( j ) = Iwa ( j ) enddo endif end subroutine dsm !******************************************************************************* !******************************************************************************* !> !  Given the sparsity pattern of an `m` by `n` matrix `a`, !  this subroutine determines the degree sequence for !  the intersection graph of the columns of `a`. ! !  In graph-theory terminology, the intersection graph of !  the columns of `a` is the loopless graph `g` with vertices !  `a(j), j = 1,2,...,n` where `a(j)` is the `j`-th column of `a` !  and with edge `(a(i),a(j))` if and only if columns `i` and `j` !  have a non-zero in the same row position. ! !@note The value of `m` is not needed by `degr` and is !      therefore not present in the subroutine statement. subroutine degr ( n , Indrow , Jpntr , Indcol , Ipntr , Ndeg , Iwa ) implicit none integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of `a`. integer , dimension ( * ), intent ( in ) :: indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ), intent ( in ) :: jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ), intent ( in ) :: indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( * ), intent ( in ) :: ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ), intent ( out ) :: ndeg !! an integer output array of length `n` which !! specifies the degree sequence. the degree of the !! `j`-th column of `a` is `ndeg(j)`. integer , dimension ( n ) :: iwa !! an integer work array of length `n` integer :: ic , ip , ir , jcol , jp ! initialization block. do jp = 1 , n Ndeg ( jp ) = 0 Iwa ( jp ) = 0 enddo ! compute the degree sequence by determining the contributions ! to the degrees from the current(jcol) column and further ! columns which have not yet been considered. do jcol = 2 , n Iwa ( jcol ) = n ! determine all positions (ir,jcol) which correspond ! to non-zeroes in the matrix. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! for each row ir, determine all positions (ir,ic) ! which correspond to non-zeroes in the matrix. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! array iwa marks columns which have contributed to ! the degree count of column jcol. update the degree ! counts of these columns as well as column jcol. if ( Iwa ( ic ) < jcol ) then Iwa ( ic ) = jcol Ndeg ( ic ) = Ndeg ( ic ) + 1 Ndeg ( jcol ) = Ndeg ( jcol ) + 1 endif enddo enddo enddo end subroutine degr !******************************************************************************* !******************************************************************************* !> !  given the sparsity pattern of an `m` by `n` matrix `a`, this !  subroutine determines an incidence-degree ordering of the !  columns of `a`. ! !  the incidence-degree ordering is defined for the loopless !  graph `g` with vertices `a(j), j = 1,2,...,n` where `a(j)` is the !  `j`-th column of `a` and with edge `(a(i),a(j))` if and only if !  columns `i` and `j` have a non-zero in the same row position. ! !  the incidence-degree ordering is determined recursively by !  letting `list(k), k = 1,...,n` be a column with maximal !  incidence to the subgraph spanned by the ordered columns. !  among all the columns of maximal incidence, `ido` chooses a !  column of maximal degree. subroutine ido ( m , n , Indrow , Jpntr , Indcol , Ipntr , Ndeg , List , Maxclq , & Iwa1 , Iwa2 , Iwa3 , Iwa4 ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of `a`. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of `a`. integer , intent ( out ) :: Maxclq !! an integer output variable set to the size !! of the largest clique found during the ordering. integer , dimension ( * ), intent ( in ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ), intent ( in ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ), intent ( in ) :: Indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( m + 1 ), intent ( in ) :: Ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ), intent ( in ) :: Ndeg !! an integer input array of length `n` which specifies !! the degree sequence. the degree of the `j`-th column !! of `a` is `ndeg(j)`. integer , dimension ( n ), intent ( out ) :: List !! an integer output array of length `n` which specifies !! the incidence-degree ordering of the columns of `a`. the `j`-th !! column in this order is `list(j)`. integer , dimension ( 0 : n - 1 ) :: Iwa1 !! integer work array of length `n`. integer , dimension ( n ) :: Iwa2 !! integer work array of length `n`. integer , dimension ( n ) :: Iwa3 !! integer work array of length `n`. integer , dimension ( n ) :: Iwa4 !! integer work array of length `n`. integer :: ic , ip , ir , jcol , jp , maxinc , maxlst , ncomp , & numinc , numlst , numord , numwgt ! sort the degree sequence. call numsrt ( n , n - 1 , Ndeg , - 1 , Iwa4 , Iwa2 , Iwa3 ) ! initialization block. ! ! create a doubly-linked list to access the incidences of the ! columns. the pointers for the linked list are as follows. ! ! each un-ordered column ic is in a list (the incidence list) ! of columns with the same incidence. ! ! iwa1(numinc) is the first column in the numinc list ! unless iwa1(numinc) = 0. in this case there are ! no columns in the numinc list. ! ! iwa2(ic) is the column before ic in the incidence list ! unless iwa2(ic) = 0. in this case ic is the first ! column in this incidence list. ! ! iwa3(ic) is the column after ic in the incidence list ! unless iwa3(ic) = 0. in this case ic is the last ! column in this incidence list. ! ! if ic is an un-ordered column, then list(ic) is the ! incidence of ic to the graph induced by the ordered ! columns. if jcol is an ordered column, then list(jcol) ! is the incidence-degree order of column jcol. maxinc = 0 do jp = n , 1 , - 1 ic = Iwa4 ( jp ) Iwa1 ( n - jp ) = 0 Iwa2 ( ic ) = 0 Iwa3 ( ic ) = Iwa1 ( 0 ) if ( Iwa1 ( 0 ) > 0 ) Iwa2 ( Iwa1 ( 0 )) = ic Iwa1 ( 0 ) = ic Iwa4 ( jp ) = 0 List ( jp ) = 0 enddo ! DETERMINE THE MAXIMAL SEARCH LENGTH FOR THE LIST ! OF COLUMNS OF MAXIMAL INCIDENCE. maxlst = 0 do ir = 1 , m maxlst = maxlst + ( Ipntr ( ir + 1 ) - Ipntr ( ir )) ** 2 enddo maxlst = maxlst / n Maxclq = 0 numord = 1 ! BEGINNING OF ITERATION LOOP. ! UPDATE THE SIZE OF THE LARGEST CLIQUE ! FOUND DURING THE ORDERING. 100 if ( maxinc == 0 ) ncomp = 0 ncomp = ncomp + 1 if ( maxinc + 1 == ncomp ) Maxclq = max ( Maxclq , ncomp ) ! CHOOSE A COLUMN JCOL OF MAXIMAL DEGREE AMONG THE ! COLUMNS OF MAXIMAL INCIDENCE MAXINC. 200 jp = Iwa1 ( maxinc ) if ( jp > 0 ) then numwgt = - 1 do numlst = 1 , maxlst if ( Ndeg ( jp ) > numwgt ) then numwgt = Ndeg ( jp ) jcol = jp endif jp = Iwa3 ( jp ) if ( jp <= 0 ) exit enddo List ( jcol ) = numord numord = numord + 1 ! TERMINATION TEST. if ( numord > n ) then ! INVERT THE ARRAY LIST. do jcol = 1 , n Iwa2 ( List ( jcol )) = jcol enddo do jp = 1 , n List ( jp ) = Iwa2 ( jp ) enddo else ! DELETE COLUMN JCOL FROM THE MAXINC LIST. if ( Iwa2 ( jcol ) == 0 ) then Iwa1 ( maxinc ) = Iwa3 ( jcol ) else Iwa3 ( Iwa2 ( jcol )) = Iwa3 ( jcol ) endif if ( Iwa3 ( jcol ) > 0 ) Iwa2 ( Iwa3 ( jcol )) = Iwa2 ( jcol ) ! FIND ALL COLUMNS ADJACENT TO COLUMN JCOL. Iwa4 ( jcol ) = n ! DETERMINE ALL POSITIONS (IR,JCOL) WHICH CORRESPOND ! TO NON-ZEROES IN THE MATRIX. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! FOR EACH ROW IR, DETERMINE ALL POSITIONS (IR,IC) ! WHICH CORRESPOND TO NON-ZEROES IN THE MATRIX. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! ARRAY IWA4 MARKS COLUMNS WHICH ARE ADJACENT TO ! COLUMN JCOL. if ( Iwa4 ( ic ) < numord ) then Iwa4 ( ic ) = numord ! UPDATE THE POINTERS TO THE CURRENT INCIDENCE LISTS. numinc = List ( ic ) List ( ic ) = List ( ic ) + 1 maxinc = max ( maxinc , List ( ic )) ! DELETE COLUMN IC FROM THE NUMINC LIST. if ( Iwa2 ( ic ) == 0 ) then Iwa1 ( numinc ) = Iwa3 ( ic ) else Iwa3 ( Iwa2 ( ic )) = Iwa3 ( ic ) endif if ( Iwa3 ( ic ) > 0 ) Iwa2 ( Iwa3 ( ic )) = Iwa2 ( ic ) ! ADD COLUMN IC TO THE NUMINC+1 LIST. Iwa2 ( ic ) = 0 Iwa3 ( ic ) = Iwa1 ( numinc + 1 ) if ( Iwa1 ( numinc + 1 ) > 0 ) Iwa2 ( Iwa1 ( numinc + 1 )) = ic Iwa1 ( numinc + 1 ) = ic endif enddo enddo ! END OF ITERATION LOOP. goto 100 endif else maxinc = maxinc - 1 goto 200 endif end subroutine ido !******************************************************************************* !******************************************************************************* !> !  Given a sequence of integers, this subroutine groups !  together those indices with the same sequence value !  and, optionally, sorts the sequence into either !  ascending or descending order. ! !  The sequence of integers is defined by the array `num`, !  and it is assumed that the integers are each from the set !  `0,1,...,nmax`. on output the indices `k` such that `num(k) = l` !  for any `l = 0,1,...,nmax` can be obtained from the arrays !  last and next as follows. !```fortran !  k = last(l) !  while (k /= 0) k = next(k) !``` !  Optionally, the subroutine produces an array index so that !  the sequence `num(index(i)), i = 1,2,...,n` is sorted. subroutine numsrt ( n , Nmax , Num , Mode , Index , Last , Next ) implicit none integer , intent ( in ) :: n !! a positive integer input variable. integer :: Nmax !! a positive integer input variable. integer :: Mode !! an integer input variable. the sequence `num` is !! sorted in ascending order if `mode` is positive and in !! descending order if `mode` is negative. if `mode` is 0, !! no sorting is done. integer , dimension ( n ) :: Num !! an input array of length `n` which contains the !! sequence of integers to be grouped and sorted. it !! is assumed that the integers are each from the set !! `0,1,...,nmax`. integer , dimension ( n ) :: Index !! an integer output array of length `n` set so !! that the sequence !! `num(index(i)), i = 1,2,...,n` !! is sorted according to the setting of mode. !! if `mode` is 0, `index` is not referenced. integer , dimension ( 0 : Nmax ) :: Last !! an integer output array of length `nmax + 1`. the !! index of `num` for the last occurrence of `l` is `last(l)` !! for any `l = 0,1,...,nmax` unless `last(l) = 0`. in !! this case `l` does not appear in `num`. integer , dimension ( n ) :: Next !! an integer output array of length `n`. if !! `num(k) = l`, then the index of `num` for the previous !! occurrence of `l` is `next(k)` for any `l = 0,1,...,nmax` !! unless `next(k) = 0`. in this case there is no previous !! occurrence of `l` in `num`. integer :: i , j , jinc , jl , ju , k , l ! determine the arrays next and last. do i = 0 , Nmax Last ( i ) = 0 enddo do k = 1 , n l = Num ( k ) Next ( k ) = Last ( l ) Last ( l ) = k enddo if ( Mode /= 0 ) then ! store the pointers to the sorted array in index. i = 1 if ( Mode > 0 ) then jl = 0 ju = Nmax jinc = 1 else jl = Nmax ju = 0 jinc = - 1 endif do j = jl , ju , jinc k = Last ( j ) do if ( k == 0 ) exit Index ( i ) = k i = i + 1 k = Next ( k ) enddo enddo end if end subroutine numsrt !******************************************************************************* !******************************************************************************* !> !  given the sparsity pattern of an `m` by `n` matrix `a`, this !  subroutine determines a consistent partition of the !  columns of `a` by a sequential algorithm. ! !  a consistent partition is defined in terms of the loopless !  graph `g` with vertices `a(j), j = 1,2,...,n` where `a(j)` is the !  `j`-th column of `a` and with edge `(a(i),a(j))` if and only if !  columns `i` and `j` have a non-zero in the same row position. ! !  a partition of the columns of a into groups is consistent !  if the columns in any group are not adjacent in the graph `g`. !  in graph-theory terminology, a consistent partition of the !  columns of a corresponds to a coloring of the graph `g`. ! !  the subroutine examines the columns in the order specified !  by the array list, and assigns the current column to the !  group with the smallest possible number. ! !  note that the value of `m` is not needed by `seq` and is !  therefore not present in the subroutine statement. subroutine seq ( n , Indrow , Jpntr , Indcol , Ipntr , List , Ngrp , Maxgrp , Iwa ) implicit none integer :: n !! a positive integer input variable set to the number !! of columns of `a`. integer :: Maxgrp !! an integer output variable which specifies the !! number of groups in the partition of the columns of `a`. integer , dimension ( * ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ) :: Indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( * ) :: Ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ) :: List !! an integer input array of length `n` which specifies !! the order to be used by the sequential algorithm. !! the `j`-th column in this order is `list(j)`. integer , dimension ( n ) :: Ngrp !! an integer output array of length `n` which specifies !! the partition of the columns of `a`. column `jcol` belongs !! to group `ngrp(jcol)`. integer , dimension ( n ) :: Iwa !! an integer work array of length `n` integer :: ic , ip , ir , j , jcol , jp ! initialization block. Maxgrp = 0 do jp = 1 , n Ngrp ( jp ) = n Iwa ( jp ) = 0 enddo ! beginning of iteration loop. do j = 1 , n jcol = List ( j ) ! find all columns adjacent to column jcol. ! ! determine all positions (ir,jcol) which correspond ! to non-zeroes in the matrix. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! for each row ir, determine all positions (ir,ic) ! which correspond to non-zeroes in the matrix. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! array iwa marks the group numbers of the ! columns which are adjacent to column jcol. Iwa ( Ngrp ( ic )) = j enddo enddo ! assign the smallest un-marked group number to jcol. do jp = 1 , Maxgrp if ( Iwa ( jp ) /= j ) then Maxgrp = Maxgrp - 1 exit end if enddo Maxgrp = Maxgrp + 1 Ngrp ( jcol ) = jp enddo ! end of iteration loop. end subroutine seq !******************************************************************************* !******************************************************************************* !> !  given a column-oriented definition of the sparsity pattern !  of an `m` by `n` matrix `a`, this subroutine determines a !  row-oriented definition of the sparsity pattern of `a`. ! !  on input the column-oriented definition is specified by !  the arrays `indrow` and `jpntr`. on output the row-oriented !  definition is specified by the arrays `indcol` and `ipntr`. subroutine setr ( m , n , Indrow , Jpntr , Indcol , Ipntr , Iwa ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of `a`. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of `a`. integer , dimension ( * ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ) :: Indcol !! an integer output array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( m + 1 ) :: Ipntr !! an integer output array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(1)` is set to 1 and that `ipntr(m+1)-1` is !! then the number of non-zero elements of the matrix `a`. integer , dimension ( m ) :: Iwa !! an integer work array of length `m`. integer :: ir , jcol , jp ! store in array iwa the counts of non-zeroes in the rows. do ir = 1 , m Iwa ( ir ) = 0 enddo do jp = 1 , Jpntr ( n + 1 ) - 1 Iwa ( Indrow ( jp )) = Iwa ( Indrow ( jp )) + 1 enddo ! set pointers to the start of the rows in indcol. Ipntr ( 1 ) = 1 do ir = 1 , m Ipntr ( ir + 1 ) = Ipntr ( ir ) + Iwa ( ir ) Iwa ( ir ) = Ipntr ( ir ) enddo ! fill indcol. do jcol = 1 , n do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) Indcol ( Iwa ( ir )) = jcol Iwa ( ir ) = Iwa ( ir ) + 1 enddo enddo end subroutine setr !******************************************************************************* !******************************************************************************* !> !  given the sparsity pattern of an `m` by `n` matrix `a`, this !  subroutine determines the smallest-last ordering of the !  columns of `a`. ! !  the smallest-last ordering is defined for the loopless !  graph `g` with vertices `a(j), j = 1,2,...,n` where `a(j)` is the !  `j`-th column of `a` and with edge `(a(i),a(j))` if and only if !  columns `i` and `j` have a non-zero in the same row position. ! !  the smallest-last ordering is determined recursively by !  letting `list(k), k = n,...,1` be a column with least degree !  in the subgraph spanned by the un-ordered columns. ! !  note that the value of `m` is not needed by `slo` and is !  therefore not present in the subroutine statement. subroutine slo ( n , Indrow , Jpntr , Indcol , Ipntr , Ndeg , List , Maxclq , Iwa1 , & Iwa2 , Iwa3 , Iwa4 ) implicit none integer :: n !! a positive integer input variable set to the number !! of columns of `a`. integer :: Maxclq !! an integer output variable set to the size !! of the largest clique found during the ordering. integer , dimension ( * ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ) :: Indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( * ) :: Ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ) :: Ndeg !! an integer input array of length `n` which specifies !! the degree sequence. the degree of the `j`-th column !! of `a` is `ndeg(j)`. integer , dimension ( n ) :: List !! an integer output array of length `n` which specifies !! the smallest-last ordering of the columns of `a`. the `j`-th !! column in this order is `list(j)`. integer , dimension ( 0 : n - 1 ) :: Iwa1 !! integer work array of length `n` integer , dimension ( n ) :: Iwa2 !! integer work array of length `n` integer , dimension ( n ) :: Iwa3 !! integer work array of length `n` integer , dimension ( n ) :: Iwa4 !! integer work array of length `n` integer :: ic , ip , ir , jcol , jp , mindeg , numdeg , numord ! INITIALIZATION BLOCK. mindeg = n do jp = 1 , n Iwa1 ( jp - 1 ) = 0 Iwa4 ( jp ) = n List ( jp ) = Ndeg ( jp ) mindeg = min ( mindeg , Ndeg ( jp )) enddo ! CREATE A DOUBLY-LINKED LIST TO ACCESS THE DEGREES OF THE ! COLUMNS. THE POINTERS FOR THE LINKED LIST ARE AS FOLLOWS. ! ! EACH UN-ORDERED COLUMN IC IS IN A LIST (THE DEGREE LIST) ! OF COLUMNS WITH THE SAME DEGREE. ! ! IWA1(NUMDEG) IS THE FIRST COLUMN IN THE NUMDEG LIST ! UNLESS IWA1(NUMDEG) = 0. IN THIS CASE THERE ARE ! NO COLUMNS IN THE NUMDEG LIST. ! ! IWA2(IC) IS THE COLUMN BEFORE IC IN THE DEGREE LIST ! UNLESS IWA2(IC) = 0. IN THIS CASE IC IS THE FIRST ! COLUMN IN THIS DEGREE LIST. ! ! IWA3(IC) IS THE COLUMN AFTER IC IN THE DEGREE LIST ! UNLESS IWA3(IC) = 0. IN THIS CASE IC IS THE LAST ! COLUMN IN THIS DEGREE LIST. ! ! IF IC IS AN UN-ORDERED COLUMN, THEN LIST(IC) IS THE ! DEGREE OF IC IN THE GRAPH INDUCED BY THE UN-ORDERED ! COLUMNS. IF JCOL IS AN ORDERED COLUMN, THEN LIST(JCOL) ! IS THE SMALLEST-LAST ORDER OF COLUMN JCOL. do jp = 1 , n numdeg = Ndeg ( jp ) Iwa2 ( jp ) = 0 Iwa3 ( jp ) = Iwa1 ( numdeg ) if ( Iwa1 ( numdeg ) > 0 ) Iwa2 ( Iwa1 ( numdeg )) = jp Iwa1 ( numdeg ) = jp enddo Maxclq = 0 numord = n !  BEGINNING OF ITERATION LOOP. ! ! ! MARK THE SIZE OF THE LARGEST CLIQUE ! FOUND DURING THE ORDERING. 100 if ( mindeg + 1 == numord . and . Maxclq == 0 ) Maxclq = numord ! CHOOSE A COLUMN JCOL OF MINIMAL DEGREE MINDEG. 200 jcol = Iwa1 ( mindeg ) if ( jcol > 0 ) then List ( jcol ) = numord numord = numord - 1 ! TERMINATION TEST. if ( numord == 0 ) then ! INVERT THE ARRAY LIST. do jcol = 1 , n Iwa2 ( List ( jcol )) = jcol enddo do jp = 1 , n List ( jp ) = Iwa2 ( jp ) enddo else ! DELETE COLUMN JCOL FROM THE MINDEG LIST. Iwa1 ( mindeg ) = Iwa3 ( jcol ) if ( Iwa3 ( jcol ) > 0 ) Iwa2 ( Iwa3 ( jcol )) = 0 ! FIND ALL COLUMNS ADJACENT TO COLUMN JCOL. Iwa4 ( jcol ) = 0 ! DETERMINE ALL POSITIONS (IR,JCOL) WHICH CORRESPOND ! TO NON-ZEROES IN THE MATRIX. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! FOR EACH ROW IR, DETERMINE ALL POSITIONS (IR,IC) ! WHICH CORRESPOND TO NON-ZEROES IN THE MATRIX. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! ARRAY IWA4 MARKS COLUMNS WHICH ARE ADJACENT TO ! COLUMN JCOL. if ( Iwa4 ( ic ) > numord ) then Iwa4 ( ic ) = numord ! UPDATE THE POINTERS TO THE CURRENT DEGREE LISTS. numdeg = List ( ic ) List ( ic ) = List ( ic ) - 1 mindeg = min ( mindeg , List ( ic )) ! DELETE COLUMN IC FROM THE NUMDEG LIST. if ( Iwa2 ( ic ) == 0 ) then Iwa1 ( numdeg ) = Iwa3 ( ic ) else Iwa3 ( Iwa2 ( ic )) = Iwa3 ( ic ) endif if ( Iwa3 ( ic ) > 0 ) Iwa2 ( Iwa3 ( ic )) = Iwa2 ( ic ) ! ADD COLUMN IC TO THE NUMDEG-1 LIST. Iwa2 ( ic ) = 0 Iwa3 ( ic ) = Iwa1 ( numdeg - 1 ) if ( Iwa1 ( numdeg - 1 ) > 0 ) Iwa2 ( Iwa1 ( numdeg - 1 )) = ic Iwa1 ( numdeg - 1 ) = ic endif enddo enddo ! END OF ITERATION LOOP. goto 100 endif else mindeg = mindeg + 1 goto 200 endif end subroutine slo !******************************************************************************* !******************************************************************************* !> !  given the non-zero elements of an `m` by `n` matrix `a` in !  arbitrary order as specified by their row and column !  indices, this subroutine permutes these elements so !  that their column indices are in non-decreasing order. ! !  on input it is assumed that the elements are specified in ! !  `indrow(k),indcol(k), k = 1,...,nnz`. ! !  on output the elements are permuted so that `indcol` is !  in non-decreasing order. in addition, the array `jpntr` !  is set so that the row indices for column `j` are ! !  `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. ! !  note that the value of `m` is not needed by srtdat and is !  therefore not present in the subroutine statement. subroutine srtdat ( n , Nnz , Indrow , Indcol , Jpntr , Iwa ) implicit none integer :: n !! a positive integer input variable set to the number !! of columns of `a`. integer :: Nnz !! a positive integer input variable set to the number !! of non-zero elements of `a`. integer , dimension ( Nnz ) :: Indrow !! an integer array of length `nnz`. on input `indrow` !! must contain the row indices of the non-zero elements of `a`. !! on output `indrow` is permuted so that the corresponding !! column indices of `indcol` are in non-decreasing order. integer , dimension ( Nnz ) :: Indcol !! an integer array of length `nnz`. on input `indcol` !! must contain the column indices of the non-zero elements !! of `a`. on output `indcol` is permuted so that these indices !! are in non-decreasing order. integer , dimension ( n + 1 ) :: Jpntr !! an integer output array of length `n + 1` which !! specifies the locations of the row indices in the output !! `indrow`. the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(1)` is set to 1 and that `jpntr(n+1)-1` !! is then `nnz`. integer , dimension ( n ) :: Iwa !! an integer work array of length `n`. integer :: i , j , k , l ! store in array iwa the counts of non-zeroes in the columns. do j = 1 , n Iwa ( j ) = 0 enddo do k = 1 , Nnz Iwa ( Indcol ( k )) = Iwa ( Indcol ( k )) + 1 enddo ! set pointers to the start of the columns in indrow. Jpntr ( 1 ) = 1 do j = 1 , n Jpntr ( j + 1 ) = Jpntr ( j ) + Iwa ( j ) Iwa ( j ) = Jpntr ( j ) enddo k = 1 ! begin in-place sort. do j = Indcol ( k ) if ( k >= Jpntr ( j ) ) then ! current element is in position. now examine the ! next element or the first un-sorted element in ! the j-th group. k = max ( k + 1 , Iwa ( j )) else ! current element is not in position. place element ! in position and make the displaced element the ! current element. l = Iwa ( j ) Iwa ( j ) = Iwa ( j ) + 1 i = Indrow ( k ) Indrow ( k ) = Indrow ( l ) Indcol ( k ) = Indcol ( l ) Indrow ( l ) = i Indcol ( l ) = j endif if ( k > Nnz ) exit end do end subroutine srtdat !******************************************************************************* !******************************************************************************* !> !  Given a consistent partition of the columns of an `m` by `n` !  jacobian matrix into groups, this subroutine computes !  approximations to those columns in a given group.  the !  approximations are stored into either a column-oriented !  or a row-oriented pattern. ! !  a partition is consistent if the columns in any group !  do not have a non-zero in the same row position. ! !  approximations to the columns of the jacobian matrix in a !  given group can be obtained by specifying a difference !  parameter array `d` with `d(jcol)` non-zero if and only if !  `jcol` is a column in the group, and an approximation to !  `jac*d` where `jac` denotes the jacobian matrix of a mapping f. ! !  `d` can be defined with the following segment of code. !```fortran !  do jcol = 1, n !  d(jcol) = 0.0 !  if (ngrp(jcol) == numgrp) d(jcol) = eta(jcol) !  end do !``` !  in the above code `numgrp` is the given group number, !  `ngrp(jcol)` is the group number of column `jcol`, and !  `eta(jcol)` is the difference parameter used to !  approximate column `jcol` of the jacobian matrix. !  suitable values for the array `eta` must be provided. ! !  as mentioned above, an approximation to `jac*d` must !  also be provided. for example, the approximation !```fortran !  f(x+d) - f(x) !``` !  corresponds to the forward difference formula at `x`. subroutine fdjs ( m , n , Col , Ind , Npntr , Ngrp , Numgrp , d , Fjacd , Fjac ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of the jacobian matrix. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of the jacobian matrix. integer :: Numgrp !! a positive integer input variable set to a group !! number in the partition. the columns of the jacobian !! matrix in this group are to be estimated on this call. integer , dimension ( * ) :: Ind !! an integer input array which contains the row !! indices for the non-zeroes in the jacobian matrix !! if `col` is true, and contains the column indices for !! the non-zeroes in the jacobian matrix if `col` is false. integer , dimension ( * ) :: Npntr !! an integer input array which specifies the !! locations of the row indices in `ind` if `col` is true, and !! specifies the locations of the column indices in `ind` if !! `col` is false. if `col` is true, the indices for column `j` are !!       `ind(k), k = npntr(j),...,npntr(j+1)-1`. !! if `col` is false, the indices for row `i` are !!       `ind(k), k = npntr(i),...,npntr(i+1)-1`. !! ***Note*** that `npntr(n+1)-1` if `col` is true, or `npntr(m+1)-1` !! if `col` is false, is then the number of non-zero elements !! of the jacobian matrix. integer , dimension ( n ) :: Ngrp !! an integer input array of length `n` which specifies !! the partition of the columns of the jacobian matrix. !! column `jcol` belongs to group `ngrp(jcol)`. real ( wp ), dimension ( n ) :: d !! an input array of length `n` which contains the !! difference parameter vector for the estimate of !! the jacobian matrix columns in group `numgrp`. real ( wp ), dimension ( m ) :: Fjacd !! an input array of length `m` which contains !! an approximation to the difference vector `jac*d`, !! where `jac` denotes the jacobian matrix. real ( wp ), dimension ( * ) :: Fjac !! an output array of length `nnz`, where `nnz` is the !! number of its non-zero elements. at each call of `fdjs`, !! `fjac` is updated to include the non-zero elements of the !! jacobian matrix for those columns in group `numgrp`. `fjac` !! should not be altered between successive calls to `fdjs`. logical , intent ( in ) :: Col !! a logical input variable. if `col` is set true, then the !! jacobian approximations are stored into a column-oriented !! pattern. if `col` is set false, then the jacobian !! approximations are stored into a row-oriented pattern. integer :: ip , irow , jcol , jp ! compute estimates of jacobian matrix columns in group ! numgrp. the array fjacd must contain an approximation ! to jac*d, where jac denotes the jacobian matrix and d ! is a difference parameter vector with d(jcol) non-zero ! if and only if jcol is a column in group numgrp. if ( Col ) then ! column orientation. do jcol = 1 , n if ( Ngrp ( jcol ) == Numgrp ) then do jp = Npntr ( jcol ) , Npntr ( jcol + 1 ) - 1 irow = Ind ( jp ) Fjac ( jp ) = Fjacd ( irow ) / d ( jcol ) enddo endif enddo else ! row orientation. do irow = 1 , m do ip = Npntr ( irow ) , Npntr ( irow + 1 ) - 1 jcol = Ind ( ip ) if ( Ngrp ( jcol ) == Numgrp ) then Fjac ( ip ) = Fjacd ( irow ) / d ( jcol ) exit endif enddo enddo endif end subroutine fdjs !******************************************************************************* !******************************************************************************* end module dsm_module !*******************************************************************************","tags":"","loc":"sourcefile/dsm_module.f90.html"},{"title":"problem_12.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_12.f90~~EfferentGraph sourcefile~problem_12.f90 problem_12.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_12.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_12 use iso_fortran_env use aoc_utilities implicit none integer , parameter :: POINT = 0 integer , parameter :: NUMBER = 1 integer , parameter :: QUESTION = 2 ! some global variables integer , dimension (:), allocatable :: a , ints , ipattern , ipattern_tmp integer ( ip ) :: n_valid integer ( ip ) :: isum integer :: iline call clk % tic () call go (. false ., isum ); write ( * , * ) '12a: ' , isum ! call go(.true., isum); write(*,*) '12b: ', isum call clk % toc ( '12' ) contains subroutine go ( expand , isum ) logical , intent ( in ) :: expand integer ( ip ), intent ( out ) :: isum integer :: iunit , n_lines , n_unknowns integer ( ip ) :: n_perms character ( len = :), allocatable :: line , pattern type ( string ), dimension (:), allocatable :: vals ! open(newunit=iunit, file='inputs/day12_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day12.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ints = parse_ints ( vals ( 2 )% str ) ! integer list  1,1,3 pattern = vals ( 1 )% str ! the pattern   #.#.### ! will convert the pattern to an array of numbers: ipattern = str_to_int_array_with_mapping ( pattern ,[ '.' , '#' , '?' ],& [ POINT , NUMBER , QUESTION ]) ! 1010111 if ( expand ) then ! brute force it ipattern = [ ipattern , QUESTION , ipattern , QUESTION , & ipattern , QUESTION , ipattern , QUESTION , & ipattern ] ints = [ ints , ints , ints , ints , ints ] end if n_unknowns = count ( ipattern == 2 ) n_valid = 0 ! number of valid permutations n_perms = 2 ** n_unknowns ! number of permutations ipattern_tmp = ipattern ! recursively test all the permutations if ( allocated ( a )) deallocate ( a ) allocate ( a ( n_unknowns )) call test ( 1 , n_unknowns ) isum = isum + n_valid ! write(*,*) iline, 'n_valid = ', n_valid end do end subroutine go recursive subroutine test ( i , n ) !! each ? can be either a . or a # !! check pattern to match the int list integer , intent ( in ) :: i , n integer :: ix integer , dimension ( * ), parameter :: icoeffs = [ POINT , NUMBER ] !! set of coefficients ['.', '#'] ! what we are not doing here is accounting for permutations ! that we know do not match, because the begin with a sequence ! that doesn't match. those need to be skipped... if ( i > n ) then ! so we have an array of 0s and 1s -> replace the 2s in the ipattern with these !     ipattern: 2220111  -> ???.### !            a: 011      -> .## !       result: 0110111  -> .##.### !write(*,'(a,1x,i5,1x, *(I1))') 'test:', iline, ipattern_tmp ipattern_tmp = unpack ( a , mask = ipattern == QUESTION , field = ipattern ) if ( match ( ipattern_tmp , ints )) n_valid = n_valid + 1 else do ix = 1 , 2 a ( i ) = icoeffs ( ix ) call test ( i + 1 , n ) end do end if end subroutine test logical function match ( ipattern , ints ) !! returns true if the pattern is valid for the int list. integer , dimension (:), intent ( in ) :: ipattern integer , dimension (:), intent ( in ) :: ints integer :: i , iacc , int_checked integer , dimension ( 1 ) :: ifirst , iend logical :: accumulating ! .##..###... -> 2,3 ! start and end indices (ignoring leading and trailing spaces) ifirst = findloc ( ipattern , 1 ) iend = findloc ( ipattern , 1 , back = . true .) if ( ifirst ( 1 ) == 0 . or . iend ( 1 ) == 0 ) then ! all blank match = . false .; return end if ! step through the pattern and stop once we find it invalid accumulating = . true . iacc = 0 int_checked = 0 ! the count of ints that have been checked match = . true . ! initialize do i = ifirst ( 1 ), iend ( 1 ) select case ( ipattern ( i )) case ( POINT ) if ( accumulating ) then int_checked = int_checked + 1 ! check the next one if ( int_checked > size ( ints )) then ! too many ints match = . false . return else if ( ints ( int_checked ) /= iacc ) then ! doesn't match match = . false . return end if accumulating = . false . iacc = 0 end if case ( NUMBER ) if ( accumulating ) then iacc = iacc + 1 else ! start of a new number accumulating = . true . iacc = 1 end if if ( i == iend ( 1 )) then ! last number int_checked = int_checked + 1 ! check the next one if ( int_checked /= size ( ints )) then ! not enough ints match = . false . return else if ( ints ( int_checked ) /= iacc ) then ! doesn't match match = . false . return end if end if end select end do end function match end program problem_12","tags":"","loc":"sourcefile/problem_12.f90.html"},{"title":"dsm_test.f90 – AoC-2023","text":"This file depends on sourcefile~~dsm_test.f90~~EfferentGraph sourcefile~dsm_test.f90 dsm_test.f90 sourcefile~dsm_module.f90 dsm_module.f90 sourcefile~dsm_test.f90->sourcefile~dsm_module.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~dsm_test.f90->sourcefile~kinds_module.f90 sourcefile~dsm_module.f90->sourcefile~kinds_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program dsm_test !! This is a test program for subroutines [[dsm]] and [[fdjs]]. !! the test data represents a neutron kinetics problem. !! !!### Reference !!  * Argonne National Laboratory. MINPACK Project. July 1983. !!    Thomas F. Coleman, Burton S. Garbow, Jorge J. More !!  * Thomas F. Coleman, Burton S. Garbow, Jorge J. More, \"Algorithm 618: !!    FORTRAN subroutines for estimating sparse Jacobian Matrices\", !!    ACM Transactions on Mathematical Software (TOMS), !!    Volume 10 Issue 3, Sept. 1984, Pages 346-347 use dsm_module use iso_fortran_env , only : output_unit use numdiff_kinds_module , only : wp implicit none integer , parameter :: nwrite = output_unit !! unit for printing integer i , info , ip , j , jp , l , m , maxgrp , maxrow , & mingrp , minrow , n , nnz , numgrp integer indcol ( 6000 ) , indrow ( 6000 ) , ipntr ( 1201 ) , jpntr ( 1201 ) , & ngrp ( 1200 ) logical col real ( wp ) :: dnsm , errij , errmax , fjact , fjactr , sum real ( wp ) :: d ( 1200 ) , fjac ( 6000 ) , fjacd ( 1200 ) , fvec ( 1200 ) , x ( 1200 ) , & xd ( 1200 ) col = . true . ! !     TEST FOR DSM AND FDJS. ! write ( nwrite , 99001 ) ! !     FORMAT STATEMENTS. ! 99001 format ( // ' TESTS FOR DSM AND FDJS - NEUTRON KINETICS PROBLEM' // & & ' STATISTICS GENERATED ' // '       N - NUMBER OF COLUMNS ' / & & '     NNZ - NUMBER OF NON-ZERO ELEMENTS' / & & '    DNSM - MATRIX DENSITY (PERCENTAGE)' / & & '  MINROW - MINIMUM NUMBER OF NON-ZEROS IN ANY ROW' / & & '  MAXROW - MAXIMUM NUMBER OF NON-ZEROS IN ANY ROW' / & & '  MINGRP - LOWER BOUND ON NUMBER OF GROUPS' / & & '  MAXGRP - NUMBER OF GROUPS DETERMINED BY DSM' // ) do n = 300 , 1200 , 300 write ( nwrite , 99002 ) 99002 format ( // 3 x , 'N' , 6 x , 'NNZ' , 5 x , 'DNSM' , 5 x , 'MINROW' , 4 x , 'MAXROW' , 4 x ,& & 'MINGRP' , 4 x , 'MAXGRP' // ) ! !        DEFINITION OF SPARSITY PATTERN. ! m = n l = n / 3 nnz = 0 do j = 1 , n nnz = nnz + 1 indrow ( nnz ) = j indcol ( nnz ) = j if ( mod ( j , l ) /= 0 ) then nnz = nnz + 1 indrow ( nnz ) = j + 1 indcol ( nnz ) = j endif if ( j <= 2 * l ) then nnz = nnz + 1 indrow ( nnz ) = j + l indcol ( nnz ) = j if ( mod ( j , l ) /= 1 ) then nnz = nnz + 1 indrow ( nnz ) = j - 1 indcol ( nnz ) = j endif endif nnz = nnz + 1 if ( j > l ) then indrow ( nnz ) = j - l else indrow ( nnz ) = j + 2 * l endif indcol ( nnz ) = j enddo ! !        CALL DSM. ! call dsm ( m , n , nnz , indrow , indcol , ngrp , maxgrp , mingrp , info , ipntr , jpntr ) if ( info <= 0 ) write ( nwrite , 99003 ) info 99003 format ( // ' *** MISTAKE IN INPUT DATA, INFO IS ***' , i6 ) ! !        STATISTICS FOR THE MATRIX. ! maxrow = 0 minrow = n do i = 1 , m maxrow = max ( maxrow , ipntr ( i + 1 ) - ipntr ( i )) minrow = min ( minrow , ipntr ( i + 1 ) - ipntr ( i )) enddo dnsm = real ( 100 * nnz , wp ) / real ( m * n , wp ) write ( nwrite , 99004 ) n , nnz , dnsm , minrow , maxrow , & & mingrp , maxgrp 99004 format ( 2 ( i5 , 3 x ), f6 . 2 , 4 x , 4 ( i5 , 5 x )) ! !        TEST FOR FDJS. ! do j = 1 , n x ( j ) = real ( j , wp ) / real ( n , wp ) enddo call fcn ( n , x , indcol , ipntr , fvec ) ! !        APPROXIMATE THE JACOBIAN MATRIX. ! do numgrp = 1 , maxgrp do j = 1 , n d ( j ) = 0.0_wp if ( ngrp ( j ) == numgrp ) d ( j ) = 1.0e-6_wp !d(j) = 0.001_wp xd ( j ) = x ( j ) + d ( j ) enddo call fcn ( n , xd , indcol , ipntr , fjacd ) do i = 1 , m fjacd ( i ) = fjacd ( i ) - fvec ( i ) enddo if ( col ) then call fdjs ( m , n , col , indrow , jpntr , ngrp , numgrp , d , fjacd , fjac ) else call fdjs ( m , n , col , indcol , ipntr , ngrp , numgrp , d , fjacd , fjac ) endif enddo ! !        TEST THE APPROXIMATION TO THE JACOBIAN. ! errmax = 0.0_wp if ( col ) then ! !           TEST FOR THE COLUMN-ORIENTED DEFINITION OF !           THE SPARSITY PATTERN. ! do j = 1 , n do jp = jpntr ( j ) , jpntr ( j + 1 ) - 1 i = indrow ( jp ) sum = 0.0_wp do ip = ipntr ( i ) , ipntr ( i + 1 ) - 1 sum = sum + x ( indcol ( ip )) enddo sum = sum + x ( i ) fjact = 1.0_wp + 2.0_wp * sum if ( i == j ) fjact = 2.0_wp * fjact errij = fjac ( jp ) - fjact if ( fjact /= 0.0_wp ) errij = errij / fjact errmax = max ( errmax , abs ( errij )) enddo enddo else ! !           TEST FOR THE ROW-ORIENTED DEFINITION OF !           THE SPARSITY PATTERN. ! do i = 1 , m sum = 0.0_wp do ip = ipntr ( i ) , ipntr ( i + 1 ) - 1 sum = sum + x ( indcol ( ip )) enddo sum = sum + x ( i ) fjactr = 1.0_wp + 2.0_wp * sum do ip = ipntr ( i ) , ipntr ( i + 1 ) - 1 j = indcol ( ip ) fjact = fjactr if ( i == j ) fjact = 2.0_wp * fjact errij = fjac ( ip ) - fjact if ( fjact /= 0.0_wp ) errij = errij / fjact errmax = max ( errmax , abs ( errij )) enddo enddo endif write ( nwrite , 99005 ) errmax 99005 format ( // ' LARGEST RELATIVE ERROR OF APPROXIMATION IS' , e10 . 2 ) col = . not . col enddo stop contains subroutine fcn ( n , x , Indcol , Ipntr , Fvec ) !! Function subroutine for testing [[fdjs]]. implicit none integer n integer Indcol ( * ) , Ipntr ( n + 1 ) real ( wp ) :: x ( n ) , Fvec ( n ) integer i , ip real ( wp ) :: sum do i = 1 , n sum = 0.0_wp do ip = Ipntr ( i ) , Ipntr ( i + 1 ) - 1 sum = sum + x ( Indcol ( ip )) enddo sum = sum + x ( i ) Fvec ( i ) = sum * ( 1.0_wp + sum ) + 1.0_wp enddo end subroutine fcn end program dsm_test","tags":"","loc":"sourcefile/dsm_test.f90.html"},{"title":"test.f90 – AoC-2023","text":"This file depends on sourcefile~~test.f90~~EfferentGraph sourcefile~test.f90 test.f90 sourcefile~fmin_module.f90 fmin_module.F90 sourcefile~test.f90->sourcefile~fmin_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  Tests for [[fmin_module]]. program test use fmin_module , wp => fmin_rk real ( wp ) :: ax , bx , xmin , xerr , x real ( wp ), parameter :: pi = acos ( - 1.0_wp ) real ( wp ), parameter :: tol = 1.0e-8_wp ax = - 4.0_wp bx = 0.0_wp x = - pi / 2.0_wp ! actual answer xmin = fmin ( func , ax , bx , tol ) xerr = xmin - x ! difference from try value write ( * , * ) 'xmin       = ' , xmin write ( * , * ) 'xmin exact = ' , x write ( * , * ) 'xmin error = ' , xerr if ( abs ( xerr ) > 1 0.0_wp * tol ) then error stop 'test failed' end if contains !***************************************************************************************** !***************************************************************************************** !> !  Test function to minimize. function func ( x ) result ( f ) implicit none real ( wp ), intent ( in ) :: x !! indep. variable real ( wp ) :: f !! function value `f(x)` f = sin ( x ) end function func !***************************************************************************************** !***************************************************************************************** end program test !*****************************************************************************************","tags":"","loc":"sourcefile/test.f90.html"},{"title":"problem_05.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_05.f90~~EfferentGraph sourcefile~problem_05.f90 problem_05.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_05.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_5 use iso_fortran_env use aoc_utilities implicit none integer :: i , iunit , n_lines character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals integer ( ip ), dimension (:), allocatable :: seeds_list integer ( ip ) :: ilocation_min , ilocation , iseed integer ( ip ), dimension (:), allocatable :: ilocation_min_parallel type :: mapping ! save the source and destination start and end values integer ( ip ), dimension (:), allocatable :: dest_start , dest_end , src_start , src_end end type mapping integer , parameter :: NSTAGES = 7 type ( mapping ), dimension ( NSTAGES ) :: mappings ! seed_to_soil, soil_to_fertilizer, fertilizer_to_water, water_to_light, ! light_to_temperature, temperature_to_humidity, humidity_to_location integer :: parsing_state ! index in mappings (1 to NSTAGES) call clk % tic () do i = 1 , NSTAGES allocate ( mappings ( i )% dest_start ( 0 ), mappings ( i )% dest_end ( 0 ),& mappings ( i )% src_start ( 0 ), mappings ( i )% src_end ( 0 )) end do ! open(newunit=iunit, file='inputs/day5_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day5.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) parsing_state = 0 do i = 1 , n_lines line = read_line ( iunit ) if ( line == '' ) cycle ! blank line if ( startswith ( line , 'seeds:' )) then ; seeds_list = parse_ints64 ( line ( 7 :)) else if ( index ( line , 'map:' ) > 0 ) then ; parsing_state = parsing_state + 1 ! one of the 7 stages else ! parse the numbers for the given state: call populate ( parse_ints64 ( line ), mappings ( parsing_state )) end if end do close ( iunit ) ! ------------ part 1 ----------------- ilocation_min = huge ( 1 ) do i = 1 , size ( seeds_list ) ilocation = traverse ( seeds_list ( i ),. false .) if ( ilocation < ilocation_min ) ilocation_min = ilocation end do print * , '5a: ' , ilocation_min ! ------------ part 2 ----------------- !  so it doesn't run in the CI !! if (. false .) then ! brute force, openMP version. just run the part a algorithm for all the seeds. ! takes a minute or so on my computer. allocate ( ilocation_min_parallel ( size ( seeds_list ) / 2 )) ilocation_min_parallel = huge ( 1 ) !$OMP PARALLEL DO SHARED(ilocation_min_parallel) PRIVATE(i,iseed,ilocation) do i = 1 , size ( seeds_list ), 2 do iseed = seeds_list ( i ), seeds_list ( i ) + seeds_list ( i + 1 ) - 1 ilocation = traverse ( iseed , . false .) if ( ilocation < ilocation_min_parallel (( i + 1 ) / 2 )) ilocation_min_parallel (( i + 1 ) / 2 ) = ilocation end do end do !$OMP END PARALLEL DO print * , '5b: ' , minval ( ilocation_min_parallel ) end if ! ------------ part 2 ----------------- ! Alternate version, go backwards from the location to the seed ! and see if it is contained in the seed set. ! this one is pretty fast (< 1 sec) do ilocation = minval ( mappings ( 7 )% dest_start ), maxval ( mappings ( 7 )% dest_end ) ! up to the max ilocation value iseed = traverse ( ilocation , reverse = . true .) ! from ilocation to iseed if ( in_seed_list ( iseed )) exit ! found the min end do print * , '5b: ' , ilocation call clk % toc ( '5' ) contains logical function in_seed_list ( iseed ) ! for part b, is the seed in the initial list integer ( ip ), intent ( in ) :: iseed integer :: i do i = 1 , size ( seeds_list ), 2 if ( iseed >= seeds_list ( i ) . and . iseed <= seeds_list ( i ) + seeds_list ( i + 1 ) - 1 ) then in_seed_list = . true . return end if end do in_seed_list = . false . end function in_seed_list subroutine populate ( nums , m ) integer ( ip ), dimension ( 3 ), intent ( in ) :: nums ! the three numbers from the line: ! [dest range start, src range start, range length type ( mapping ), intent ( inout ) :: m ! structure to add this data to associate ( dest => nums ( 1 ), source => nums ( 2 ), range => nums ( 3 ) ) m % dest_start = [ m % dest_start , dest ] m % dest_end = [ m % dest_end , dest + range - 1 ] m % src_start = [ m % src_start , source ] m % src_end = [ m % src_end , source + range - 1 ] end associate end subroutine populate pure function map ( ival , m , reverse ) result ( idest ) integer ( ip ), intent ( in ) :: ival type ( mapping ), intent ( in ) :: m logical , intent ( in ) :: reverse ! if reversed, go from: dest -> src integer ( ip ) :: idest integer :: i if ( reverse ) then do i = 1 , size ( m % src_start ) ! locate ival (dest) in the dest start:end range if ( ival >= m % dest_start ( i ) . and . ival <= m % dest_end ( i )) then ! found it, map to dest idest = m % src_start ( i ) + ( ival - m % dest_start ( i )) ! this is the resultant isource return end if end do else do i = 1 , size ( m % src_start ) ! locate ival (source) in the source start:end range if ( ival >= m % src_start ( i ) . and . ival <= m % src_end ( i )) then ! found it, map to dest idest = m % dest_start ( i ) + ( ival - m % src_start ( i )) return end if end do end if idest = ival ! if not found in any of the sets end function map pure function traverse ( iseed , reverse ) result ( ilocation ) integer ( ip ), intent ( in ) :: iseed logical , intent ( in ) :: reverse !! if reverse, then ilocation -> iseed integer ( ip ) :: ilocation integer :: i ilocation = iseed ! initialize if ( reverse ) then do i = NSTAGES , 1 , - 1 ilocation = map ( ilocation , mappings ( i ), reverse ) ! this is really iseed end do else do i = 1 , NSTAGES ilocation = map ( ilocation , mappings ( i ), reverse ) end do end if end function traverse end program problem_5","tags":"","loc":"sourcefile/problem_05.f90.html"},{"title":"problem_12b.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_12b.f90~~EfferentGraph sourcefile~problem_12b.f90 problem_12b.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_12b.f90->sourcefile~aoc_utilities.f90 sourcefile~cache_module.f90~2 cache_module.f90 sourcefile~problem_12b.f90->sourcefile~cache_module.f90~2 sourcefile~cache_module.f90~2->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_12b !! completely reworked solution from part a !! this one starts with the int list and checks it against the pattern. !! it also employs a function cache to speed it up. use iso_fortran_env use aoc_utilities use aoc_cache_module implicit none ! note: these are negative because we are appending ! them to the pattern for the cache integer ( ip ), parameter :: POINT = - 1 ! . integer ( ip ), parameter :: NUMBER = - 2 ! # integer ( ip ), parameter :: QUESTION = - 3 ! ? ! some global variables integer :: iunit , n_lines , iline character ( len = :), allocatable :: line , pattern type ( string ), dimension (:), allocatable :: vals integer ( ip ), dimension (:), allocatable :: ints , ipattern integer ( ip ) :: isum , ival type ( function_cache ) :: cache !! to cache the [[go]] function values call clk % tic () call cache % initialize ( isize = 10000 , chunk_size = 1000 ) ! open(newunit=iunit, file='inputs/day12_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day12.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ints = parse_ints ( vals ( 2 )% str ) ! integer list pattern = vals ( 1 )% str ! the pattern ! will convert the pattern to an array of numbers: ipattern = str_to_int64_array_with_mapping ( pattern ,[ '.' , '#' , '?' ],& [ POINT , NUMBER , QUESTION ]) ! expand the input ipattern = [ ipattern , QUESTION , ipattern , QUESTION , & ipattern , QUESTION , ipattern , QUESTION , & ipattern ] ints = [ ints , ints , ints , ints , ints ] ival = go ( ipattern , ints ) isum = isum + ival end do write ( * , * ) '12b: ' , isum call clk % toc ( '12b' ) contains recursive function go ( ipattern , ints ) result ( ival ) integer ( ip ), dimension (:), intent ( in ) :: ipattern integer ( ip ), dimension (:), intent ( in ) :: ints integer ( ip ) :: ival integer ( ip ), dimension (:), allocatable :: ival_vec integer ( ip ) :: idx logical :: found ! first check the cache: call cache % get ([ ipattern , ints ], idx , ival_vec , found ) if ( found ) then ival = ival_vec ( 1 ) else if ( size ( ints ) == 0 ) then ! no more ints ival = merge ( 0 , 1 , any ( ipattern == NUMBER )) ! if any more numbers, invalid else if ( size ( ipattern ) == 0 ) then ival = 0 ! too many ints else ! process next element in pattern select case ( ipattern ( 1 )) case ( NUMBER ); ival = ipound ( ipattern , ints ) case ( POINT ); ival = ipoint ( ipattern , ints ) case ( QUESTION ); ival = ipoint ( ipattern , ints ) + ipound ( ipattern , ints ) end select end if ! cache this function call: ival_vec = [ ival ] call cache % put ( idx ,[ ipattern , ints ], ival_vec ) end if end function go recursive integer ( ip ) function ipound ( ipattern , ints ) integer ( ip ), dimension (:), intent ( in ) :: ipattern !! first char is a # integer ( ip ), dimension (:), intent ( in ) :: ints integer ( ip ), dimension (:), allocatable :: this_group ! check for the number of # that correspond to the first group if ( size ( ipattern ) >= ints ( 1 )) then this_group = ipattern ( 1 : ints ( 1 )) where ( this_group == QUESTION ) this_group = NUMBER ! replace ? with # if ( any ( this_group /= NUMBER )) then ! can't fit all the #'s so not valid ipound = 0 return else ! so far so good end if else ! not enough room to hold all the #'s ipound = 0 return end if if ( size ( ipattern ) == ints ( 1 )) then ! if this is the last group, then we are done ipound = merge ( 1 , 0 , size ( ints ) == 1 ) else ! the next character after this number must be a ? or . if ( size ( ipattern ) >= ints ( 1 ) + 1 ) then if ( any ( ipattern ( ints ( 1 ) + 1 ) == [ QUESTION , POINT ])) then block integer ( ip ), dimension (:), allocatable :: ipattern_tmp , ints_tmp ! to handle edge cases ! skip it and process the next group if ( size ( ipattern ) >= ints ( 1 ) + 2 ) then ipattern_tmp = ipattern ( ints ( 1 ) + 2 :) else allocate ( ipattern_tmp ( 0 )) end if if ( size ( ints ) >= 2 ) then ints_tmp = ints ( 2 :) else allocate ( ints_tmp ( 0 )) end if ipound = go ( ipattern_tmp , ints_tmp ) return end block end if end if ! not valid at this point ipound = 0 end if end function ipound recursive integer ( ip ) function ipoint ( ipattern , ints ) integer ( ip ), dimension (:), intent ( in ) :: ipattern !! first char is a . integer ( ip ), dimension (:), intent ( in ) :: ints if ( size ( ipattern ) <= 1 ) then ipoint = go ([ integer ( ip ) :: ], ints ) ! done, pass in empty array else ipoint = go ( ipattern ( 2 :), ints ) ! skip it and go to next one end if end function ipoint end program problem_12b","tags":"","loc":"sourcefile/problem_12b.f90.html"},{"title":"problem_08.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_08.f90~~EfferentGraph sourcefile~problem_08.f90 problem_08.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_08.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_8 use iso_fortran_env use aoc_utilities implicit none integer :: iunit , n_lines character ( len = :), allocatable :: line , instructions type ( string ), dimension (:), allocatable :: vals integer ( ip ) :: i , j , idx , idx_zzz , imoves , ias , izs integer ( ip ), dimension (:), allocatable :: instructions_ints integer ( ip ), dimension (:), allocatable :: idx_vec , idx_zzz_vec integer ( ip ), dimension (:), allocatable :: imoves_vec type :: node character ( len = 3 ) :: name = '' character ( len = 3 ), dimension ( 2 ) :: lr integer , dimension ( 2 ) :: lr_idx ! the indices in the nodes array of the l,r nodes end type node type ( node ), dimension (:), allocatable :: nodes call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day8_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day8.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( nodes ( n_lines - 2 )) instructions = read_line ( iunit ) allocate ( instructions_ints ( len ( instructions ))) do i = 1 , len ( instructions ) select case ( instructions ( i : i )) ! make an int array for easier access case ( 'L' ); instructions_ints ( i ) = 1 case ( 'R' ); instructions_ints ( i ) = 2 end select end do do i = 0 , n_lines - 1 line = read_line ( iunit ) if ( line == '' ) cycle read ( line , \"(A3,1X,1X,1X,1X,A3,1X,1X,A3,1X)\" ) nodes ( i )% name , nodes ( i )% lr ( 1 ), nodes ( i )% lr ( 2 ) end do close ( iunit ) ! compute all the lr indices: do i = 1 , size ( nodes ) nodes ( i )% lr_idx ( 1 ) = find_node ( nodes ( i )% lr ( 1 )) nodes ( i )% lr_idx ( 2 ) = find_node ( nodes ( i )% lr ( 2 )) end do !******************************************** imoves = moves ( find_node ( 'AAA' ), find_node ( 'ZZZ' )) write ( * , * ) '8a : number of moves:' , imoves !******************************************** ! get indices of the ones that end in A and Z: allocate ( idx_vec ( 0 ), idx_zzz_vec ( 0 )) do i = 1 , size ( nodes ) if ( nodes ( i )% name ( 3 : 3 ) == 'A' ) idx_vec = [ idx_vec , i ] if ( nodes ( i )% name ( 3 : 3 ) == 'Z' ) idx_zzz_vec = [ idx_zzz_vec , i ] end do if ( size ( idx_vec ) /= size ( idx_zzz_vec )) error stop 'error: they need to be the same size?' allocate ( imoves_vec ( size ( idx_vec ))) ! for EACH start, find the number of moves that it takes to get to ONE of the ends. do i = 1 , size ( idx_vec ) imoves_vec ( i ) = moves_any_z ( idx_vec ( i ), idx_zzz_vec ) end do ! don't know why this works ¯\\_(ツ)_/¯ ! I think it's a feature of the specific data given ! (it's a repeating cycle once it gets to the end) write ( * , * ) '8b : number of moves: ' , lcm ( lcm ( lcm ( lcm ( lcm ( imoves_vec ( 1 ),& imoves_vec ( 2 )),& imoves_vec ( 3 )),& imoves_vec ( 4 )),& imoves_vec ( 5 )),& imoves_vec ( 6 )) ! ! ! ! brute force. run all the moves in parallel until they are all done. ! ! ! i = 0 ! imoves = 0 ! do !     if (all_in_set(idx_vec, idx_zzz_vec)) exit !     imoves = imoves + 1 ! another move !     i = i + 1 !     if (i>len(instructions)) i = 1 !     do concurrent (j = 1 : size(idx_vec)) !         idx_vec(j) = nodes(idx_vec(j))%lr_idx(instructions_ints(i)) !     end do ! end do ! write(*,*) '8b : number of moves:', imoves call clk % toc ( '8' ) contains pure function moves ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart , iend !! indices for start and end nodes integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( idx == iend ) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves pure function moves_any_z ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart !! indices for start and end nodes integer ( ip ), dimension (:), intent ( in ) :: iend integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( any ( idx == iend )) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves_any_z pure logical function all_in_set ( ivals , iset ) !! returns true if all the elements of ivals are in the set iset integer ( ip ), dimension (:), intent ( in ) :: ivals , iset integer :: i all_in_set = . true . do i = 1 , size ( ivals ) if (. not . any ( ivals ( i ) == iset )) then all_in_set = . false . exit end if end do end function all_in_set pure integer ( ip ) function find_node ( name ) character ( len =* ), intent ( in ) :: name integer ( ip ) :: i do i = 1 , size ( nodes ) if ( name == nodes ( i )% name ) then find_node = i return end if end do error stop 'could not find node' end function find_node end program problem_8","tags":"","loc":"sourcefile/problem_08.f90.html"},{"title":"test1.f90 – AoC-2023","text":"This file depends on sourcefile~~test1.f90~~EfferentGraph sourcefile~test1.f90 test1.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~test1.f90->sourcefile~kinds_module.f90 sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~test1.f90->sourcefile~numerical_differentiation_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~kinds_module.f90 sourcefile~cache_module.f90 cache_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~cache_module.f90 sourcefile~diff_module.f90 diff_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~diff_module.f90 sourcefile~dsm_module.f90 dsm_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~dsm_module.f90 sourcefile~utilities_module.f90 utilities_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~utilities_module.f90 sourcefile~cache_module.f90->sourcefile~kinds_module.f90 sourcefile~cache_module.f90->sourcefile~utilities_module.f90 sourcefile~diff_module.f90->sourcefile~kinds_module.f90 sourcefile~dsm_module.f90->sourcefile~kinds_module.f90 sourcefile~utilities_module.f90->sourcefile~kinds_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> author: Jacob Williams !  date: October 31, 2016 ! !  Test1 for the numerical differentiation module. program test1 use iso_fortran_env , only : output_unit , error_unit use numerical_differentiation_module use numdiff_kinds_module , only : wp implicit none integer , parameter :: n = 10 integer , parameter :: m = 6 real ( wp ), dimension ( n ), parameter :: x = 1.0_wp real ( wp ), dimension ( n ), parameter :: xlow = - 1 0.0_wp real ( wp ), dimension ( n ), parameter :: xhigh = 1 0.0_wp real ( wp ), dimension ( n ), parameter :: dpert = 1.0e-5_wp integer , parameter :: perturb_mode = 1 integer , parameter :: cache_size = 0 !! `0` indicates not to use cache integer , parameter :: sparsity_mode = 4 type ( numdiff_type ) :: my_prob integer :: i !! counter integer :: j !! counter real ( wp ), dimension (:), allocatable :: jac character ( len = :), allocatable :: formula type ( finite_diff_method ) :: fd logical :: status_ok type ( meth_array ) :: meths integer :: func_evals !! function evaluation counter integer , dimension (:), allocatable :: methods !! array of method IDs character ( len = :), allocatable :: error_msg !! error message string methods = [( i , i = 1 , 44 )] methods = [ methods , 500 , 600 , 700 , 800 ] ! these only have central diffs do j = 1 , size ( methods ) ! try different finite diff methods i = methods ( j ) call get_finite_diff_formula ( i , formula ) if ( formula == '' ) then write ( output_unit , * ) 'id ' , i , 'not available' cycle end if func_evals = 0 call my_prob % destroy () call my_prob % initialize ( n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func = my_func ,& sparsity_mode = sparsity_mode ,& jacobian_method = i ,& partition_sparsity_pattern = . false .,& cache_size = cache_size ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if if ( i == 1 ) then write ( output_unit , '(A)' ) '' call my_prob % print_sparsity_pattern ( output_unit ) write ( output_unit , '(A)' ) '' call my_prob % print_sparsity_matrix ( output_unit ) write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '--------------------------------------' write ( output_unit , '(A,I4)' ) ' specify method [no partitioning] : ' , i write ( output_unit , '(A)' ) '--------------------------------------' write ( output_unit , '(A)' ) '' end if write ( output_unit , '(A)' ) formula write ( output_unit , '(A)' ) '' write ( output_unit , '(A,1X,*(F27.16,\",\"))' ) 'jac =' , jac write ( output_unit , '(A,1X,I5)' ) 'function evaluations:' , func_evals write ( output_unit , '(A)' ) '' end do do j = 1 , size ( methods ) ! try different finite diff methods i = methods ( j ) call get_finite_diff_formula ( i , formula ) if ( formula == '' ) then write ( output_unit , * ) 'id ' , i , 'not available' cycle end if func_evals = 0 call my_prob % destroy () call my_prob % initialize ( n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func = my_func ,& sparsity_mode = sparsity_mode ,& jacobian_method = i ,& partition_sparsity_pattern = . true .,& cache_size = 1000 ) ! use the cache for these cases if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if if ( i == 1 ) then write ( output_unit , '(A)' ) '' call my_prob % print_sparsity_pattern ( output_unit ) write ( output_unit , '(A)' ) '' call my_prob % print_sparsity_matrix ( output_unit ) write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '--------------------------------------' write ( output_unit , '(A,I4)' ) ' specify method [with partitioning] : ' , i write ( output_unit , '(A)' ) '--------------------------------------' write ( output_unit , '(A)' ) '' end if write ( output_unit , '(A)' ) formula write ( output_unit , '(A)' ) '' write ( output_unit , '(A,1X,*(F27.16,\",\"))' ) 'jac =' , jac write ( output_unit , '(A,1X,I5)' ) 'function evaluations:' , func_evals write ( output_unit , '(A)' ) '' end do meths = get_all_methods_in_class ( 3 ) write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) 'select_finite_diff_method' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) '' call my_prob % select_finite_diff_method ( 0.0_wp , 0.0_wp , 1.0_wp , 0.001_wp , meths , fd , status_ok ) call fd % get_formula ( formula ) write ( output_unit , '(A)' ) formula write ( output_unit , '(A)' ) '' call my_prob % select_finite_diff_method ( 0.9999_wp , 0.0_wp , 1.0_wp , 0.001_wp , meths , fd , status_ok ) call fd % get_formula ( formula ) write ( output_unit , '(A)' ) formula write ( output_unit , '(A)' ) '' do i = 2 , 9 write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A,I2)' ) ' specify class [no partitioning] : ' , i write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) '' func_evals = 0 call my_prob % destroy () call my_prob % initialize ( n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func = my_func ,& sparsity_mode = sparsity_mode ,& class = i ,& cache_size = cache_size ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if write ( output_unit , '(A,1X,*(F27.16,\",\"))' ) 'jac =' , jac write ( output_unit , '(A,1X,I5)' ) 'function evaluations:' , func_evals write ( output_unit , '(A)' ) '' end do do i = 2 , 9 write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A,I2)' ) ' specify class [with partitioning] : ' , i write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) '' func_evals = 0 call my_prob % destroy () call my_prob % initialize ( n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func = my_func ,& sparsity_mode = sparsity_mode ,& class = i , partition_sparsity_pattern = . true .,& cache_size = cache_size ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if write ( output_unit , '(A,1X,*(F27.16,\",\"))' ) 'jac =' , jac write ( output_unit , '(A,1X,I5)' ) 'function evaluations:' , func_evals write ( output_unit , '(A)' ) '' end do write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) ' diff algorithm' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) '' func_evals = 0 call my_prob % diff_initialize ( n , m , xlow , xhigh , my_func , sparsity_mode = 1 ,& ! use a dense method for this one cache_size = cache_size ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if write ( output_unit , '(A,1X,*(F27.16,\",\"))' ) 'jac =' , jac write ( output_unit , '(A,1X,I5)' ) 'function evaluations:' , func_evals write ( output_unit , '(A)' ) '' contains subroutine my_func ( me , x , f , funcs_to_compute ) !! Problem function implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f integer , dimension (:), intent ( in ) :: funcs_to_compute if ( any ( funcs_to_compute == 1 )) f ( 1 ) = x ( 1 ) * x ( 2 ) - x ( 3 ) ** 3 if ( any ( funcs_to_compute == 2 )) f ( 2 ) = x ( 3 ) - 1.0_wp if ( any ( funcs_to_compute == 3 )) f ( 3 ) = x ( 4 ) * x ( 5 ) if ( any ( funcs_to_compute == 4 )) f ( 4 ) = 2.0_wp * x ( 6 ) + sin ( x ( 7 )) if ( any ( funcs_to_compute == 5 )) f ( 5 ) = cos ( x ( 8 )) + sqrt ( abs ( x ( 9 ))) if ( any ( funcs_to_compute == 6 )) f ( 6 ) = 1.0_wp / ( 1.0_wp + exp ( x ( 10 ))) func_evals = func_evals + 1 end subroutine my_func !******************************************************************************* end program test1 !*******************************************************************************","tags":"","loc":"sourcefile/test1.f90.html"},{"title":"cache_module.f90 – AoC-2023","text":"This file depends on sourcefile~~cache_module.f90~~EfferentGraph sourcefile~cache_module.f90 cache_module.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~cache_module.f90->sourcefile~kinds_module.f90 sourcefile~utilities_module.f90 utilities_module.f90 sourcefile~cache_module.f90->sourcefile~utilities_module.f90 sourcefile~utilities_module.f90->sourcefile~kinds_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~cache_module.f90~~AfferentGraph sourcefile~cache_module.f90 cache_module.f90 sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~cache_module.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~numerical_differentiation_module.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~numerical_differentiation_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> author: Jacob Williams ! !  For caching function evaluations. module numdiff_cache_module use iso_fortran_env , only : ip => int64 ! same number of bits as real(wp) use numdiff_kinds_module use numdiff_utilities_module , only : unique implicit none private type :: fx !! an [x,f(x)] cached pair. private real ( wp ), dimension (:), allocatable :: x !! vector of input values real ( wp ), dimension (:), allocatable :: f !! vector of output functions `f(x)` !! note: only the elements indicated by `ifs` !! will have valid values. The others will !! be dummy values. integer , dimension (:), allocatable :: ifs !! elements of `f` present in the cache !! (this is just an array of the indices !! present in `f`) end type fx type , public :: function_cache !! a vector function cache. private integer :: n = 0 !! size of `x` integer :: m = 0 !! size of `f` type ( fx ), dimension (:), allocatable :: c !! the cache of `f(x)` integer :: chunk_size = 100 !! for resizing vectors !! in the [[unique]] function contains private procedure , public :: initialize => initialize_cache procedure , public :: get => get_from_cache procedure , public :: put => put_in_cache procedure , public :: destroy => destroy_cache procedure , public :: print => print_cache end type function_cache contains !******************************************************************************* !******************************************************************************* !> !  Initialize the cache. Must be called first before use. subroutine initialize_cache ( me , isize , n , m , chunk_size ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: isize !! the size of the hash table integer , intent ( in ) :: n !! number of independant variables (x) integer , intent ( in ) :: m !! number of functions (f) integer , intent ( in ), optional :: chunk_size !! chunk size to speed up reallocation !! of arrays. A good value is a guess for !! the actual number of elements of `f` that !! will be saved per value of `x` [default is 100] call me % destroy () allocate ( me % c ( 0 : isize - 1 )) me % n = n me % m = m if ( present ( chunk_size )) then me % chunk_size = chunk_size else me % chunk_size = 100 end if end subroutine initialize_cache !******************************************************************************* !******************************************************************************* !> !  Print the contents of the cache. Used for debugging. subroutine print_cache ( me , iunit ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: iunit !! file unit for writing !! (assumed to be opened) integer :: i !! counter write ( iunit , '(A)' ) '' write ( iunit , '(A)' ) '------------------------' if ( allocated ( me % c )) then do i = 1 , size ( me % c ) if ( allocated ( me % c ( i )% x )) then write ( iunit , '(A)' ) '' write ( iunit , '(A,1X,I10)' ) 'Entry ' , i write ( iunit , '(A,1X,*(F27.16,1X))' ) 'x  :' , me % c ( i )% x if ( allocated ( me % c ( i )% f )) then write ( iunit , '(A,1X,*(I27,1X))' ) 'ifs:' , me % c ( i )% ifs write ( iunit , '(A,1X,*(F27.16,1X))' ) 'f  :' , me % c ( i )% f ( me % c ( i )% ifs ) end if write ( iunit , '(A)' ) '------------------------' end if end do else write ( iunit , '(A)' ) 'Cache is not initialized' write ( iunit , '(A)' ) '------------------------' end if write ( iunit , '(A)' ) '' end subroutine print_cache !******************************************************************************* !******************************************************************************* !> !  Check if the `x` vector is in the cache, if so return `f`. !  Note that only some of the elements may be present, so it will return !  the ones there are there, and indicate which ones were found. subroutine get_from_cache ( me , x , ifs , i , f , xfound , ffound ) implicit none class ( function_cache ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! independant variable vector integer , dimension (:), intent ( in ) :: ifs !! elements of `f` needed integer , intent ( out ) :: i !! index in the hash table real ( wp ), dimension (:), intent ( out ) :: f !! `f(x)` from the cache (if it was found) logical , intent ( out ) :: xfound !! if `x` was found in the cache logical , dimension ( size ( ifs )), intent ( out ) :: ffound !! which `ifs` were found in the cache integer :: j !! counter ! initialize: xfound = . false . ffound = . false . if ( allocated ( me % c )) then ! get index in the hash table: i = mod ( abs ( vector_djb_hash ( x )), int ( size ( me % c ), ip ) ) ! check the table: if ( allocated ( me % c ( i )% x ) . and . allocated ( me % c ( i )% f )) then if ( size ( me % c ( i )% x ) == size ( x ) . and . & size ( me % c ( i )% f ) == size ( f )) then if ( all ( me % c ( i )% x == x )) then xfound = . true . ! return the elements that were found in the cache: f ( me % c ( i )% ifs ) = me % c ( i )% f ( me % c ( i )% ifs ) ! what indices are in the cache? do j = 1 , size ( ifs ) ffound ( j ) = any ( ifs ( j ) == me % c ( i )% ifs ) end do end if end if end if else error stop 'Error: the cache has not been initialized.' end if end subroutine get_from_cache !******************************************************************************* !******************************************************************************* !> !  Put a value into the cache. subroutine put_in_cache ( me , i , x , f , ifs ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: i !! index in the hash table real ( wp ), dimension (:), intent ( in ) :: x !! independant variable vector (dimension `n`) real ( wp ), dimension (:), intent ( in ) :: f !! function vector `f(x)` (dimension `m`) integer , dimension (:), intent ( in ) :: ifs !! elements of `f` to add (should all be `>0, <=m`) real ( wp ), parameter :: null = huge ( 1.0_wp ) !! an unusual value to initialize arrays if ( allocated ( me % c )) then if ( i <= size ( me % c )) then if ( allocated ( me % c ( i )% x )) then ! we need to check if there is an x already there, ! which may already have some function indices present. ! if same x, then add the new indices to them. ! if a different x, then replace indices. if ( all ( me % c ( i )% x == x )) then ! this x is already present in this location. ! so merge the new f,ifs into what is already there. if ( allocated ( me % c ( i )% f )) then me % c ( i )% ifs = unique ([ me % c ( i )% ifs , ifs ],& chunk_size = me % chunk_size ) else allocate ( me % c ( i )% f ( me % m )) me % c ( i )% f = null ! initialize to an unusual value me % c ( i )% ifs = ifs end if me % c ( i )% f ( ifs ) = f ( ifs ) else ! replace existing x and f. me % c ( i )% x = x me % c ( i )% ifs = ifs if ( allocated ( me % c ( i )% f )) deallocate ( me % c ( i )% f ) allocate ( me % c ( i )% f ( me % m )) me % c ( i )% f = null ! initialize to an unusual value me % c ( i )% f ( ifs ) = f ( ifs ) end if else ! new entry in the cache: me % c ( i )% x = x allocate ( me % c ( i )% f ( me % m )) me % c ( i )% f = null ! initialize to an unusual value me % c ( i )% ifs = ifs me % c ( i )% f ( ifs ) = f ( ifs ) end if else error stop 'Error: invalid index in hash table.' end if else error stop 'Error: the cache has not been initialized.' end if end subroutine put_in_cache !******************************************************************************* !******************************************************************************* !> !  Destroy a cache. subroutine destroy_cache ( me ) implicit none class ( function_cache ), intent ( out ) :: me end subroutine destroy_cache !******************************************************************************* !******************************************************************************* !> !  DJB hash algorithm for a `real(wp)` vector. ! !### See also !  * J. Shahbazian, Fortran hashing algorithm, July 6, 2013 !   [Fortran Dev](https://fortrandev.wordpress.com/2013/07/06/fortran-hashing-algorithm/) pure function vector_djb_hash ( r ) result ( hash ) real ( wp ), dimension (:), intent ( in ) :: r !! the vector integer ( ip ) :: hash !! the hash value integer :: i !! counter hash = 5381_ip do i = 1 , size ( r ) hash = ishft ( hash , 5_ip ) + hash + transfer ( r ( i ), 1_ip ) end do end function vector_djb_hash !******************************************************************************* !******************************************************************************* end module numdiff_cache_module !*******************************************************************************","tags":"","loc":"sourcefile/cache_module.f90.html"},{"title":"dag_module.f90 – AoC-2023","text":"Files dependent on this one sourcefile~~dag_module.f90~~AfferentGraph sourcefile~dag_module.f90 dag_module.f90 sourcefile~dag_example.f90 dag_example.f90 sourcefile~dag_example.f90->sourcefile~dag_module.f90 sourcefile~problem_25.f90 problem_25.f90 sourcefile~problem_25.f90->sourcefile~dag_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> !  DAG Module. module dag_module implicit none private type :: vertex !! a vertex of a directed acyclic graph (DAG) private integer , dimension (:), allocatable :: edges !! these are the vertices that this vertex depends on integer :: ivertex = 0 !! vertex number logical :: checking = . false . !! used for toposort logical :: marked = . false . !! used for toposort character ( len = :), allocatable :: label !! used for diagraph character ( len = :), allocatable :: attributes !! used for diagraph contains generic :: set_edges => set_edge_vector , add_edge procedure :: set_edge_vector procedure :: add_edge end type vertex type , public :: dag !! a directed acyclic graph (DAG) private integer :: n = 0 !! number of `vertices` type ( vertex ), dimension (:), allocatable :: vertices !! the vertices in the DAG. contains procedure , public :: set_vertices => dag_set_vertices procedure , public :: set_edges => dag_set_edges procedure , public :: set_vertex_info => dag_set_vertex_info procedure , public :: toposort => dag_toposort procedure , public :: generate_digraph => dag_generate_digraph procedure , public :: generate_dependency_matrix => dag_generate_dependency_matrix procedure , public :: save_digraph => dag_save_digraph procedure , public :: get_edges => dag_get_edges procedure , public :: get_dependencies => dag_get_dependencies procedure , public :: destroy => dag_destroy end type dag contains !******************************************************************************* !******************************************************************************* !> !  Destroy the `dag`. subroutine dag_destroy ( me ) class ( dag ), intent ( inout ) :: me me % n = 0 if ( allocated ( me % vertices )) deallocate ( me % vertices ) end subroutine dag_destroy !******************************************************************************* !******************************************************************************* !> !  specify the edge indices for this vertex subroutine set_edge_vector ( me , edges ) class ( vertex ), intent ( inout ) :: me integer , dimension (:), intent ( in ) :: edges integer :: i !! counter if ( allocated ( me % edges )) then do i = 1 , size ( edges ) call me % add_edge ( edges ( i )) end do else allocate ( me % edges ( size ( edges ))) ! note: not checking for uniqueness here. me % edges = edges end if end subroutine set_edge_vector !******************************************************************************* !******************************************************************************* !> !  add an edge index for this vertex subroutine add_edge ( me , edge ) class ( vertex ), intent ( inout ) :: me integer , intent ( in ) :: edge if ( allocated ( me % edges )) then if (. not . any ( edge == me % edges )) then me % edges = [ me % edges , edge ] ! auto lhs reallocation end if else allocate ( me % edges ( 1 )) me % edges = [ edge ] end if end subroutine add_edge !******************************************************************************* !******************************************************************************* !> !  get the edges for the vertex (all the the vertices !  that this vertex depends on). pure function dag_get_edges ( me , ivertex ) result ( edges ) implicit none class ( dag ), intent ( in ) :: me integer , intent ( in ) :: ivertex integer , dimension (:), allocatable :: edges if ( ivertex > 0 . and . ivertex <= me % n ) then edges = me % vertices ( ivertex )% edges ! auto LHS allocation end if end function dag_get_edges !******************************************************************************* !******************************************************************************* !> !  get all the vertices that depend on this vertex. pure function dag_get_dependencies ( me , ivertex ) result ( dep ) implicit none class ( dag ), intent ( in ) :: me integer , intent ( in ) :: ivertex integer , dimension (:), allocatable :: dep !! the set of all vertices !! than depend on `ivertex` integer :: i !! vertex counter if ( ivertex > 0 . and . ivertex <= me % n ) then ! have to check all the vertices: do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then if ( any ( me % vertices ( i )% edges == ivertex )) then if ( allocated ( dep )) then dep = [ dep , i ] ! auto LHS allocation else dep = [ i ] ! auto LHS allocation end if end if end if end do end if end function dag_get_dependencies !******************************************************************************* !******************************************************************************* !> !  set the number of vertices in the dag subroutine dag_set_vertices ( me , nvertices ) class ( dag ), intent ( inout ) :: me integer , intent ( in ) :: nvertices !! number of vertices integer :: i me % n = nvertices allocate ( me % vertices ( nvertices )) me % vertices % ivertex = [( i , i = 1 , nvertices )] end subroutine dag_set_vertices !******************************************************************************* !******************************************************************************* !> !  set info about a vertex in a dag. subroutine dag_set_vertex_info ( me , ivertex , label , attributes ) class ( dag ), intent ( inout ) :: me integer , intent ( in ) :: ivertex !! vertex number character ( len =* ), intent ( in ), optional :: label !! if a label is not set, !! then the integer vertex !! number is used. character ( len =* ), intent ( in ), optional :: attributes !! other attributes when !! saving as a diagraph. if ( present ( label )) then me % vertices ( ivertex )% label = label else ! just use the vertex number me % vertices ( ivertex )% label = integer_to_string ( ivertex ) end if if ( present ( attributes )) then me % vertices ( ivertex )% attributes = attributes end if end subroutine dag_set_vertex_info !******************************************************************************* !******************************************************************************* !> !  set the edges for a vertex in a dag subroutine dag_set_edges ( me , ivertex , edges ) class ( dag ), intent ( inout ) :: me integer , intent ( in ) :: ivertex !! vertex number integer , dimension (:), intent ( in ) :: edges call me % vertices ( ivertex )% set_edges ( edges ) end subroutine dag_set_edges !******************************************************************************* !******************************************************************************* !> !  Main toposort routine subroutine dag_toposort ( me , order , istat ) class ( dag ), intent ( inout ) :: me integer , dimension (:), allocatable , intent ( out ) :: order !! the toposort order integer , intent ( out ) :: istat !! Status flag: !! !! * 0 if no errors !! * -1 if circular dependency !!  (in this case, `order` will not be allocated) integer :: i , iorder if ( me % n == 0 ) return allocate ( order ( me % n )) iorder = 0 ! index in order array istat = 0 ! no errors so far do i = 1 , me % n if (. not . me % vertices ( i )% marked ) call dfs ( me % vertices ( i )) if ( istat ==- 1 ) exit end do if ( istat ==- 1 ) deallocate ( order ) contains recursive subroutine dfs ( v ) !! depth-first graph traversal type ( vertex ), intent ( inout ) :: v integer :: j if ( istat ==- 1 ) return if ( v % checking ) then ! error: circular dependency istat = - 1 else if (. not . v % marked ) then v % checking = . true . if ( allocated ( v % edges )) then do j = 1 , size ( v % edges ) call dfs ( me % vertices ( v % edges ( j ))) if ( istat ==- 1 ) return end do end if v % checking = . false . v % marked = . true . iorder = iorder + 1 order ( iorder ) = v % ivertex end if end if end subroutine dfs end subroutine dag_toposort !******************************************************************************* !******************************************************************************* !> !  Generate a Graphviz digraph structure for the DAG. ! !### Example !  * To convert this to a PDF using `dot`: `dot -Tpdf -o test.pdf test.dot`, !    where `test.dot` is `str` written to a file. function dag_generate_digraph ( me , rankdir , dpi ) result ( str ) implicit none class ( dag ), intent ( in ) :: me character ( len = :), allocatable :: str character ( len =* ), intent ( in ), optional :: rankdir !! right to left orientation (e.g. 'RL') integer , intent ( in ), optional :: dpi !! resolution (e.g. 300) integer :: i , j !! counter integer :: n_edges !! number of edges character ( len = :), allocatable :: attributes , label logical :: has_label , has_attributes character ( len =* ), parameter :: tab = '  ' !! for indenting character ( len =* ), parameter :: newline = new_line ( ' ' ) !! line break character if ( me % n == 0 ) return str = 'digraph G {' // newline // newline if ( present ( rankdir )) & str = str // tab // 'rankdir=' // rankdir // newline // newline if ( present ( dpi )) & str = str // tab // 'graph [ dpi = ' // integer_to_string ( dpi ) // ' ]' // newline // newline ! define the vertices: do i = 1 , me % n has_label = allocated ( me % vertices ( i )% label ) has_attributes = allocated ( me % vertices ( i )% attributes ) if ( has_label ) label = 'label=\"' // trim ( adjustl ( me % vertices ( i )% label )) // '\"' if ( has_label . and . has_attributes ) then attributes = '[' // trim ( adjustl ( me % vertices ( i )% attributes )) // ',' // label // ']' elseif ( has_label . and . . not . has_attributes ) then attributes = '[' // label // ']' elseif (. not . has_label . and . has_attributes ) then attributes = '[' // trim ( adjustl ( me % vertices ( i )% attributes )) // ']' else ! neither attributes = '' end if str = str // tab // integer_to_string ( i ) // ' ' // attributes // newline if ( i == me % n ) str = str // newline end do ! define the dependencies: do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then n_edges = size ( me % vertices ( i )% edges ) str = str // tab // integer_to_string ( i ) // merge ( ' -> ' , '    ' , n_edges /= 0 ) do j = 1 , n_edges ! comma-separated list: str = str // integer_to_string ( me % vertices ( i )% edges ( j )) if ( n_edges > 1 . and . j < n_edges ) str = str // ',' end do str = str // ';' // newline end if end do str = str // newline // '}' end function dag_generate_digraph !******************************************************************************* !******************************************************************************* !> !  Generate the dependency matrix for the DAG. ! !  This is an n \\times n  matrix with elements A_{ij}, !  such that A_{ij} is true if vertex i depends on vertex j. subroutine dag_generate_dependency_matrix ( me , mat ) implicit none class ( dag ), intent ( in ) :: me logical , dimension (:,:), intent ( out ), allocatable :: mat !! dependency matrix integer :: i !! vertex counter if ( me % n > 0 ) then allocate ( mat ( me % n , me % n )) mat = . false . do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then mat ( i , me % vertices ( i )% edges ) = . true . end if end do end if end subroutine dag_generate_dependency_matrix !******************************************************************************* !******************************************************************************* !> !  Generate a Graphviz digraph structure for the DAG and write it to a file. subroutine dag_save_digraph ( me , filename , rankdir , dpi ) implicit none class ( dag ), intent ( in ) :: me character ( len =* ), intent ( in ), optional :: filename !! file name for diagraph character ( len =* ), intent ( in ), optional :: rankdir !! right to left orientation (e.g. 'RL') integer , intent ( in ), optional :: dpi !! resolution (e.g. 300) integer :: iunit , istat character ( len = :), allocatable :: diagraph diagraph = me % generate_digraph ( rankdir , dpi ) open ( newunit = iunit , file = filename , status = 'REPLACE' , iostat = istat ) if ( istat == 0 ) then write ( iunit , fmt = '(A)' , iostat = istat ) diagraph else write ( * , * ) 'error opening ' // trim ( filename ) end if close ( iunit , iostat = istat ) end subroutine dag_save_digraph !******************************************************************************* !******************************************************************************* !> !  Integer to allocatable string. pure function integer_to_string ( i ) result ( s ) implicit none integer , intent ( in ) :: i character ( len = :), allocatable :: s integer :: istat allocate ( character ( len = 64 ) :: s ) ! should be big enough write ( s , fmt = '(ss,I0)' , iostat = istat ) i if ( istat == 0 ) then s = trim ( adjustl ( s )) else s = '***' end if end function integer_to_string !******************************************************************************* !******************************************************************************* end module dag_module !*******************************************************************************","tags":"","loc":"sourcefile/dag_module.f90.html"},{"title":"problem_03.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_03.f90~~EfferentGraph sourcefile~problem_03.f90 problem_03.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_03.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_3 use iso_fortran_env use aoc_utilities implicit none integer :: n_lines , i , j , n_cols , jstart , jend logical :: adjacent , tmp integer ( ip ) :: isum character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:), allocatable :: ivals call clk % tic () ! read file: ! pad around with blanks to simplify logic below array = read_file_to_char_array ( 'inputs/day3.txt' , border = '.' ) n_lines = size ( array , 1 ) n_cols = size ( array , 2 ) !----------------- part 1 ----------------- isum = 0 do i = 1 , n_lines ! is this character adjacent to a symbol? jend = 0 do j = 1 , n_cols if ( is_not_number ( array ( i , j ))) cycle if ( j <= jend ) cycle ! skip the cols that we already have jend = 0 adjacent = is_symbol ( array ( i - 1 , j ) ) . or . & is_symbol ( array ( i - 1 , j - 1 )) . or . & is_symbol ( array ( i - 1 , j + 1 )) . or . & is_symbol ( array ( i , j - 1 ) ) . or . & is_symbol ( array ( i , j + 1 ) ) . or . & is_symbol ( array ( i + 1 , j ) ) . or . & is_symbol ( array ( i + 1 , j - 1 )) . or . & is_symbol ( array ( i + 1 , j + 1 )) if ( adjacent ) isum = isum + get_number ( i , j ) ! note: this sets jend end do end do write ( * , * ) '3a: sum :' , isum !----------------- part 2 ----------------- ! now look for '*' and find adjacent numbers .... isum = 0 do i = 1 , n_lines do j = 1 , n_cols if ( array ( i , j ) == '*' ) then ! look for 2 adjacent numbers. if ( allocated ( ivals )) deallocate ( ivals ); allocate ( ivals ( 0 )) ! above tmp = check ( i - 1 , j ) ! if only one on top if (. not . tmp ) then tmp = check ( i - 1 , j - 1 ) tmp = check ( i - 1 , j + 1 ) end if tmp = check ( i , j - 1 ) ! left and right tmp = check ( i , j + 1 ) ! below tmp = check ( i + 1 , j ) ! if only one below if (. not . tmp ) then tmp = check ( i + 1 , j - 1 ) tmp = check ( i + 1 , j + 1 ) end if if ( size ( ivals ) == 2 ) isum = isum + product ( ivals ) ! sum gear ratio end if end do end do write ( * , * ) '3b: result :' , isum call clk % toc ( '3' ) contains logical function check ( i , j ) !! if the char is part of a number, then get it and append to ivals integer , intent ( in ) :: i , j check = is_number ( array ( i , j )) if ( check ) ivals = [ ivals , get_number ( i , j )] end function check logical function is_symbol ( c ) character ( len = 1 ), intent ( in ) :: c is_symbol = is_not_number ( c ) . and . c /= '.' end function is_symbol integer ( ip ) function get_number ( i , j ) !! get the full number contining the character at i,j integer , intent ( in ) :: i , j jstart = j jend = j do if ( array ( i , jstart - 1 ) == '.' . or . is_symbol ( array ( i , jstart - 1 ))) exit jstart = jstart - 1 end do do if ( array ( i , jend + 1 ) == '.' . or . is_symbol ( array ( i , jend + 1 ))) exit jend = jend + 1 end do get_number = int ( array ( i , jstart : jend )) end function get_number end program problem_3","tags":"","loc":"sourcefile/problem_03.f90.html"},{"title":"problem_17.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_17.f90~~EfferentGraph sourcefile~problem_17.f90 problem_17.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_17.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_17 use aoc_utilities use iso_fortran_env !! Based on AOC 2021 Day 15: https://github.com/jacobwilliams/AoC-2021/blob/master/test/problem_15.f90 !! see: https://en.wikipedia.org/wiki/Dijkstra's_algorithm#Pseudocode !! !! only difference is the constraint that it can move at most three blocks in a single direction implicit none integer , parameter :: NSTATE = 4 !! number of state dimensions [i,j,direction,moves_in_that_direction] integer , parameter :: N_DIRECTIONS = 4 ! 1,2,3,4 integer ( ip ), parameter :: UP = 1 ! direction traveling integer ( ip ), parameter :: DOWN = - 1 integer ( ip ), parameter :: LEFT = 2 integer ( ip ), parameter :: RIGHT = - 2 integer , parameter :: MAX_MOVES_IN_DIR = 3 ! queue for the states and distances... rather than constructing the 2d array... ! just create this as we go... type :: item integer ( ip ), dimension ( NSTATE ) :: state = 0 !! state: [i, j, direction, and # of moves] integer ( ip ) :: dist = huge ( 1 ) !! distance for this one logical :: visited = . false . !! if this one is done integer ( ip ) :: iprev = - 1 !! index in the queue of the previous one end type item type ( item ), dimension (:), allocatable :: queue !! will be expanding integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: idx integer :: i , j , n_rows , n_cols integer , dimension (:,:), allocatable :: map !! heat map ! for the CI ! need a faster version ... write ( * , * ) 'it works but takes a few minutes...' stop call clk % tic () ! map = read_file_to_int_array('inputs/day17_test.txt') map = read_file_to_int_array ( 'inputs/day17.txt' ) n_rows = size ( map , 1 ) n_cols = size ( map , 2 ) call add_to_queue ([ 1_ip , 1_ip , 0_ip , 0_ip ], idx ) ! start queue ( idx )% dist = 0 do ! find min distance so far for ones not visited iloc = minloc ( queue % dist , mask = . not . queue % visited ) idx = iloc ( 1 ) ! index in the queue queue ( idx )% visited = . true . !write(*,*) 'visited ', queue(idx)%state(1), queue(idx)%state(2), n_rows, n_cols if ( queue ( idx )% state ( 1 ) == n_rows . and . queue ( idx )% state ( 2 ) == n_cols ) exit ! destination: we are done ! process ajacent ones: call check ( idx , UP ) call check ( idx , DOWN ) call check ( idx , LEFT ) call check ( idx , RIGHT ) end do write ( * , * ) '15a: ' , queue ( idx )% dist ! ...draw the path ! block !     character(len=1),dimension(:,:),allocatable :: char_map !     char_map = int_array_to_char_array(map) !     do !         char_map(queue(idx)%state(1),queue(idx)%state(2)) = '#' !         if (queue(idx)%state(1)==1) then !             write(*,*) queue(idx)%state !         end if !         if (queue(idx)%state(1)==1 .and. queue(idx)%state(2)==1) exit !         idx = queue(idx)%iprev !     end do !     write(*,*) ' path: ' !     do i = 1, n_rows !         write(*,'(*(A1))') char_map(i,:) !     end do ! end block call clk % toc ( '17' ) contains subroutine check ( idx , idirection ) implicit none integer ( ip ), intent ( in ) :: idx ! current item in the queue to process integer ( ip ), intent ( in ) :: idirection !! direction to move from current integer ( ip ) :: alt integer ( ip ), dimension ( 2 ) :: v ! neighbor to move to integer ( ip ) :: imovesv , idxv , distv integer ( ip ), dimension ( NSTATE ) :: istate logical :: in_queue associate ( i => queue ( idx )% state ( 1 ), & j => queue ( idx )% state ( 2 ), & direction => queue ( idx )% state ( 3 ), & n_moves => queue ( idx )% state ( 4 )) if ( direction ==- idirection ) return ! can't reverse ! the one to go to: if ( direction == idirection ) then if ( n_moves == MAX_MOVES_IN_DIR ) return ! can't move in this direction anymore imovesv = n_moves + 1 else imovesv = 1 ! reset on change of direction end if select case ( idirection ) case ( UP ); v = [ i - 1 , j ] case ( DOWN ); v = [ i + 1 , j ] case ( LEFT ); v = [ i , j - 1 ] case ( RIGHT ); v = [ i , j + 1 ] end select if ( v ( 1 ) < 1 . or . v ( 2 ) < 1 . or . v ( 1 ) > n_rows . or . v ( 2 ) > n_cols ) return ! can't go off the board istate = [ v ( 1 ), v ( 2 ), idirection , imovesv ] ! new state idxv = index_in_queue ( istate ) ! is it already in the queue in_queue = idxv > 0 ! if this one is already part of another path if ( in_queue ) then if ( queue ( idxv )% visited ) return ! already visited this one distv = queue ( idxv )% dist ! distance in the queue else !call add_to_queue(istate, idxv) ! add this to the queue for processing ! always add it ?? distv = huge ( 1_ip ) ! not processed yet, so huge number end if !alt = queue(idx)%dist + map(queue(idxv)%state(1), queue(idxv)%state(2)) alt = queue ( idx )% dist + map ( v ( 1 ), v ( 2 )) ! new distance if ( alt < distv ) then ! the new one is better, so replace values in the queue if (. not . in_queue ) call add_to_queue ( istate , idxv ) ! only add it if we accept it ???? ! accept this step queue ( idxv )% dist = alt ! new best dist queue ( idxv )% iprev = idx ! previous end if end associate end subroutine check ! .. need a faster queue... function index_in_queue ( state ) result ( idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ) :: idx !! index in the queue. -1 if not present integer :: i idx = - 1 if (. not . allocated ( queue )) error stop 'error: queue not allocated' do i = 1 , size ( queue ) if ( all ( state == queue ( i )% state )) then idx = i return end if end do end function index_in_queue subroutine add_to_queue ( state , idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ), intent ( out ) :: idx !! index of the element in the queue if ( allocated ( queue )) then queue = [ queue , item ( state = state )] idx = size ( queue ) else queue = [ item ( state = state )] idx = 1 end if end subroutine add_to_queue end program problem_17","tags":"","loc":"sourcefile/problem_17.f90.html"},{"title":"problem_13.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_13.f90~~EfferentGraph sourcefile~problem_13.f90 problem_13.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_13.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_13 use iso_fortran_env use aoc_utilities implicit none integer :: i , iunit , iline , n_lines , ival , isum , ival2 , isum2 , & m , n , nrows , ncols , ileft , iabove , ileft2 , iabove2 type ( string ), dimension (:), allocatable :: lines integer , dimension (:,:), allocatable :: puzzle , puzzle2 character ( len = :), allocatable :: line integer , parameter :: ASH = 0 !! . integer , parameter :: ROCK = 1 !! # call clk % tic () ! open(newunit=iunit, file='inputs/day13_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day13.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 isum2 = 0 do iline = 1 , n_lines line = read_line ( iunit ) if ( line == '' . or . iline == n_lines ) then ! process this puzzle ! convert the puzzle to a numeric matrix: if ( allocated ( puzzle )) deallocate ( puzzle ) nrows = size ( lines ) ncols = len ( lines ( 1 )% str ) allocate ( puzzle ( nrows , ncols )) do i = 1 , nrows puzzle ( i ,:) = str_to_int_array_with_mapping ( lines ( i )% str , [ '.' , '#' ], [ ASH , ROCK ]) end do ! part 1 call go ( puzzle , ileft ) call go ( transpose ( puzzle ), iabove ) ival = ileft + 100 * iabove isum = isum + ival ! part 2 main : do m = 1 , nrows do n = 1 , ncols ! permute each with a smudge and find the different non-zero value puzzle2 = puzzle if ( puzzle ( m , n ) == ASH ) then puzzle2 ( m , n ) = ROCK else puzzle2 ( m , n ) = ASH end if ! don't consider the one from part a (since that one still may be valid) call go ( puzzle2 , ileft2 , iskip = ileft ) call go ( transpose ( puzzle2 ), iabove2 , iskip = iabove ) if (( ileft2 /= ileft . or . iabove2 /= iabove ) . and . ( ileft2 /= 0 . or . iabove2 /= 0 )) then ival = ileft2 + 100 * iabove2 ! found it exit main end if end do end do main isum2 = isum2 + ival deallocate ( lines ) else ! accumulate this line in the current puzzle if (. not . allocated ( lines )) allocate ( lines ( 0 )) lines = [ lines , string ( line )] end if end do write ( * , * ) '13a: ' , isum write ( * , * ) '13b: ' , isum2 call clk % toc ( '13' ) contains subroutine go ( puzzle , ileft , iskip ) !! compute the number of cols to left of mirror (0 if none) !! call with transpose(puzzle) to get number of rows above. integer , dimension (:,:), intent ( in ) :: puzzle integer , intent ( out ) :: ileft integer , intent ( in ), optional :: iskip !! don't consider this column integer :: nrows , ncols , i , j logical :: mirror nrows = size ( puzzle , 1 ) ncols = size ( puzzle , 2 ) ileft = 0 do i = 1 , ncols - 1 if ( present ( iskip )) then if ( i == iskip ) cycle end if mirror = . true . do j = 1 , min ( i , ncols - i ) if ( any ( puzzle (:, i - j + 1 ) /= puzzle (:, i + j )) ) then mirror = . false . ! no mirror on this line exit end if end do if ( mirror ) then ileft = i exit end if end do end subroutine go end program problem_13","tags":"","loc":"sourcefile/problem_13.f90.html"},{"title":"problem_25.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_25.f90~~EfferentGraph sourcefile~problem_25.f90 problem_25.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_25.f90->sourcefile~aoc_utilities.f90 sourcefile~dag_module.f90 dag_module.f90 sourcefile~problem_25.f90->sourcefile~dag_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_25 use aoc_utilities use dag_module implicit none integer :: iunit , n_lines , i , j , n_nodes , inode , inode2 character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals , vals2 character ( len = 3 ) :: node1 , node2 character ( len = 3 ), dimension (:), allocatable :: nodes integer , dimension (:), allocatable :: inodedep , icounts character ( len =* ), parameter :: filetype = 'pdf' type ( dag ) :: d type :: node_t !character(len=3) :: name = '' integer , dimension (:), allocatable :: connections !! the ones connected to this one end type node_t type ( node_t ), dimension (:), allocatable :: graph !! index is the node number logical , dimension (:), allocatable :: visited call clk % tic () ! read the data: ! open(newunit=iunit, file='inputs/day25_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day25.txt' , status = 'OLD' ) allocate ( nodes ( 0 )) n_lines = number_of_lines_in_file ( iunit ) do i = 1 , n_lines line = read_line ( iunit ) ! for starters, get a list of all the nodes vals = split ( line , ': ' ) node1 = vals ( 1 )% str if (. not . any ( nodes == node1 )) nodes = [ nodes , node1 ] vals2 = split ( vals ( 2 )% str , ' ' ) do j = 1 , size ( vals2 ) node2 = vals2 ( j )% str if (. not . any ( nodes == node2 )) nodes = [ nodes , node2 ] end do end do rewind ( iunit ) n_nodes = size ( nodes ) ! create a dag: call d % set_vertices ( n_nodes ) allocate ( graph ( n_nodes )) !... do i = 1 , n_nodes allocate ( graph ( i )% connections ( 0 )) ! initialize end do do i = 1 , n_lines line = read_line ( iunit ) ! for starters, get a list of all the nodes vals = split ( line , ': ' ) node1 = vals ( 1 )% str inode = node_index ( node1 ) !inode = findloc(nodes,node1) if (. not . any ( nodes == node1 )) nodes = [ nodes , node1 ] vals2 = split ( vals ( 2 )% str , ' ' ) if ( allocated ( inodedep )) deallocate ( inodedep ) allocate ( inodedep ( 0 )) do j = 1 , size ( vals2 ) node2 = vals2 ( j )% str inode2 = node_index ( node2 ) !-------------------------------------------- ! prune the ones by inspection by looking at the graph, opening in Inkscape, ! coloring the 3 lines and finding the nodes that connect them if ( ( node1 == 'ljm' . and . node2 == 'sfd' ) . or . ( node2 == 'ljm' . and . node1 == 'sfd' ) ) cycle if ( ( node1 == 'gst' . and . node2 == 'rph' ) . or . ( node2 == 'gst' . and . node1 == 'rph' ) ) cycle if ( ( node1 == 'jkn' . and . node2 == 'cfn' ) . or . ( node2 == 'jkn' . and . node1 == 'cfn' ) ) cycle !-------------------------------------------- ! accumulate the graph: ! connection between inode <--> inodedep graph ( inode )% connections = [ graph ( inode )% connections , inode2 ] graph ( inode2 )% connections = [ graph ( inode2 )% connections , inode ] ! for the plot: inodedep = [ inodedep , inode2 ] end do call d % set_edges ( inode , inodedep ) end do ! define some styles for the GraphViz output: do i = 1 , n_nodes call d % set_vertex_info ( i , label = nodes ( i )) end do ! generate the GraphViz output: call d % save_digraph ( 'problem25.dot' , rankdir = 'TB' , dpi = 300 ) call d % destroy () call execute_command_line ( 'dot -Tpdf -o problem25.pdf problem25.dot' ) ! add to dot file:  !todo add this to daglib ... ! mindist=10 ! ranksep=20 ! count the ones connected to each node and get the unique two we need allocate ( visited ( n_nodes )) allocate ( icounts ( 0 )) do i = 1 , n_lines visited = . false . call traverse ( i ) icounts = unique ([ icounts , count ( visited )]) write ( * , * ) i , icounts end do write ( * , * ) '25a:' , product ( icounts ) call clk % toc ( '25' ) contains pure integer function node_index ( node ) !! find the node number for this name character ( len =* ), intent ( in ) :: node integer , dimension ( 1 ) :: idx idx = findloc ( nodes , node ) node_index = idx ( 1 ) end function node_index recursive subroutine traverse ( i ) !! travere the graph and visit all the connected nodes integer , intent ( in ) :: i integer :: j if ( visited ( i )) return visited ( i ) = . true . do j = 1 , size ( graph ( i )% connections ) call traverse ( graph ( i )% connections ( j )) end do end subroutine traverse end program problem_25","tags":"","loc":"sourcefile/problem_25.f90.html"},{"title":"problem_07.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_07.f90~~EfferentGraph sourcefile~problem_07.f90 problem_07.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_07.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_7 use iso_fortran_env use aoc_utilities implicit none integer :: i , iunit , n_lines , icase character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals logical :: done type :: hand character ( len = 1 ), dimension ( 5 ) :: cards !! the cards in a hand integer ( ip ) :: bid = 0 ! the bit for the hand integer :: type = 0 ! the hand type end type hand type ( hand ), dimension (:), allocatable :: hands !! array of hands character ( len = 1 ), dimension ( 2 ), parameter :: cases = [ 'a' , 'b' ] character ( len = 1 ), dimension ( * ), parameter :: cards = [ 'A' , 'K' , 'Q' , 'J' , 'T' , & '9' , '8' , '7' , '6' , '5' , & '4' , '3' , '2' ] character ( len = 1 ), dimension ( * ), parameter :: cards_with_joker = [ 'A' , 'K' , 'Q' , 'T' , & '9' , '8' , '7' , '6' , '5' , & '4' , '3' , '2' , 'J' ] integer , parameter :: FIVE_OF_A_KIND = 1 ! the hand types integer , parameter :: FOUR_OF_A_KIND = 2 integer , parameter :: FULL_HOUSE = 3 integer , parameter :: THREE_OF_A_KIND = 4 integer , parameter :: TWO_PAIR = 5 integer , parameter :: ONE_PAIR = 6 integer , parameter :: HIGH_CARD = 7 call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day7_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day7.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( hands ( n_lines )) do i = 1 , n_lines line = read_line ( iunit ); vals = split ( line , ' ' ) hands ( i )% cards = str_to_array ( vals ( 1 )% str ) hands ( i )% bid = int ( vals ( 2 )) end do close ( iunit ) do icase = 1 , 2 ! first time normally, second time processing the jokers ! sort the list from worst to best to determinte the rank of each hand hands % type = 0 ! reinitialize since they need to be recomputed do ! bubble sort ! done = . true . do i = 1 , n_lines - 1 if ( beats ( hands ( i ), hands ( i + 1 ), icase == 2 )) then call swap_hands ( hands ( i ), hands ( i + 1 )); done = . false . end if end do if ( done ) exit end do write ( * , * ) '7' // cases ( icase ) // ':' , sum ( hands % bid * [( i , i = 1 , n_lines )]) end do call clk % toc ( '7' ) contains integer function hand_type ( me , with_jokers ) !! returns the type of hand class ( hand ), intent ( in ) :: me logical , intent ( in ) :: with_jokers !! if considering jokers integer , dimension ( 5 ) :: i integer , dimension (:), allocatable :: u integer :: n_jokers , n_unique character ( len = 1 ), dimension ( 5 ) :: h h = me % cards i = ichar ( h ) ! convert to code u = unique ( i ) ! unique elements n_unique = size ( u ) if ( with_jokers . and . any ( h == 'J' )) then ! have to pick best hand for all jokers ! just do it by inspection n_jokers = count ( h == 'J' ) select case ( n_jokers ) case ( 5 ) hand_type = FIVE_OF_A_KIND !jjjjj case ( 4 ) hand_type = FIVE_OF_A_KIND !jjjja case ( 3 ) ! can always turn to 4 or 5 of a kind if ( n_unique == 2 ) then !jjjaa hand_type = FIVE_OF_A_KIND else ! jjjab hand_type = FOUR_OF_A_KIND end if case ( 2 ) if ( n_unique == 2 ) then !jjaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then !jjaab hand_type = FOUR_OF_A_KIND else !jjabc hand_type = THREE_OF_A_KIND end if case ( 1 ) if ( n_unique == 2 ) then !jaaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then if ( any ([ count ( i == u ( 1 )) == 3 , & count ( i == u ( 2 )) == 3 , & count ( i == u ( 3 )) == 3 ]) ) then !jaaab hand_type = FOUR_OF_A_KIND elseif ( ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 ) . or . & ( count ( i == u ( 2 )) == 2 . and . count ( i == u ( 2 )) == 2 ) ) then !jaabb hand_type = FULL_HOUSE end if else if ( n_unique == 4 ) then !jaabc hand_type = THREE_OF_A_KIND else if ( n_unique == 5 ) then !jabcd hand_type = ONE_PAIR end if end select else !Every hand is exactly one type. From strongest to weakest, they are: select case ( n_unique ) case ( 1 ) ! aaaaa hand_type = FIVE_OF_A_KIND case ( 2 ) ! aaaab, aaabb if (( count ( i == u ( 1 )) == 4 . and . count ( i == u ( 2 )) == 1 ) . or . & ( count ( i == u ( 1 )) == 1 . and . count ( i == u ( 2 )) == 4 ) ) then hand_type = FOUR_OF_A_KIND else if (( count ( i == u ( 1 )) == 3 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 3 ) ) then hand_type = FULL_HOUSE end if case ( 3 ) ! aaabc, aabcc if ( any ([ count ( i == u ( 1 )) == 3 , count ( i == u ( 2 )) == 3 , count ( i == u ( 3 )) == 3 ]) ) then hand_type = THREE_OF_A_KIND else if ( any ([ count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 , & count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 , & count ( i == u ( 2 )) == 2 . and . count ( i == u ( 3 )) == 2 ]) ) then hand_type = TWO_PAIR end if case ( 4 ) !aabcd hand_type = ONE_PAIR case ( 5 ) !abcde hand_type = HIGH_CARD ! High card, where all cards' labels are distinct: 23456 end select end if end function hand_type logical function beats ( hand1 , hand2 , with_jokers ) !! return true if hand1 beats hand2 (has a higher score) class ( hand ), intent ( inout ) :: hand1 , hand2 logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i associate ( h1 => hand1 % cards , h2 => hand2 % cards ) ! recompute type if it hasn't already been computed if ( hand1 % type == 0 ) hand1 % type = hand_type ( hand1 , with_jokers ) if ( hand2 % type == 0 ) hand2 % type = hand_type ( hand2 , with_jokers ) if ( hand1 % type == hand2 % type ) then ! lower index is stronger do i = 1 , 5 if ( h1 ( i ) /= h2 ( i )) then beats = index_in_cards ( h1 ( i ), with_jokers ) < & index_in_cards ( h2 ( i ), with_jokers ) ! lower is stronger return end if end do else ! one hand beat the other beats = hand1 % type < hand2 % type ! lower score is better (1-7) end if end associate end function beats integer function index_in_cards ( c , with_jokers ) character ( len = 1 ), intent ( in ) :: c logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i do i = 1 , size ( cards_with_joker ) if ( with_jokers ) then if ( c == cards_with_joker ( i )) then index_in_cards = i return end if else if ( c == cards ( i )) then index_in_cards = i return end if end if end do error stop 'card not found' end function index_in_cards pure elemental subroutine swap_hands ( i1 , i2 ) !! swap function for hand type type ( hand ), intent ( inout ) :: i1 type ( hand ), intent ( inout ) :: i2 type ( hand ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_hands end program problem_7","tags":"","loc":"sourcefile/problem_07.f90.html"},{"title":"problem_02.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_02.f90~~EfferentGraph sourcefile~problem_02.f90 problem_02.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_02.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_2 use iso_fortran_env use aoc_utilities implicit none integer :: iunit logical :: status_ok , game_possible character ( len = :), allocatable :: line , color integer :: n_lines , id , j , k , ipossible , inum , min_red , min_green , min_blue , power type ( string ), dimension (:), allocatable :: vals , trys , cubes , num_color integer , parameter :: n_red = 12 integer , parameter :: n_green = 13 integer , parameter :: n_blue = 14 call clk % tic () !example: Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green open ( newunit = iunit , file = 'inputs/day2.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) ! will parse the line with successive splits ipossible = 0 power = 0 main : do id = 1 , n_lines game_possible = . true . min_red = 0 ; min_green = 0 ; min_blue = 0 line = read_line ( iunit , status_ok ) vals = split ( line , ': ' ) trys = split ( vals ( 2 ), '; ' ) do j = 1 , size ( trys ) cubes = split ( trys ( j ), ', ' ) do k = 1 , size ( cubes ) num_color = split ( cubes ( k ), ' ' ) inum = int ( num_color ( 1 )% str ) color = num_color ( 2 )% str select case ( color ) case ( 'red' ) if ( inum > n_red ) game_possible = . false . if ( inum > min_red ) min_red = inum case ( 'green' ) if ( inum > n_green ) game_possible = . false . if ( inum > min_green ) min_green = inum case ( 'blue' ) if ( inum > n_blue ) game_possible = . false . if ( inum > min_blue ) min_blue = inum end select end do end do power = power + ( min_red * min_green * min_blue ) if ( game_possible ) ipossible = ipossible + id end do main write ( * , * ) '2a: result   :' , ipossible write ( * , * ) '2b: power sum:' , power close ( iunit ) call clk % toc ( '2' ) end program problem_2","tags":"","loc":"sourcefile/problem_02.f90.html"},{"title":"problem_18.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_18.f90~~EfferentGraph sourcefile~problem_18.f90 problem_18.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_18.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_18 use aoc_utilities use iso_fortran_env implicit none integer ( ip ) :: iresult call clk % tic () call go (. false ., iresult ); write ( * , * ) '18a:' , iresult call go (. true ., iresult ); write ( * , * ) '18b:' , iresult call clk % toc ( '18' ) contains subroutine go ( partb , iresult ) logical , intent ( in ) :: partb !! if solving part b integer ( ip ), intent ( out ) :: iresult integer :: iunit , iline , n_lines , n character ( len = :), allocatable :: line , hex type ( string ), dimension (:), allocatable :: vals character ( len = 1 ) :: direction integer ( ip ), dimension ( 2 ) :: iloc , iloc2 integer ( ip ) :: ival , isteps real ( wp ), dimension (:), allocatable :: xvec , yvec character ( len = 1 ), dimension ( 0 : 3 ) :: direction_str = [ 'R' , 'D' , 'L' , 'U' ] ! directions for part b : 0,1,2,3 ! open(newunit=iunit, file='inputs/day18_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day18.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) iloc = [ 0 , 0 ] ! where to start isteps = 0 xvec = [ 0 ]; yvec = [ 0 ] do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ! direction, number, (hex) if ( partb ) then ! values encoded in hex hex = vals ( 3 )% str ival = hex2int ( hex ( 3 : 7 )) direction = direction_str ( int ( hex ( 8 : 8 ))) else direction = vals ( 1 )% str ival = int ( vals ( 2 )% str ) end if isteps = isteps + ival ! keep track of the total perimeter size iloc2 = destination ( iloc , direction , ival ) ! destination oint xvec = [ xvec , real ( iloc2 ( 1 ), wp )] ! save the points of the polygon yvec = [ yvec , real ( iloc2 ( 2 ), wp )] ! iloc = iloc2 ! update for next move end do close ( iunit ) ! the area including the boundary = area + 1/2 the perimeter + 1 ! using NSWC parea function! n = size ( xvec ) iresult = int ( abs ( parea ( yvec , xvec , n )) + real ( isteps , wp ) / 2_ip + 1_ip , ip ) end subroutine go pure function destination ( initial , direction , steps ) result ( final ) !! get destination point integer ( ip ), dimension ( 2 ), intent ( in ) :: initial character ( len = 1 ), intent ( in ) :: direction integer ( ip ), intent ( in ) :: steps integer ( ip ), dimension ( 2 ) :: final !! x,y of desination point select case ( direction ) case ( 'R' ); final = [ initial ( 1 ), initial ( 2 ) + steps ] case ( 'L' ); final = [ initial ( 1 ), initial ( 2 ) - steps ] case ( 'D' ); final = [ initial ( 1 ) + steps , initial ( 2 )] case ( 'U' ); final = [ initial ( 1 ) - steps , initial ( 2 )] end select end function destination end program problem_18","tags":"","loc":"sourcefile/problem_18.f90.html"},{"title":"problem_11.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_11.f90~~EfferentGraph sourcefile~problem_11.f90 problem_11.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_11.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_11 use iso_fortran_env use aoc_utilities implicit none call clk % tic () write ( * , * ) '11a: ' , go ( 2_ip ) write ( * , * ) '11b: ' , go ( 1000000_ip ) call clk % toc ( '11' ) contains integer ( ip ) function go ( expansion_factor ) integer ( ip ), intent ( in ) :: expansion_factor integer :: i , j , nrows , ncols , n_galaxies , n , k character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:,:), allocatable :: idists integer ( ip ), dimension (:), allocatable :: igal , jgal integer ( ip ), dimension (:,:), allocatable :: ix , iy ! array = read_file_to_char_array('inputs/day11_test.txt') array = read_file_to_char_array ( 'inputs/day11.txt' ) nrows = size ( array , 1 ); ncols = size ( array , 2 ) n_galaxies = count ( array == '#' ) ! track the real indices after expansion ix = transpose ( spread ([( i , i = 1 , ncols )], 1 , nrows )) ! row indices iy = spread ([( i , i = 1 , nrows )], 1 , ncols ) ! col indices igal = pack ( ix , array == '#' ) ! indices of galaxies jgal = pack ( iy , array == '#' ) ! expand the array, keeping track of the new row indices do i = 1 , nrows ! add rows if necessary if ( all ( array ( i ,:) == '.' )) ix ( i :,:) = ix ( i :,:) + expansion_factor - 1 ! new row end do do j = 1 , ncols ! add cols if necessary if ( all ( array (:, j ) == '.' )) iy (:, j :) = iy (:, j :) + expansion_factor - 1 ! new column end do ! now compute all the distances: allocate ( idists ( n_galaxies , n_galaxies )); idists = 0 do i = 1 , n_galaxies do j = 1 , n_galaxies if ( j <= i ) cycle ! only need the lower diagonal idists ( i , j ) = manhatten_distance ( ix ( igal ( i ), jgal ( i )), iy ( igal ( i ), jgal ( i )),& ix ( igal ( j ), jgal ( j )), iy ( igal ( j ), jgal ( j ))) end do end do go = sum ( idists ) end function go end program problem_11","tags":"","loc":"sourcefile/problem_11.f90.html"},{"title":"nlesolver_module.F90 – AoC-2023","text":"This file depends on sourcefile~~nlesolver_module.f90~~EfferentGraph sourcefile~nlesolver_module.f90 nlesolver_module.F90 sourcefile~fmin_module.f90 fmin_module.F90 sourcefile~nlesolver_module.f90->sourcefile~fmin_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~nlesolver_module.f90~~AfferentGraph sourcefile~nlesolver_module.f90 nlesolver_module.F90 sourcefile~nlesolver_test_1.f90 nlesolver_test_1.f90 sourcefile~nlesolver_test_1.f90->sourcefile~nlesolver_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !****************************************************************************************************** !> !  A basic multidimensional nonlinear equation solver, using a Newton-Raphson type direct method. ! !### Features !  * Works with square, under-determined, or over-determined systems. !  * Uses LAPACK routines (`dgesv` or `dgels`) to solve the linear system. !  * Has a Broyden update option. !  * Has various line search options. ! !### References !  * https://en.wikipedia.org/wiki/Backtracking_line_search !  * http://projecteuclid.org/download/pdf_1/euclid.pjm/1102995080 !  * http://help.agi.com/stk/index.htm#gator/eq-diffcorr.htm !  * http://gmat.sourceforge.net/doc/R2015a/html/DifferentialCorrector.html ! !### Author !  * Jacob Williams ! !### License !  * BSD-3 ! !@todo add an `istat` output to func and grad, for user stopping !      or to take a smaller stop (if istat>0 take a smaller step, if istat<0 abort) ! !@note The default real kind (`wp`) can be !      changed using optional preprocessor flags. !      This library was built with real kind: #ifdef REAL32 !      `real(kind=real32)` [4 bytes] #elif REAL64 !      `real(kind=real64)` [8 bytes] #elif REAL128 !      `real(kind=real128)` [16 bytes] #else !      `real(kind=real64)` [8 bytes] #endif module nlesolver_module use iso_fortran_env use fmin_module , only : fmin implicit none private #ifdef REAL32 integer , parameter , public :: nlesolver_rk = real32 !! real kind used by this module [4 bytes] #elif REAL64 integer , parameter , public :: nlesolver_rk = real64 !! real kind used by this module [8 bytes] #elif REAL128 integer , parameter , public :: nlesolver_rk = real128 !! real kind used by this module [16 bytes] #else integer , parameter , public :: nlesolver_rk = real64 !! real kind used by this module [8 bytes] #endif integer , parameter :: wp = nlesolver_rk !! local copy of `nlesolver_rk` with a shorter name real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: two = 2.0_wp real ( wp ), parameter :: eps = epsilon ( one ) !! machine  \\epsilon  real ( wp ), parameter :: big = huge ( one ) !********************************************************* type , public :: nlesolver_type !! Nonlinear equations solver class. private integer :: n = 0 !! number of opt vars integer :: m = 0 !! number of constraints integer :: max_iter = 100 !! maximum number of iterations real ( wp ) :: tol = 1.0e-6_wp !! convergence tolerance for function values real ( wp ) :: alpha = 1.0_wp !! step length (when specified constant) real ( wp ) :: alpha_min = 0.1_wp !! minimum step length (when allowed to vary) real ( wp ) :: alpha_max = 1.0_wp !! maximum step length (when allowed to vary) real ( wp ) :: tolx = 1.0e-8_wp !! convergence tolerance for `x` real ( wp ) :: c = 0.5_wp !! backtracking linesearch parameter (0,1) real ( wp ) :: tau = 0.5_wp !! backtracking linesearch parameter (0,1) real ( wp ) :: fmin_tol = 1.0e-5_wp !! tolerance for \"exact\" linesearch integer :: n_intervals = 2 !! number of intervals for fixed point linesearch logical :: use_broyden = . false . !! if true, a Broyden update is used !! rather than computing the Jacobian !! at every step. The `grad` function is !! only called for the initial evaluation. integer :: broyden_update_n = 4 !! if this value is `>0`, the Broyden update !! is computed at most this many times before !! the full Jacobian is recomputed. integer :: n_uphill_max = 5 !! maximum number of consecutive steps !! to allow where the value of `f` increases logical :: verbose = . false . !! verbose output printing integer :: iunit = output_unit !! output unit for printing (assumed to be open). character ( len = :), allocatable :: message !! latest status message integer :: istat = - 999 !! latest status message procedure ( func_func ), pointer :: func => null () !! user-supplied routine to compute the function procedure ( grad_func ), pointer :: grad => null () !! user-supplied routine tocompute the gradient of the function procedure ( export_func ), pointer :: export_iteration => null () !! user-supplied routine to export iterations procedure ( wait_func ), pointer :: user_input_check => null () !! user-supplied routine to enable user to stop iterations procedure ( linesearch_func ), pointer :: linesearch => null () !! line search method (determined by `step_mode` user input in [[nlesolver_type:initialize]]) contains private procedure , public :: initialize => initialize_nlesolver_variables procedure , public :: solve => nlesolver_solver procedure , public :: destroy => destroy_nlesolver_variables procedure , public :: status => get_status procedure :: set_status end type nlesolver_type !********************************************************* abstract interface subroutine func_func ( me , x , f ) !! compute the function import :: wp , nlesolver_type implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f end subroutine func_func subroutine grad_func ( me , x , g ) !! compute the gradient of the function (Jacobian): import :: wp , nlesolver_type implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:,:), intent ( out ) :: g end subroutine grad_func subroutine export_func ( me , x , f , iter ) !! export an iteration: import :: wp , nlesolver_type implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: f integer , intent ( in ) :: iter !! iteration number end subroutine export_func subroutine wait_func ( me , user_stop ) !! enable a user-triggered stop of the iterations: import :: wp , nlesolver_type implicit none class ( nlesolver_type ), intent ( inout ) :: me logical , intent ( out ) :: user_stop end subroutine wait_func subroutine linesearch_func ( me , xold , p , fjac , x , f , fvec ) !! line search method. Note that not all inputs/outputs are !! used by all methods. import :: wp , nlesolver_type implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: xold !! previous value of `x` real ( wp ), dimension ( me % n ), intent ( in ) :: p !! search direction real ( wp ), dimension ( me % m , me % n ), intent ( in ) :: fjac !! jacobian matrix real ( wp ), dimension ( me % n ), intent ( out ) :: x !! new `x` real ( wp ), intent ( inout ) :: f !! input: current magnitude of `fvec`, !! output: new value of `f` real ( wp ), dimension ( me % m ), intent ( inout ) :: fvec !! input: current function vector, !! output: new function vector end subroutine linesearch_func end interface contains !******************************************************************************************************* !***************************************************************************************** !> !  Set status flag and message. subroutine set_status ( me , istat , string , i , r ) implicit none class ( nlesolver_type ), intent ( inout ) :: me integer , intent ( in ) :: istat !! status code character ( len =* ), intent ( in ) :: string !! status message integer , intent ( in ), optional :: i !! an integer value to append real ( wp ), intent ( in ), optional :: r !! a real value to append character ( len = 256 ) :: numstr !! for number fo string conversion character ( len = :), allocatable :: message !! the full message to log integer :: iostat !! write `iostat` code message = trim ( string ) if ( present ( i )) then numstr = '' write ( numstr , fmt =* , iostat = iostat ) i if ( iostat /= 0 ) numstr = '****' message = message // ' ' // trim ( adjustl ( numstr )) end if if ( present ( r )) then numstr = '' write ( numstr , fmt =* , iostat = iostat ) r if ( iostat /= 0 ) numstr = '****' message = message // ' ' // trim ( adjustl ( numstr )) end if if ( me % verbose ) then write ( me % iunit , '(A)' , iostat = iostat ) message end if ! store in the class: me % istat = istat me % message = message end subroutine set_status !***************************************************************************************** !***************************************************************************************** !> !  Return the status code and message from the [[nlesolver_type]] class. ! !### Status codes ! !  * -1   -- Error: Invalid alpha !  * -2   -- Error: Invalid alpha_min !  * -3   -- Error: Invalid alpha_max !  * -4   -- Error: Alpha_min must be < alpha_max !  * -5   -- Error: Invalid step_mode !  * -6   -- Error solving linear system !  * -7   -- Error: More than 5 steps in the uphill direction !  * -8   -- Error: Divide by zero when computing Broyden update !  * -9   -- Error: Out of memory !  * -10  -- Error: function routine is not associated !  * -11  -- Error: gradient routine is not associated !  * -12  -- Error: backtracking linesearch c must be in range (0, 1) !  * -13  -- Error: backtracking linesearch tau must be in range (0, 1) !  * -999 -- Error: class has not been initialized !  * 0    -- Class successfully initialized in [[nlesolver_type:initialize]] !  * 1    -- Required accuracy achieved !  * 2    -- Solution cannot be improved !  * 3    -- Maximum number of iterations reached !  * 4    -- Stopped by the user subroutine get_status ( me , istat , message ) implicit none class ( nlesolver_type ), intent ( inout ) :: me integer , intent ( out ), optional :: istat !! Integer status code. character ( len = :), allocatable , intent ( out ), optional :: message !! Text status message if ( present ( istat )) istat = me % istat if ( present ( message )) then if ( allocated ( me % message )) then message = trim ( me % message ) else message = 'Error: class has not been initialized' end if end if end subroutine get_status !***************************************************************************************** !***************************************************************************************** !> !  Constructor for the class. subroutine initialize_nlesolver_variables ( me ,& n , m , max_iter , tol , alpha , alpha_min , alpha_max , tolx , fmin_tol ,& backtrack_c , backtrack_tau ,& use_broyden , broyden_update_n , step_mode , func , grad ,& export_iteration , user_input_check ,& verbose , iunit , n_uphill_max , n_intervals ) implicit none class ( nlesolver_type ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of optimization variables integer , intent ( in ) :: m !! number of constraints integer , intent ( in ) :: max_iter !! maximum number of iterations real ( wp ), intent ( in ) :: tol !! function convergence tolerance procedure ( func_func ) :: func !! computes the function vector procedure ( grad_func ) :: grad !! computes the jacobian integer , intent ( in ), optional :: step_mode !! step mode: !! !!  * 1 = use the specified `alpha` (0,1] !!  * 2 = backtracking linesearch (between `alpha_min` and `alpha_max`) !!  * 3 = exact linesearch (between `alpha_min` and `alpha_max`) !!  * 4 = evaluate function at specified fixed points  (between `alpha_min` and `alpha_max`) real ( wp ), intent ( in ), optional :: alpha !! constant step length for `step_mode=1` (0,1] real ( wp ), intent ( in ), optional :: alpha_min !! minimum step length (0,1] real ( wp ), intent ( in ), optional :: alpha_max !! maximum step length (0,1] real ( wp ), intent ( in ), optional :: tolx !! convergence tolerance for changes in `x` real ( wp ), intent ( in ), optional :: fmin_tol !! convergence tolerance for [[fmin]] (used when `step_mode=3`) real ( wp ), intent ( in ), optional :: backtrack_c !! backtracking linesearch parameter (0,1) real ( wp ), intent ( in ), optional :: backtrack_tau !! backtracking linesearch parameter (0,1) logical , intent ( in ), optional :: use_broyden !! use a Broyden update (default is False) integer , intent ( in ), optional :: broyden_update_n !! For Broyden mode, update the full Jacobian !! at most every this many iterations (must be >1) !! If <=1 then Jacobian is only computed on the !! first iteration. procedure ( export_func ), optional :: export_iteration !! function to export each iteration procedure ( wait_func ), optional :: user_input_check !! check for user input (to stop solver if necessary) logical , intent ( in ), optional :: verbose !! for verbose status printing integer , intent ( in ), optional :: iunit !! unit for verbose printing (assumed to be open). !! by default this is `output_unit`. integer , intent ( in ), optional :: n_uphill_max !! maximum number of consecutive steps !! to allow where the value of `f` increases integer , intent ( in ), optional :: n_intervals !! number of intervals for fixed point linesearch logical :: status_ok !! true if there were no errors status_ok = . true . !required: me % n = abs ( n ) me % m = abs ( m ) me % max_iter = abs ( max_iter ) me % tol = abs ( tol ) me % func => func me % grad => grad !optional: if ( present ( step_mode )) then select case ( step_mode ) case ( 1 ) ! = use the specified `alpha` (0,1] me % linesearch => simple_step case ( 2 ) ! = backtracking linesearch (between `alpha_min` and `alpha_max`) me % linesearch => backtracking_linesearch case ( 3 ) ! = exact linesearch (between `alpha_min` and `alpha_max`) me % linesearch => exact_linesearch case ( 4 ) ! = evaluate function at specified fixed points (between `alpha_min` and `alpha_max`) me % linesearch => fixed_point_linesearch case default status_ok = . false . call me % set_status ( istat = - 5 , string = 'Error: invalid step_mode:' , i = step_mode ) return end select else me % linesearch => simple_step end if if ( present ( alpha )) me % alpha = abs ( alpha ) if ( present ( alpha_min )) me % alpha_min = abs ( alpha_min ) if ( present ( alpha_max )) me % alpha_max = abs ( alpha_max ) if ( present ( tolx )) me % tolx = abs ( tolx ) if ( present ( backtrack_c )) me % c = abs ( backtrack_c ) if ( present ( backtrack_tau )) me % tau = abs ( backtrack_tau ) if ( present ( use_broyden )) me % use_broyden = use_broyden if ( present ( broyden_update_n )) me % broyden_update_n = abs ( broyden_update_n ) if ( present ( verbose )) me % verbose = verbose if ( present ( iunit )) me % iunit = iunit if ( present ( n_uphill_max )) me % n_uphill_max = abs ( n_uphill_max ) if ( present ( n_intervals )) me % n_intervals = max ( abs ( n_intervals ), 1 ) if ( present ( fmin_tol )) me % fmin_tol = abs ( fmin_tol ) if ( present ( export_iteration )) me % export_iteration => export_iteration if ( present ( user_input_check )) me % user_input_check => user_input_check ! error checks: if ( me % alpha < zero . or . me % alpha > one ) then status_ok = . false . call me % set_status ( istat = - 1 , string = 'Error: invalid alpha:' , r = me % alpha ) return end if if ( me % alpha_min < zero . or . me % alpha_min > one ) then status_ok = . false . call me % set_status ( istat = - 2 , string = 'Error: invalid alpha_min:' , r = me % alpha_min ) return end if if ( me % alpha_max < zero . or . me % alpha_max > one ) then status_ok = . false . call me % set_status ( istat = - 3 , string = 'Error: invalid alpha_max:' , r = me % alpha_max ) return end if if ( me % alpha_max <= me % alpha_min ) then status_ok = . false . call me % set_status ( istat = - 4 , string = 'Error: alpha_min must be < alpha_max' ) return end if if ( me % c < zero . or . me % c > one ) then status_ok = . false . call me % set_status ( istat = - 12 , string = 'Error: backtracking linesearch c must be in range (0, 1):' , r = me % c ) return end if if ( me % tau < zero . or . me % tau > one ) then status_ok = . false . call me % set_status ( istat = - 13 , string = 'Error: backtracking linesearch tau must be in range (0, 1):' , r = me % tau ) return end if if ( status_ok ) then call me % set_status ( istat = 0 , string = 'Class successfully initialized' ) end if end subroutine initialize_nlesolver_variables !***************************************************************************************** !***************************************************************************************** !> !  Main solver. subroutine nlesolver_solver ( me , x ) implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( inout ) :: x real ( wp ), dimension (:) , allocatable :: fvec !! function vector real ( wp ), dimension (:,:), allocatable :: fjac !! jacobian matrix real ( wp ), dimension (:) , allocatable :: rhs !! linear system right-hand side real ( wp ), dimension (:) , allocatable :: p !! search direction real ( wp ), dimension (:) , allocatable :: xold !! previous value of `x` real ( wp ), dimension (:) , allocatable :: prev_fvec !! previous function vector real ( wp ), dimension (:,:), allocatable :: prev_fjac !! previous jacobian matrix real ( wp ), dimension (:,:), allocatable :: delf !! used for Broyden (rank 2 for `matmul`) real ( wp ), dimension (:,:), allocatable :: delx !! used for Broyden (rank 2 for `matmul`) logical :: user_stop !! user stop button flag integer :: info !! status flag from the [[linear_solver]] integer :: iter !! iteration counter real ( wp ) :: f !! magnitude of `fvec` real ( wp ) :: fold !! previous value of `f` integer :: n_uphill !! number of steps taken in the \"uphill\" direction !! (where `f` is increasing) real ( wp ) :: delxmag2 !! used for Broyden logical :: recompute_jac !! if using Broyden, and we want to call the user !! jacobian routine instead integer :: broyden_counter !! number of times the broyden update has been used integer :: alloc_stat !! allocation status flag if ( me % istat < 0 ) return ! class was not initialized properly if (. not . associated ( me % func )) then call me % set_status ( istat = - 10 , string = 'Error: function routine is not associated' ) return end if if (. not . associated ( me % grad )) then call me % set_status ( istat = - 11 , string = 'Error: gradient routine is not associated' ) return end if ! initialize: iter = 0 n_uphill = 0 recompute_jac = . false . broyden_counter = 0 ! allocate the arrays: alloc_stat = 0 if ( alloc_stat == 0 ) allocate ( fvec ( me % m ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( fjac ( me % m , me % n ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( rhs ( me % m ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( p ( me % n ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( xold ( me % n ) , stat = alloc_stat ) if ( me % use_broyden ) then ! only need these for broyden: if ( alloc_stat == 0 ) allocate ( prev_fvec ( me % m ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( prev_fjac ( me % m , me % n ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( delf ( me % m , 1 ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( delx ( me % n , 1 ) , stat = alloc_stat ) end if if ( alloc_stat /= 0 ) then call me % set_status ( istat = - 9 , string = 'Error: Out of memory' ) return else me % istat = - 998 me % message = 'Unknown error' end if ! evaluate the function: call me % func ( x , fvec ) f = norm2 ( fvec ) ! check to see if initial guess is a root: if ( f <= me % tol ) then call me % set_status ( istat = 1 , string = 'Required accuracy achieved' ) else ! main iteration loop: do iter = 1 , me % max_iter ! Export the current iteration: if ( associated ( me % export_iteration )) call me % export_iteration ( x , fvec , iter ) ! Check for user stop: if ( associated ( me % user_input_check )) then call me % user_input_check ( user_stop ) if ( user_stop ) then call me % set_status ( istat = 4 , string = 'Stopped by the user' ) exit end if end if if ( me % use_broyden . and . . not . recompute_jac ) then if ( iter == 1 ) then ! always compute Jacobian on the first iteration call me % grad ( x , fjac ) broyden_counter = 0 else ! and use Broyden update to estimate Jacobian ! for subsequent iterations. ! note: fvec was computed the last iteration delx (:, 1 ) = x - xold delf (:, 1 ) = fvec - prev_fvec delxmag2 = dot_product ( delx (:, 1 ), delx (:, 1 )) if ( delxmag2 < eps ) then call me % set_status ( istat = - 8 , & string = 'Error: Divide by zero when computing Broyden update' ) exit end if ! Jacobian estimate: fjac = prev_fjac + & matmul (( delf - matmul ( prev_fjac , delx )),& transpose ( delx )) / delxmag2 broyden_counter = broyden_counter + 1 end if prev_fjac = fjac prev_fvec = fvec else ! compute the jacobian: call me % grad ( x , fjac ) recompute_jac = . false . ! for broyden broyden_counter = 0 end if xold = x fold = f ! compute the search direction p by solving linear system: rhs = - fvec ! RHS of the linear system call linear_solver ( me % m , me % n , fjac , rhs , p , info ) ! check for errors: if ( info /= 0 ) then call me % set_status ( istat = - 6 , string = 'Error solving linear system. info =' , i = info ) exit else ! next step, using the specified method: call me % linesearch ( xold , p , fjac , x , f , fvec ) ! keep track of the number of steps in the \"uphill\" direction: if ( f > fold ) then n_uphill = n_uphill + 1 else n_uphill = 0 end if ! check for stopping conditions if ( f <= me % tol ) then call me % set_status ( istat = 1 , string = 'Required accuracy achieved' ) exit elseif ( maxval ( abs ( x - xold )) <= me % tolx ) then call me % set_status ( istat = 2 , string = 'Solution cannot be improved' ) exit elseif ( iter == me % max_iter ) then call me % set_status ( istat = 3 , string = 'Maximum number of iterations reached' ) exit elseif ( n_uphill > me % n_uphill_max ) then call me % set_status ( istat = 5 , string = 'Too many steps in the uphill direction' ) exit elseif ( me % use_broyden ) then ! If delxmag2 is too small when using broyden, just ! call the user-supplied jacobian function to avoid ! a divide by zero on the next step. This should ! normally only happen when the solution is almost converged. if ( norm2 ( x - xold ) ** 2 <= eps ) then recompute_jac = . true . else if ( me % broyden_update_n > 0 ) then ! Note that we also recompute if we have taken an uphill step if ( broyden_counter == me % broyden_update_n . or . n_uphill > 0 ) then ! time to recompute the full jacobian recompute_jac = . true . end if end if end if endif end if end do !end of iterations loop end if !Export the last iteration: iter = iter + 1 if ( associated ( me % export_iteration )) call me % export_iteration ( x , fvec , iter ) end subroutine nlesolver_solver !***************************************************************************************** !***************************************************************************************** !> !   Destructor subroutine destroy_nlesolver_variables ( me ) implicit none class ( nlesolver_type ), intent ( out ) :: me me % message = 'Error: class has not been initialized' me % istat = - 999 end subroutine destroy_nlesolver_variables !***************************************************************************************** !***************************************************************************************** !> !  Solve the linear system:  Ax = b , using a dense, direct method. ! !  * if `n=m` : use LAPACK `dgesv` (LU decomposition) !  * if `n/=m` : use LAPACK `dgels` (if m>n uses QR factorization, !    if m<n uses LQ factorization) subroutine linear_solver ( m , n , a , b , x , info ) implicit none integer , intent ( in ) :: n !! number of columns in `a` integer , intent ( in ) :: m !! number of rows in `a` real ( wp ), dimension ( m , n ), intent ( in ) :: a !! `A` matrix of the linear system real ( wp ), dimension ( m ), intent ( in ) :: b !! RHS of the linear system real ( wp ), dimension ( n ), intent ( out ) :: x !! the solution of the linear system. integer , intent ( out ) :: info !! output status flag (`=0` if success) ! LAPACK routine interfaces: interface subroutine dgesv ( n , nrhs , a , lda , ipiv , b , ldb , info ) !! See: [?gesv](https://www.intel.com/content/www/us/en/develop/documentation/onemkl-developer-reference-fortran/top/lapack-routines/lapack-linear-equation-routines/lapack-linear-equation-driver-routines/gesv.html) import :: wp implicit none integer :: info integer :: lda integer :: ldb integer :: n integer :: nrhs integer :: ipiv ( * ) real ( wp ) :: a ( lda , * ) real ( wp ) :: b ( ldb , * ) end subroutine dgesv subroutine dgels ( trans , m , n , nrhs , a , lda , b , ldb , work , lwork , info ) !! See: [?gels](https://www.intel.com/content/www/us/en/develop/documentation/onemkl-developer-reference-fortran/top/lapack-routines/lapack-least-squares-and-eigenvalue-problem/lapack-least-squares-eigenvalue-problem-driver/linear-least-squares-lls-problems-lapack-driver/gels.html) import :: wp implicit none character :: trans integer :: info integer :: lda integer :: ldb integer :: lwork integer :: m integer :: n integer :: nrhs real ( wp ) :: a ( lda , * ) real ( wp ) :: b ( ldb , * ) real ( wp ) :: work ( * ) end subroutine dgels end interface integer , dimension (:), allocatable :: ipiv !! pivot indices array real ( wp ), dimension (:,:), allocatable :: bmat !! copy of `b` so it won't be overwritten real ( wp ), dimension (:), allocatable :: work !! work array for `dgels` real ( wp ), dimension (:,:), allocatable :: amat !! copy of `a` so it won't be overwritten integer :: lwork !! size of `work` allocate ( amat ( m , n )) allocate ( bmat ( max ( 1 , m , n ), 1 )) if ( n == m ) then !normal inverse allocate ( ipiv ( n )) amat = a bmat ( 1 : n , 1 ) = b call dgesv ( n , 1 , amat , n , ipiv , bmat , n , info ) x = bmat ( 1 : n , 1 ) else amat = a bmat = zero bmat ( 1 : m , 1 ) = b lwork = min ( m , n ) + max ( 1 , m , n ) allocate ( work ( lwork )) call dgels ( 'N' , m , n , 1 , amat , m , bmat , max ( 1 , m , n ), work , lwork , info ) x = bmat ( 1 : n , 1 ) end if end subroutine linear_solver !***************************************************************************************** !***************************************************************************************** !> !  Take a simple step in the search direction of `p * alpha`. subroutine simple_step ( me , xold , p , fjac , x , f , fvec ) implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: xold !! previous value of `x` real ( wp ), dimension ( me % n ), intent ( in ) :: p !! search direction real ( wp ), dimension ( me % m , me % n ), intent ( in ) :: fjac !! jacobian matrix real ( wp ), dimension ( me % n ), intent ( out ) :: x !! new `x` real ( wp ), intent ( inout ) :: f !! magnitude of `fvec` real ( wp ), dimension ( me % m ), intent ( inout ) :: fvec !! function vector x = xold + p * me % alpha !evaluate the function at the new point: call me % func ( x , fvec ) f = norm2 ( fvec ) end subroutine simple_step !***************************************************************************************** !***************************************************************************************** !> !  Backtracking line search. ! !### See also !  * [Backtracking line search](https://en.wikipedia.org/wiki/Backtracking_line_search) subroutine backtracking_linesearch ( me , xold , p , fjac , x , f , fvec ) implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: xold !! previous value of `x` real ( wp ), dimension ( me % n ), intent ( in ) :: p !! search direction real ( wp ), dimension ( me % m , me % n ), intent ( in ) :: fjac !! jacobian matrix real ( wp ), dimension ( me % n ), intent ( out ) :: x !! new `x` real ( wp ), intent ( inout ) :: f !! magnitude of `fvec` real ( wp ), dimension ( me % m ), intent ( inout ) :: fvec !! function vector integer :: i !! counter real ( wp ) :: slope !! local slope of the function of `alpha` along the search direction used for line search logical :: min_alpha_reached !! if the minimum step size is reached during the line search real ( wp ) :: alpha !! `alpha` for the line search real ( wp ) :: ftmp !! `f` value for linesearch real ( wp ) :: t !! used for line search real ( wp ), dimension (:), allocatable :: gradf !! line search objective function gradient vector real ( wp ), dimension (:), allocatable :: xtmp !! `x` value for linesearch real ( wp ), dimension (:), allocatable :: fvectmp !! `fvec` value for linesearch ! allocate arrays: allocate ( gradf ( me % n )) allocate ( xtmp ( me % n )) allocate ( fvectmp ( me % m )) ! compute the gradient of the function to be minimized ! (which in this case is 1/2 the norm of fvec). Use the chain ! rule and the Jacobian matrix already computed. do i = 1 , me % n gradf ( i ) = dot_product ( fvec , fjac (:, i )) end do slope = dot_product ( p , gradf ) t = - me % c * slope if ( me % verbose ) then write ( me % iunit , '(1P,*(A,1X,E16.6))' ) '        slope    = ' , slope write ( me % iunit , '(1P,*(A,1X,E16.6))' ) '        t        = ' , t end if ! perform the line search: min_alpha_reached = . false . alpha = me % alpha_max ! start with the largest step do xtmp = xold + p * alpha call me % func ( xtmp , fvectmp ) ftmp = norm2 ( fvectmp ) if ( me % verbose ) then write ( me % iunit , '(1P,*(A,1X,E16.6))' ) '        alpha    = ' , alpha , ' f       = ' , ftmp if ( f - ftmp >= alpha * t ) then write ( me % iunit , '(1P,2(A,1X,E16.6),1X,A)' ) '        f - ftmp = ' , f - ftmp , ' alpha*t = ' , alpha * t , ' [ACCEPTED]' else write ( me % iunit , '(1P,*(A,1X,E16.6))' ) '        f - ftmp = ' , f - ftmp , ' alpha*t = ' , alpha * t end if end if if ((( f - ftmp ) / 2.0_wp >= alpha * t ) . or . min_alpha_reached ) then if ( min_alpha_reached ) then write ( me % iunit , '(A)' ) '        Minimum alpha reached' end if ! Armijo-Goldstein condition is satisfied ! (or the min step has been reached) x = xtmp fvec = fvectmp f = ftmp exit end if alpha = alpha * me % tau ! reduce step size if ( alpha <= me % alpha_min ) then alpha = me % alpha_min min_alpha_reached = . true . ! will stop on the next step end if end do end subroutine backtracking_linesearch !***************************************************************************************** !***************************************************************************************** !> !  An exact linesearch that uses a derivative-free minimizer to !  find the minimum value of `f(x)` between !  `x = xold + p * alpha_min` and !  `x = xold + p * alpha_max`. ! !  Usually this is overkill and not necessary, but is here as an option for testing. subroutine exact_linesearch ( me , xold , p , fjac , x , f , fvec ) implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: xold !! previous value of `x` real ( wp ), dimension ( me % n ), intent ( in ) :: p !! search direction real ( wp ), dimension ( me % m , me % n ), intent ( in ) :: fjac !! jacobian matrix real ( wp ), dimension ( me % n ), intent ( out ) :: x !! new `x` real ( wp ), intent ( inout ) :: f !! magnitude of `fvec` real ( wp ), dimension ( me % m ), intent ( inout ) :: fvec !! function vector real ( wp ), dimension (:), allocatable :: xnew !! used in [[func_for_fmin]] real ( wp ) :: alpha_min allocate ( xnew ( me % n )) ! find the minimum value of f in the range of alphas: alpha_min = fmin ( func_for_fmin , me % alpha_min , me % alpha_max , me % fmin_tol ) if ( me % verbose ) write ( me % iunit , '(1P,*(A,1X,E16.6))' ) '        alpha_min = ' , alpha_min x = xold + p * alpha_min if ( all ( x == xnew )) then ! already computed in the func else call me % func ( x , fvec ) f = norm2 ( fvec ) end if contains real ( wp ) function func_for_fmin ( alpha ) !! function for [[fmin]] implicit none real ( wp ), intent ( in ) :: alpha !! indep variable xnew = xold + p * alpha call me % func ( xnew , fvec ) func_for_fmin = norm2 ( fvec ) ! return result f = func_for_fmin ! just in case this is the solution end function func_for_fmin end subroutine exact_linesearch !***************************************************************************************** !***************************************************************************************** !> !  A simple search that just evaluates the function at a specified !  number of points and picks the one with the minimum function value. subroutine fixed_point_linesearch ( me , xold , p , fjac , x , f , fvec ) implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: xold !! previous value of `x` real ( wp ), dimension ( me % n ), intent ( in ) :: p !! search direction real ( wp ), dimension ( me % m , me % n ), intent ( in ) :: fjac !! jacobian matrix real ( wp ), dimension ( me % n ), intent ( out ) :: x !! new `x` real ( wp ), intent ( inout ) :: f !! magnitude of `fvec` real ( wp ), dimension ( me % m ), intent ( inout ) :: fvec !! function vector integer :: i !! counter integer :: n_points !! number of points to compute real ( wp ), dimension (:), allocatable :: alphas_to_try !! set of `alpha` values to try real ( wp ), dimension (:), allocatable :: x_tmp !! temp `x` real ( wp ), dimension (:), allocatable :: fvec_tmp !! temp `fvec` real ( wp ) :: f_tmp !! temp `f` real ( wp ) :: step_size !! step size for `alpha` integer :: n !! number of steps to divide the interval ! 1 o-----------o ! 2 o-----o-----o ! 3 o---o---o---o n = me % n_intervals n_points = n + 1 allocate ( alphas_to_try ( n_points )) allocate ( x_tmp ( me % n )) allocate ( fvec_tmp ( me % m )) step_size = ( me % alpha_max - me % alpha_min ) / real ( n , wp ) ! compute the alphas: alphas_to_try ( 1 ) = me % alpha_min do i = 2 , n alphas_to_try ( i ) = alphas_to_try ( i - 1 ) + step_size end do alphas_to_try ( n_points ) = me % alpha_max ! now compute the functions at these alphas: f = big do i = 1 , n_points x_tmp = xold + p * alphas_to_try ( i ) ! evaluate the function at tthis point: call me % func ( x_tmp , fvec_tmp ) f_tmp = norm2 ( fvec_tmp ) if ( f_tmp <= f ) then ! new best point x = x_tmp f = f_tmp fvec = fvec_tmp end if end do end subroutine fixed_point_linesearch !***************************************************************************************** !****************************************************************************************************** end module nlesolver_module !******************************************************************************************************","tags":"","loc":"sourcefile/nlesolver_module.f90.html"},{"title":"test2.f90 – AoC-2023","text":"This file depends on sourcefile~~test2.f90~~EfferentGraph sourcefile~test2.f90 test2.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~test2.f90->sourcefile~kinds_module.f90 sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~test2.f90->sourcefile~numerical_differentiation_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~kinds_module.f90 sourcefile~cache_module.f90 cache_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~cache_module.f90 sourcefile~diff_module.f90 diff_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~diff_module.f90 sourcefile~dsm_module.f90 dsm_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~dsm_module.f90 sourcefile~utilities_module.f90 utilities_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~utilities_module.f90 sourcefile~cache_module.f90->sourcefile~kinds_module.f90 sourcefile~cache_module.f90->sourcefile~utilities_module.f90 sourcefile~diff_module.f90->sourcefile~kinds_module.f90 sourcefile~dsm_module.f90->sourcefile~kinds_module.f90 sourcefile~utilities_module.f90->sourcefile~kinds_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> author: Jacob Williams !  date: October 1, 2022 ! !  Test2 for the numerical differentiation module. !  Makes a plot of the errors using different methods and step sizes. program test2 use iso_fortran_env use numerical_differentiation_module use numdiff_kinds_module , only : wp use pyplot_module implicit none integer , parameter :: n = 1 !! number of variables integer , parameter :: m = 1 !! number of functions real ( wp ), dimension ( n ), parameter :: x = 1.0_wp !! point at which to compute the derivative real ( wp ), dimension ( n ), parameter :: xlow = - 10000 0.0_wp !! bounds not really needed real ( wp ), dimension ( n ), parameter :: xhigh = 10000 0.0_wp !! integer , parameter :: perturb_mode = 1 !! absolute step integer , parameter :: cache_size = 0 !! `0` indicates not to use cache integer , parameter :: sparsity_mode = 1 !! assume dense integer , dimension ( * ), parameter :: methods = [ 1 , 3 , 10 , 21 , 36 , 500 , 600 , 700 , 800 ] !! array of method IDs: !! [1,3,10,21,36,500,600,700,800] !! forward + all the central diff ones integer , parameter :: exp_star = - ceiling ( log10 ( epsilon ( 1.0_wp ))) !! exponent to start with integer , parameter :: exp_stop = - 2 !! exponent to end with integer , parameter :: exp_step = - 1 !! ecponent step integer , parameter :: exp_scale = 5 !! number of substeps from one to the next type ( numdiff_type ) :: my_prob !! main class to compute the derivatives integer :: i !! method counter integer :: j !! counter real ( wp ), dimension (:), allocatable :: jac !! jacobian integer :: func_evals !! function evaluation counter character ( len = :), allocatable :: error_msg !! error message string real ( wp ), dimension ( n ) :: dpert !! perturbation step size integer :: ipert !! perturbation step size counter real ( wp ) :: error !! diff from true derivative integer :: num_dperts !! number of dperts to test integer :: num_methods !! number of methods to test real ( wp ), dimension (:), allocatable :: results_dpert !! results array - dpert real ( wp ), dimension (:), allocatable :: results_errors !! results array - errors type ( pyplot ) :: plt !! for plotting the results character ( len = :), allocatable :: formula !! finite diff formula for the plot legend character ( len = :), allocatable :: name !! finite diff name for the plot legend integer :: idx !! index in results arrays character ( len = :), allocatable :: real_kind_str !! real kind for the plot title real ( wp ), dimension ( 3 ) :: color !! line color array real ( wp ), dimension ( 2 ) :: ylim !! plot y limit array ! size the arrays: num_methods = size ( methods ) num_dperts = size ([( i , i = exp_star * exp_scale , exp_stop * exp_scale , exp_step )]) allocate ( results_errors ( num_dperts )); results_errors = - huge ( 1.0_wp ) ! for plot title: select case ( wp ) case ( REAL32 ); real_kind_str = '[Single Precision]' case ( REAL64 ); real_kind_str = '[Double Precision]' case ( REAL128 ); real_kind_str = '[Quad Precision]' case default ; error stop 'Invalid real kind' end select ! initialize the plot: call plt % initialize ( grid = . true .,& figsize = [ 20 , 10 ],& axes_labelsize = 30 , & xtick_labelsize = 30 , & ytick_labelsize = 30 , & font_size = 30 , & xlabel = 'Finite Difference Perturbation Step Size $h$' ,& ylabel = 'Finite Difference Derivative Error' ,& title = 'Derivative of $x + \\sin(x)$ at $x=1$ ' // real_kind_str ,& legend = . true ., & legend_fontsize = 10 ,& usetex = . true .) ! try different finite diff methods do j = 1 , size ( methods ) idx = 0 i = methods ( j ) ! method id call get_finite_diff_formula ( i , formula , name ) ! cycle through perturbation step sizes: do ipert = exp_star * exp_scale , exp_stop * exp_scale , exp_step idx = idx + 1 ! index for arrays dpert = 1 0.0_wp ** ( - ipert / real ( exp_scale , wp )) ! compute perturbation step size if ( j == 1 ) then if (. not . allocated ( results_dpert )) allocate ( results_dpert ( 0 )) results_dpert = [ results_dpert , dpert ( 1 )] ! save dpert end if func_evals = 0 call my_prob % destroy () call my_prob % initialize ( n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func = my_func ,& sparsity_mode = sparsity_mode ,& jacobian_method = i ,& partition_sparsity_pattern = . false .,& cache_size = cache_size ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) error stop error_msg end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) error stop error_msg end if error = abs ( deriv ( x ( 1 )) - jac ( 1 )) !write(output_unit,'(I5,1X,*(F27.16))') i , dpert, error if ( error <= epsilon ( 1.0_wp )) error = 0.0_wp results_errors ( idx ) = error ! save result end do ! line color for the plot: select case ( j ) case ( 1 ); color = [ 1.0_wp , 0.0_wp , 0.0_wp ] ! red case ( 2 ); color = [ 0.0_wp , 1.0_wp , 0.0_wp ] ! green case default ! blue gradient for the others color = [ real ( j - 2 , wp ) / num_methods , & real ( j - 2 , wp ) / num_methods , & 0.9_wp ] end select ylim = [ 1 0.0_wp ** ( ceiling ( log10 ( epsilon ( 1.0_wp )))), 1.0_wp ] ! plot for this method: call plt % add_plot ( results_dpert , results_errors ,& xscale = 'log' , yscale = 'log' ,& label = formula , linestyle = '.-' , markersize = 5 , linewidth = 2 , & color = color ,& xlim = ylim ,& ylim = ylim ) end do ! save plot: call plt % savefig ( 'results ' // real_kind_str // '.pdf' , pyfile = 'results.py' ) contains function func ( x ) !! Problem function real ( wp ), intent ( in ) :: x real ( wp ) :: func func = x + sin ( x ) end function func function deriv ( x ) !! Problem function true derivative real ( wp ), intent ( in ) :: x real ( wp ) :: deriv deriv = 1.0_wp + cos ( x ) end function deriv subroutine my_func ( me , x , f , funcs_to_compute ) !! Problem function interface for numdiff class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f integer , dimension (:), intent ( in ) :: funcs_to_compute if ( any ( funcs_to_compute == 1 )) f ( 1 ) = func ( x ( 1 )) func_evals = func_evals + 1 end subroutine my_func !******************************************************************************* end program test2 !*******************************************************************************","tags":"","loc":"sourcefile/test2.f90.html"},{"title":"problem_06.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_06.f90~~EfferentGraph sourcefile~problem_06.f90 problem_06.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_06.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_6 use iso_fortran_env use aoc_utilities implicit none ! just copy and paste the inputs here: ! a integer ( ip ), dimension ( * ), parameter :: time_a = [ 60 , 94 , 78 , 82 ] integer ( ip ), dimension ( * ), parameter :: distance_a = [ 475 , 2138 , 1015 , 1650 ] ! b integer ( ip ), dimension ( * ), parameter :: time_b = [ 60947882_ip ] integer ( ip ), dimension ( * ), parameter :: distance_b = [ 475213810151650_ip ] call clk % tic () print * , '6a: ways to win:' , go ( time_a , distance_a ) print * , '6b: ways to win:' , go ( time_b , distance_b ) call clk % toc ( '6' ) contains function go ( time , distance ) result ( iproduct ) integer ( ip ), dimension (:), intent ( in ) :: time integer ( ip ), dimension (:), intent ( in ) :: distance integer ( ip ) :: iproduct integer ( ip ) :: i , ihold , iways , idistance iproduct = 1 do i = 1 , size ( time ) iways = 0 do ihold = 1 , time ( i ) ! time to hold the button idistance = ihold * ( time ( i ) - ihold ) if ( idistance > distance ( i )) iways = iways + 1 end do iproduct = iproduct * iways end do end function go end program problem_6","tags":"","loc":"sourcefile/problem_06.f90.html"},{"title":"problem_16.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_16.f90~~EfferentGraph sourcefile~problem_16.f90 problem_16.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_16.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_16 use iso_fortran_env use aoc_utilities implicit none integer :: i , j , nrows , ncols , max_count , icount , icase character ( len = 1 ), dimension (:,:), allocatable :: array logical , dimension (:,:,:), allocatable :: visited ! top,bottom,left,right integer , parameter :: TOP = 1 ! direction traveling FROM integer , parameter :: BOTTOM = 2 integer , parameter :: LEFT = 3 integer , parameter :: RIGHT = 4 call clk % tic () ! read the data file: ! array = read_file_to_char_array('inputs/day16_test.txt') ! pad with wall around the array array = read_file_to_char_array ( 'inputs/day16.txt' ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) ! track if we have already done this case, to avoid unnecessary duplication, ! otherwise it may loop indefinitly? allocate ( visited ( 4 , nrows , ncols )) ! part 1: visited = . false . call go ( 1 , 1 , LEFT ) write ( * , * ) '16a: ' , count ( visited ( 1 ,:,:) . or . & visited ( 2 ,:,:) . or . & visited ( 3 ,:,:) . or . & visited ( 4 ,:,:)) ! part 2, just do all the cases: max_count = 0 do icase = 1 , 2 ! first and last col do i = 1 , nrows visited = . false . if ( icase == 1 ) then ; call go ( i , 1 , LEFT ) else ; call go ( i , ncols , RIGHT ) end if icount = count ( visited ( 1 ,:,:) . or . & visited ( 2 ,:,:) . or . & visited ( 3 ,:,:) . or . & visited ( 4 ,:,:)) if ( icount > max_count ) max_count = icount end do end do do icase = 1 , 2 ! first and last row do j = 1 , ncols visited = . false . if ( icase == 1 ) then ; call go ( 1 , j , TOP ) else ; call go ( nrows , j , BOTTOM ) end if icount = count ( visited ( 1 ,:,:) . or . & visited ( 2 ,:,:) . or . & visited ( 3 ,:,:) . or . & visited ( 4 ,:,:)) if ( icount > max_count ) max_count = icount end do end do write ( * , * ) '16b: ' , max_count call clk % toc ( '16' ) contains recursive subroutine go ( i , j , direction_from ) integer , intent ( in ) :: i , j !! grid coordinate integer , intent ( in ) :: direction_from !! direction coming from (TOP,BOTTOM,LEFT,RIGHT integer :: k if ( i > nrows . or . i < 1 . or . j > ncols . or . j < 1 ) return ! off the board if ( visited ( direction_from , i , j )) return ! this case has already been done visited ( direction_from , i , j ) = . true . ! mark this one as visited in this direction associate ( c => array ( i , j )) select case ( c ) case ( '.' ) ! continue in same direction k = 1 do ! loop until we hit something else ! (to avoid unnecessary recursion) select case ( direction_from ) case ( TOP ) ! V if (( i + k ) > nrows ) return if ( array ( i + k , j ) /= '.' ) then call go ( i + k , j , direction_from ) return end if visited ( direction_from , i + k , j ) = . true . case ( BOTTOM ) ! &#94; if (( i - k ) < 1 ) return if ( array ( i - k , j ) /= '.' ) then call go ( i - k , j , direction_from ) return end if visited ( direction_from , i - k , j ) = . true . case ( LEFT ) ! --> if (( j + k ) > ncols ) return if ( array ( i , j + k ) /= '.' ) then call go ( i , j + k , direction_from ) return end if visited ( direction_from , i , j + k ) = . true . case ( RIGHT ) ! <-- if (( j - k ) < 1 ) return if ( array ( i , j - k ) /= '.' ) then call go ( i , j - k , direction_from ) return end if visited ( direction_from , i , j - k ) = . true . end select k = k + 1 end do case ( '-' ) select case ( direction_from ) case ( TOP , BOTTOM ) ! V, &#94; call go ( i , j + 1 , LEFT ) ! split call go ( i , j - 1 , RIGHT ) case ( LEFT ) ! --> call go ( i , j + 1 , LEFT ) case ( RIGHT ) ! <-- call go ( i , j - 1 , RIGHT ) end select case ( '|' ) select case ( direction_from ) case ( TOP ) ! V call go ( i + 1 , j , TOP ) case ( BOTTOM ) ! &#94; call go ( i - 1 , j , BOTTOM ) case ( LEFT , RIGHT ) ! -->, <-- call go ( i + 1 , j , TOP ) call go ( i - 1 , j , BOTTOM ) end select case ( '/' ) select case ( direction_from ) case ( TOP ) ! V call go ( i , j - 1 , RIGHT ) case ( BOTTOM ) ! &#94; call go ( i , j + 1 , LEFT ) case ( LEFT ) ! --> call go ( i - 1 , j , BOTTOM ) case ( RIGHT ) ! <-- call go ( i + 1 , j , TOP ) end select case ( '\\' ) select case ( direction_from ) case ( TOP ) ! V call go ( i , j + 1 , LEFT ) case ( BOTTOM ) ! &#94; call go ( i , j - 1 , RIGHT ) case ( LEFT ) ! --> call go ( i + 1 , j , TOP ) case ( RIGHT ) ! <-- call go ( i - 1 , j , BOTTOM ) end select end select end associate end subroutine go end program problem_16","tags":"","loc":"sourcefile/problem_16.f90.html"},{"title":"nlesolver_test_1.f90 – AoC-2023","text":"This file depends on sourcefile~~nlesolver_test_1.f90~~EfferentGraph sourcefile~nlesolver_test_1.f90 nlesolver_test_1.f90 sourcefile~nlesolver_module.f90 nlesolver_module.F90 sourcefile~nlesolver_test_1.f90->sourcefile~nlesolver_module.f90 sourcefile~fmin_module.f90 fmin_module.F90 sourcefile~nlesolver_module.f90->sourcefile~fmin_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !****************************************************************************************************** !> !  Test of a small, square (`n=m`) problem. program nlesolver_test_1 use nlesolver_module , wp => nlesolver_rk implicit none integer , parameter :: n = 2 integer , parameter :: m = 2 integer , parameter :: max_iter = 100 real ( wp ), parameter :: tol = 1.0e-8_wp logical , parameter :: verbose = . false . type ( nlesolver_type ) :: solver real ( wp ) :: alpha logical :: use_broyden integer :: step_mode integer :: n_intervals integer :: istat !! Integer status code. character ( len = :), allocatable :: message !! Text status message real ( wp ), dimension ( n ) :: x integer :: f_evals integer :: i character ( len = :), allocatable :: description real ( wp ) :: fmin_tol fmin_tol = 1.0e-2_wp ! don't need a tight tol for this n_intervals = 2 alpha = 1.0_wp write ( * , * ) '' do i = 1 , 8 select case ( i ) case ( 1 ) step_mode = 1 use_broyden = . false . f_evals = 0 description = 'Constant alpha' case ( 2 ) step_mode = 1 use_broyden = . true . f_evals = 0 description = 'Constant alpha + broyden' case ( 3 ) step_mode = 2 use_broyden = . false . f_evals = 0 description = 'Backtracking line search' case ( 4 ) step_mode = 2 use_broyden = . true . f_evals = 0 description = 'Backtracking line search + broyden' case ( 5 ) step_mode = 3 use_broyden = . false . f_evals = 0 description = 'Exact line search' case ( 6 ) step_mode = 3 use_broyden = . true . f_evals = 0 description = 'Exact line search + broyden' case ( 7 ) step_mode = 4 use_broyden = . false . f_evals = 0 description = 'Fixed point search' case ( 8 ) step_mode = 4 use_broyden = . true . f_evals = 0 description = 'Fixed point search + broyden' case default error stop 'invalid case' end select write ( * , * ) '-------------------------------------------------------' write ( * , '(A,I3,A,A)' ) 'Case ' , i , ' : ' , description write ( * , * ) '' call solver % initialize ( n = n , & m = m , & max_iter = max_iter , & tol = tol , & func = func , & grad = grad , & step_mode = step_mode ,& use_broyden = use_broyden ,& export_iteration = export ,& n_intervals = n_intervals , & fmin_tol = fmin_tol , & verbose = verbose ) call solver % status ( istat , message ) write ( * , '(I3,1X,A)' ) istat , message if ( istat /= 0 ) error stop x = [ 1.0_wp , 2.0_wp ] call solver % solve ( x ) call solver % status ( istat , message ) write ( * , '(I3,1X,A)' ) istat , message write ( * , * ) '' end do contains subroutine func ( me , x , f ) !! compute the function implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f f_evals = f_evals + 1 f ( 1 ) = x ( 1 ) ** 2 + x ( 2 ) - 0.1_wp f ( 2 ) = x ( 2 ) + 0.2_wp ! root is 5.477226E-01  -2.000000E-01 end subroutine func subroutine grad ( me , x , g ) !! compute the gradient of the function (Jacobian): implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:,:), intent ( out ) :: g f_evals = f_evals + 2 ! to approximate forward diff derivatives g ( 1 , 1 ) = 2.0_wp * x ( 1 ) !df(1)/dx g ( 2 , 1 ) = 0.0_wp !df(2)/dx g ( 1 , 2 ) = 1.0_wp !df(1)/dy g ( 2 , 2 ) = 1.0_wp !df(2)/dy end subroutine grad subroutine export ( me , x , f , iter ) !! export an iteration: implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: f integer , intent ( in ) :: iter !! iteration number write ( * , '(1P,I3,1X,A,I3,A,*(E15.6))' ) iter , '(' , f_evals , ')' , x , norm2 ( f ) end subroutine export !****************************************************************************************************** end program nlesolver_test_1 !******************************************************************************************************","tags":"","loc":"sourcefile/nlesolver_test_1.f90.html"},{"title":"problem_23.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_23.f90~~EfferentGraph sourcefile~problem_23.f90 problem_23.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_23.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_23 !! alternate one... collapse the maze into a graph ! Process: !   1. locate the start and end nodes (top and bottom) !   2. find all the cells that have 3 or 4 adjacent cells: ! !      1    2    3    4 !     ###  #.#  ###  #.# !-->  #.#  #.#  ...  ... !     #.#  #.#  #.#  #.# ! !     those are the nodes, and the paths between them are the edges !   3. compute the edges between each node combination and construct the graph !   4. DFS all paths to find the longest. use iso_fortran_env use aoc_utilities implicit none type :: node integer ( ip ), dimension (:), allocatable :: inext !! the node connected to this one integer ( ip ), dimension (:), allocatable :: idist !! distance to inext nodes end type node type ( node ), dimension (:), allocatable :: nodes !! the list of nodes logical :: slopes !! a=true, b=false logical , dimension (:,:), allocatable :: visited logical , dimension (:), allocatable :: nodes_visited integer ( ip ), dimension (:), allocatable :: inodes , jnodes !! node coordinates integer ( ip ) :: max_dist , total_nodes , nrows , ncols character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:), allocatable :: node_dist integer ( ip ), dimension (:), allocatable :: node_prev call clk % tic () ! call go('23a', 'inputs/day23_test.txt', .true. ) ! call go('23b', 'inputs/day23_test.txt', .false.) call go ( '23a' , 'inputs/day23.txt' , . true . ) call go ( '23b' , 'inputs/day23.txt' , . false .) call clk % toc ( '23' ) contains subroutine go ( case , filename , parta ) !! solve the case character ( len =* ), intent ( in ) :: case !! case name for printing character ( len =* ), intent ( in ) :: filename !! input file to read logical , intent ( in ) :: parta !! if this is part a, then consider the slopes integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: istart , iend , idist , i , j logical , parameter :: use_dijkstra = . false . !.... doesn't work yet .... don't know why ....... ! initialize: max_dist = 0 slopes = parta if ( allocated ( nodes )) deallocate ( nodes ) if ( allocated ( visited )) deallocate ( visited ) if ( allocated ( nodes_visited )) deallocate ( nodes_visited ) if ( allocated ( inodes )) deallocate ( inodes ) if ( allocated ( jnodes )) deallocate ( jnodes ) if ( allocated ( node_dist )) deallocate ( node_dist ) if ( allocated ( node_prev )) deallocate ( node_prev ) ! read the data file: array = read_file_to_char_array ( filename ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) iloc = findloc ( array ( 1 ,:), '.' ); istart = iloc ( 1 ) ! get start and end columns iloc = findloc ( array ( nrows ,:), '.' ); iend = iloc ( 1 ) ! ! identify the coordinates of all the nodes: inodes = [ 1 ] ! start node jnodes = [ istart ] do i = 1 , nrows do j = 1 , ncols if ( count_adjacent ( i , j ) >= 3 ) then inodes = [ inodes , i ] jnodes = [ jnodes , j ] end if end do end do inodes = [ inodes , nrows ] ! end node jnodes = [ jnodes , iend ] total_nodes = size ( inodes ) ! for each node, find the other nodes they are ! connected to and the distances between them (the edges) allocate ( nodes ( total_nodes )) allocate ( visited ( nrows , ncols )) do i = 1 , total_nodes visited = . false . idist = 0 call build_graph ( i , inodes ( i ), jnodes ( i ), idist , visited ) end do if ( use_dijkstra ) then !write(*,*) 'hello use_dijkstra'         ! ... something wrong here... don't get the right answer ! based on AOC 2021, Problem 15 allocate ( node_dist ( total_nodes )); node_dist = - 1 ; node_dist ( 1 ) = 0 allocate ( node_prev ( total_nodes )); node_prev = - 1 allocate ( nodes_visited ( total_nodes )); nodes_visited = . false . do iloc = maxloc ( node_dist , mask = . not . nodes_visited ) i = iloc ( 1 ) nodes_visited ( i ) = . true . if ( i == total_nodes ) exit ! we are done! !write(*,*) 'visited ', i if ( allocated ( nodes ( i )% inext )) then do j = 1 , size ( nodes ( i )% inext ) ! adjacent nodes to this one call dijkstra ( i , j ) end do end if !if (all(nodes_visited)) exit ! done end do !write(*,*) case, node_dist(size(node_dist)) ! result for this case (last node) !write(*,*) nodes_visited !write(*,*) node_dist else ! start at first, and find the longest that gets to the last. ! recursively traverse the graph. visited = . false . allocate ( nodes_visited ( total_nodes )); nodes_visited = . false . call traverse ( 1_ip , 0_ip , nodes_visited ) write ( * , * ) case , max_dist ! result for this case end if end subroutine go subroutine dijkstra ( u , inext ) integer ( ip ), intent ( in ) :: u ! current integer ( ip ), intent ( in ) :: inext ! index in inext array of the next node integer ( ip ) :: idist associate ( next_node => nodes ( u )% inext ( inext ), & distance_to_next_node => nodes ( u )% idist ( inext )) if ( nodes_visited ( next_node )) return ! already visited this one idist = node_dist ( u ) + distance_to_next_node ! add distance from u to v if ( idist > node_dist ( next_node )) then !write(*,*) 'highest so far: ', idist node_dist ( next_node ) = idist node_prev ( next_node ) = u end if end associate end subroutine dijkstra recursive subroutine build_graph ( node_num , i , j , idist , visited ) integer ( ip ), intent ( in ) :: node_num !! current node number integer ( ip ), intent ( in ) :: i , j !! current position integer ( ip ), intent ( in ) :: idist !! current distance (number of steps) logical , dimension (:,:), intent ( in ) :: visited !! elements visited in this path (not counting this one) logical , dimension (:,:), allocatable :: tmp_visited integer ( ip ) :: child_node_num if ( i < 1 . or . i > nrows . or . j < 1 . or . j > ncols ) return if ( visited ( i , j )) return if ( array ( i , j ) == '#' ) return ! can't continue from here ! go until we hit another node child_node_num = node_number ( i , j ) if ( child_node_num > 0 . and . child_node_num /= node_num ) then ! we have reached another node call add_edge ( node_num , child_node_num , idist ) else ! continue processing this edge tmp_visited = visited !make a copy and mark this one tmp_visited ( i , j ) = . true . ! we are here now associate ( a => get_cell ( i , j )) ! paths (.), forest (#), and steep slopes (&#94;, >, v, and <). select case ( a ) case ( '.' ) ! path call build_graph ( node_num , i - 1 , j , idist + 1 , tmp_visited ) call build_graph ( node_num , i + 1 , j , idist + 1 , tmp_visited ) call build_graph ( node_num , i , j + 1 , idist + 1 , tmp_visited ) call build_graph ( node_num , i , j - 1 , idist + 1 , tmp_visited ) ! these don't have a choice, must go in these directions: case ( '&#94;' ); call build_graph ( node_num , i - 1 , j , idist + 1 , tmp_visited ) case ( 'v' ); call build_graph ( node_num , i + 1 , j , idist + 1 , tmp_visited ) case ( '>' ); call build_graph ( node_num , i , j + 1 , idist + 1 , tmp_visited ) case ( '<' ); call build_graph ( node_num , i , j - 1 , idist + 1 , tmp_visited ) end select end associate end if end subroutine build_graph recursive subroutine traverse ( node_num , idist , nodes_visited ) !! traverse the graph until we get to the end and check the max distance integer ( ip ), intent ( in ) :: node_num !! current node integer ( ip ), intent ( in ) :: idist !! distance to get here logical , dimension (:), intent ( in ) :: nodes_visited logical , dimension (:), allocatable :: tmp_nodes_visited integer :: i if ( nodes_visited ( node_num )) return ! already visited this node if ( node_num == total_nodes ) then ! reached the destination if ( idist > max_dist ) max_dist = idist ! best so far else ! are their child nodes? if ( allocated ( nodes ( node_num )% inext )) then tmp_nodes_visited = nodes_visited tmp_nodes_visited ( node_num ) = . true . ! mark this node do i = 1 , size ( nodes ( node_num )% inext ) call traverse ( nodes ( node_num )% inext ( i ), idist + nodes ( node_num )% idist ( i ), tmp_nodes_visited ) end do end if end if end subroutine traverse pure logical function is_node ( i , j ) !! returns true if a node is at these coordinates integer ( ip ), intent ( in ) :: i , j is_node = any ( inodes == i . and . jnodes == j ) end function is_node subroutine add_edge ( inode , ichild , idist ) !! add an edge to this node (path to another node with the specified distance) integer ( ip ), intent ( in ) :: inode , ichild , idist if (. not . allocated ( nodes ( inode )% inext )) then allocate ( nodes ( inode )% inext ( 0 )) allocate ( nodes ( inode )% idist ( 0 )) end if nodes ( inode )% inext = [ nodes ( inode )% inext , ichild ] nodes ( inode )% idist = [ nodes ( inode )% idist , idist ] end subroutine add_edge pure integer ( ip ) function node_number ( i , j ) !! returns the index of these coordinates in !! the list of nodes (0 if it is not a node) integer ( ip ), intent ( in ) :: i , j integer ( ip ), dimension ( 1 ) :: iloc iloc = findloc ( inodes == i . and . jnodes == j , . true .) node_number = iloc ( 1 ) end function node_number pure function count_adjacent ( i , j ) result ( icount ) !! count the number of adjacent cells not a tree integer ( ip ), intent ( in ) :: i , j integer ( ip ) :: icount icount = 0 if ( i >= 1 ) icount = icount + count ([ not_tree ( i - 1 , j )]) if ( i <= nrows ) icount = icount + count ([ not_tree ( i + 1 , j )]) if ( j <= ncols ) icount = icount + count ([ not_tree ( i , j + 1 )]) if ( j >= 1 ) icount = icount + count ([ not_tree ( i , j - 1 )]) end function count_adjacent pure function get_cell ( i , j ) result ( a ) integer ( ip ), intent ( in ) :: i , j !! coordinates character ( len = 1 ) :: a if ( slopes ) then a = array ( i , j ) else a = '.' ! ignore the slopes for part b end if end function get_cell pure logical function not_tree ( i , j ) !! returns true if the cell isn't a tree integer ( ip ), intent ( in ) :: i , j !! coordinates if ( i < 1 . or . i > nrows . or . j < 1 . or . j > ncols ) then not_tree = . false . ! off the board, call it a tree else not_tree = array ( i , j ) /= '#' end if end function not_tree end program problem_23","tags":"","loc":"sourcefile/problem_23.f90.html"},{"title":"aoc_utilities.F90 – AoC-2023","text":"Files dependent on this one sourcefile~~aoc_utilities.f90~~AfferentGraph sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~cache_module.f90~2 cache_module.f90 sourcefile~cache_module.f90~2->sourcefile~aoc_utilities.f90 sourcefile~problem_01.f90 problem_01.f90 sourcefile~problem_01.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_02.f90 problem_02.f90 sourcefile~problem_02.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_03.f90 problem_03.f90 sourcefile~problem_03.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_04.f90 problem_04.f90 sourcefile~problem_04.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_05.f90 problem_05.f90 sourcefile~problem_05.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_06.f90 problem_06.f90 sourcefile~problem_06.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_07.f90 problem_07.f90 sourcefile~problem_07.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_08.f90 problem_08.f90 sourcefile~problem_08.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_09.f90 problem_09.f90 sourcefile~problem_09.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_10.f90 problem_10.f90 sourcefile~problem_10.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_11.f90 problem_11.f90 sourcefile~problem_11.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_12.f90 problem_12.f90 sourcefile~problem_12.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_12b.f90 problem_12b.f90 sourcefile~problem_12b.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_12b.f90->sourcefile~cache_module.f90~2 sourcefile~problem_13.f90 problem_13.f90 sourcefile~problem_13.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_15.f90 problem_15.f90 sourcefile~problem_15.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_16.f90 problem_16.f90 sourcefile~problem_16.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_17.f90 problem_17.f90 sourcefile~problem_17.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_17b.f90 problem_17b.f90 sourcefile~problem_17b.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_17b.f90->sourcefile~cache_module.f90~2 sourcefile~problem_18.f90 problem_18.f90 sourcefile~problem_18.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_19.f90 problem_19.f90 sourcefile~problem_19.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_19b.f90 problem_19b.f90 sourcefile~problem_19b.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_21.f90 problem_21.f90 sourcefile~problem_21.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_22.f90 problem_22.f90 sourcefile~problem_22.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_22.f90->sourcefile~cache_module.f90~2 sourcefile~problem_23.f90 problem_23.f90 sourcefile~problem_23.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_24.f90 problem_24.f90 sourcefile~problem_24.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_25.f90 problem_25.f90 sourcefile~problem_25.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !************************************************************************************************ !> !  Helper classes and routines for Advent of Code ! !### Author !  * Jacob Williams module aoc_utilities use iso_fortran_env , ip => int64 , wp => real64 implicit none private public :: ip , wp integer , parameter :: chunk_size = 100 !! for dynamic allocations type , public :: clock private integer ( ip ) :: begin , end , rate contains procedure , public :: tic => clock_start procedure , public :: toc => clock_end end type clock type ( clock ), public :: clk !! a public clock to use for timing in the problems type , public :: string !! a type containing an allocatable character string. !! so we can have an array of strings of different lengths. character ( len = :), allocatable :: str contains procedure , public :: to_int => string_to_int !! convert to integer procedure , public :: to_int_64 => string_to_int_64 end type string type , public :: int64_vec !! an type that contains an allocatable ip array. !! so we can have an array of these. integer ( ip ), dimension (:), allocatable :: vals end type int64_vec public :: read_file_to_integer_array , & read_file_to_integer64_array , & read_file_to_char_array , & read_file_to_int_array public :: number_of_lines_in_file public :: read_line public :: parse_ints , parse_ints64 public :: is_number , is_not_number public :: str_to_array public :: lcm public :: reverse public :: diff public :: locpt , parea public :: str_to_int_array_with_mapping , str_to_int64_array_with_mapping public :: int_array_to_char_array public :: hex2int public :: inverse public :: cross interface sort procedure :: sort_ascending , sort_ascending_64 end interface sort public :: sort interface parse procedure :: parse_nums64 end interface parse public :: parse interface split procedure :: split1 , split2 end interface split public :: split interface int procedure :: string_to_int , & char_to_int , char_to_int64 , & char_array_to_int end interface int public :: int interface unique procedure :: unique32 , unique64 end interface unique public :: unique interface startswith !! test if a string starts with a specified substring procedure :: startswith_cc , startswith_ss , startswith_sc , startswith_cs end interface startswith public :: startswith interface swap procedure :: swap32 , swap64 , swap_str end interface swap public :: swap interface manhatten_distance procedure :: manhatten_distance_64 end interface manhatten_distance public :: manhatten_distance contains !************************************************************************************************ !**************************************************************** !> !  Start the clock subroutine clock_start ( me ) class ( clock ), intent ( inout ) :: me call system_clock ( me % begin , me % rate ) end subroutine clock_start !**************************************************************** !**************************************************************** !> !  Print runtime in milliseconds form the start of the clock. subroutine clock_end ( me , case_str ) class ( clock ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: case_str !! description of the case integer :: itime !! time in integer milliseconds call system_clock ( me % end ) itime = int ( 1000 * ( me % end - me % begin ) / real ( me % rate , wp )) write ( * , '(a,I4,a)' ) trim ( case_str ) // ' runtime: ' , itime , ' ms' write ( * , '(a)' ) '---------------------------' write ( * , * ) '' end subroutine clock_end !**************************************************************** !**************************************************************** !> !  Basic string to integer routine pure function char_to_int ( str ) result ( i ) character ( len =* ), intent ( in ) :: str integer :: i read ( str , * ) i end function char_to_int !**************************************************************** !**************************************************************** !> !  Basic string to integer routine pure elemental function string_to_int ( me ) result ( i ) class ( string ), intent ( in ) :: me integer :: i i = int ( me % str ) end function string_to_int !**************************************************************** !**************************************************************** !> !  Basic string to integer routine pure elemental function string_to_int_64 ( me ) result ( i ) class ( string ), intent ( in ) :: me integer ( ip ) :: i i = int ( me % str , ip ) end function string_to_int_64 !**************************************************************** !**************************************************************** !> !  Basic string to integer(ip) routine. !  Hacky hack just so we can overload as int() pure function char_to_int64 ( str , kind ) result ( i ) character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: kind integer ( ip ) :: i if ( kind /= ip ) error stop 'error' read ( str , * ) i end function char_to_int64 !**************************************************************** !**************************************************************** !> !  Character array to integer routine pure function char_array_to_int ( str_array ) result ( i ) character ( len = 1 ), dimension (:), intent ( in ) :: str_array !! example ['1','3'] --> 13 integer :: i character ( len = :), allocatable :: str integer :: k str = '' do k = 1 , size ( str_array ) str = str // str_array ( k ) end do i = char_to_int ( str ) end function char_array_to_int !**************************************************************** !**************************************************************** !> !  integer array to Character array pure function int_array_to_char_array ( iarray ) result ( carray ) integer , dimension (:,:), intent ( in ) :: iarray character ( len = 1 ), dimension (:,:), allocatable :: carray integer :: i , j allocate ( carray ( size ( iarray , 1 ), size ( iarray , 2 ))) do i = 1 , size ( iarray , 1 ) do j = 1 , size ( iarray , 2 ) write ( carray ( i , j ), '(I1)' ) iarray ( i , j ) end do end do end function int_array_to_char_array !**************************************************************** !**************************************************************** !> !  Read a file into a 2d character array. function read_file_to_char_array ( filename , border ) result ( array ) character ( len =* ), intent ( in ) :: filename character ( len = 1 ), intent ( in ), optional :: border !! if true, extra border is added with this char character ( len = 1 ), dimension (:,:), allocatable :: array integer :: i , j , iunit , n_lines , n_cols character ( len = :), allocatable :: line open ( newunit = iunit , file = filename , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) line = read_line ( iunit ); n_cols = len ( line ) rewind ( iunit ) if ( present ( border )) then allocate ( array ( 0 : n_lines + 1 , 0 : n_cols + 1 )) ! padding with border array = border else allocate ( array ( n_lines , n_cols )) end if do i = 1 , n_lines line = read_line ( iunit ) do j = 1 , n_cols array ( i , j ) = line ( j : j ) end do end do close ( iunit ) end function read_file_to_char_array !**************************************************************** !**************************************************************** !> !  Read a file into a 2d character array. function read_file_to_int_array ( filename ) result ( array ) character ( len =* ), intent ( in ) :: filename integer , dimension (:,:), allocatable :: array integer :: i , iunit , n_lines , n_cols character ( len = :), allocatable :: line open ( newunit = iunit , file = filename , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) line = read_line ( iunit ) n_cols = len ( line ) rewind ( iunit ) allocate ( array ( n_lines , n_cols )) do i = 1 , n_lines line = read_line ( iunit ) read ( line , '(*(I1))' ) array ( i , 1 : n_cols ) end do close ( iunit ) end function read_file_to_int_array !**************************************************************** !**************************************************************** !> !  Read a file into an integer array (one element per line) function read_file_to_integer_array ( filename ) result ( iarray ) character ( len =* ), intent ( in ) :: filename integer , dimension (:), allocatable :: iarray integer :: i , iunit , n_lines , istat open ( newunit = iunit , file = filename , iostat = istat ) if ( istat /= 0 ) error stop ' error reading file' n_lines = number_of_lines_in_file ( iunit ) allocate ( iarray ( n_lines )) do i = 1 , n_lines read ( iunit , '(I10)' ) iarray ( i ) end do close ( iunit ) end function read_file_to_integer_array !**************************************************************** !**************************************************************** !> !  Read a file into an ip integer array (one element per line) function read_file_to_integer64_array ( filename ) result ( iarray ) character ( len =* ), intent ( in ) :: filename integer ( ip ), dimension (:), allocatable :: iarray integer :: i , iunit , n_lines , istat open ( newunit = iunit , file = filename , iostat = istat ) if ( istat /= 0 ) error stop ' error reading file' n_lines = number_of_lines_in_file ( iunit ) allocate ( iarray ( n_lines )) do i = 1 , n_lines read ( iunit , * ) iarray ( i ) end do close ( iunit ) end function read_file_to_integer64_array !**************************************************************** !**************************************************************** !> !  Returns the number of lines in a file (assumed to be open) function number_of_lines_in_file ( iunit ) result ( n_lines ) integer , intent ( in ) :: iunit !! the file unit number !! (assumed to be open) integer :: n_lines !! the number of lines in the file character ( len = 1 ) :: tmp integer :: istat rewind ( iunit ) n_lines = 0 do read ( iunit , fmt = '(A1)' , iostat = istat ) tmp if ( is_iostat_end ( istat )) exit n_lines = n_lines + 1 end do rewind ( iunit ) end function number_of_lines_in_file !**************************************************************** !**************************************************************** !> !  Sorts an integer array `ivec` in increasing order. !  Uses a basic recursive quicksort !  (with insertion sort for partitions with \\le 20 elements). subroutine sort_ascending ( ivec ) integer , dimension (:), intent ( inout ) :: ivec integer , parameter :: max_size_for_insertion_sort = 20 !! max size for using insertion sort. call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending !**************************************************************** !**************************************************************** !> subroutine sort_ascending_64 ( ivec ) integer ( ip ), dimension (:), intent ( inout ) :: ivec integer ( ip ), parameter :: max_size_for_insertion_sort = 20 !! max size for using insertion sort. call quicksort ( 1_ip , size ( ivec , kind = ip )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array integer ( ip ), intent ( in ) :: ilow integer ( ip ), intent ( in ) :: ihigh integer ( ip ) :: ipivot !! pivot element integer ( ip ) :: i !! counter integer ( ip ) :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap64 ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer ( ip ), intent ( in ) :: ilow integer ( ip ), intent ( in ) :: ihigh integer ( ip ), intent ( out ) :: ipivot integer ( ip ) :: i , ip call swap64 ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap64 ( ivec ( ip ), ivec ( i )) end if end do call swap64 ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending_64 !**************************************************************** !**************************************************************** !> !  Swap two integer values. pure elemental subroutine swap32 ( i1 , i2 ) integer , intent ( inout ) :: i1 integer , intent ( inout ) :: i2 integer :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap32 !**************************************************************** !**************************************************************** !> !  Swap two integer values. pure elemental subroutine swap64 ( i1 , i2 ) integer ( ip ), intent ( inout ) :: i1 integer ( ip ), intent ( inout ) :: i2 integer ( ip ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap64 !**************************************************************** !**************************************************************** !> !  Swap two character string values pure elemental subroutine swap_str ( i1 , i2 ) character ( len =* ), intent ( inout ) :: i1 character ( len =* ), intent ( inout ) :: i2 character ( len = len ( i1 )) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_str !**************************************************************** !**************************************************************** !> !  Split a `string`, given a token. pure function split2 ( s , token ) result ( vals ) implicit none type ( string ), intent ( in ) :: s character ( len =* ), intent ( in ) :: token type ( string ), dimension (:), allocatable :: vals if ( allocated ( s % str )) then vals = split1 ( s % str , token ) else error stop 'error: string not allocated' end if end function split2 !**************************************************************** !**************************************************************** !> !  Split a character string using a token. !  This routine is inspired by the Python split function. ! !### Example !````Fortran !   character(len=:),allocatable :: s !   type(string),dimension(:),allocatable :: vals !   s = '1,2,3,4,5' !   call split(s,',',vals) !```` pure function split1 ( str , token ) result ( vals ) implicit none character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ) :: token type ( string ), dimension (:), allocatable :: vals integer :: i !! counter integer :: len_str !! significant length of `str` integer :: len_token !! length of the token integer :: n_tokens !! number of tokens integer :: i1 !! index integer :: i2 !! index integer :: j !! counters integer , dimension (:), allocatable :: itokens !! start indices of the !! token locations in `str` len_token = len ( token ) ! length of the token n_tokens = 0 ! initialize the token counter j = 0 ! index to start looking for the next token ! first, count the number of times the token ! appears in the string, and get the token indices. ! ! Examples: !  ',         '    --> 1 !  '1234,67,90'    --> 5,8 !  '123,      '    --> 4 ! length of the string if ( token == ' ' ) then ! in this case, we can't ignore trailing space len_str = len ( str ) else ! safe to ignore trailing space when looking for tokens len_str = len_trim ( str ) end if j = 1 n_tokens = 0 do if ( j > len_str ) exit ! end of string, finished i = index ( str ( j :), token ) ! index of next token in remaining string if ( i <= 0 ) exit ! no more tokens found call expand_vector ( itokens , n_tokens , i + j - 1 ) ! save the token location j = j + i + ( len_token - 1 ) end do call expand_vector ( itokens , n_tokens , finished = . true .) ! resize the vector allocate ( vals ( n_tokens + 1 )) if ( n_tokens > 0 ) then len_str = len ( str ) i1 = 1 i2 = itokens ( 1 ) - 1 if ( i2 >= i1 ) then vals ( 1 )% str = str ( i1 : i2 ) else vals ( 1 )% str = '' !the first character is a token end if !      1 2 3 !    'a,b,c,d' do i = 2 , n_tokens i1 = itokens ( i - 1 ) + len_token i2 = itokens ( i ) - 1 if ( i2 >= i1 ) then vals ( i )% str = str ( i1 : i2 ) else vals ( i )% str = '' !empty element (e.g., 'abc,,def') end if end do i1 = itokens ( n_tokens ) + len_token i2 = len_str if ( itokens ( n_tokens ) + len_token <= len_str ) then vals ( n_tokens + 1 )% str = str ( i1 : i2 ) else vals ( n_tokens + 1 )% str = '' !the last character was a token end if else !no tokens present, so just return the original string: vals ( 1 )% str = str end if end function split1 !**************************************************************** !**************************************************************** !> !  Add elements to the integer vector in chunks. pure subroutine expand_vector ( vec , n , val , finished ) integer , dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) integer , dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector !**************************************************************** !**************************************************************** !> !  Reads the next line from a file. function read_line ( iunit , status_ok ) result ( line ) integer , intent ( in ) :: iunit character ( len = :), allocatable :: line logical , intent ( out ), optional :: status_ok !! true if no problems integer :: nread !! character count specifier for read statement integer :: istat !! file read io status flag character ( len = chunk_size ) :: buffer !! the file read buffer nread = 0 buffer = '' line = '' if ( present ( status_ok )) status_ok = . true . do ! read in the next block of text from the line: read ( iunit , fmt = '(A)' , advance = 'NO' , size = nread , iostat = istat ) buffer if ( IS_IOSTAT_END ( istat ) . or . IS_IOSTAT_EOR ( istat )) then ! add the last block of text before the end of record if ( nread > 0 ) line = line // buffer ( 1 : nread ) exit else if ( istat == 0 ) then ! all the characters were read line = line // buffer ! add this block of text to the string else ! some kind of error if ( present ( status_ok )) then status_ok = . false . exit else error stop 'Read error' end if end if end do end function read_line !**************************************************************** !**************************************************************** !> !  Return only the unique values from vec. function unique32 ( vec ) result ( vec_unique ) integer , dimension (:), intent ( in ) :: vec integer , dimension (:), allocatable :: vec_unique integer :: i , num logical , dimension ( size ( vec )) :: mask mask = . false . do i = 1 , size ( vec ) !count the number of occurrences of this element: num = count ( vec ( i ) == vec ) if ( num == 1 ) then !there is only one, flag it: mask ( i ) = . true . else !flag this value only if it hasn't already been flagged: if (. not . any ( vec ( i ) == vec . and . mask ) ) mask ( i ) = . true . end if end do !return only flagged elements: allocate ( vec_unique ( count ( mask )) ) vec_unique = pack ( vec , mask ) ! also sort it: call sort ( vec_unique ) end function unique32 !**************************************************************** !**************************************************************** !> !  Return only the unique values from vec. function unique64 ( vec ) result ( vec_unique ) integer ( ip ), dimension (:), intent ( in ) :: vec integer ( ip ), dimension (:), allocatable :: vec_unique integer ( ip ) :: i , num logical , dimension ( size ( vec )) :: mask mask = . false . do i = 1 , size ( vec ) !count the number of occurrences of this element: num = count ( vec ( i ) == vec ) if ( num == 1 ) then !there is only one, flag it: mask ( i ) = . true . else !flag this value only if it hasn't already been flagged: if (. not . any ( vec ( i ) == vec . and . mask ) ) mask ( i ) = . true . end if end do !return only flagged elements: allocate ( vec_unique ( count ( mask )) ) vec_unique = pack ( vec , mask ) ! also sort it: call sort ( vec_unique ) end function unique64 !**************************************************************** !**************************************************************** !> !  parse positive ints from a string that also includes text function parse_ints ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer , dimension (:), allocatable :: ints ! array of integers integer :: i , j , n integer :: istart character ( len =* ), parameter :: tokens = '0123456789' n = len ( line ) istart = 0 allocate ( ints ( 0 )) do i = 1 , n if ( index ( tokens , line ( i : i )) > 0 ) then if ( istart == 0 ) istart = i else if ( istart /= 0 ) ints = [ ints , int ( line ( istart : i - 1 ))] ! get previous int istart = 0 end if end do if ( istart /= 0 ) ints = [ ints , int ( line ( istart : n ))] ! get last int end function parse_ints !**************************************************************** !**************************************************************** !> !  Parse positive ints from a string that also includes text function parse_ints64 ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer ( ip ), dimension (:), allocatable :: ints ! array of integers integer ( ip ) :: i , j , n integer ( ip ) :: istart character ( len =* ), parameter :: tokens = '0123456789' n = len ( line ) istart = 0 allocate ( ints ( 0 )) do i = 1 , n if ( index ( tokens , line ( i : i )) > 0 ) then if ( istart == 0 ) istart = i else if ( istart /= 0 ) ints = [ ints , int ( line ( istart : i - 1 ), kind = ip )] ! get previous int istart = 0 end if end do if ( istart /= 0 ) ints = [ ints , int ( line ( istart : n ), kind = ip )] ! get last int end function parse_ints64 !**************************************************************** !**************************************************************** !> !  parse space-deliminated ip sequence (positive or negative) function parse_nums64 ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer ( ip ), dimension (:), allocatable :: ints ! array of integers ints = int ( split ( line , ' ' )) end function parse_nums64 !**************************************************************** !> !  starts with function for strings pure logical function startswith_cc ( str , substring ) character ( len =* ), intent ( in ) :: str , substring startswith_cc = index ( str , substring ) == 1 end function startswith_cc pure logical function startswith_ss ( str , substring ) type ( string ), intent ( in ) :: str , substring startswith_ss = startswith ( str % str , substring % str ) end function startswith_ss pure logical function startswith_sc ( str , substring ) type ( string ), intent ( in ) :: str character ( len =* ), intent ( in ) :: substring startswith_sc = startswith ( str % str , substring ) end function startswith_sc pure logical function startswith_cs ( str , substring ) character ( len =* ), intent ( in ) :: str type ( string ), intent ( in ) :: substring startswith_cs = startswith ( str , substring % str ) end function startswith_cs !**************************************************************** !**************************************************************** !> !  returns true if the character is a number from 0 to 9. logical function is_number ( c ) character ( len = 1 ), intent ( in ) :: c is_number = c >= '0' . and . c <= '9' end function is_number !**************************************************************** !**************************************************************** !> !  returns true if the character is not a number. logical function is_not_number ( c ) character ( len = 1 ), intent ( in ) :: c is_not_number = . not . is_number ( c ) end function is_not_number !**************************************************************** !**************************************************************** !> !  convert the character string to an array of characters function str_to_array ( s ) result ( a ) character ( len =* ), intent ( in ) :: s character ( len = 1 ), dimension ( len ( s )) :: a integer :: i do i = 1 , len ( s ) ! transfer a ( i ) = s ( i : i ) end do end function str_to_array !**************************************************************** !**************************************************************** !> !  LCM. based on code from NCAR Command Language pure integer ( ip ) function lcm ( i , j ) integer ( ip ), intent ( in ) :: i , j integer ( ip ) :: rem , m , n m = abs ( i ) n = abs ( j ) lcm = 0 if ( m <= 0 . or . n <= 0 ) return do rem = mod ( m , n ) if ( rem <= 0 ) exit m = n n = rem end do lcm = abs ( i * j / n ) end function lcm !**************************************************************** !**************************************************************** !> !  Reverse an ip vector pure function reverse ( ivals ) result ( ireverse ) integer ( ip ), dimension (:), intent ( in ) :: ivals integer ( ip ), dimension ( size ( ivals )) :: ireverse integer :: i ireverse = [( ivals ( i ), i = size ( ivals ), 1 , - 1 )] end function reverse !**************************************************************** !**************************************************************** !> !  Difference ip vector pure function diff ( ivals ) result ( idiff ) integer ( ip ), dimension (:), intent ( in ) :: ivals integer ( ip ), dimension (:), allocatable :: idiff integer :: i !! counter idiff = [( ivals ( i + 1 ) - ivals ( i ), i = 1 , size ( ivals ) - 1 )] end function diff !**************************************************************** ! the following routine is from the Fortran Astrodynamics Toolkit !***************************************************************************************** !> !  given a polygonal line connecting the vertices (x(i),y(i)) !  (i = 1,...,n) taken in this order. it is assumed that the !  polygonal path is a loop, where (x(n),y(n)) = (x(1),y(1)) !  or there is an arc from (x(n),y(n)) to (x(1),y(1)). ! !  (x0,y0) is an arbitrary point and l and m are variables. !  l and m are assigned the following values: ! !     l = -1   if (x0,y0) is outside the polygonal path !     l =  0   if (x0,y0) lies on the polygonal path !     l =  1   if (x0,y0) is inside the polygonal path ! !  m = 0 if (x0,y0) is on or outside the path. if (x0,y0) !  is inside the path then m is the winding number of the !  path around the point (x0,y0). ! !# History !  * Original version from the NSWC Library !  * Modified by J. Williams : 08/04/2012 : refactored to modern Fortran pure subroutine locpt ( x0 , y0 , x , y , n , l , m ) implicit none !arguments: integer , intent ( in ) :: n real ( wp ), intent ( in ) :: x0 real ( wp ), intent ( in ) :: y0 real ( wp ), dimension ( n ), intent ( in ) :: x real ( wp ), dimension ( n ), intent ( in ) :: y integer , intent ( out ) :: l integer , intent ( out ) :: m !constants: real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) real ( wp ), parameter :: pi = atan2 ( 0.0_wp , - 1.0_wp ) real ( wp ), parameter :: pi2 = 2.0_wp * pi real ( wp ), parameter :: tol = 4.0_wp * eps * pi !local variables: integer :: i , n0 real ( wp ) :: u , v , theta1 , sum , theta , angle , thetai n0 = n if ( x ( 1 ) == x ( n ) . and . y ( 1 ) == y ( n )) n0 = n - 1 l = - 1 m = 0 u = x ( 1 ) - x0 v = y ( 1 ) - y0 if ( u == 0.0_wp . and . v == 0.0_wp ) then l = 0 !(x0, y0) is on the boundary of the path else if ( n0 >= 2 ) then theta1 = atan2 ( v , u ) sum = 0.0_wp theta = theta1 do i = 2 , n0 u = x ( i ) - x0 v = y ( i ) - y0 if ( u == 0.0_wp . and . v == 0.0_wp ) then l = 0 !(x0, y0) is on the boundary of the path exit end if thetai = atan2 ( v , u ) angle = abs ( thetai - theta ) if ( abs ( angle - pi ) < tol ) then l = 0 !(x0, y0) is on the boundary of the path exit end if if ( angle > pi ) angle = angle - pi2 if ( theta > thetai ) angle = - angle sum = sum + angle theta = thetai end do if ( l /= 0 ) then angle = abs ( theta1 - theta ) if ( abs ( angle - pi ) < tol ) then l = 0 !(x0, y0) is on the boundary of the path else if ( angle > pi ) angle = angle - pi2 if ( theta > theta1 ) angle = - angle sum = sum + angle !sum = 2*pi*m where m is the winding number m = abs ( sum ) / pi2 + 0.2_wp if ( m /= 0 ) then l = 1 if ( sum < 0.0_wp ) m = - m end if end if end if end if end if end subroutine locpt !***************************************************************************************** !***************************************************************************************** !> !  given a sequence of nb points (x(i),y(i)). parea computes !  the area bounded by the closed polygonal curve which passes !  through the points in the order that they are indexed. the !  final point of the curve is assumed to be the first point !  given. therefore, it need not be listed at the end of x and !  y. the curve is not required to be simple. ! !  * Original version from the NSWC Library real ( wp ) function parea ( x , y , nb ) real ( wp ), intent ( in ) :: x ( nb ), y ( nb ) integer , intent ( in ) :: nb real ( wp ) :: a integer :: n , nm1 , i n = nb if ( x ( 1 ) == x ( n ) . and . y ( 1 ) == y ( n )) n = n - 1 if ( n - 3 < 0 ) then parea = 0.0_wp else if ( n - 3 == 0 ) then parea = 0.5_wp * (( x ( 2 ) - x ( 1 )) * ( y ( 3 ) - y ( 1 )) - ( x ( 3 ) - x ( 1 )) * ( y ( 2 ) - y ( 1 ))) else nm1 = n - 1 a = x ( 1 ) * ( y ( 2 ) - y ( n )) + x ( n ) * ( y ( 1 ) - y ( nm1 )) do i = 2 , nm1 a = a + x ( i ) * ( y ( i + 1 ) - y ( i - 1 )) end do parea = 0.5_wp * a end if end function parea !***************************************************************************************** !***************************************************************************************** !> !  Manhattan distance between two `ip` points. pure integer ( ip ) function manhatten_distance_64 ( x1 , y1 , x2 , y2 ) integer ( ip ), intent ( in ) :: x1 , y1 , x2 , y2 manhatten_distance_64 = abs ( x1 - x2 ) + abs ( y1 - y2 ) end function manhatten_distance_64 !***************************************************************************************** !***************************************************************************************** !> !  Convert a string to a numeric array by mapping characters to integers (user-specified) pure function str_to_int_array_with_mapping ( str , ichars , iints ) result ( array ) character ( len =* ), intent ( in ) :: str character ( len = 1 ), dimension (:), intent ( in ) :: ichars !! characters to process integer , dimension (:), intent ( in ) :: iints !! int values of the chars integer , dimension (:), allocatable :: array integer :: i integer , dimension ( 1 ) :: iloc allocate ( array ( len ( str ))) do i = 1 , len ( str ) iloc = findloc ( ichars , str ( i : i )) if ( iloc ( 1 ) > 0 ) then array ( i ) = iints ( iloc ( 1 )) else error stop 'error: could not map character: ' // str ( i : i ) end if end do end function str_to_int_array_with_mapping !***************************************************************************************** !***************************************************************************************** !> !  Convert a string to a numeric array by mapping characters to integers (user-specified) pure function str_to_int64_array_with_mapping ( str , ichars , iints ) result ( array ) character ( len =* ), intent ( in ) :: str character ( len = 1 ), dimension (:), intent ( in ) :: ichars !! characters to process integer ( ip ), dimension (:), intent ( in ) :: iints !! int values of the chars integer ( ip ), dimension (:), allocatable :: array integer :: i integer , dimension ( 1 ) :: iloc allocate ( array ( len ( str ))) do i = 1 , len ( str ) iloc = findloc ( ichars , str ( i : i )) if ( iloc ( 1 ) > 0 ) then array ( i ) = iints ( iloc ( 1 )) else error stop 'error: could not map character: ' // str ( i : i ) end if end do end function str_to_int64_array_with_mapping !***************************************************************************************** !***************************************************************************************** !> !!  hex string to int value. lowercase letters assumed! !!  no error checking here! pure integer function hex2int ( hex ) character ( len =* ), intent ( in ) :: hex integer :: i , n , ipower ! 70c71 -> 461937 n = len ( hex ) hex2int = 0 !base 16 (0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f) ipower = - 1 do i = n , 1 , - 1 ipower = ipower + 1 associate ( c => hex ( i : i )) if ( c >= 'a' . and . c <= 'f' ) then hex2int = hex2int + ( 10 + iachar ( c ) - iachar ( 'a' )) * ( 16 ** ipower ) else hex2int = hex2int + ( iachar ( c ) - iachar ( '0' )) * ( 16 ** ipower ) end if end associate end do end function hex2int !***************************************************************************************** !***************************************************************************************** !> !  inverse of a 2x2 matrix. ! !  See: https://caps.gsfc.nasa.gov/simpson/software/m22inv_f90.txt subroutine inverse ( a , ainv , status_ok ) real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: a real ( wp ), dimension ( 2 , 2 ), intent ( out ) :: ainv logical , intent ( out ) :: status_ok real ( wp ), parameter :: eps = 1.0e-10_wp real ( wp ), dimension ( 2 , 2 ) :: cofactor associate ( det => a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 2 , 1 ) ) if ( abs ( det ) <= eps ) then ainv = 0.0_wp status_ok = . false . else cofactor ( 1 , 1 ) = + a ( 2 , 2 ) cofactor ( 1 , 2 ) = - a ( 2 , 1 ) cofactor ( 2 , 1 ) = - a ( 1 , 2 ) cofactor ( 2 , 2 ) = + a ( 1 , 1 ) ainv = transpose ( cofactor ) / det status_ok = . true . end if end associate end subroutine inverse !************************************************************************************************ !************************************************************************************************ !> !   Cross product of two real 3x1 vectors pure function cross ( r , v ) result ( c ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r real ( wp ), dimension ( 3 ), intent ( in ) :: v real ( wp ), dimension ( 3 ) :: c c ( 1 ) = r ( 2 ) * v ( 3 ) - v ( 2 ) * r ( 3 ) c ( 2 ) = r ( 3 ) * v ( 1 ) - v ( 3 ) * r ( 1 ) c ( 3 ) = r ( 1 ) * v ( 2 ) - v ( 1 ) * r ( 2 ) end function cross !************************************************************************************************ !************************************************************************************************ end module aoc_utilities !************************************************************************************************","tags":"","loc":"sourcefile/aoc_utilities.f90.html"},{"title":"problem_17b.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_17b.f90~~EfferentGraph sourcefile~problem_17b.f90 problem_17b.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_17b.f90->sourcefile~aoc_utilities.f90 sourcefile~cache_module.f90~2 cache_module.f90 sourcefile~problem_17b.f90->sourcefile~cache_module.f90~2 sourcefile~cache_module.f90~2->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_17 !! part b use aoc_utilities use iso_fortran_env use aoc_cache_module implicit none integer , parameter :: NSTATE = 4 !! number of state dimensions [i,j,direction,moves_in_that_direction] integer , parameter :: N_DIRECTIONS = 4 ! 1,2,3,4 integer ( ip ), parameter :: UP = 1 ! direction traveling integer ( ip ), parameter :: DOWN = - 1 integer ( ip ), parameter :: LEFT = 2 integer ( ip ), parameter :: RIGHT = - 2 integer , parameter :: MAX_MOVES_IN_DIR = 10 !3 type ( function_cache ) :: cache !! to cache the queue access ... to try to speed things up !!! ! queue for the states and distances... rather than constructing the 2d array... ! just create this as we go... type :: item integer ( ip ), dimension ( NSTATE ) :: state = 0 !! state: [i, j, direction, and # of moves] integer ( ip ) :: dist = huge ( 1 ) !! distance for this one logical :: visited = . false . !! if this one is done integer ( ip ) :: iprev = - 1 !! index in the queue of the previous one end type item type ( item ), dimension (:), allocatable :: queue !! will be expanding integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: idx integer :: i , j , n_rows , n_cols integer , dimension (:,:), allocatable :: map !! heat map integer ( ip ) :: queue_size ! for the CI ! need a faster version ... write ( * , * ) 'it works but takes a few minutes...' stop call clk % tic () call cache % initialize ( isize = 10000 , chunk_size = 1000 ) ! map = read_file_to_int_array('inputs/day17_test.txt') map = read_file_to_int_array ( 'inputs/day17.txt' ) n_rows = size ( map , 1 ) n_cols = size ( map , 2 ) queue_size = 0 call add_to_queue ([ 1_ip , 1_ip , 0_ip , 0_ip ], idx ) ! start queue ( idx )% dist = 0 do ! find min distance so far for ones not visited iloc = minloc ( queue ( 1 : queue_size )% dist , mask = . not . queue ( 1 : queue_size )% visited ) idx = iloc ( 1 ) ! index in the queue queue ( idx )% visited = . true . if ( queue ( idx )% state ( 1 ) == n_rows . and . queue ( idx )% state ( 2 ) == n_cols ) exit ! destination: we are done ! process ajacent ones: call check ( idx , UP ) call check ( idx , DOWN ) call check ( idx , LEFT ) call check ( idx , RIGHT ) end do write ( * , * ) '17b: ' , queue ( idx )% dist call clk % toc ( '17' ) contains subroutine check ( idx , idirection ) implicit none integer ( ip ), intent ( in ) :: idx ! current item in the queue to process integer ( ip ), intent ( in ) :: idirection !! direction to move from current integer ( ip ) :: alt integer ( ip ), dimension ( 2 ) :: v ! neighbor to move to integer ( ip ) :: imovesv , idxv , distv integer ( ip ), dimension ( NSTATE ) :: istate logical :: in_queue associate ( i => queue ( idx )% state ( 1 ), & j => queue ( idx )% state ( 2 ), & direction => queue ( idx )% state ( 3 ), & n_moves => queue ( idx )% state ( 4 )) if ( direction ==- idirection ) return ! can't reverse ! the one to go to: if ( direction == idirection ) then if ( n_moves == MAX_MOVES_IN_DIR ) return ! can't move in this direction anymore imovesv = n_moves + 1 else if ( n_moves /= 0 . and . n_moves < 4 ) return ! must move at last 4 before a turn! imovesv = 1 ! reset on change of direction end if select case ( idirection ) case ( UP ); v = [ i - 1 , j ] case ( DOWN ); v = [ i + 1 , j ] case ( LEFT ); v = [ i , j - 1 ] case ( RIGHT ); v = [ i , j + 1 ] end select if ( v ( 1 ) < 1 . or . v ( 2 ) < 1 . or . v ( 1 ) > n_rows . or . v ( 2 ) > n_cols ) return ! can't go off the board if ( v ( 1 ) == n_rows . and . v ( 2 ) == n_cols . and . imovesv < 4 ) return ! require at least 4 to end istate = [ v ( 1 ), v ( 2 ), idirection , imovesv ] ! new state idxv = index_in_queue ( istate ) ! is it already in the queue in_queue = idxv > 0 ! if this one is already part of another path if ( in_queue ) then if ( queue ( idxv )% visited ) return ! already visited this one distv = queue ( idxv )% dist ! distance in the queue else !call add_to_queue(istate, idxv) ! add this to the queue for processing ! always add it ?? distv = huge ( 1_ip ) ! not processed yet, so huge number end if !alt = queue(idx)%dist + map(queue(idxv)%state(1), queue(idxv)%state(2)) alt = queue ( idx )% dist + map ( v ( 1 ), v ( 2 )) ! new distance if ( alt < distv ) then ! the new one is better, so replace values in the queue if (. not . in_queue ) call add_to_queue ( istate , idxv ) ! only add it if we accept it ???? ! accept this step queue ( idxv )% dist = alt ! new best dist queue ( idxv )% iprev = idx ! previous end if end associate end subroutine check ! .. need a faster queue... function index_in_queue ( state ) result ( idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ) :: idx !! index in the queue. -1 if not present integer ( ip ) :: i logical :: found integer ( ip ) :: cache_idx integer ( ip ), dimension (:), allocatable :: cache_ival call cache % get ( state , cache_idx , cache_ival , found ) if ( found ) then idx = cache_ival ( 1 ) else idx = - 1 if (. not . allocated ( queue )) error stop 'error: queue not allocated' do i = 1 , queue_size if ( all ( state == queue ( i )% state )) then idx = i exit end if end do if ( idx /= - 1 ) call cache % put ( cache_idx , state ,[ idx ]) end if end function index_in_queue subroutine add_to_queue ( state , idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ), intent ( out ) :: idx !! index of the element in the queue if ( allocated ( queue )) then call expand_queue ( queue , queue_size , item ( state = state )) idx = queue_size else queue = [ item ( state = state )] queue_size = 1 idx = 1 end if end subroutine add_to_queue !**************************************************************** !> !  Add elements to the integer vector in chunks. pure subroutine expand_queue ( vec , n , val , finished ) integer ( ip ), parameter :: chunk_size = 1000 type ( item ), dimension (:), allocatable , intent ( inout ) :: vec integer ( ip ), intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call type ( item ), intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) type ( item ), dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_queue !**************************************************************** end program problem_17","tags":"","loc":"sourcefile/problem_17b.f90.html"},{"title":"cache_module.f90 – AoC-2023","text":"This file depends on sourcefile~~cache_module.f90~2~~EfferentGraph sourcefile~cache_module.f90~2 cache_module.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~cache_module.f90~2->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~cache_module.f90~2~~AfferentGraph sourcefile~cache_module.f90~2 cache_module.f90 sourcefile~problem_12b.f90 problem_12b.f90 sourcefile~problem_12b.f90->sourcefile~cache_module.f90~2 sourcefile~problem_17b.f90 problem_17b.f90 sourcefile~problem_17b.f90->sourcefile~cache_module.f90~2 sourcefile~problem_22.f90 problem_22.f90 sourcefile~problem_22.f90->sourcefile~cache_module.f90~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> author: Jacob Williams ! !  For caching function evaluations. ! !  This is based on the cache module from `NumDiff`. !  It has been modified to cache integers (`int64`) instead of reals. module aoc_cache_module use aoc_utilities , only : ip , wp implicit none private type :: fx !! an [x,f(x)] cached pair. !! x is a vector and f is a vector. private integer ( ip ), dimension (:), allocatable :: x !! vector of input values integer ( ip ), dimension (:), allocatable :: f !! output functions end type fx type , public :: function_cache !! a vector function cache. private type ( fx ), dimension (:), allocatable :: c !! the cache of `f(x)` integer :: chunk_size = 100 !! for resizing vectors !! in the [[unique]] function contains private procedure , public :: initialize => initialize_cache procedure , public :: get => get_from_cache procedure , public :: put => put_in_cache procedure , public :: destroy => destroy_cache end type function_cache contains !******************************************************************************* !******************************************************************************* !> !  Initialize the cache. Must be called first before use. subroutine initialize_cache ( me , isize , chunk_size ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: isize !! the size of the hash table integer , intent ( in ), optional :: chunk_size !! chunk size to speed up reallocation !! of arrays. A good value is a guess for !! the actual number of elements of `f` that !! will be saved per value of `x` [default is 100] call me % destroy () allocate ( me % c ( 0 : isize - 1 )) if ( present ( chunk_size )) then me % chunk_size = chunk_size else me % chunk_size = 100 end if end subroutine initialize_cache !******************************************************************************* !******************************************************************************* !> !  Check if the `x` vector is in the cache, if so return `f`. !  Note that only some of the elements may be present, so it will return !  the ones there are there, and indicate which ones were found. subroutine get_from_cache ( me , x , i , f , found ) implicit none class ( function_cache ), intent ( inout ) :: me integer ( ip ), dimension (:), intent ( in ) :: x !! independant variable vector integer ( ip ), intent ( out ) :: i !! index in the hash table integer ( ip ), dimension (:), allocatable , intent ( out ) :: f !! `f(x)` from the cache (if it was found) logical , intent ( out ) :: found !! if `x` was found in the cache integer :: j !! counter ! initialize: found = . false . if ( allocated ( me % c )) then ! get index in the hash table: i = mod ( abs ( vector_djb_hash ( x )), int ( size ( me % c ), ip ) ) ! check the table: if ( allocated ( me % c ( i )% x )) then if ( size ( me % c ( i )% x ) == size ( x )) then if ( all ( me % c ( i )% x == x )) then found = . true . f = me % c ( i )% f end if end if end if else error stop 'Error: the cache has not been initialized.' end if end subroutine get_from_cache !******************************************************************************* !******************************************************************************* !> !  Put a value into the cache. subroutine put_in_cache ( me , i , x , f ) implicit none class ( function_cache ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: i !! index in the hash table integer ( ip ), dimension (:), intent ( in ) :: x !! independant variable vector integer ( ip ), dimension (:), intent ( in ) :: f !! function integer ( ip ), parameter :: null = huge ( 1 ) !! an unusual value to initialize arrays if ( allocated ( me % c )) then if ( i <= size ( me % c )) then ! add to the cache me % c ( i )% x = x me % c ( i )% f = f else error stop 'Error: invalid index in hash table.' end if else error stop 'Error: the cache has not been initialized.' end if end subroutine put_in_cache !******************************************************************************* !******************************************************************************* !> !  Destroy a cache. subroutine destroy_cache ( me ) implicit none class ( function_cache ), intent ( out ) :: me end subroutine destroy_cache !******************************************************************************* !******************************************************************************* !> !  DJB hash algorithm for a `integer(ip)` vector. ! !### See also !  * J. Shahbazian, Fortran hashing algorithm, July 6, 2013 !   [Fortran Dev](https://fortrandev.wordpress.com/2013/07/06/fortran-hashing-algorithm/) pure function vector_djb_hash ( r ) result ( hash ) integer ( ip ), dimension (:), intent ( in ) :: r !! the vector integer ( ip ) :: hash !! the hash value integer :: i !! counter hash = 5381_ip do i = 1 , size ( r ) hash = ishft ( hash , 5_ip ) + hash + r ( i ) end do end function vector_djb_hash !******************************************************************************* !******************************************************************************* end module aoc_cache_module !*******************************************************************************","tags":"","loc":"sourcefile/cache_module.f90~2.html"},{"title":"kinds_module.F90 – AoC-2023","text":"Files dependent on this one sourcefile~~kinds_module.f90~~AfferentGraph sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~cache_module.f90 cache_module.f90 sourcefile~cache_module.f90->sourcefile~kinds_module.f90 sourcefile~utilities_module.f90 utilities_module.f90 sourcefile~cache_module.f90->sourcefile~utilities_module.f90 sourcefile~diff_module.f90 diff_module.f90 sourcefile~diff_module.f90->sourcefile~kinds_module.f90 sourcefile~dsm_module.f90 dsm_module.f90 sourcefile~dsm_module.f90->sourcefile~kinds_module.f90 sourcefile~dsm_test.f90 dsm_test.f90 sourcefile~dsm_test.f90->sourcefile~kinds_module.f90 sourcefile~dsm_test.f90->sourcefile~dsm_module.f90 sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~kinds_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~cache_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~diff_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~dsm_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~utilities_module.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~kinds_module.f90 sourcefile~test1.f90->sourcefile~numerical_differentiation_module.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~kinds_module.f90 sourcefile~test2.f90->sourcefile~numerical_differentiation_module.f90 sourcefile~utilities_module.f90->sourcefile~kinds_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> !  Numeric kinds for NumDiff. ! !@note The default real kind (`wp`) can be !      changed using optional preprocessor flags. !      This library was built with real kind: #ifdef REAL32 !      `real(kind=real32)` [4 bytes] #elif REAL64 !      `real(kind=real64)` [8 bytes] #elif REAL128 !      `real(kind=real128)` [16 bytes] #else !      `real(kind=real64)` [8 bytes] #endif module numdiff_kinds_module use iso_fortran_env private #ifdef REAL32 integer , parameter , public :: wp = real32 !! default real kind [4 bytes] #elif REAL64 integer , parameter , public :: wp = real64 !! default real kind [8 bytes] #elif REAL128 integer , parameter , public :: wp = real128 !! default real kind [16 bytes] #else integer , parameter , public :: wp = real64 !! default real kind [8 bytes] #endif end module numdiff_kinds_module !*******************************************************************************","tags":"","loc":"sourcefile/kinds_module.f90.html"},{"title":"problem_22.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_22.f90~~EfferentGraph sourcefile~problem_22.f90 problem_22.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_22.f90->sourcefile~aoc_utilities.f90 sourcefile~cache_module.f90~2 cache_module.f90 sourcefile~problem_22.f90->sourcefile~cache_module.f90~2 sourcefile~cache_module.f90~2->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_22 use iso_fortran_env use aoc_utilities use aoc_cache_module implicit none integer :: iunit , n_lines integer ( ip ) :: i , j , k character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: start_end , starts , ends integer ( ip ), dimension (:,:), allocatable :: istart_array integer ( ip ), dimension (:,:), allocatable :: iend_array integer ( ip ), dimension (:,:,:), allocatable :: array integer ( ip ), dimension (:), allocatable :: ipieces_above , ipieces_below integer ( ip ) :: ok_to_disintegrate , isum , isum_total logical :: ok_tmp type ( function_cache ) :: above_cache , below_cache call clk % tic () !find the ones we can remove without any other falling: !  to do that, look to see if any above it are not otherwise held up by another piece call initialize () ok_to_disintegrate = 0 do i = 1 , n_lines ipieces_above = get_pieces_above ( i ) if ( size ( ipieces_above ) == 0 ) then ! nothing above, it so ok to remove ok_to_disintegrate = ok_to_disintegrate + 1 else ok_tmp = . true . do j = 1 , size ( ipieces_above ) ! check all the pieces above. if ALL have other supporters then OK to remove ipieces_below = get_pieces_below ( ipieces_above ( j )) if ( all ( ipieces_below == i )) then ! only supported by i , so can't remove i ok_tmp = . false . exit end if end do if ( ok_tmp ) ok_to_disintegrate = ok_to_disintegrate + 1 end if end do write ( * , * ) '22a: ' , ok_to_disintegrate ! for part 2, we need to find all the nodes in the tree ! that are only supportd by ones below that in the tree ! !  777  44444 ! 66111222  9 !88 333333333   <--- deleting 3 will cause 1, 2, 4, 9 to fall, but not 6,7,8 ! just use a cache to save the ones above/below a given piece ! since there is a lot of duplication in that calculation call above_cache % initialize ( isize = 1000 , chunk_size = 1000 ) call below_cache % initialize ( isize = 1000 , chunk_size = 1000 ) call initialize () isum_total = 0 do i = 1 , n_lines ! try remove piece i ipieces_above = get_all_pieces_above ( i ) isum = size ( ipieces_above ) ! start out assuming they will all fall if ( isum > 0 ) then main : do j = 1 , size ( ipieces_above ) ! for all the ones, see if there are any below that are not in the above set. ! is so, then it will not fall. ipieces_below = get_all_pieces_below ( ipieces_above ( j ), iskip = i ) ipieces_below = pack ( ipieces_below , ipieces_below /= i ) ! remove i if present (the one being removed) do k = 1 , size ( ipieces_below ) if (. not . any ( ipieces_below ( k ) == [ ipieces_above ])) then isum = isum - 1 ! this one will not fall, so remove it from total cycle main end if end do end do main end if isum_total = isum_total + isum end do write ( * , * ) '22b: ' , isum_total call clk % toc ( '22' ) contains subroutine initialize () !! read the data ! open(newunit=iunit, file='inputs/day22_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day22.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) if ( allocated ( istart_array )) deallocate ( istart_array ); allocate ( istart_array ( n_lines , 3 )) if ( allocated ( iend_array )) deallocate ( iend_array ); allocate ( iend_array ( n_lines , 3 )) do i = 1 , n_lines line = read_line ( iunit ); start_end = split ( line , '~' ) starts = split ( start_end ( 1 )% str , ',' ) ends = split ( start_end ( 2 )% str , ',' ) istart_array ( i ,:) = [( int ( starts ( j )% str ), j = 1 , 3 )] iend_array ( i ,:) = [( int ( ends ( j )% str ), j = 1 , 3 )] end do close ( iunit ) ! create the array to hold all the pieces: if ( allocated ( array )) deallocate ( array ) allocate ( array ( 0 : maxval ([ istart_array (:, 1 ), iend_array (:, 1 )]),& 0 : maxval ([ istart_array (:, 2 ), iend_array (:, 2 )]),& 0 : maxval ([ istart_array (:, 3 ), iend_array (:, 3 )]))) call update_array () ! set array values from the start/end arrays call drop () ! continue forward in time until all the bricks settle. end subroutine initialize subroutine drop () !! continue forward in time until all the bricks settle. logical :: moved , tmp_moved integer ( ip ) :: i do moved = . false . do i = 1 , n_lines call move_piece_down ( i , tmp_moved ) if ( tmp_moved ) moved = . true . ! at least one was moved end do if (. not . moved ) exit ! done moving all the pieces end do end subroutine drop recursive function get_all_pieces_above ( i ) result ( ipieces ) !! reursively get a list of all pieces above piece i integer ( ip ), intent ( in ) :: i integer ( ip ), dimension (:), allocatable :: ipieces integer :: j !! counter logical :: found integer ( ip ) :: idx call above_cache % get ([ i ], idx , ipieces , found ) if (. not . found ) then allocate ( ipieces ( 0 )) associate ( tmp => get_pieces_above ( i )) if ( size ( tmp ) > 0 ) then ipieces = [ ipieces , tmp ] ! ones directly above do j = 1 , size ( tmp ) ! go up the tree ipieces = [ ipieces , get_all_pieces_above ( tmp ( j ))] end do ipieces = unique ( ipieces ) end if end associate call above_cache % put ( idx ,[ i ], ipieces ) end if end function get_all_pieces_above recursive function get_all_pieces_below ( i , iskip ) result ( ipieces ) !! reursively get a list of all pieces below piece i integer ( ip ), intent ( in ) :: i integer ( ip ), intent ( in ) :: iskip !! skip this one and it's children integer ( ip ), dimension (:), allocatable :: ipieces integer :: j !! counter logical :: found integer ( ip ) :: idx integer ( ip ), dimension (:), allocatable :: tmp call below_cache % get ([ i , iskip ], idx , ipieces , found ) if (. not . found ) then allocate ( ipieces ( 0 )) if ( i == iskip ) return tmp = get_pieces_below ( i ) if ( size ( tmp ) > 0 ) then tmp = pack ( tmp , tmp /= iskip ) ! remove the skipped one ipieces = [ ipieces , tmp ] ! ones directly below do j = 1 , size ( tmp ) ! go down the tree ipieces = [ ipieces , get_all_pieces_below ( tmp ( j ), iskip = iskip )] end do ipieces = unique ( ipieces ) end if call below_cache % put ( idx ,[ i , iskip ], ipieces ) end if end function get_all_pieces_below subroutine update_array () !! populate the array using the start/end indices integer :: i array = 0 do i = 1 , n_lines array ( istart_array ( i , 1 ): iend_array ( i , 1 ),& istart_array ( i , 2 ): iend_array ( i , 2 ),& istart_array ( i , 3 ): iend_array ( i , 3 )) = i end do end subroutine update_array function get_pieces_above ( i ) result ( ipieces ) !! get set of pieces directly above piece i integer ( ip ), intent ( in ) :: i integer ( ip ), dimension (:), allocatable :: ipieces integer ( ip ) :: x , y , z !! counter allocate ( ipieces ( 0 )) do x = istart_array ( i , 1 ), iend_array ( i , 1 ) do y = istart_array ( i , 2 ), iend_array ( i , 2 ) do z = istart_array ( i , 3 ), iend_array ( i , 3 ) if ( z + 1 <= ubound ( array , 3 )) then if ( array ( x , y , z + 1 ) /= 0 ) ipieces = [ ipieces , array ( x , y , z + 1 )] ! above this one end if end do end do end do ipieces = unique ( pack ( ipieces , ipieces /= i )) ! exclude the ones in this piece end function get_pieces_above function get_pieces_below ( i ) result ( ipieces ) !! get set of pieces directly below piece i integer ( ip ), intent ( in ) :: i integer ( ip ), dimension (:), allocatable :: ipieces integer ( ip ) :: x , y , z !! counter allocate ( ipieces ( 0 )) do x = istart_array ( i , 1 ), iend_array ( i , 1 ) do y = istart_array ( i , 2 ), iend_array ( i , 2 ) do z = istart_array ( i , 3 ), iend_array ( i , 3 ) if ( z - 1 > 0 ) then ! 0 is the floor if ( array ( x , y , z - 1 ) /= 0 ) ipieces = [ ipieces , array ( x , y , z - 1 )] ! below this one end if end do end do end do ipieces = unique ( pack ( ipieces , ipieces /= i )) ! exclude the ones in this piece end function get_pieces_below subroutine move_piece_down ( i , moved ) !! move a piece down (fall one square) if it can be moved integer ( ip ), intent ( in ) :: i !! piece number logical , intent ( out ) :: moved !! if it was actually movec moved = . false . if ( size ( get_pieces_below ( i )) == 0 ) then ! can only move if nothing below if ( istart_array ( i , 3 ) > 1 . and . iend_array ( i , 3 ) > 1 ) then istart_array ( i , 3 ) = istart_array ( i , 3 ) - 1 iend_array ( i , 3 ) = iend_array ( i , 3 ) - 1 moved = . true . call update_array () end if end if end subroutine move_piece_down end program problem_22","tags":"","loc":"sourcefile/problem_22.f90.html"},{"title":"problem_19.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_19.f90~~EfferentGraph sourcefile~problem_19.f90 problem_19.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_19.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_19 use aoc_utilities use iso_fortran_env implicit none integer :: iunit , n_lines , iline , i character ( len = :), allocatable :: line !, name type ( string ), dimension (:), allocatable :: vals logical :: accepted integer ( ip ) :: total_accepted type :: part integer ( ip ), dimension ( 4 ) :: xmas ! [x,m,a,s] end type part type ( part ), dimension (:), allocatable :: parts type :: rule logical :: accept = . false . logical :: reject = . false . integer :: operator = 0 ! 1:<, 2:> integer :: operator_arg = 0 ! 1:x, 2:m, 3:a, 4:s integer :: operator_val = 0 ! value to compare to character ( len = :), allocatable :: goto ! where to next (workflow name) end type rule type :: workflow character ( len = :), allocatable :: name type ( rule ), dimension (:), allocatable :: rules end type workflow type ( workflow ), dimension (:), allocatable :: workflows type ( workflow ), allocatable :: w call clk % tic () ! open(newunit=iunit, file='inputs/day19_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day19.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( workflows ( 0 )) do iline = 1 , n_lines line = read_line ( iunit ) if ( line == '' ) then !now parse part ratings allocate ( parts ( 0 )) end if if ( allocated ( parts )) then ! parsing parts if ( line == '' ) cycle ! {x=787,m=2655,a=1222,s=2876} vals = split ( line , ',' ) parts = [ parts , part ( xmas = [ int ( vals ( 1 )% str ( 4 :)), & int ( vals ( 2 )% str ( 3 :)), & int ( vals ( 3 )% str ( 3 :)), & int ( vals ( 4 )% str ( 3 : len ( vals ( 4 )% str ) - 1 ))])] else ! parsing workflows : qqz{s>2770:qs,m<1801:hdj,R} if ( allocated ( w )) deallocate ( w ); allocate ( w ) ! blank one vals = split ( line , '{' ) w % name = vals ( 1 )% str ! workflow name !write(*,*) '--->'//w%name//'<-----' vals ( 2 )% str = vals ( 2 )% str ( 1 : len ( vals ( 2 )% str ) - 1 ) ! remove last bracket vals = split ( vals ( 2 )% str , ',' ) ! workflow rules ! add each rule to the workflow allocate ( w % rules ( 0 )) do i = 1 , size ( vals ) w % rules = [ w % rules , parse_rule ( vals ( i )% str )] end do workflows = [ workflows , w ] end if end do total_accepted = 0 do i = 1 , size ( parts ) accepted = process ( parts ( i )) !write(*,*) parts(i), accepted if ( accepted ) then total_accepted = total_accepted + rating ( parts ( i )) end if end do write ( * , * ) '19a: ' , total_accepted call clk % toc ( '19' ) contains pure integer ( ip ) function rating ( p ) type ( part ), intent ( in ) :: p rating = sum ( p % xmas ) end function rating function process ( p ) result ( accepted ) !! process this part through all the workflows. type ( part ), intent ( in ) :: p logical :: accepted integer :: i , irule i = workflow_name_to_index ( 'in' ) ! start at the first workflow irule = 1 ! first rule do associate ( r => workflows ( i )% rules ( irule ) ) ! check if we are done if ( r % accept ) then ; accepted = . true .; return ; end if if ( r % reject ) then ; accepted = . false .; return ; end if if ( r % operator > 0 ) then ! process the operator select case ( r % operator ) case ( 1 ) ! < if ( p % xmas ( r % operator_arg ) < r % operator_val ) then ! check if done if ( r % goto == 'A' ) then ; accepted = . true .; return ; end if if ( r % goto == 'R' ) then ; accepted = . false .; return ; end if ! go to next workflow: i = workflow_name_to_index ( r % goto ) !write(*,*) 'goto '//r%goto irule = 1 ! start at first rule of new workflow else irule = irule + 1 ! next rule end if case ( 2 ) ! > if ( p % xmas ( r % operator_arg ) > r % operator_val ) then ! check if done if ( r % goto == 'A' ) then ; accepted = . true .; return ; end if if ( r % goto == 'R' ) then ; accepted = . false .; return ; end if ! go to next workflow: i = workflow_name_to_index ( r % goto ) irule = 1 ! start at first rule of new workflow else irule = irule + 1 ! next rule end if end select else ! goto another workflow i = workflow_name_to_index ( r % goto ) irule = 1 ! start at first rule of new workflow end if end associate end do end function process function workflow_name_to_index ( name ) result ( idx ) !! get the index of this workflow in the array character ( len =* ), intent ( in ) :: name integer :: idx do idx = 1 , size ( workflows ) if ( name == workflows ( idx )% name ) return ! found it end do if ( idx > size ( workflows )) error stop 'workflow not found: ' // name end function workflow_name_to_index function parse_rule ( s ) result ( r ) character ( len =* ), intent ( in ) :: s type ( rule ) :: r type ( string ), dimension (:), allocatable :: v character ( len =* ), parameter :: xmas = 'xmas' ! 1,2,3,4 if ( s == 'A' ) then r % accept = . true . else if ( s == 'R' ) then r % reject = . true . else if ( index ( s , '>' ) > 0 ) then v = split ( s ( 3 :), ':' ) ! example: a<2006:qkq r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 2 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else if ( index ( s , '<' ) > 0 ) then v = split ( s ( 3 :), ':' ) r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 1 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else r % goto = s ! it's a workflow name end if end if end function parse_rule end program problem_19","tags":"","loc":"sourcefile/problem_19.f90.html"},{"title":"problem_19b.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_19b.f90~~EfferentGraph sourcefile~problem_19b.f90 problem_19b.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_19b.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_19b !! reformulated to operate on ranges of the x,m,a,s ratings use aoc_utilities use iso_fortran_env implicit none integer :: iunit , n_lines , iline , i character ( len = :), allocatable :: line !, name type ( string ), dimension (:), allocatable :: vals logical :: accepted integer ( ip ) :: total_accepted type :: interval integer ( ip ), dimension ( 2 ) :: v !! [start, end] of the interval end type interval type :: part type ( interval ), dimension ( 4 ) :: xmas ! [x,m,a,s] ranges end type part type ( part ) :: parts type :: rule logical :: accept = . false . logical :: reject = . false . integer :: operator = 0 ! 1:<, 2:> integer :: operator_arg = 0 ! 1:x, 2:m, 3:a, 4:s integer :: operator_val = 0 ! value to compare to character ( len = :), allocatable :: goto ! where to next (workflow name) end type rule type :: workflow character ( len = :), allocatable :: name type ( rule ), dimension (:), allocatable :: rules end type workflow type ( workflow ), dimension (:), allocatable :: workflows type ( workflow ), allocatable :: w call clk % tic () ! open(newunit=iunit, file='inputs/day19_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day19.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( workflows ( 0 )) do iline = 1 , n_lines line = read_line ( iunit ) if ( line == '' ) exit ! done - dont need the parts list for part b ! parsing workflows : qqz{s>2770:qs,m<1801:hdj,R} if ( allocated ( w )) deallocate ( w ); allocate ( w ) ! blank one vals = split ( line , '{' ) w % name = vals ( 1 )% str ! workflow name !write(*,*) '--->'//w%name//'<-----' vals ( 2 )% str = vals ( 2 )% str ( 1 : len ( vals ( 2 )% str ) - 1 ) ! remove last bracket vals = split ( vals ( 2 )% str , ',' ) ! workflow rules ! add each rule to the workflow allocate ( w % rules ( 0 )) do i = 1 , size ( vals ) w % rules = [ w % rules , parse_rule ( vals ( i )% str )] end do workflows = [ workflows , w ] end do parts = part ( xmas = [ interval ([ 1 , 4000 ]), & interval ([ 1 , 4000 ]), & interval ([ 1 , 4000 ]),& interval ([ 1 , 4000 ])]) i = workflow_name_to_index ( 'in' ) ! start at the first workflow total_accepted = process ( i , 1 , parts ) write ( * , * ) '19b: ' , total_accepted call clk % toc ( '19b' ) contains recursive function process ( iworkflow , irule , p ) result ( iaccepted ) !! process this part range starting with irule integer , intent ( in ) :: iworkflow integer , intent ( in ) :: irule type ( part ), intent ( in ) :: p integer ( ip ) :: iaccepted integer ( ip ), dimension (:), allocatable :: itmp , itmp_t , itmp_f integer ( ip ) :: i type ( part ) :: pt , pf iaccepted = 0 associate ( r => workflows ( iworkflow )% rules ( irule ) ) ! check if we are done if ( r % accept ) then iaccepted = get_accepted ( p ) return else if ( r % reject ) then iaccepted = 0 return end if ! process recursively, by splitting up the intervals when necessary if ( r % operator > 0 ) then ! process the operator select case ( r % operator ) case ( 1 ) ! < ! always create the two sets and process the two cases below ! [note that some sets maybe empty] ! ! example: ![1,200]   < 10   ==> [1,9]    TRUE !                     [10,200] FALSE itmp = [( i , i = p % xmas ( r % operator_arg )% v ( 1 ), p % xmas ( r % operator_arg )% v ( 2 ))] itmp_t = pack ( itmp , mask = itmp < r % operator_val ) !true itmp_f = pack ( itmp , mask = itmp >= r % operator_val ) !false if ( size ( itmp_t ) > 0 ) then ! some are true pt = p pt % xmas ( r % operator_arg )% v = [ itmp_t ( 1 ), itmp_t ( size ( itmp_t ))] if ( r % goto == 'A' ) then iaccepted = iaccepted + get_accepted ( pt ) else if ( r % goto /= 'R' ) then ! go to next workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , pt ) end if end if if ( size ( itmp_f ) > 0 ) then ! some are false pf = p pf % xmas ( r % operator_arg )% v = [ itmp_f ( 1 ), itmp_f ( size ( itmp_f ))] iaccepted = iaccepted + process ( iworkflow , irule + 1 , pf ) ! next rule end if case ( 2 ) ! > itmp = [( i , i = p % xmas ( r % operator_arg )% v ( 1 ), p % xmas ( r % operator_arg )% v ( 2 ))] itmp_t = pack ( itmp , mask = itmp > r % operator_val ) !true itmp_f = pack ( itmp , mask = itmp <= r % operator_val ) !false if ( size ( itmp_t ) > 0 ) then ! some are true pt = p pt % xmas ( r % operator_arg )% v = [ itmp_t ( 1 ), itmp_t ( size ( itmp_t ))] if ( r % goto == 'A' ) then iaccepted = iaccepted + get_accepted ( pt ) else if ( r % goto /= 'R' ) then ! go to next workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , pt ) end if end if if ( size ( itmp_f ) > 0 ) then ! some are false pf = p pf % xmas ( r % operator_arg )% v = [ itmp_f ( 1 ), itmp_f ( size ( itmp_f ))] iaccepted = iaccepted + process ( iworkflow , irule + 1 , pf ) ! next rule end if end select else ! goto another workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , p ) end if end associate !end do end function process integer ( ip ) function get_accepted ( p ) !! count of all the parts in the set type ( part ), intent ( in ) :: p get_accepted = ( 1 + ( p % xmas ( 1 )% v ( 2 ) - p % xmas ( 1 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 2 )% v ( 2 ) - p % xmas ( 2 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 3 )% v ( 2 ) - p % xmas ( 3 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 4 )% v ( 2 ) - p % xmas ( 4 )% v ( 1 ))) end function get_accepted function workflow_name_to_index ( name ) result ( idx ) !! get the index of this workflow in the array character ( len =* ), intent ( in ) :: name integer :: idx do idx = 1 , size ( workflows ) if ( name == workflows ( idx )% name ) return ! found it end do if ( idx > size ( workflows )) error stop 'workflow not found: ' // name end function workflow_name_to_index function parse_rule ( s ) result ( r ) character ( len =* ), intent ( in ) :: s type ( rule ) :: r type ( string ), dimension (:), allocatable :: v character ( len =* ), parameter :: xmas = 'xmas' ! 1,2,3,4 if ( s == 'A' ) then r % accept = . true . else if ( s == 'R' ) then r % reject = . true . else if ( index ( s , '>' ) > 0 ) then v = split ( s ( 3 :), ':' ) ! example: a<2006:qkq r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 2 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else if ( index ( s , '<' ) > 0 ) then v = split ( s ( 3 :), ':' ) r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 1 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else r % goto = s ! it's a workflow name end if end if end function parse_rule end program problem_19b","tags":"","loc":"sourcefile/problem_19b.f90.html"}]}