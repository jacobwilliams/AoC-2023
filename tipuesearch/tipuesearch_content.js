var tipuesearch = {"pages":[{"title":" AoC-2023 ","text":"AoC-2023 Advent of Code 2023 with Modern Fortran. Compiling All the cases can be compiled and run using the Fortran Package Manager . to run individual cases: fpm run --profile release problem_01 to run them all: fpm run --profile release --all Current status Problem Stars Solution Runtime 1 ⭐⭐ problem_01.f90 12 ms 2 ⭐⭐ problem_02.f90 4 ms 3 ⭐⭐ problem_03.f90 2 ms 4 ⭐⭐ problem_04.f90 5 ms 5 ⭐⭐ problem_05.f90 622 ms 6 ⭐⭐ problem_06.f90 45 ms 7 ⭐⭐ problem_07.f90 17 ms 8 ⭐⭐ problem_08.f90 11 ms 9 ⭐⭐ problem_09.f90 23 ms 10 ⭐⭐ problem_10.f90 708 ms † † With OpenMP enabled (i.e, add --flag \"-fopenmp\" to the FPM call). Previous Years AoC-2020 AoC-2021 AoC-2022 AoC-2023 ## Documentation The API documentation for the current master branch can be found here .  This is generated by processing the source files with FORD . Developer Info Jacob Williams","tags":"home","loc":"index.html"},{"title":"hand – AoC-2023 ","text":"type :: hand Components Type Visibility Attributes Name Initial character(len=1), public, dimension(5) :: cards the cards in a hand integer(kind=ip), public :: bid = 0 integer, public :: type = 0 Source Code type :: hand character ( len = 1 ), dimension ( 5 ) :: cards !! the cards in a hand integer ( ip ) :: bid = 0 ! the bit for the hand integer :: type = 0 ! the hand type end type hand","tags":"","loc":"type/hand.html"},{"title":"node – AoC-2023 ","text":"type :: node Components Type Visibility Attributes Name Initial character(len=3), public :: name = '' character(len=3), public, dimension(2) :: lr integer, public, dimension(2) :: lr_idx Source Code type :: node character ( len = 3 ) :: name = '' character ( len = 3 ), dimension ( 2 ) :: lr integer , dimension ( 2 ) :: lr_idx ! the indices in the nodes array of the l,r nodes end type node","tags":"","loc":"type/node.html"},{"title":"mapping – AoC-2023 ","text":"type :: mapping Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(:), allocatable :: dest_start integer(kind=ip), public, dimension(:), allocatable :: dest_end integer(kind=ip), public, dimension(:), allocatable :: src_start integer(kind=ip), public, dimension(:), allocatable :: src_end Source Code type :: mapping ! save the source and destination start and end values integer ( ip ), dimension (:), allocatable :: dest_start , dest_end , src_start , src_end end type mapping","tags":"","loc":"type/mapping.html"},{"title":"clock – AoC-2023 ","text":"type, public :: clock Components Type Visibility Attributes Name Initial integer(kind=int64), private :: begin integer(kind=int64), private :: end integer(kind=int64), private :: rate Type-Bound Procedures procedure, public :: tic => clock_start private  subroutine clock_start (me) Start the clock Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me procedure, public :: toc => clock_end private  subroutine clock_end (me, case_str) Print runtime in milliseconds form the start of the clock. Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me character(len=*), intent(in) :: case_str description of the case Source Code type , public :: clock private integer ( int64 ) :: begin , end , rate contains procedure , public :: tic => clock_start procedure , public :: toc => clock_end end type clock","tags":"","loc":"type/clock.html"},{"title":"string – AoC-2023 ","text":"type, public :: string a type containing an allocatable character string.\nso we can have an array of strings of different lengths. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: str Type-Bound Procedures procedure, public :: to_int => string_to_int convert to integer private pure elemental function string_to_int (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer procedure, public :: to_int_64 => string_to_int_64 private pure elemental function string_to_int_64 (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer(kind=int64) Source Code type , public :: string !! a type containing an allocatable character string. !! so we can have an array of strings of different lengths. character ( len = :), allocatable :: str contains procedure , public :: to_int => string_to_int !! convert to integer procedure , public :: to_int_64 => string_to_int_64 end type string","tags":"","loc":"type/string.html"},{"title":"int64_vec – AoC-2023 ","text":"type, public :: int64_vec an type that contains an allocatable int64 array.\nso we can have an array of these. Components Type Visibility Attributes Name Initial integer(kind=int64), public, dimension(:), allocatable :: vals Source Code type , public :: int64_vec !! an type that contains an allocatable int64 array. !! so we can have an array of these. integer ( int64 ), dimension (:), allocatable :: vals end type int64_vec","tags":"","loc":"type/int64_vec.html"},{"title":"hand_type – AoC-2023","text":"function hand_type(me, with_jokers) returns the type of hand Arguments Type Intent Optional Attributes Name class( hand ), intent(in) :: me logical, intent(in) :: with_jokers if considering jokers Return Value integer Calls proc~~hand_type~~CallsGraph proc~hand_type problem_7::hand_type interface~unique aoc_utilities::unique proc~hand_type->interface~unique proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hand_type~~CalledByGraph proc~hand_type problem_7::hand_type proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code integer function hand_type ( me , with_jokers ) !! returns the type of hand class ( hand ), intent ( in ) :: me logical , intent ( in ) :: with_jokers !! if considering jokers integer , dimension ( 5 ) :: i integer , dimension (:), allocatable :: u integer :: n_jokers , n_unique character ( len = 1 ), dimension ( 5 ) :: h h = me % cards i = ichar ( h ) ! convert to code u = unique ( i ) ! unique elements n_unique = size ( u ) if ( with_jokers . and . any ( h == 'J' )) then ! have to pick best hand for all jokers ! just do it by inspection n_jokers = count ( h == 'J' ) select case ( n_jokers ) case ( 5 ) hand_type = FIVE_OF_A_KIND !jjjjj case ( 4 ) hand_type = FIVE_OF_A_KIND !jjjja case ( 3 ) ! can always turn to 4 or 5 of a kind if ( n_unique == 2 ) then !jjjaa hand_type = FIVE_OF_A_KIND else ! jjjab hand_type = FOUR_OF_A_KIND end if case ( 2 ) if ( n_unique == 2 ) then !jjaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then !jjaab hand_type = FOUR_OF_A_KIND else !jjabc hand_type = THREE_OF_A_KIND end if case ( 1 ) if ( n_unique == 2 ) then !jaaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then if ( any ([ count ( i == u ( 1 )) == 3 , & count ( i == u ( 2 )) == 3 , & count ( i == u ( 3 )) == 3 ]) ) then !jaaab hand_type = FOUR_OF_A_KIND elseif ( ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 ) . or . & ( count ( i == u ( 2 )) == 2 . and . count ( i == u ( 2 )) == 2 ) ) then !jaabb hand_type = FULL_HOUSE end if else if ( n_unique == 4 ) then !jaabc hand_type = THREE_OF_A_KIND else if ( n_unique == 5 ) then !jabcd hand_type = ONE_PAIR end if end select else !Every hand is exactly one type. From strongest to weakest, they are: select case ( n_unique ) case ( 1 ) ! aaaaa hand_type = FIVE_OF_A_KIND case ( 2 ) ! aaaab, aaabb if (( count ( i == u ( 1 )) == 4 . and . count ( i == u ( 2 )) == 1 ) . or . & ( count ( i == u ( 1 )) == 1 . and . count ( i == u ( 2 )) == 4 ) ) then hand_type = FOUR_OF_A_KIND else if (( count ( i == u ( 1 )) == 3 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 3 ) ) then hand_type = FULL_HOUSE end if case ( 3 ) ! aaabc, aabcc if ( any ([ count ( i == u ( 1 )) == 3 , count ( i == u ( 2 )) == 3 , count ( i == u ( 3 )) == 3 ]) ) then hand_type = THREE_OF_A_KIND else if ( any ([ count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 , & count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 , & count ( i == u ( 2 )) == 2 . and . count ( i == u ( 3 )) == 2 ]) ) then hand_type = TWO_PAIR end if case ( 4 ) !aabcd hand_type = ONE_PAIR case ( 5 ) !abcde hand_type = HIGH_CARD ! High card, where all cards' labels are distinct: 23456 end select end if end function hand_type","tags":"","loc":"proc/hand_type.html"},{"title":"beats – AoC-2023","text":"function beats(hand1, hand2, with_jokers) return true if hand1 beats hand2 (has a higher score) Arguments Type Intent Optional Attributes Name class( hand ), intent(inout) :: hand1 class( hand ), intent(inout) :: hand2 logical, intent(in) :: with_jokers if considering jokers Return Value logical Calls proc~~beats~~CallsGraph proc~beats problem_7::beats proc~hand_type problem_7::hand_type proc~beats->proc~hand_type proc~index_in_cards problem_7::index_in_cards proc~beats->proc~index_in_cards interface~unique aoc_utilities::unique proc~hand_type->interface~unique proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~beats~~CalledByGraph proc~beats problem_7::beats program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function beats ( hand1 , hand2 , with_jokers ) !! return true if hand1 beats hand2 (has a higher score) class ( hand ), intent ( inout ) :: hand1 , hand2 logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i associate ( h1 => hand1 % cards , h2 => hand2 % cards ) ! recompute type if it hasn't already been computed if ( hand1 % type == 0 ) hand1 % type = hand_type ( hand1 , with_jokers ) if ( hand2 % type == 0 ) hand2 % type = hand_type ( hand2 , with_jokers ) if ( hand1 % type == hand2 % type ) then ! lower index is stronger do i = 1 , 5 if ( h1 ( i ) /= h2 ( i )) then beats = index_in_cards ( h1 ( i ), with_jokers ) < & index_in_cards ( h2 ( i ), with_jokers ) ! lower is stronger return end if end do else ! one hand beat the other beats = hand1 % type < hand2 % type ! lower score is better (1-7) end if end associate end function beats","tags":"","loc":"proc/beats.html"},{"title":"index_in_cards – AoC-2023","text":"function index_in_cards(c, with_jokers) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c logical, intent(in) :: with_jokers if considering jokers Return Value integer Called by proc~~index_in_cards~~CalledByGraph proc~index_in_cards problem_7::index_in_cards proc~beats problem_7::beats proc~beats->proc~index_in_cards program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code integer function index_in_cards ( c , with_jokers ) character ( len = 1 ), intent ( in ) :: c logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i do i = 1 , size ( cards_with_joker ) if ( with_jokers ) then if ( c == cards_with_joker ( i )) then index_in_cards = i return end if else if ( c == cards ( i )) then index_in_cards = i return end if end if end do error stop 'card not found' end function index_in_cards","tags":"","loc":"proc/index_in_cards.html"},{"title":"swap_hands – AoC-2023","text":"pure elemental subroutine swap_hands(i1, i2) swap function for hand type Arguments Type Intent Optional Attributes Name type( hand ), intent(inout) :: i1 type( hand ), intent(inout) :: i2 Called by proc~~swap_hands~~CalledByGraph proc~swap_hands problem_7::swap_hands program~problem_7 problem_7 program~problem_7->proc~swap_hands Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap_hands ( i1 , i2 ) !! swap function for hand type type ( hand ), intent ( inout ) :: i1 type ( hand ), intent ( inout ) :: i2 type ( hand ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_hands","tags":"","loc":"proc/swap_hands.html"},{"title":"check – AoC-2023","text":"function check(i, j) if the char is part of a number, then get it and append to ivals Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Return Value logical Calls proc~~check~~CallsGraph proc~check problem_3::check proc~get_number problem_3::get_number proc~check->proc~get_number proc~is_number aoc_utilities::is_number proc~check->proc~is_number proc~is_symbol problem_3::is_symbol proc~get_number->proc~is_symbol proc~is_not_number aoc_utilities::is_not_number proc~is_symbol->proc~is_not_number proc~is_not_number->proc~is_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check~~CalledByGraph proc~check problem_3::check program~problem_3 problem_3 program~problem_3->proc~check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function check ( i , j ) !! if the char is part of a number, then get it and append to ivals integer , intent ( in ) :: i , j check = is_number ( array ( i , j )) if ( check ) ivals = [ ivals , get_number ( i , j )] end function check","tags":"","loc":"proc/check.html"},{"title":"is_symbol – AoC-2023","text":"function is_symbol(c) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical Calls proc~~is_symbol~~CallsGraph proc~is_symbol problem_3::is_symbol proc~is_not_number aoc_utilities::is_not_number proc~is_symbol->proc~is_not_number proc~is_number aoc_utilities::is_number proc~is_not_number->proc~is_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~is_symbol~~CalledByGraph proc~is_symbol problem_3::is_symbol proc~get_number problem_3::get_number proc~get_number->proc~is_symbol program~problem_3 problem_3 program~problem_3->proc~is_symbol program~problem_3->proc~get_number proc~check problem_3::check program~problem_3->proc~check proc~check->proc~get_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function is_symbol ( c ) character ( len = 1 ), intent ( in ) :: c is_symbol = is_not_number ( c ) . and . c /= '.' end function is_symbol","tags":"","loc":"proc/is_symbol.html"},{"title":"get_number – AoC-2023","text":"function get_number(i, j) get the full number contining the character at i,j Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Return Value integer(kind=int64) Calls proc~~get_number~~CallsGraph proc~get_number problem_3::get_number proc~is_symbol problem_3::is_symbol proc~get_number->proc~is_symbol proc~is_not_number aoc_utilities::is_not_number proc~is_symbol->proc~is_not_number proc~is_number aoc_utilities::is_number proc~is_not_number->proc~is_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_number~~CalledByGraph proc~get_number problem_3::get_number proc~check problem_3::check proc~check->proc~get_number program~problem_3 problem_3 program~problem_3->proc~get_number program~problem_3->proc~check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code integer ( int64 ) function get_number ( i , j ) !! get the full number contining the character at i,j integer , intent ( in ) :: i , j jstart = j jend = j do if ( array ( i , jstart - 1 ) == '.' . or . is_symbol ( array ( i , jstart - 1 ))) exit jstart = jstart - 1 end do do if ( array ( i , jend + 1 ) == '.' . or . is_symbol ( array ( i , jend + 1 ))) exit jend = jend + 1 end do get_number = int ( array ( i , jstart : jend )) end function get_number","tags":"","loc":"proc/get_number.html"},{"title":"moves – AoC-2023","text":"pure function moves(istart, iend) result(imoves) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: istart indices for start and end nodes integer(kind=ip), intent(in) :: iend indices for start and end nodes Return Value integer(kind=ip) Called by proc~~moves~~CalledByGraph proc~moves problem_8::moves program~problem_8 problem_8 program~problem_8->proc~moves Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function moves ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart , iend !! indices for start and end nodes integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( idx == iend ) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves","tags":"","loc":"proc/moves.html"},{"title":"moves_any_z – AoC-2023","text":"pure function moves_any_z(istart, iend) result(imoves) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: istart indices for start and end nodes integer(kind=ip), intent(in), dimension(:) :: iend Return Value integer(kind=ip) Called by proc~~moves_any_z~~CalledByGraph proc~moves_any_z problem_8::moves_any_z program~problem_8 problem_8 program~problem_8->proc~moves_any_z Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function moves_any_z ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart !! indices for start and end nodes integer ( ip ), dimension (:), intent ( in ) :: iend integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( any ( idx == iend )) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves_any_z","tags":"","loc":"proc/moves_any_z.html"},{"title":"all_in_set – AoC-2023","text":"pure function all_in_set(ivals, iset) returns true if all the elements of ivals are in the set iset Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals integer(kind=ip), intent(in), dimension(:) :: iset Return Value logical Source Code pure logical function all_in_set ( ivals , iset ) !! returns true if all the elements of ivals are in the set iset integer ( ip ), dimension (:), intent ( in ) :: ivals , iset integer :: i all_in_set = . true . do i = 1 , size ( ivals ) if (. not . any ( ivals ( i ) == iset )) then all_in_set = . false . exit end if end do end function all_in_set","tags":"","loc":"proc/all_in_set.html"},{"title":"find_node – AoC-2023","text":"pure function find_node(name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value integer(kind=ip) Called by proc~~find_node~~CalledByGraph proc~find_node problem_8::find_node program~problem_8 problem_8 program~problem_8->proc~find_node Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer ( ip ) function find_node ( name ) character ( len =* ), intent ( in ) :: name integer ( ip ) :: i do i = 1 , size ( nodes ) if ( name == nodes ( i )% name ) then find_node = i return end if end do error stop 'could not find node' end function find_node","tags":"","loc":"proc/find_node.html"},{"title":"extrapolate – AoC-2023","text":"pure function extrapolate(ivals) result(iextrap) extrapolate the next value in the sequence using\na difference table. Straightfoward implemention:\ncreate the full table, and then evaluate it. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals Return Value integer(kind=ip) Calls proc~~extrapolate~~CallsGraph proc~extrapolate problem_9::extrapolate proc~diff aoc_utilities::diff proc~extrapolate->proc~diff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~extrapolate~~CalledByGraph proc~extrapolate problem_9::extrapolate program~problem_9 problem_9 program~problem_9->proc~extrapolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function extrapolate ( ivals ) result ( iextrap ) !! extrapolate the next value in the sequence using !! a difference table. Straightfoward implemention: !! create the full table, and then evaluate it. integer ( ip ), dimension (:), intent ( in ) :: ivals integer ( ip ) :: iextrap integer :: i , n type ( int64_vec ), dimension (:), allocatable :: diff_table !! difference table (vector of vectors) ! create the difference table: diff_table = [ int64_vec ( ivals )]; n = 1 do n = n + 1 diff_table = [ diff_table , int64_vec ( diff ( diff_table ( n - 1 )% vals ))] ! next line is diff of previous line if ( all ( diff_table ( n )% vals == 0 )) exit end do ! extrapolate iextrap = 0 do i = n - 1 , 1 , - 1 associate ( ilast => diff_table ( i )% vals ( size ( diff_table ( i )% vals )) ) iextrap = iextrap + ilast end associate end do end function extrapolate","tags":"","loc":"proc/extrapolate.html"},{"title":"pipe_info – AoC-2023","text":"pure function pipe_info(p) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: p Return Value character(len=2) Called by proc~~pipe_info~~CalledByGraph proc~pipe_info problem_10::pipe_info proc~move problem_10::move proc~move->proc~pipe_info proc~move->proc~move program~problem_10 problem_10 program~problem_10->proc~move Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/pipe_info.html"},{"title":"move – AoC-2023","text":"recursive subroutine move(i, j, direction, distance, save_path) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: direction integer, intent(inout), dimension(:,:) :: distance logical, intent(in) :: save_path to save the path coordinates Calls proc~~move~~CallsGraph proc~move problem_10::move proc~move->proc~move proc~pipe_info problem_10::pipe_info proc~move->proc~pipe_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~move~~CalledByGraph proc~move problem_10::move proc~move->proc~move program~problem_10 problem_10 program~problem_10->proc~move Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine move ( i , j , direction , distance , save_path ) integer , intent ( in ) :: i , j , direction integer , dimension (:,:), intent ( inout ) :: distance logical , intent ( in ) :: save_path !! to save the path coordinates integer :: inew , jnew , imove logical :: valid_move select case ( direction ) case ( 1 ); inew = i - 1 ; jnew = j ! north case ( 2 ); inew = i + 1 ; jnew = j ! south case ( 3 ); inew = i ; jnew = j + 1 ! east case ( 4 ); inew = i ; jnew = j - 1 ! west end select if ( visited ( inew , jnew ) . or . array ( inew , jnew ) == '.' ) return ! can we move in this direction? valid_move = . false . associate ( current_pipe => array ( i , j ), & current_distance => distance ( i , j ), & move_to => array ( inew , jnew ) ) select case ( current_pipe ) case ( 'S' ) ! don't know what the first pip is, so have to try them all select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '|' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south end select case ( '-' ) select case ( direction ) case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'L' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select case ( 'J' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '7' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'F' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select end select if ( valid_move ) then distance ( inew , jnew ) = current_distance + 1 visited ( inew , jnew ) = . true . do imove = 1 , 4 call move ( inew , jnew , imove , distance , save_path ) end do if ( save_path ) then x = [ x , real ( inew , wp )] ! save cordinates of point on the path y = [ y , real ( jnew , wp )] end if end if end associate end subroutine move","tags":"","loc":"proc/move.html"},{"title":"go – AoC-2023","text":"function go(time, distance) result(iproduct) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: time integer(kind=ip), intent(in), dimension(:) :: distance Return Value integer(kind=ip) Called by proc~~go~~CalledByGraph proc~go problem_6::go program~problem_6 problem_6 program~problem_6->proc~go Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function go ( time , distance ) result ( iproduct ) integer ( ip ), dimension (:), intent ( in ) :: time integer ( ip ), dimension (:), intent ( in ) :: distance integer ( ip ) :: iproduct integer ( ip ) :: i , ihold , iways , idistance iproduct = 1 do i = 1 , size ( time ) iways = 0 do ihold = 1 , time ( i ) ! time to hold the button idistance = ihold * ( time ( i ) - ihold ) if ( idistance > distance ( i )) iways = iways + 1 end do iproduct = iproduct * iways end do end function go","tags":"","loc":"proc/go.html"},{"title":"go – AoC-2023","text":"function go(expansion_factor) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: expansion_factor Return Value integer(kind=ip) Calls proc~~go~2~~CallsGraph proc~go~2 problem_11::go proc~dist problem_11::dist proc~go~2->proc~dist proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~go~2->proc~read_file_to_char_array proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~go~2~~CalledByGraph proc~go~2 problem_11::go program~problem_11 problem_11 program~problem_11->proc~go~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code integer ( ip ) function go ( expansion_factor ) integer ( ip ), intent ( in ) :: expansion_factor integer :: i , j , nrows , ncols , n_galaxies , n , k character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:,:), allocatable :: idists integer ( ip ), dimension (:), allocatable :: igal , jgal integer ( ip ), dimension (:,:), allocatable :: ix , iy ! array = read_file_to_char_array('inputs/day11_test.txt') array = read_file_to_char_array ( 'inputs/day11.txt' ) nrows = size ( array , 1 ); ncols = size ( array , 2 ) n_galaxies = count ( array == '#' ) ! track the real indices after expansion ix = transpose ( spread ([( i , i = 1 , ncols )], 1 , nrows )) ! row indices iy = spread ([( i , i = 1 , nrows )], 1 , ncols ) ! col indices igal = pack ( ix , array == '#' ) ! indices of galaxies jgal = pack ( iy , array == '#' ) ! expand the array, keeping track of the new row indices do i = 1 , nrows ! add rows if necessary if ( all ( array ( i ,:) == '.' )) ix ( i :,:) = ix ( i :,:) + expansion_factor - 1 ! new row end do do j = 1 , ncols ! add cols if necessary if ( all ( array (:, j ) == '.' )) iy (:, j :) = iy (:, j :) + expansion_factor - 1 ! new column end do ! now compute all the distances: allocate ( idists ( n_galaxies , n_galaxies )); idists = 0 do i = 1 , n_galaxies do j = 1 , n_galaxies if ( j <= i ) cycle ! only need the lower diagonal idists ( i , j ) = dist ( ix ( igal ( i ), jgal ( i )), iy ( igal ( i ), jgal ( i )),& ix ( igal ( j ), jgal ( j )), iy ( igal ( j ), jgal ( j ))) end do end do go = sum ( idists ) end function go","tags":"","loc":"proc/go~2.html"},{"title":"dist – AoC-2023","text":"pure function dist(x1, y1, x2, y2) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: x1 integer(kind=ip), intent(in) :: y1 integer(kind=ip), intent(in) :: x2 integer(kind=ip), intent(in) :: y2 Return Value integer Called by proc~~dist~~CalledByGraph proc~dist problem_11::dist proc~go~2 problem_11::go proc~go~2->proc~dist program~problem_11 problem_11 program~problem_11->proc~go~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer function dist ( x1 , y1 , x2 , y2 ) ! Manhattan distance integer ( ip ), intent ( in ) :: x1 , y1 , x2 , y2 dist = abs ( x1 - x2 ) + abs ( y1 - y2 ) end function dist","tags":"","loc":"proc/dist.html"},{"title":"in_seed_list – AoC-2023","text":"function in_seed_list(iseed) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: iseed Return Value logical Called by proc~~in_seed_list~~CalledByGraph proc~in_seed_list problem_5::in_seed_list program~problem_5 problem_5 program~problem_5->proc~in_seed_list Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function in_seed_list ( iseed ) ! for part b, is the seed in the initial list integer ( ip ), intent ( in ) :: iseed integer :: i do i = 1 , size ( seeds_list ), 2 if ( iseed >= seeds_list ( i ) . and . iseed <= seeds_list ( i ) + seeds_list ( i + 1 ) - 1 ) then in_seed_list = . true . return end if end do in_seed_list = . false . end function in_seed_list","tags":"","loc":"proc/in_seed_list.html"},{"title":"map – AoC-2023","text":"pure function map(ival, m, reverse) result(idest) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: ival type( mapping ), intent(in) :: m logical, intent(in) :: reverse Return Value integer(kind=ip) Called by proc~~map~~CalledByGraph proc~map problem_5::map proc~traverse problem_5::traverse proc~traverse->proc~map program~problem_5 problem_5 program~problem_5->proc~traverse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function map ( ival , m , reverse ) result ( idest ) integer ( ip ), intent ( in ) :: ival type ( mapping ), intent ( in ) :: m logical , intent ( in ) :: reverse ! if reversed, go from: dest -> src integer ( ip ) :: idest integer :: i if ( reverse ) then do i = 1 , size ( m % src_start ) ! locate ival (dest) in the dest start:end range if ( ival >= m % dest_start ( i ) . and . ival <= m % dest_end ( i )) then ! found it, map to dest idest = m % src_start ( i ) + ( ival - m % dest_start ( i )) ! this is the resultant isource return end if end do else do i = 1 , size ( m % src_start ) ! locate ival (source) in the source start:end range if ( ival >= m % src_start ( i ) . and . ival <= m % src_end ( i )) then ! found it, map to dest idest = m % dest_start ( i ) + ( ival - m % src_start ( i )) return end if end do end if idest = ival ! if not found in any of the sets end function map","tags":"","loc":"proc/map.html"},{"title":"traverse – AoC-2023","text":"pure function traverse(iseed, reverse) result(ilocation) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: iseed logical, intent(in) :: reverse if reverse, then ilocation -> iseed Return Value integer(kind=ip) Calls proc~~traverse~~CallsGraph proc~traverse problem_5::traverse proc~map problem_5::map proc~traverse->proc~map Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~traverse~~CalledByGraph proc~traverse problem_5::traverse program~problem_5 problem_5 program~problem_5->proc~traverse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function traverse ( iseed , reverse ) result ( ilocation ) integer ( ip ), intent ( in ) :: iseed logical , intent ( in ) :: reverse !! if reverse, then ilocation -> iseed integer ( ip ) :: ilocation integer :: i ilocation = iseed ! initialize if ( reverse ) then do i = NSTAGES , 1 , - 1 ilocation = map ( ilocation , mappings ( i ), reverse ) ! this is really iseed end do else do i = 1 , NSTAGES ilocation = map ( ilocation , mappings ( i ), reverse ) end do end if end function traverse","tags":"","loc":"proc/traverse.html"},{"title":"populate – AoC-2023","text":"subroutine populate(nums, m) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(3) :: nums type( mapping ), intent(inout) :: m Called by proc~~populate~~CalledByGraph proc~populate problem_5::populate program~problem_5 problem_5 program~problem_5->proc~populate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine populate ( nums , m ) integer ( ip ), dimension ( 3 ), intent ( in ) :: nums ! the three numbers from the line: ! [dest range start, src range start, range length type ( mapping ), intent ( inout ) :: m ! structure to add this data to associate ( dest => nums ( 1 ), source => nums ( 2 ), range => nums ( 3 ) ) m % dest_start = [ m % dest_start , dest ] m % dest_end = [ m % dest_end , dest + range - 1 ] m % src_start = [ m % src_start , source ] m % src_end = [ m % src_end , source + range - 1 ] end associate end subroutine populate","tags":"","loc":"proc/populate.html"},{"title":"char_to_int – AoC-2023","text":"private pure function char_to_int(str) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer Called by proc~~char_to_int~~CalledByGraph proc~char_to_int aoc_utilities::char_to_int interface~int aoc_utilities::int interface~int->proc~char_to_int proc~char_array_to_int aoc_utilities::char_array_to_int interface~int->proc~char_array_to_int proc~char_array_to_int->proc~char_to_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function char_to_int ( str ) result ( i ) character ( len =* ), intent ( in ) :: str integer :: i read ( str , * ) i end function char_to_int","tags":"","loc":"proc/char_to_int.html"},{"title":"string_to_int – AoC-2023","text":"private pure elemental function string_to_int(me) result(i) Basic string to integer routine Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer Called by proc~~string_to_int~~CalledByGraph proc~string_to_int aoc_utilities::string%string_to_int interface~int aoc_utilities::int interface~int->proc~string_to_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental function string_to_int ( me ) result ( i ) class ( string ), intent ( in ) :: me integer :: i i = int ( me % str ) end function string_to_int","tags":"","loc":"proc/string_to_int.html"},{"title":"string_to_int_64 – AoC-2023","text":"private pure elemental function string_to_int_64(me) result(i) Basic string to integer routine Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer(kind=int64) Source Code pure elemental function string_to_int_64 ( me ) result ( i ) class ( string ), intent ( in ) :: me integer ( int64 ) :: i i = int ( me % str ) end function string_to_int_64","tags":"","loc":"proc/string_to_int_64.html"},{"title":"char_to_int64 – AoC-2023","text":"private pure function char_to_int64(str, kind) result(i) Basic string to integer(ip) routine.\nHacky hack just so we can overload as int() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: kind Return Value integer(kind=int64) Called by proc~~char_to_int64~~CalledByGraph proc~char_to_int64 aoc_utilities::char_to_int64 interface~int aoc_utilities::int interface~int->proc~char_to_int64 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function char_to_int64 ( str , kind ) result ( i ) character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: kind integer ( int64 ) :: i if ( kind /= int64 ) error stop 'error' read ( str , * ) i end function char_to_int64","tags":"","loc":"proc/char_to_int64.html"},{"title":"char_array_to_int – AoC-2023","text":"private pure function char_array_to_int(str_array) result(i) Character array to integer routine Arguments Type Intent Optional Attributes Name character(len=1), intent(in), dimension(:) :: str_array example ['1','3'] --> 13 Return Value integer Calls proc~~char_array_to_int~~CallsGraph proc~char_array_to_int aoc_utilities::char_array_to_int proc~char_to_int aoc_utilities::char_to_int proc~char_array_to_int->proc~char_to_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~char_array_to_int~~CalledByGraph proc~char_array_to_int aoc_utilities::char_array_to_int interface~int aoc_utilities::int interface~int->proc~char_array_to_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function char_array_to_int ( str_array ) result ( i ) character ( len = 1 ), dimension (:), intent ( in ) :: str_array !! example ['1','3'] --> 13 integer :: i character ( len = :), allocatable :: str integer :: k str = '' do k = 1 , size ( str_array ) str = str // str_array ( k ) end do i = char_to_int ( str ) end function char_array_to_int","tags":"","loc":"proc/char_array_to_int.html"},{"title":"read_file_to_char_array – AoC-2023","text":"public  function read_file_to_char_array(filename, border) result(array) Read a file into a 2d character array. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=1), intent(in), optional :: border if true, extra border is added with this char Return Value character(len=1), dimension(:,:), allocatable Calls proc~~read_file_to_char_array~~CallsGraph proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_file_to_char_array~~CalledByGraph proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~go~2 problem_11::go proc~go~2->proc~read_file_to_char_array program~problem_10 problem_10 program~problem_10->proc~read_file_to_char_array program~problem_3 problem_3 program~problem_3->proc~read_file_to_char_array program~problem_11 problem_11 program~problem_11->proc~go~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function read_file_to_char_array ( filename , border ) result ( array ) character ( len =* ), intent ( in ) :: filename character ( len = 1 ), intent ( in ), optional :: border !! if true, extra border is added with this char character ( len = 1 ), dimension (:,:), allocatable :: array integer :: i , j , iunit , n_lines , n_cols character ( len = :), allocatable :: line open ( newunit = iunit , file = filename , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) line = read_line ( iunit ); n_cols = len ( line ) rewind ( iunit ) if ( present ( border )) then allocate ( array ( 0 : n_lines + 1 , 0 : n_cols + 1 )) ! padding with border array = border else allocate ( array ( n_lines , n_cols )) end if do i = 1 , n_lines line = read_line ( iunit ) do j = 1 , n_cols array ( i , j ) = line ( j : j ) end do end do close ( iunit ) end function read_file_to_char_array","tags":"","loc":"proc/read_file_to_char_array.html"},{"title":"read_file_to_integer_array – AoC-2023","text":"public  function read_file_to_integer_array(filename) result(iarray) Read a file into an integer array (one element per line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer, dimension(:), allocatable Calls proc~~read_file_to_integer_array~~CallsGraph proc~read_file_to_integer_array aoc_utilities::read_file_to_integer_array proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_integer_array->proc~number_of_lines_in_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function read_file_to_integer_array ( filename ) result ( iarray ) character ( len =* ), intent ( in ) :: filename integer , dimension (:), allocatable :: iarray integer :: i , iunit , n_lines , istat open ( newunit = iunit , file = filename , iostat = istat ) if ( istat /= 0 ) error stop ' error reading file' n_lines = number_of_lines_in_file ( iunit ) allocate ( iarray ( n_lines )) do i = 1 , n_lines read ( iunit , '(I10)' ) iarray ( i ) end do close ( iunit ) end function read_file_to_integer_array","tags":"","loc":"proc/read_file_to_integer_array.html"},{"title":"read_file_to_integer64_array – AoC-2023","text":"public  function read_file_to_integer64_array(filename) result(iarray) Read a file into an int64 integer array (one element per line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer(kind=int64), dimension(:), allocatable Calls proc~~read_file_to_integer64_array~~CallsGraph proc~read_file_to_integer64_array aoc_utilities::read_file_to_integer64_array proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_integer64_array->proc~number_of_lines_in_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function read_file_to_integer64_array ( filename ) result ( iarray ) character ( len =* ), intent ( in ) :: filename integer ( int64 ), dimension (:), allocatable :: iarray integer :: i , iunit , n_lines , istat open ( newunit = iunit , file = filename , iostat = istat ) if ( istat /= 0 ) error stop ' error reading file' n_lines = number_of_lines_in_file ( iunit ) allocate ( iarray ( n_lines )) do i = 1 , n_lines read ( iunit , * ) iarray ( i ) end do close ( iunit ) end function read_file_to_integer64_array","tags":"","loc":"proc/read_file_to_integer64_array.html"},{"title":"number_of_lines_in_file – AoC-2023","text":"public  function number_of_lines_in_file(iunit) result(n_lines) Returns the number of lines in a file (assumed to be open) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit the file unit number\n(assumed to be open) Return Value integer the number of lines in the file Called by proc~~number_of_lines_in_file~~CalledByGraph proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_file_to_integer64_array aoc_utilities::read_file_to_integer64_array proc~read_file_to_integer64_array->proc~number_of_lines_in_file proc~read_file_to_integer_array aoc_utilities::read_file_to_integer_array proc~read_file_to_integer_array->proc~number_of_lines_in_file program~problem_1 problem_1 program~problem_1->proc~number_of_lines_in_file program~problem_2 problem_2 program~problem_2->proc~number_of_lines_in_file program~problem_4 problem_4 program~problem_4->proc~number_of_lines_in_file program~problem_5 problem_5 program~problem_5->proc~number_of_lines_in_file program~problem_7 problem_7 program~problem_7->proc~number_of_lines_in_file program~problem_8 problem_8 program~problem_8->proc~number_of_lines_in_file program~problem_9 problem_9 program~problem_9->proc~number_of_lines_in_file proc~go~2 problem_11::go proc~go~2->proc~read_file_to_char_array program~problem_10 problem_10 program~problem_10->proc~read_file_to_char_array program~problem_3 problem_3 program~problem_3->proc~read_file_to_char_array program~problem_11 problem_11 program~problem_11->proc~go~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function number_of_lines_in_file ( iunit ) result ( n_lines ) integer , intent ( in ) :: iunit !! the file unit number !! (assumed to be open) integer :: n_lines !! the number of lines in the file character ( len = 1 ) :: tmp integer :: istat rewind ( iunit ) n_lines = 0 do read ( iunit , fmt = '(A1)' , iostat = istat ) tmp if ( is_iostat_end ( istat )) exit n_lines = n_lines + 1 end do rewind ( iunit ) end function number_of_lines_in_file","tags":"","loc":"proc/number_of_lines_in_file.html"},{"title":"split2 – AoC-2023","text":"private pure function split2(s, token) result(vals) Split a string , given a token. Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: s character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable Calls proc~~split2~~CallsGraph proc~split2 aoc_utilities::split2 proc~split1 aoc_utilities::split1 proc~split2->proc~split1 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~split2~~CalledByGraph proc~split2 aoc_utilities::split2 interface~split aoc_utilities::split interface~split->proc~split2 proc~parse_nums64 aoc_utilities::parse_nums64 proc~parse_nums64->interface~split program~problem_2 problem_2 program~problem_2->interface~split program~problem_4 problem_4 program~problem_4->interface~split program~problem_7 problem_7 program~problem_7->interface~split interface~parse aoc_utilities::parse interface~parse->proc~parse_nums64 program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function split2 ( s , token ) result ( vals ) implicit none type ( string ), intent ( in ) :: s character ( len =* ), intent ( in ) :: token type ( string ), dimension (:), allocatable :: vals if ( allocated ( s % str )) then vals = split1 ( s % str , token ) else error stop 'error: string not allocated' end if end function split2","tags":"","loc":"proc/split2.html"},{"title":"split1 – AoC-2023","text":"private pure function split1(str, token) result(vals) Split a character string using a token.\n  This routine is inspired by the Python split function. Example character ( len = :), allocatable :: s type ( string ), dimension (:), allocatable :: vals s = '1,2,3,4,5' call split ( s , ',' , vals ) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable Calls proc~~split1~~CallsGraph proc~split1 aoc_utilities::split1 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~split1~~CalledByGraph proc~split1 aoc_utilities::split1 interface~split aoc_utilities::split interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~split2->proc~split1 proc~parse_nums64 aoc_utilities::parse_nums64 proc~parse_nums64->interface~split program~problem_2 problem_2 program~problem_2->interface~split program~problem_4 problem_4 program~problem_4->interface~split program~problem_7 problem_7 program~problem_7->interface~split interface~parse aoc_utilities::parse interface~parse->proc~parse_nums64 program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function split1 ( str , token ) result ( vals ) implicit none character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ) :: token type ( string ), dimension (:), allocatable :: vals integer :: i !! counter integer :: len_str !! significant length of `str` integer :: len_token !! length of the token integer :: n_tokens !! number of tokens integer :: i1 !! index integer :: i2 !! index integer :: j !! counters integer , dimension (:), allocatable :: itokens !! start indices of the !! token locations in `str` len_token = len ( token ) ! length of the token n_tokens = 0 ! initialize the token counter j = 0 ! index to start looking for the next token ! first, count the number of times the token ! appears in the string, and get the token indices. ! ! Examples: !  ',         '    --> 1 !  '1234,67,90'    --> 5,8 !  '123,      '    --> 4 ! length of the string if ( token == ' ' ) then ! in this case, we can't ignore trailing space len_str = len ( str ) else ! safe to ignore trailing space when looking for tokens len_str = len_trim ( str ) end if j = 1 n_tokens = 0 do if ( j > len_str ) exit ! end of string, finished i = index ( str ( j :), token ) ! index of next token in remaining string if ( i <= 0 ) exit ! no more tokens found call expand_vector ( itokens , n_tokens , i + j - 1 ) ! save the token location j = j + i + ( len_token - 1 ) end do call expand_vector ( itokens , n_tokens , finished = . true .) ! resize the vector allocate ( vals ( n_tokens + 1 )) if ( n_tokens > 0 ) then len_str = len ( str ) i1 = 1 i2 = itokens ( 1 ) - 1 if ( i2 >= i1 ) then vals ( 1 )% str = str ( i1 : i2 ) else vals ( 1 )% str = '' !the first character is a token end if !      1 2 3 !    'a,b,c,d' do i = 2 , n_tokens i1 = itokens ( i - 1 ) + len_token i2 = itokens ( i ) - 1 if ( i2 >= i1 ) then vals ( i )% str = str ( i1 : i2 ) else vals ( i )% str = '' !empty element (e.g., 'abc,,def') end if end do i1 = itokens ( n_tokens ) + len_token i2 = len_str if ( itokens ( n_tokens ) + len_token <= len_str ) then vals ( n_tokens + 1 )% str = str ( i1 : i2 ) else vals ( n_tokens + 1 )% str = '' !the last character was a token end if else !no tokens present, so just return the original string: vals ( 1 )% str = str end if end function split1","tags":"","loc":"proc/split1.html"},{"title":"read_line – AoC-2023","text":"public  function read_line(iunit, status_ok) result(line) Reads the next line from a file. Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit logical, intent(out), optional :: status_ok true if no problems Return Value character(len=:), allocatable Called by proc~~read_line~~CalledByGraph proc~read_line aoc_utilities::read_line proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~read_file_to_char_array->proc~read_line program~problem_1 problem_1 program~problem_1->proc~read_line program~problem_2 problem_2 program~problem_2->proc~read_line program~problem_4 problem_4 program~problem_4->proc~read_line program~problem_5 problem_5 program~problem_5->proc~read_line program~problem_7 problem_7 program~problem_7->proc~read_line program~problem_8 problem_8 program~problem_8->proc~read_line program~problem_9 problem_9 program~problem_9->proc~read_line proc~go~2 problem_11::go proc~go~2->proc~read_file_to_char_array program~problem_10 problem_10 program~problem_10->proc~read_file_to_char_array program~problem_3 problem_3 program~problem_3->proc~read_file_to_char_array program~problem_11 problem_11 program~problem_11->proc~go~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function read_line ( iunit , status_ok ) result ( line ) integer , intent ( in ) :: iunit character ( len = :), allocatable :: line logical , intent ( out ), optional :: status_ok !! true if no problems integer :: nread !! character count specifier for read statement integer :: istat !! file read io status flag character ( len = chunk_size ) :: buffer !! the file read buffer nread = 0 buffer = '' line = '' if ( present ( status_ok )) status_ok = . true . do ! read in the next block of text from the line: read ( iunit , fmt = '(A)' , advance = 'NO' , size = nread , iostat = istat ) buffer if ( IS_IOSTAT_END ( istat ) . or . IS_IOSTAT_EOR ( istat )) then ! add the last block of text before the end of record if ( nread > 0 ) line = line // buffer ( 1 : nread ) exit else if ( istat == 0 ) then ! all the characters were read line = line // buffer ! add this block of text to the string else ! some kind of error if ( present ( status_ok )) then status_ok = . false . exit else error stop 'Read error' end if end if end do end function read_line","tags":"","loc":"proc/read_line.html"},{"title":"unique32 – AoC-2023","text":"private  function unique32(vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec Return Value integer, dimension(:), allocatable Calls proc~~unique32~~CallsGraph proc~unique32 aoc_utilities::unique32 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~unique32~~CalledByGraph proc~unique32 aoc_utilities::unique32 interface~unique aoc_utilities::unique interface~unique->proc~unique32 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function unique32 ( vec ) result ( vec_unique ) integer , dimension (:), intent ( in ) :: vec integer , dimension (:), allocatable :: vec_unique integer :: i , num logical , dimension ( size ( vec )) :: mask mask = . false . do i = 1 , size ( vec ) !count the number of occurrences of this element: num = count ( vec ( i ) == vec ) if ( num == 1 ) then !there is only one, flag it: mask ( i ) = . true . else !flag this value only if it hasn't already been flagged: if (. not . any ( vec ( i ) == vec . and . mask ) ) mask ( i ) = . true . end if end do !return only flagged elements: allocate ( vec_unique ( count ( mask )) ) vec_unique = pack ( vec , mask ) ! also sort it: call sort ( vec_unique ) end function unique32","tags":"","loc":"proc/unique32.html"},{"title":"unique64 – AoC-2023","text":"private  function unique64(vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: vec Return Value integer(kind=int64), dimension(:), allocatable Calls proc~~unique64~~CallsGraph proc~unique64 aoc_utilities::unique64 interface~sort aoc_utilities::sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~unique64~~CalledByGraph proc~unique64 aoc_utilities::unique64 interface~unique aoc_utilities::unique interface~unique->proc~unique64 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function unique64 ( vec ) result ( vec_unique ) integer ( int64 ), dimension (:), intent ( in ) :: vec integer ( int64 ), dimension (:), allocatable :: vec_unique integer ( int64 ) :: i , num logical , dimension ( size ( vec )) :: mask mask = . false . do i = 1 , size ( vec ) !count the number of occurrences of this element: num = count ( vec ( i ) == vec ) if ( num == 1 ) then !there is only one, flag it: mask ( i ) = . true . else !flag this value only if it hasn't already been flagged: if (. not . any ( vec ( i ) == vec . and . mask ) ) mask ( i ) = . true . end if end do !return only flagged elements: allocate ( vec_unique ( count ( mask )) ) vec_unique = pack ( vec , mask ) ! also sort it: call sort ( vec_unique ) end function unique64","tags":"","loc":"proc/unique64.html"},{"title":"parse_ints – AoC-2023","text":"public  function parse_ints(line) result(ints) parse positive ints from a string that also includes text Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer, dimension(:), allocatable Called by proc~~parse_ints~~CalledByGraph proc~parse_ints aoc_utilities::parse_ints program~problem_4 problem_4 program~problem_4->proc~parse_ints Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function parse_ints ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer , dimension (:), allocatable :: ints ! array of integers integer :: i , j , n integer :: istart character ( len =* ), parameter :: tokens = '0123456789' n = len ( line ) istart = 0 allocate ( ints ( 0 )) do i = 1 , n if ( index ( tokens , line ( i : i )) > 0 ) then if ( istart == 0 ) istart = i else if ( istart /= 0 ) ints = [ ints , int ( line ( istart : i - 1 ))] ! get previous int istart = 0 end if end do if ( istart /= 0 ) ints = [ ints , int ( line ( istart : n ))] ! get last int end function parse_ints","tags":"","loc":"proc/parse_ints.html"},{"title":"parse_ints64 – AoC-2023","text":"public  function parse_ints64(line) result(ints) Parse positive ints from a string that also includes text Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=int64), dimension(:), allocatable Called by proc~~parse_ints64~~CalledByGraph proc~parse_ints64 aoc_utilities::parse_ints64 program~problem_5 problem_5 program~problem_5->proc~parse_ints64 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function parse_ints64 ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer ( int64 ), dimension (:), allocatable :: ints ! array of integers integer ( int64 ) :: i , j , n integer ( int64 ) :: istart character ( len =* ), parameter :: tokens = '0123456789' n = len ( line ) istart = 0 allocate ( ints ( 0 )) do i = 1 , n if ( index ( tokens , line ( i : i )) > 0 ) then if ( istart == 0 ) istart = i else if ( istart /= 0 ) ints = [ ints , int ( line ( istart : i - 1 ), kind = int64 )] ! get previous int istart = 0 end if end do if ( istart /= 0 ) ints = [ ints , int ( line ( istart : n ), kind = int64 )] ! get last int end function parse_ints64","tags":"","loc":"proc/parse_ints64.html"},{"title":"parse_nums64 – AoC-2023","text":"private  function parse_nums64(line) result(ints) parse space-deliminated int64 sequence (positive or negative) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=int64), dimension(:), allocatable Calls proc~~parse_nums64~~CallsGraph proc~parse_nums64 aoc_utilities::parse_nums64 interface~split aoc_utilities::split proc~parse_nums64->interface~split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~parse_nums64~~CalledByGraph proc~parse_nums64 aoc_utilities::parse_nums64 interface~parse aoc_utilities::parse interface~parse->proc~parse_nums64 program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function parse_nums64 ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer ( int64 ), dimension (:), allocatable :: ints ! array of integers ints = int ( split ( line , ' ' )) end function parse_nums64","tags":"","loc":"proc/parse_nums64.html"},{"title":"startswith_cc – AoC-2023","text":"private pure function startswith_cc(str, substring) starts with function for strings Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical Called by proc~~startswith_cc~~CalledByGraph proc~startswith_cc aoc_utilities::startswith_cc interface~startswith aoc_utilities::startswith interface~startswith->proc~startswith_cc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith program~problem_5 problem_5 program~problem_5->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function startswith_cc ( str , substring ) character ( len =* ), intent ( in ) :: str , substring startswith_cc = index ( str , substring ) == 1 end function startswith_cc","tags":"","loc":"proc/startswith_cc.html"},{"title":"startswith_ss – AoC-2023","text":"private pure function startswith_ss(str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str type( string ), intent(in) :: substring Return Value logical Calls proc~~startswith_ss~~CallsGraph proc~startswith_ss aoc_utilities::startswith_ss interface~startswith aoc_utilities::startswith proc~startswith_ss->interface~startswith interface~startswith->proc~startswith_ss proc~startswith_cc aoc_utilities::startswith_cc interface~startswith->proc~startswith_cc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~startswith_ss~~CalledByGraph proc~startswith_ss aoc_utilities::startswith_ss interface~startswith aoc_utilities::startswith proc~startswith_ss->interface~startswith interface~startswith->proc~startswith_ss proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith program~problem_5 problem_5 program~problem_5->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function startswith_ss ( str , substring ) type ( string ), intent ( in ) :: str , substring startswith_ss = startswith ( str % str , substring % str ) end function startswith_ss","tags":"","loc":"proc/startswith_ss.html"},{"title":"startswith_sc – AoC-2023","text":"private pure function startswith_sc(str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical Calls proc~~startswith_sc~~CallsGraph proc~startswith_sc aoc_utilities::startswith_sc interface~startswith aoc_utilities::startswith proc~startswith_sc->interface~startswith interface~startswith->proc~startswith_sc proc~startswith_cc aoc_utilities::startswith_cc interface~startswith->proc~startswith_cc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_cs->interface~startswith proc~startswith_ss->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~startswith_sc~~CalledByGraph proc~startswith_sc aoc_utilities::startswith_sc interface~startswith aoc_utilities::startswith proc~startswith_sc->interface~startswith interface~startswith->proc~startswith_sc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_cs->interface~startswith proc~startswith_ss->interface~startswith program~problem_5 problem_5 program~problem_5->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function startswith_sc ( str , substring ) type ( string ), intent ( in ) :: str character ( len =* ), intent ( in ) :: substring startswith_sc = startswith ( str % str , substring ) end function startswith_sc","tags":"","loc":"proc/startswith_sc.html"},{"title":"startswith_cs – AoC-2023","text":"private pure function startswith_cs(str, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str type( string ), intent(in) :: substring Return Value logical Calls proc~~startswith_cs~~CallsGraph proc~startswith_cs aoc_utilities::startswith_cs interface~startswith aoc_utilities::startswith proc~startswith_cs->interface~startswith interface~startswith->proc~startswith_cs proc~startswith_cc aoc_utilities::startswith_cc interface~startswith->proc~startswith_cc proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~startswith_cs~~CalledByGraph proc~startswith_cs aoc_utilities::startswith_cs interface~startswith aoc_utilities::startswith proc~startswith_cs->interface~startswith interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith program~problem_5 problem_5 program~problem_5->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function startswith_cs ( str , substring ) character ( len =* ), intent ( in ) :: str type ( string ), intent ( in ) :: substring startswith_cs = startswith ( str , substring % str ) end function startswith_cs","tags":"","loc":"proc/startswith_cs.html"},{"title":"is_number – AoC-2023","text":"public  function is_number(c) returns true if the character is a number from 0 to 9. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical Called by proc~~is_number~~CalledByGraph proc~is_number aoc_utilities::is_number proc~check problem_3::check proc~check->proc~is_number proc~get_number problem_3::get_number proc~check->proc~get_number proc~is_not_number aoc_utilities::is_not_number proc~is_not_number->proc~is_number proc~is_symbol problem_3::is_symbol proc~is_symbol->proc~is_not_number program~problem_3 problem_3 program~problem_3->proc~check program~problem_3->proc~is_not_number program~problem_3->proc~is_symbol program~problem_3->proc~get_number proc~get_number->proc~is_symbol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function is_number ( c ) character ( len = 1 ), intent ( in ) :: c is_number = c >= '0' . and . c <= '9' end function is_number","tags":"","loc":"proc/is_number.html"},{"title":"is_not_number – AoC-2023","text":"public  function is_not_number(c) returns true if the character is not a number. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical Calls proc~~is_not_number~~CallsGraph proc~is_not_number aoc_utilities::is_not_number proc~is_number aoc_utilities::is_number proc~is_not_number->proc~is_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~is_not_number~~CalledByGraph proc~is_not_number aoc_utilities::is_not_number proc~is_symbol problem_3::is_symbol proc~is_symbol->proc~is_not_number program~problem_3 problem_3 program~problem_3->proc~is_not_number program~problem_3->proc~is_symbol proc~get_number problem_3::get_number program~problem_3->proc~get_number proc~check problem_3::check program~problem_3->proc~check proc~get_number->proc~is_symbol proc~check->proc~get_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function is_not_number ( c ) character ( len = 1 ), intent ( in ) :: c is_not_number = . not . is_number ( c ) end function is_not_number","tags":"","loc":"proc/is_not_number.html"},{"title":"str_to_array – AoC-2023","text":"public  function str_to_array(s) result(a) convert the character string to an array of characters Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value character(len=1), dimension(len(s)) Called by proc~~str_to_array~~CalledByGraph proc~str_to_array aoc_utilities::str_to_array program~problem_7 problem_7 program~problem_7->proc~str_to_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function str_to_array ( s ) result ( a ) character ( len =* ), intent ( in ) :: s character ( len = 1 ), dimension ( len ( s )) :: a integer :: i do i = 1 , len ( s ) ! transfer a ( i ) = s ( i : i ) end do end function str_to_array","tags":"","loc":"proc/str_to_array.html"},{"title":"lcm – AoC-2023","text":"public pure function lcm(i, j) LCM. based on code from NCAR Command Language Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: i integer(kind=int64), intent(in) :: j Return Value integer(kind=int64) Called by proc~~lcm~~CalledByGraph proc~lcm aoc_utilities::lcm program~problem_8 problem_8 program~problem_8->proc~lcm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer ( int64 ) function lcm ( i , j ) integer ( int64 ), intent ( in ) :: i , j integer ( int64 ) :: rem , m , n m = abs ( i ) n = abs ( j ) lcm = 0 if ( m <= 0 . or . n <= 0 ) return do rem = mod ( m , n ) if ( rem <= 0 ) exit m = n n = rem end do lcm = abs ( i * j / n ) end function lcm","tags":"","loc":"proc/lcm.html"},{"title":"reverse – AoC-2023","text":"public pure function reverse(ivals) result(ireverse) Reverse an int64 vector Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: ivals Return Value integer(kind=int64), dimension(size(ivals)) Called by proc~~reverse~~CalledByGraph proc~reverse aoc_utilities::reverse program~problem_9 problem_9 program~problem_9->proc~reverse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function reverse ( ivals ) result ( ireverse ) integer ( int64 ), dimension (:), intent ( in ) :: ivals integer ( int64 ), dimension ( size ( ivals )) :: ireverse integer :: i ireverse = [( ivals ( i ), i = size ( ivals ), 1 , - 1 )] end function reverse","tags":"","loc":"proc/reverse.html"},{"title":"diff – AoC-2023","text":"public pure function diff(ivals) result(idiff) Difference int64 vector Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: ivals Return Value integer(kind=int64), dimension(:), allocatable Called by proc~~diff~~CalledByGraph proc~diff aoc_utilities::diff proc~extrapolate problem_9::extrapolate proc~extrapolate->proc~diff program~problem_9 problem_9 program~problem_9->proc~extrapolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function diff ( ivals ) result ( idiff ) integer ( int64 ), dimension (:), intent ( in ) :: ivals integer ( int64 ), dimension (:), allocatable :: idiff integer :: i !! counter idiff = [( ivals ( i + 1 ) - ivals ( i ), i = 1 , size ( ivals ) - 1 )] end function diff","tags":"","loc":"proc/diff.html"},{"title":"clock_start – AoC-2023","text":"private  subroutine clock_start(me) Start the clock Type Bound clock Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me Called by proc~~clock_start~~CalledByGraph proc~clock_start aoc_utilities::clock%clock_start program~problem_1 problem_1 program~problem_1->proc~clock_start program~problem_10 problem_10 program~problem_10->proc~clock_start program~problem_11 problem_11 program~problem_11->proc~clock_start program~problem_2 problem_2 program~problem_2->proc~clock_start program~problem_3 problem_3 program~problem_3->proc~clock_start program~problem_4 problem_4 program~problem_4->proc~clock_start program~problem_5 problem_5 program~problem_5->proc~clock_start program~problem_6 problem_6 program~problem_6->proc~clock_start program~problem_7 problem_7 program~problem_7->proc~clock_start program~problem_8 problem_8 program~problem_8->proc~clock_start program~problem_9 problem_9 program~problem_9->proc~clock_start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine clock_start ( me ) class ( clock ), intent ( inout ) :: me call system_clock ( me % begin , me % rate ) end subroutine clock_start","tags":"","loc":"proc/clock_start.html"},{"title":"clock_end – AoC-2023","text":"private  subroutine clock_end(me, case_str) Print runtime in milliseconds form the start of the clock. Type Bound clock Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me character(len=*), intent(in) :: case_str description of the case Called by proc~~clock_end~~CalledByGraph proc~clock_end aoc_utilities::clock%clock_end program~problem_1 problem_1 program~problem_1->proc~clock_end program~problem_10 problem_10 program~problem_10->proc~clock_end program~problem_11 problem_11 program~problem_11->proc~clock_end program~problem_2 problem_2 program~problem_2->proc~clock_end program~problem_3 problem_3 program~problem_3->proc~clock_end program~problem_4 problem_4 program~problem_4->proc~clock_end program~problem_5 problem_5 program~problem_5->proc~clock_end program~problem_6 problem_6 program~problem_6->proc~clock_end program~problem_7 problem_7 program~problem_7->proc~clock_end program~problem_8 problem_8 program~problem_8->proc~clock_end program~problem_9 problem_9 program~problem_9->proc~clock_end Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine clock_end ( me , case_str ) class ( clock ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: case_str !! description of the case integer :: itime !! time in integer milliseconds call system_clock ( me % end ) itime = int ( 1000 * ( me % end - me % begin ) / real ( me % rate , wp )) write ( * , '(a,I4,a)' ) trim ( case_str ) // ' runtime: ' , itime , ' ms' write ( * , '(a)' ) '---------------------------' write ( * , * ) '' end subroutine clock_end","tags":"","loc":"proc/clock_end.html"},{"title":"sort_ascending – AoC-2023","text":"private  subroutine sort_ascending(ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec Calls proc~~sort_ascending~~CallsGraph proc~sort_ascending aoc_utilities::sort_ascending interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap64 aoc_utilities::swap64 interface~swap->proc~swap64 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sort_ascending~~CalledByGraph proc~sort_ascending aoc_utilities::sort_ascending interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine sort_ascending ( ivec ) integer , dimension (:), intent ( inout ) :: ivec integer , parameter :: max_size_for_insertion_sort = 20 !! max size for using insertion sort. call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending","tags":"","loc":"proc/sort_ascending.html"},{"title":"sort_ascending_64 – AoC-2023","text":"private  subroutine sort_ascending_64(ivec) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:) :: ivec Calls proc~~sort_ascending_64~~CallsGraph proc~sort_ascending_64 aoc_utilities::sort_ascending_64 proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sort_ascending_64~~CalledByGraph proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending_64 proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine sort_ascending_64 ( ivec ) integer ( int64 ), dimension (:), intent ( inout ) :: ivec integer ( int64 ), parameter :: max_size_for_insertion_sort = 20 !! max size for using insertion sort. call quicksort ( 1_int64 , size ( ivec , kind = int64 )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array integer ( int64 ), intent ( in ) :: ilow integer ( int64 ), intent ( in ) :: ihigh integer ( int64 ) :: ipivot !! pivot element integer ( int64 ) :: i !! counter integer ( int64 ) :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap64 ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer ( int64 ), intent ( in ) :: ilow integer ( int64 ), intent ( in ) :: ihigh integer ( int64 ), intent ( out ) :: ipivot integer ( int64 ) :: i , ip call swap64 ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap64 ( ivec ( ip ), ivec ( i )) end if end do call swap64 ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending_64","tags":"","loc":"proc/sort_ascending_64.html"},{"title":"swap32 – AoC-2023","text":"private pure elemental subroutine swap32(i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 Called by proc~~swap32~~CalledByGraph proc~swap32 aoc_utilities::swap32 interface~swap aoc_utilities::swap interface~swap->proc~swap32 proc~sort_ascending aoc_utilities::sort_ascending proc~sort_ascending->interface~swap interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap32 ( i1 , i2 ) integer , intent ( inout ) :: i1 integer , intent ( inout ) :: i2 integer :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap32","tags":"","loc":"proc/swap32.html"},{"title":"swap64 – AoC-2023","text":"private pure elemental subroutine swap64(i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: i1 integer(kind=int64), intent(inout) :: i2 Called by proc~~swap64~~CalledByGraph proc~swap64 aoc_utilities::swap64 interface~swap aoc_utilities::swap interface~swap->proc~swap64 proc~sort_ascending_64 aoc_utilities::sort_ascending_64 proc~sort_ascending_64->proc~swap64 interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending_64 proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending->interface~swap proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap64 ( i1 , i2 ) integer ( int64 ), intent ( inout ) :: i1 integer ( int64 ), intent ( inout ) :: i2 integer ( int64 ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap64","tags":"","loc":"proc/swap64.html"},{"title":"swap_str – AoC-2023","text":"private pure elemental subroutine swap_str(i1, i2) Swap two character string values Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: i1 character(len=*), intent(inout) :: i2 Called by proc~~swap_str~~CalledByGraph proc~swap_str aoc_utilities::swap_str interface~swap aoc_utilities::swap interface~swap->proc~swap_str proc~sort_ascending aoc_utilities::sort_ascending proc~sort_ascending->interface~swap interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap_str ( i1 , i2 ) character ( len =* ), intent ( inout ) :: i1 character ( len =* ), intent ( inout ) :: i2 character ( len = len ( i1 )) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_str","tags":"","loc":"proc/swap_str.html"},{"title":"expand_vector – AoC-2023","text":"private pure subroutine expand_vector(vec, n, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) Called by proc~~expand_vector~~CalledByGraph proc~expand_vector aoc_utilities::expand_vector proc~split1 aoc_utilities::split1 proc~split1->proc~expand_vector interface~split aoc_utilities::split interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~split2->proc~split1 proc~parse_nums64 aoc_utilities::parse_nums64 proc~parse_nums64->interface~split program~problem_2 problem_2 program~problem_2->interface~split program~problem_4 problem_4 program~problem_4->interface~split program~problem_7 problem_7 program~problem_7->interface~split interface~parse aoc_utilities::parse interface~parse->proc~parse_nums64 program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine expand_vector ( vec , n , val , finished ) integer , dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) integer , dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector","tags":"","loc":"proc/expand_vector.html"},{"title":"locpt – AoC-2023","text":"public pure subroutine locpt(x0, y0, x, y, n, l, m) given a polygonal line connecting the vertices (x(i),y(i))\n  (i = 1,...,n) taken in this order. it is assumed that the\n  polygonal path is a loop, where (x(n),y(n)) = (x(1),y(1))\n  or there is an arc from (x(n),y(n)) to (x(1),y(1)). (x0,y0) is an arbitrary point and l and m are variables.\n  l and m are assigned the following values: l = - 1 if ( x0 , y0 ) is outside the polygonal path l = 0 if ( x0 , y0 ) lies on the polygonal path l = 1 if ( x0 , y0 ) is inside the polygonal path m = 0 if (x0,y0) is on or outside the path. if (x0,y0)\n  is inside the path then m is the winding number of the\n  path around the point (x0,y0). History Original version from the NSWC Library Modified by J. Williams : 08/04/2012 : refactored to modern Fortran Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: y0 real(kind=wp), intent(in), dimension(n) :: x real(kind=wp), intent(in), dimension(n) :: y integer, intent(in) :: n integer, intent(out) :: l integer, intent(out) :: m Called by proc~~locpt~~CalledByGraph proc~locpt aoc_utilities::locpt program~problem_10 problem_10 program~problem_10->proc~locpt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine locpt ( x0 , y0 , x , y , n , l , m ) implicit none !arguments: integer , intent ( in ) :: n real ( wp ), intent ( in ) :: x0 real ( wp ), intent ( in ) :: y0 real ( wp ), dimension ( n ), intent ( in ) :: x real ( wp ), dimension ( n ), intent ( in ) :: y integer , intent ( out ) :: l integer , intent ( out ) :: m !constants: real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) real ( wp ), parameter :: pi = atan2 ( 0.0_wp , - 1.0_wp ) real ( wp ), parameter :: pi2 = 2.0_wp * pi real ( wp ), parameter :: tol = 4.0_wp * eps * pi !local variables: integer :: i , n0 real ( wp ) :: u , v , theta1 , sum , theta , angle , thetai n0 = n if ( x ( 1 ) == x ( n ) . and . y ( 1 ) == y ( n )) n0 = n - 1 l = - 1 m = 0 u = x ( 1 ) - x0 v = y ( 1 ) - y0 if ( u == 0.0_wp . and . v == 0.0_wp ) then l = 0 !(x0, y0) is on the boundary of the path else if ( n0 >= 2 ) then theta1 = atan2 ( v , u ) sum = 0.0_wp theta = theta1 do i = 2 , n0 u = x ( i ) - x0 v = y ( i ) - y0 if ( u == 0.0_wp . and . v == 0.0_wp ) then l = 0 !(x0, y0) is on the boundary of the path exit end if thetai = atan2 ( v , u ) angle = abs ( thetai - theta ) if ( abs ( angle - pi ) < tol ) then l = 0 !(x0, y0) is on the boundary of the path exit end if if ( angle > pi ) angle = angle - pi2 if ( theta > thetai ) angle = - angle sum = sum + angle theta = thetai end do if ( l /= 0 ) then angle = abs ( theta1 - theta ) if ( abs ( angle - pi ) < tol ) then l = 0 !(x0, y0) is on the boundary of the path else if ( angle > pi ) angle = angle - pi2 if ( theta > theta1 ) angle = - angle sum = sum + angle !sum = 2*pi*m where m is the winding number m = abs ( sum ) / pi2 + 0.2_wp if ( m /= 0 ) then l = 1 if ( sum < 0.0_wp ) m = - m end if end if end if end if end if end subroutine locpt","tags":"","loc":"proc/locpt.html"},{"title":"sort – AoC-2023","text":"public interface sort Calls interface~~sort~~CallsGraph interface~sort aoc_utilities::sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~sort~~CalledByGraph interface~sort aoc_utilities::sort proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine sort_ascending (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_64 (ivec) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:) :: ivec","tags":"","loc":"interface/sort.html"},{"title":"parse – AoC-2023","text":"public interface parse Calls interface~~parse~~CallsGraph interface~parse aoc_utilities::parse proc~parse_nums64 aoc_utilities::parse_nums64 interface~parse->proc~parse_nums64 interface~split aoc_utilities::split proc~parse_nums64->interface~split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~parse~~CalledByGraph interface~parse aoc_utilities::parse program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function parse_nums64 (line) result(ints) parse space-deliminated int64 sequence (positive or negative) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=int64), dimension(:), allocatable","tags":"","loc":"interface/parse.html"},{"title":"split – AoC-2023","text":"public interface split Calls interface~~split~~CallsGraph interface~split aoc_utilities::split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~split~~CalledByGraph interface~split aoc_utilities::split proc~parse_nums64 aoc_utilities::parse_nums64 proc~parse_nums64->interface~split program~problem_2 problem_2 program~problem_2->interface~split program~problem_4 problem_4 program~problem_4->interface~split program~problem_7 problem_7 program~problem_7->interface~split interface~parse aoc_utilities::parse interface~parse->proc~parse_nums64 program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function split1 (str, token) result(vals) Split a character string using a token.\n  This routine is inspired by the Python split function. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable private pure function split2 (s, token) result(vals) Split a string , given a token. Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: s character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable","tags":"","loc":"interface/split.html"},{"title":"int – AoC-2023","text":"public interface int Calls interface~~int~~CallsGraph interface~int aoc_utilities::int proc~char_array_to_int aoc_utilities::char_array_to_int interface~int->proc~char_array_to_int proc~char_to_int aoc_utilities::char_to_int interface~int->proc~char_to_int proc~char_to_int64 aoc_utilities::char_to_int64 interface~int->proc~char_to_int64 proc~string_to_int aoc_utilities::string%string_to_int interface~int->proc~string_to_int proc~char_array_to_int->proc~char_to_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure elemental function string_to_int (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer private pure function char_to_int (str) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer private pure function char_to_int64 (str, kind) result(i) Basic string to integer(ip) routine.\nHacky hack just so we can overload as int() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: kind Return Value integer(kind=int64) private pure function char_array_to_int (str_array) result(i) Character array to integer routine Arguments Type Intent Optional Attributes Name character(len=1), intent(in), dimension(:) :: str_array example ['1','3'] --> 13 Return Value integer","tags":"","loc":"interface/int.html"},{"title":"unique – AoC-2023","text":"public interface unique Calls interface~~unique~~CallsGraph interface~unique aoc_utilities::unique proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~unique~~CalledByGraph interface~unique aoc_utilities::unique proc~hand_type problem_7::hand_type proc~hand_type->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function unique32 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec Return Value integer, dimension(:), allocatable private  function unique64 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: vec Return Value integer(kind=int64), dimension(:), allocatable","tags":"","loc":"interface/unique.html"},{"title":"startswith – AoC-2023","text":"public interface startswith test if a string starts with a specified substring Calls interface~~startswith~~CallsGraph interface~startswith aoc_utilities::startswith proc~startswith_cc aoc_utilities::startswith_cc interface~startswith->proc~startswith_cc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~startswith~~CalledByGraph interface~startswith aoc_utilities::startswith proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith program~problem_5 problem_5 program~problem_5->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function startswith_cc (str, substring) starts with function for strings Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_ss (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str type( string ), intent(in) :: substring Return Value logical private pure function startswith_sc (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_cs (str, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str type( string ), intent(in) :: substring Return Value logical","tags":"","loc":"interface/startswith.html"},{"title":"swap – AoC-2023","text":"public interface swap Calls interface~~swap~~CallsGraph interface~swap aoc_utilities::swap proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap64 aoc_utilities::swap64 interface~swap->proc~swap64 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~swap~~CalledByGraph interface~swap aoc_utilities::swap proc~sort_ascending aoc_utilities::sort_ascending proc~sort_ascending->interface~swap interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~hand_type problem_7::hand_type proc~hand_type->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure elemental subroutine swap32 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap64 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: i1 integer(kind=int64), intent(inout) :: i2 private pure elemental subroutine swap_str (i1, i2) Swap two character string values Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: i1 character(len=*), intent(inout) :: i2","tags":"","loc":"interface/swap.html"},{"title":"aoc_utilities – AoC-2023","text":"Helper classes and routines for Advent of Code Author Jacob Williams Uses iso_fortran_env module~~aoc_utilities~~UsesGraph module~aoc_utilities aoc_utilities iso_fortran_env iso_fortran_env module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aoc_utilities~~UsedByGraph module~aoc_utilities aoc_utilities program~problem_1 problem_1 program~problem_1->module~aoc_utilities program~problem_10 problem_10 program~problem_10->module~aoc_utilities program~problem_11 problem_11 program~problem_11->module~aoc_utilities program~problem_2 problem_2 program~problem_2->module~aoc_utilities program~problem_3 problem_3 program~problem_3->module~aoc_utilities program~problem_4 problem_4 program~problem_4->module~aoc_utilities program~problem_5 problem_5 program~problem_5->module~aoc_utilities program~problem_6 problem_6 program~problem_6->module~aoc_utilities program~problem_7 problem_7 program~problem_7->module~aoc_utilities program~problem_8 problem_8 program~problem_8->module~aoc_utilities program~problem_9 problem_9 program~problem_9->module~aoc_utilities Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, private, parameter :: chunk_size = 100 for dynamic allocations type( clock ), public :: clk a public clock to use for timing in the problems Interfaces public        interface sort private  subroutine sort_ascending (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_64 (ivec) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:) :: ivec public        interface parse private  function parse_nums64 (line) result(ints) parse space-deliminated int64 sequence (positive or negative) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=int64), dimension(:), allocatable public        interface split private pure function split1 (str, token) result(vals) Split a character string using a token.\n  This routine is inspired by the Python split function. Example character ( len = :), allocatable :: s type ( string ), dimension (:), allocatable :: vals s = '1,2,3,4,5' call split ( s , ',' , vals ) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable private pure function split2 (s, token) result(vals) Split a string , given a token. Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: s character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable public        interface int private pure elemental function string_to_int (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer private pure function char_to_int (str) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer private pure function char_to_int64 (str, kind) result(i) Basic string to integer(ip) routine.\nHacky hack just so we can overload as int() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: kind Return Value integer(kind=int64) private pure function char_array_to_int (str_array) result(i) Character array to integer routine Arguments Type Intent Optional Attributes Name character(len=1), intent(in), dimension(:) :: str_array example ['1','3'] --> 13 Return Value integer public        interface unique private  function unique32 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec Return Value integer, dimension(:), allocatable private  function unique64 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: vec Return Value integer(kind=int64), dimension(:), allocatable public        interface startswith test if a string starts with a specified substring private pure function startswith_cc (str, substring) starts with function for strings Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_ss (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str type( string ), intent(in) :: substring Return Value logical private pure function startswith_sc (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_cs (str, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str type( string ), intent(in) :: substring Return Value logical public        interface swap private pure elemental subroutine swap32 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap64 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: i1 integer(kind=int64), intent(inout) :: i2 private pure elemental subroutine swap_str (i1, i2) Swap two character string values Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: i1 character(len=*), intent(inout) :: i2 Derived Types type, public :: clock Components Type Visibility Attributes Name Initial integer(kind=int64), private :: begin integer(kind=int64), private :: end integer(kind=int64), private :: rate Type-Bound Procedures procedure, public :: tic => clock_start procedure, public :: toc => clock_end type, public :: string a type containing an allocatable character string.\nso we can have an array of strings of different lengths. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: str Type-Bound Procedures procedure, public :: to_int => string_to_int convert to integer procedure, public :: to_int_64 => string_to_int_64 type, public :: int64_vec an type that contains an allocatable int64 array.\nso we can have an array of these. Components Type Visibility Attributes Name Initial integer(kind=int64), public, dimension(:), allocatable :: vals Functions private pure function char_to_int (str) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer private pure elemental function string_to_int (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer private pure elemental function string_to_int_64 (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer(kind=int64) private pure function char_to_int64 (str, kind) result(i) Basic string to integer(ip) routine.\nHacky hack just so we can overload as int() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: kind Return Value integer(kind=int64) private pure function char_array_to_int (str_array) result(i) Character array to integer routine Arguments Type Intent Optional Attributes Name character(len=1), intent(in), dimension(:) :: str_array example ['1','3'] --> 13 Return Value integer public  function read_file_to_char_array (filename, border) result(array) Read a file into a 2d character array. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=1), intent(in), optional :: border if true, extra border is added with this char Return Value character(len=1), dimension(:,:), allocatable public  function read_file_to_integer_array (filename) result(iarray) Read a file into an integer array (one element per line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer, dimension(:), allocatable public  function read_file_to_integer64_array (filename) result(iarray) Read a file into an int64 integer array (one element per line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer(kind=int64), dimension(:), allocatable public  function number_of_lines_in_file (iunit) result(n_lines) Returns the number of lines in a file (assumed to be open) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit the file unit number\n(assumed to be open) Return Value integer the number of lines in the file private pure function split2 (s, token) result(vals) Split a string , given a token. Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: s character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable private pure function split1 (str, token) result(vals) Split a character string using a token.\n  This routine is inspired by the Python split function. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable public  function read_line (iunit, status_ok) result(line) Reads the next line from a file. Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit logical, intent(out), optional :: status_ok true if no problems Return Value character(len=:), allocatable private  function unique32 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec Return Value integer, dimension(:), allocatable private  function unique64 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: vec Return Value integer(kind=int64), dimension(:), allocatable public  function parse_ints (line) result(ints) parse positive ints from a string that also includes text Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer, dimension(:), allocatable public  function parse_ints64 (line) result(ints) Parse positive ints from a string that also includes text Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=int64), dimension(:), allocatable private  function parse_nums64 (line) result(ints) parse space-deliminated int64 sequence (positive or negative) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=int64), dimension(:), allocatable private pure function startswith_cc (str, substring) starts with function for strings Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_ss (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str type( string ), intent(in) :: substring Return Value logical private pure function startswith_sc (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_cs (str, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str type( string ), intent(in) :: substring Return Value logical public  function is_number (c) returns true if the character is a number from 0 to 9. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical public  function is_not_number (c) returns true if the character is not a number. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical public  function str_to_array (s) result(a) convert the character string to an array of characters Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value character(len=1), dimension(len(s)) public pure function lcm (i, j) LCM. based on code from NCAR Command Language Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: i integer(kind=int64), intent(in) :: j Return Value integer(kind=int64) public pure function reverse (ivals) result(ireverse) Reverse an int64 vector Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: ivals Return Value integer(kind=int64), dimension(size(ivals)) public pure function diff (ivals) result(idiff) Difference int64 vector Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: ivals Return Value integer(kind=int64), dimension(:), allocatable Subroutines private  subroutine clock_start (me) Start the clock Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me private  subroutine clock_end (me, case_str) Print runtime in milliseconds form the start of the clock. Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me character(len=*), intent(in) :: case_str description of the case private  subroutine sort_ascending (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_64 (ivec) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:) :: ivec private pure elemental subroutine swap32 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap64 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: i1 integer(kind=int64), intent(inout) :: i2 private pure elemental subroutine swap_str (i1, i2) Swap two character string values Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: i1 character(len=*), intent(inout) :: i2 private pure subroutine expand_vector (vec, n, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) public pure subroutine locpt (x0, y0, x, y, n, l, m) given a polygonal line connecting the vertices (x(i),y(i))\n  (i = 1,...,n) taken in this order. it is assumed that the\n  polygonal path is a loop, where (x(n),y(n)) = (x(1),y(1))\n  or there is an arc from (x(n),y(n)) to (x(1),y(1)). Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: y0 real(kind=wp), intent(in), dimension(n) :: x real(kind=wp), intent(in), dimension(n) :: y integer, intent(in) :: n integer, intent(out) :: l integer, intent(out) :: m","tags":"","loc":"module/aoc_utilities.html"},{"title":"problem_7 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_7~~UsesGraph program~problem_7 problem_7 iso_fortran_env iso_fortran_env program~problem_7->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_7->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_7~~CallsGraph program~problem_7 problem_7 interface~split aoc_utilities::split program~problem_7->interface~split proc~beats problem_7::beats program~problem_7->proc~beats proc~clock_end aoc_utilities::clock%clock_end program~problem_7->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_7->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_7->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_7->proc~read_line proc~str_to_array aoc_utilities::str_to_array program~problem_7->proc~str_to_array proc~swap_hands problem_7::swap_hands program~problem_7->proc~swap_hands proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~hand_type problem_7::hand_type proc~beats->proc~hand_type proc~index_in_cards problem_7::index_in_cards proc~beats->proc~index_in_cards interface~unique aoc_utilities::unique proc~hand_type->interface~unique proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: iunit integer :: n_lines integer :: icase character(len=:), allocatable :: line type( string ), dimension(:), allocatable :: vals logical :: done type( hand ), dimension(:), allocatable :: hands array of hands character(len=1), parameter,               dimension(2) :: cases = ['a', 'b'] character(len=1), parameter,               dimension(*) :: cards = ['A', 'K', 'Q', 'J', 'T', '9', '8', '7', '6', '5', '4', '3', '2'] character(len=1), parameter,               dimension(*) :: cards_with_joker = ['A', 'K', 'Q', 'T', '9', '8', '7', '6', '5', '4', '3', '2', 'J'] integer, parameter :: FIVE_OF_A_KIND = 1 integer, parameter :: FOUR_OF_A_KIND = 2 integer, parameter :: FULL_HOUSE = 3 integer, parameter :: THREE_OF_A_KIND = 4 integer, parameter :: TWO_PAIR = 5 integer, parameter :: ONE_PAIR = 6 integer, parameter :: HIGH_CARD = 7 Derived Types type :: hand Components Type Visibility Attributes Name Initial character(len=1), public, dimension(5) :: cards the cards in a hand integer(kind=ip), public :: bid = 0 integer, public :: type = 0 Functions function hand_type (me, with_jokers) returns the type of hand Arguments Type Intent Optional Attributes Name class( hand ), intent(in) :: me logical, intent(in) :: with_jokers if considering jokers Return Value integer function beats (hand1, hand2, with_jokers) return true if hand1 beats hand2 (has a higher score) Arguments Type Intent Optional Attributes Name class( hand ), intent(inout) :: hand1 class( hand ), intent(inout) :: hand2 logical, intent(in) :: with_jokers if considering jokers Return Value logical function index_in_cards (c, with_jokers) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c logical, intent(in) :: with_jokers if considering jokers Return Value integer Subroutines pure elemental subroutine swap_hands (i1, i2) swap function for hand type Arguments Type Intent Optional Attributes Name type( hand ), intent(inout) :: i1 type( hand ), intent(inout) :: i2 Source Code program problem_7 use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none integer :: i , iunit , n_lines , icase character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals logical :: done type :: hand character ( len = 1 ), dimension ( 5 ) :: cards !! the cards in a hand integer ( ip ) :: bid = 0 ! the bit for the hand integer :: type = 0 ! the hand type end type hand type ( hand ), dimension (:), allocatable :: hands !! array of hands character ( len = 1 ), dimension ( 2 ), parameter :: cases = [ 'a' , 'b' ] character ( len = 1 ), dimension ( * ), parameter :: cards = [ 'A' , 'K' , 'Q' , 'J' , 'T' , & '9' , '8' , '7' , '6' , '5' , & '4' , '3' , '2' ] character ( len = 1 ), dimension ( * ), parameter :: cards_with_joker = [ 'A' , 'K' , 'Q' , 'T' , & '9' , '8' , '7' , '6' , '5' , & '4' , '3' , '2' , 'J' ] integer , parameter :: FIVE_OF_A_KIND = 1 ! the hand types integer , parameter :: FOUR_OF_A_KIND = 2 integer , parameter :: FULL_HOUSE = 3 integer , parameter :: THREE_OF_A_KIND = 4 integer , parameter :: TWO_PAIR = 5 integer , parameter :: ONE_PAIR = 6 integer , parameter :: HIGH_CARD = 7 call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day7_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day7.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( hands ( n_lines )) do i = 1 , n_lines line = read_line ( iunit ); vals = split ( line , ' ' ) hands ( i )% cards = str_to_array ( vals ( 1 )% str ) hands ( i )% bid = int ( vals ( 2 )) end do close ( iunit ) do icase = 1 , 2 ! first time normally, second time processing the jokers ! sort the list from worst to best to determinte the rank of each hand hands % type = 0 ! reinitialize since they need to be recomputed do ! bubble sort ! done = . true . do i = 1 , n_lines - 1 if ( beats ( hands ( i ), hands ( i + 1 ), icase == 2 )) then call swap_hands ( hands ( i ), hands ( i + 1 )); done = . false . end if end do if ( done ) exit end do write ( * , * ) '7' // cases ( icase ) // ':' , sum ( hands % bid * [( i , i = 1 , n_lines )]) end do call clk % toc ( '7' ) contains integer function hand_type ( me , with_jokers ) !! returns the type of hand class ( hand ), intent ( in ) :: me logical , intent ( in ) :: with_jokers !! if considering jokers integer , dimension ( 5 ) :: i integer , dimension (:), allocatable :: u integer :: n_jokers , n_unique character ( len = 1 ), dimension ( 5 ) :: h h = me % cards i = ichar ( h ) ! convert to code u = unique ( i ) ! unique elements n_unique = size ( u ) if ( with_jokers . and . any ( h == 'J' )) then ! have to pick best hand for all jokers ! just do it by inspection n_jokers = count ( h == 'J' ) select case ( n_jokers ) case ( 5 ) hand_type = FIVE_OF_A_KIND !jjjjj case ( 4 ) hand_type = FIVE_OF_A_KIND !jjjja case ( 3 ) ! can always turn to 4 or 5 of a kind if ( n_unique == 2 ) then !jjjaa hand_type = FIVE_OF_A_KIND else ! jjjab hand_type = FOUR_OF_A_KIND end if case ( 2 ) if ( n_unique == 2 ) then !jjaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then !jjaab hand_type = FOUR_OF_A_KIND else !jjabc hand_type = THREE_OF_A_KIND end if case ( 1 ) if ( n_unique == 2 ) then !jaaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then if ( any ([ count ( i == u ( 1 )) == 3 , & count ( i == u ( 2 )) == 3 , & count ( i == u ( 3 )) == 3 ]) ) then !jaaab hand_type = FOUR_OF_A_KIND elseif ( ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 ) . or . & ( count ( i == u ( 2 )) == 2 . and . count ( i == u ( 2 )) == 2 ) ) then !jaabb hand_type = FULL_HOUSE end if else if ( n_unique == 4 ) then !jaabc hand_type = THREE_OF_A_KIND else if ( n_unique == 5 ) then !jabcd hand_type = ONE_PAIR end if end select else !Every hand is exactly one type. From strongest to weakest, they are: select case ( n_unique ) case ( 1 ) ! aaaaa hand_type = FIVE_OF_A_KIND case ( 2 ) ! aaaab, aaabb if (( count ( i == u ( 1 )) == 4 . and . count ( i == u ( 2 )) == 1 ) . or . & ( count ( i == u ( 1 )) == 1 . and . count ( i == u ( 2 )) == 4 ) ) then hand_type = FOUR_OF_A_KIND else if (( count ( i == u ( 1 )) == 3 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 3 ) ) then hand_type = FULL_HOUSE end if case ( 3 ) ! aaabc, aabcc if ( any ([ count ( i == u ( 1 )) == 3 , count ( i == u ( 2 )) == 3 , count ( i == u ( 3 )) == 3 ]) ) then hand_type = THREE_OF_A_KIND else if ( any ([ count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 , & count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 , & count ( i == u ( 2 )) == 2 . and . count ( i == u ( 3 )) == 2 ]) ) then hand_type = TWO_PAIR end if case ( 4 ) !aabcd hand_type = ONE_PAIR case ( 5 ) !abcde hand_type = HIGH_CARD ! High card, where all cards' labels are distinct: 23456 end select end if end function hand_type logical function beats ( hand1 , hand2 , with_jokers ) !! return true if hand1 beats hand2 (has a higher score) class ( hand ), intent ( inout ) :: hand1 , hand2 logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i associate ( h1 => hand1 % cards , h2 => hand2 % cards ) ! recompute type if it hasn't already been computed if ( hand1 % type == 0 ) hand1 % type = hand_type ( hand1 , with_jokers ) if ( hand2 % type == 0 ) hand2 % type = hand_type ( hand2 , with_jokers ) if ( hand1 % type == hand2 % type ) then ! lower index is stronger do i = 1 , 5 if ( h1 ( i ) /= h2 ( i )) then beats = index_in_cards ( h1 ( i ), with_jokers ) < & index_in_cards ( h2 ( i ), with_jokers ) ! lower is stronger return end if end do else ! one hand beat the other beats = hand1 % type < hand2 % type ! lower score is better (1-7) end if end associate end function beats integer function index_in_cards ( c , with_jokers ) character ( len = 1 ), intent ( in ) :: c logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i do i = 1 , size ( cards_with_joker ) if ( with_jokers ) then if ( c == cards_with_joker ( i )) then index_in_cards = i return end if else if ( c == cards ( i )) then index_in_cards = i return end if end if end do error stop 'card not found' end function index_in_cards pure elemental subroutine swap_hands ( i1 , i2 ) !! swap function for hand type type ( hand ), intent ( inout ) :: i1 type ( hand ), intent ( inout ) :: i2 type ( hand ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_hands end program problem_7","tags":"","loc":"program/problem_7.html"},{"title":"problem_3 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_3~~UsesGraph program~problem_3 problem_3 iso_fortran_env iso_fortran_env program~problem_3->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_3->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_3~~CallsGraph program~problem_3 problem_3 proc~check problem_3::check program~problem_3->proc~check proc~clock_end aoc_utilities::clock%clock_end program~problem_3->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_3->proc~clock_start proc~get_number problem_3::get_number program~problem_3->proc~get_number proc~is_not_number aoc_utilities::is_not_number program~problem_3->proc~is_not_number proc~is_symbol problem_3::is_symbol program~problem_3->proc~is_symbol proc~read_file_to_char_array aoc_utilities::read_file_to_char_array program~problem_3->proc~read_file_to_char_array proc~check->proc~get_number proc~is_number aoc_utilities::is_number proc~check->proc~is_number proc~get_number->proc~is_symbol proc~is_not_number->proc~is_number proc~is_symbol->proc~is_not_number proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: n_lines integer :: i integer :: j integer :: n_cols integer :: jstart integer :: jend logical :: adjacent logical :: tmp integer(kind=int64) :: isum character(len=1), dimension(:,:), allocatable :: array integer(kind=int64), dimension(:), allocatable :: ivals Functions function check (i, j) if the char is part of a number, then get it and append to ivals Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Return Value logical function is_symbol (c) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical function get_number (i, j) get the full number contining the character at i,j Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Return Value integer(kind=int64) Source Code program problem_3 use iso_fortran_env use aoc_utilities implicit none integer :: n_lines , i , j , n_cols , jstart , jend logical :: adjacent , tmp integer ( int64 ) :: isum character ( len = 1 ), dimension (:,:), allocatable :: array integer ( int64 ), dimension (:), allocatable :: ivals call clk % tic () ! read file: ! pad around with blanks to simplify logic below array = read_file_to_char_array ( 'inputs/day3.txt' , border = '.' ) n_lines = size ( array , 1 ) n_cols = size ( array , 2 ) !----------------- part 1 ----------------- isum = 0 do i = 1 , n_lines ! is this character adjacent to a symbol? jend = 0 do j = 1 , n_cols if ( is_not_number ( array ( i , j ))) cycle if ( j <= jend ) cycle ! skip the cols that we already have jend = 0 adjacent = is_symbol ( array ( i - 1 , j ) ) . or . & is_symbol ( array ( i - 1 , j - 1 )) . or . & is_symbol ( array ( i - 1 , j + 1 )) . or . & is_symbol ( array ( i , j - 1 ) ) . or . & is_symbol ( array ( i , j + 1 ) ) . or . & is_symbol ( array ( i + 1 , j ) ) . or . & is_symbol ( array ( i + 1 , j - 1 )) . or . & is_symbol ( array ( i + 1 , j + 1 )) if ( adjacent ) isum = isum + get_number ( i , j ) ! note: this sets jend end do end do write ( * , * ) '3a: sum :' , isum !----------------- part 2 ----------------- ! now look for '*' and find adjacent numbers .... isum = 0 do i = 1 , n_lines do j = 1 , n_cols if ( array ( i , j ) == '*' ) then ! look for 2 adjacent numbers. if ( allocated ( ivals )) deallocate ( ivals ); allocate ( ivals ( 0 )) ! above tmp = check ( i - 1 , j ) ! if only one on top if (. not . tmp ) then tmp = check ( i - 1 , j - 1 ) tmp = check ( i - 1 , j + 1 ) end if tmp = check ( i , j - 1 ) ! left and right tmp = check ( i , j + 1 ) ! below tmp = check ( i + 1 , j ) ! if only one below if (. not . tmp ) then tmp = check ( i + 1 , j - 1 ) tmp = check ( i + 1 , j + 1 ) end if if ( size ( ivals ) == 2 ) isum = isum + product ( ivals ) ! sum gear ratio end if end do end do write ( * , * ) '3b: result :' , isum call clk % toc ( '3' ) contains logical function check ( i , j ) !! if the char is part of a number, then get it and append to ivals integer , intent ( in ) :: i , j check = is_number ( array ( i , j )) if ( check ) ivals = [ ivals , get_number ( i , j )] end function check logical function is_symbol ( c ) character ( len = 1 ), intent ( in ) :: c is_symbol = is_not_number ( c ) . and . c /= '.' end function is_symbol integer ( int64 ) function get_number ( i , j ) !! get the full number contining the character at i,j integer , intent ( in ) :: i , j jstart = j jend = j do if ( array ( i , jstart - 1 ) == '.' . or . is_symbol ( array ( i , jstart - 1 ))) exit jstart = jstart - 1 end do do if ( array ( i , jend + 1 ) == '.' . or . is_symbol ( array ( i , jend + 1 ))) exit jend = jend + 1 end do get_number = int ( array ( i , jstart : jend )) end function get_number end program problem_3","tags":"","loc":"program/problem_3.html"},{"title":"problem_8 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_8~~UsesGraph program~problem_8 problem_8 iso_fortran_env iso_fortran_env program~problem_8->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_8->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_8~~CallsGraph program~problem_8 problem_8 proc~clock_end aoc_utilities::clock%clock_end program~problem_8->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_8->proc~clock_start proc~find_node problem_8::find_node program~problem_8->proc~find_node proc~lcm aoc_utilities::lcm program~problem_8->proc~lcm proc~moves problem_8::moves program~problem_8->proc~moves proc~moves_any_z problem_8::moves_any_z program~problem_8->proc~moves_any_z proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_8->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_8->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit integer :: n_lines character(len=:), allocatable :: line character(len=:), allocatable :: instructions type( string ), dimension(:), allocatable :: vals integer(kind=ip) :: i integer(kind=ip) :: j integer(kind=ip) :: idx integer(kind=ip) :: idx_zzz integer(kind=ip) :: imoves integer(kind=ip) :: ias integer(kind=ip) :: izs integer(kind=ip), dimension(:), allocatable :: instructions_ints integer(kind=ip), dimension(:), allocatable :: idx_vec integer(kind=ip), dimension(:), allocatable :: idx_zzz_vec integer(kind=ip), dimension(:), allocatable :: imoves_vec type( node ), dimension(:), allocatable :: nodes Derived Types type :: node Components Type Visibility Attributes Name Initial character(len=3), public :: name = '' character(len=3), public, dimension(2) :: lr integer, public, dimension(2) :: lr_idx Functions pure function moves (istart, iend) result(imoves) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: istart indices for start and end nodes integer(kind=ip), intent(in) :: iend indices for start and end nodes Return Value integer(kind=ip) pure function moves_any_z (istart, iend) result(imoves) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: istart indices for start and end nodes integer(kind=ip), intent(in), dimension(:) :: iend Return Value integer(kind=ip) pure function all_in_set (ivals, iset) returns true if all the elements of ivals are in the set iset Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals integer(kind=ip), intent(in), dimension(:) :: iset Return Value logical pure function find_node (name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value integer(kind=ip) Source Code program problem_8 use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none integer :: iunit , n_lines character ( len = :), allocatable :: line , instructions type ( string ), dimension (:), allocatable :: vals integer ( ip ) :: i , j , idx , idx_zzz , imoves , ias , izs integer ( ip ), dimension (:), allocatable :: instructions_ints integer ( ip ), dimension (:), allocatable :: idx_vec , idx_zzz_vec integer ( ip ), dimension (:), allocatable :: imoves_vec type :: node character ( len = 3 ) :: name = '' character ( len = 3 ), dimension ( 2 ) :: lr integer , dimension ( 2 ) :: lr_idx ! the indices in the nodes array of the l,r nodes end type node type ( node ), dimension (:), allocatable :: nodes call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day8_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day8.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( nodes ( n_lines - 2 )) instructions = read_line ( iunit ) allocate ( instructions_ints ( len ( instructions ))) do i = 1 , len ( instructions ) select case ( instructions ( i : i )) ! make an int array for easier access case ( 'L' ); instructions_ints ( i ) = 1 case ( 'R' ); instructions_ints ( i ) = 2 end select end do do i = 0 , n_lines - 1 line = read_line ( iunit ) if ( line == '' ) cycle read ( line , \"(A3,1X,1X,1X,1X,A3,1X,1X,A3,1X)\" ) nodes ( i )% name , nodes ( i )% lr ( 1 ), nodes ( i )% lr ( 2 ) end do close ( iunit ) ! compute all the lr indices: do i = 1 , size ( nodes ) nodes ( i )% lr_idx ( 1 ) = find_node ( nodes ( i )% lr ( 1 )) nodes ( i )% lr_idx ( 2 ) = find_node ( nodes ( i )% lr ( 2 )) end do !******************************************** imoves = moves ( find_node ( 'AAA' ), find_node ( 'ZZZ' )) write ( * , * ) '8a : number of moves:' , imoves !******************************************** ! get indices of the ones that end in A and Z: allocate ( idx_vec ( 0 ), idx_zzz_vec ( 0 )) do i = 1 , size ( nodes ) if ( nodes ( i )% name ( 3 : 3 ) == 'A' ) idx_vec = [ idx_vec , i ] if ( nodes ( i )% name ( 3 : 3 ) == 'Z' ) idx_zzz_vec = [ idx_zzz_vec , i ] end do if ( size ( idx_vec ) /= size ( idx_zzz_vec )) error stop 'error: they need to be the same size?' allocate ( imoves_vec ( size ( idx_vec ))) ! for EACH start, find the number of moves that it takes to get to ONE of the ends. do i = 1 , size ( idx_vec ) imoves_vec ( i ) = moves_any_z ( idx_vec ( i ), idx_zzz_vec ) end do ! don't know why this works ¯\\_(ツ)_/¯ ! I think it's a feature of the specific data given ! (it's a repeating cycle once it gets to the end) write ( * , * ) '8b : number of moves: ' , lcm ( lcm ( lcm ( lcm ( lcm ( imoves_vec ( 1 ),& imoves_vec ( 2 )),& imoves_vec ( 3 )),& imoves_vec ( 4 )),& imoves_vec ( 5 )),& imoves_vec ( 6 )) ! ! ! ! brute force. run all the moves in parallel until they are all done. ! ! ! i = 0 ! imoves = 0 ! do !     if (all_in_set(idx_vec, idx_zzz_vec)) exit !     imoves = imoves + 1 ! another move !     i = i + 1 !     if (i>len(instructions)) i = 1 !     do concurrent (j = 1 : size(idx_vec)) !         idx_vec(j) = nodes(idx_vec(j))%lr_idx(instructions_ints(i)) !     end do ! end do ! write(*,*) '8b : number of moves:', imoves call clk % toc ( '8' ) contains pure function moves ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart , iend !! indices for start and end nodes integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( idx == iend ) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves pure function moves_any_z ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart !! indices for start and end nodes integer ( ip ), dimension (:), intent ( in ) :: iend integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( any ( idx == iend )) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves_any_z pure logical function all_in_set ( ivals , iset ) !! returns true if all the elements of ivals are in the set iset integer ( ip ), dimension (:), intent ( in ) :: ivals , iset integer :: i all_in_set = . true . do i = 1 , size ( ivals ) if (. not . any ( ivals ( i ) == iset )) then all_in_set = . false . exit end if end do end function all_in_set pure integer ( ip ) function find_node ( name ) character ( len =* ), intent ( in ) :: name integer ( ip ) :: i do i = 1 , size ( nodes ) if ( name == nodes ( i )% name ) then find_node = i return end if end do error stop 'could not find node' end function find_node end program problem_8","tags":"","loc":"program/problem_8.html"},{"title":"problem_9 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_9~~UsesGraph program~problem_9 problem_9 iso_fortran_env iso_fortran_env program~problem_9->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_9->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_9~~CallsGraph program~problem_9 problem_9 interface~parse aoc_utilities::parse program~problem_9->interface~parse proc~clock_end aoc_utilities::clock%clock_end program~problem_9->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_9->proc~clock_start proc~extrapolate problem_9::extrapolate program~problem_9->proc~extrapolate proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_9->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_9->proc~read_line proc~reverse aoc_utilities::reverse program~problem_9->proc~reverse proc~parse_nums64 aoc_utilities::parse_nums64 interface~parse->proc~parse_nums64 proc~diff aoc_utilities::diff proc~extrapolate->proc~diff interface~split aoc_utilities::split proc~parse_nums64->interface~split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: iunit integer :: n_lines integer(kind=ip) :: isum Functions pure function extrapolate (ivals) result(iextrap) extrapolate the next value in the sequence using\na difference table. Straightfoward implemention:\ncreate the full table, and then evaluate it. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals Return Value integer(kind=ip) Source Code program problem_9 use iso_fortran_env , ip => int64 ! use long ints use aoc_utilities implicit none integer :: i , iunit , n_lines integer ( ip ) :: isum call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day9_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day9.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = sum ([( extrapolate ( parse ( read_line ( iunit ))), i = 1 , n_lines )]) close ( iunit ) write ( * , * ) '9a: sum: ' , isum open ( newunit = iunit , file = 'inputs/day9.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = sum ([( extrapolate ( reverse ( parse ( read_line ( iunit )))), i = 1 , n_lines )]) close ( iunit ) write ( * , * ) '9b: sum: ' , isum call clk % toc ( '9' ) contains pure function extrapolate ( ivals ) result ( iextrap ) !! extrapolate the next value in the sequence using !! a difference table. Straightfoward implemention: !! create the full table, and then evaluate it. integer ( ip ), dimension (:), intent ( in ) :: ivals integer ( ip ) :: iextrap integer :: i , n type ( int64_vec ), dimension (:), allocatable :: diff_table !! difference table (vector of vectors) ! create the difference table: diff_table = [ int64_vec ( ivals )]; n = 1 do n = n + 1 diff_table = [ diff_table , int64_vec ( diff ( diff_table ( n - 1 )% vals ))] ! next line is diff of previous line if ( all ( diff_table ( n )% vals == 0 )) exit end do ! extrapolate iextrap = 0 do i = n - 1 , 1 , - 1 associate ( ilast => diff_table ( i )% vals ( size ( diff_table ( i )% vals )) ) iextrap = iextrap + ilast end associate end do end function extrapolate end program problem_9","tags":"","loc":"program/problem_9.html"},{"title":"problem_10 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_10~~UsesGraph program~problem_10 problem_10 iso_fortran_env iso_fortran_env program~problem_10->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_10->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_10~~CallsGraph program~problem_10 problem_10 proc~clock_end aoc_utilities::clock%clock_end program~problem_10->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_10->proc~clock_start proc~locpt aoc_utilities::locpt program~problem_10->proc~locpt proc~move problem_10::move program~problem_10->proc~move proc~read_file_to_char_array aoc_utilities::read_file_to_char_array program~problem_10->proc~read_file_to_char_array proc~move->proc~move proc~pipe_info problem_10::pipe_info proc~move->proc~pipe_info proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: j integer :: nrows integer :: ncols integer :: imove integer :: l integer :: m logical, dimension(:,:), allocatable :: icounts character(len=1), dimension(:,:), allocatable :: array integer, dimension(:,:), allocatable :: distance integer, dimension(:,:), allocatable :: distance_reverse logical, dimension(:,:), allocatable :: visited real(kind=wp), dimension(:), allocatable :: x path cooidinates real(kind=wp), dimension(:), allocatable :: y path cooidinates integer, dimension(2) :: Sij i,j of the S char in array Functions pure function pipe_info (p) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: p Return Value character(len=2) Subroutines recursive subroutine move (i, j, direction, distance, save_path) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: direction integer, intent(inout), dimension(:,:) :: distance logical, intent(in) :: save_path to save the path coordinates Source Code program problem_10 use iso_fortran_env , ip => int64 , wp => real64 use aoc_utilities implicit none integer :: i , j , nrows , ncols , imove , l , m logical , dimension (:,:), allocatable :: icounts character ( len = 1 ), dimension (:,:), allocatable :: array integer , dimension (:,:), allocatable :: distance , distance_reverse logical , dimension (:,:), allocatable :: visited real ( wp ), dimension (:), allocatable :: x , y !! path cooidinates integer , dimension ( 2 ) :: Sij !! i,j of the S char in array call clk % tic () array = read_file_to_char_array ( 'inputs/day10.txt' , '.' ) ! pad with . to simplify edge logic nrows = size ( array , 1 ) ncols = size ( array , 2 ) allocate ( distance ( nrows , ncols )); distance = - 1 allocate ( distance_reverse ( nrows , ncols )); distance_reverse = - 1 allocate ( visited ( nrows , ncols )) ! start at the S coordinate: Sij = findloc ( array , 'S' ) x = [ Sij ( 1 )] ! to store the path for part b y = [ Sij ( 2 )] ! traverse the maze: visited = . false .; visited ( Sij ( 1 ), Sij ( 2 )) = . true .; distance ( Sij ( 1 ), Sij ( 2 )) = 0 do imove = 1 , 4 call move ( Sij ( 1 ), Sij ( 2 ), imove , distance , . true .) end do ! traverse the maze again in reverse: visited = . false .; visited ( Sij ( 1 ), Sij ( 2 )) = . true .; distance_reverse ( Sij ( 1 ), Sij ( 2 )) = 0 do imove = 4 , 1 , - 1 call move ( Sij ( 1 ), Sij ( 2 ), imove , distance_reverse , . false .) end do ! where they match is the distance furthest away from the start write ( * , * ) '10a: ' , pack ( distance , mask = ( distance == distance_reverse . and . distance > 0 )) ! for part b, use locpt to test all the points ! allow openmp to be used here to do each row in parallel allocate ( icounts ( nrows , ncols )); icounts = . false . !$OMP PARALLEL DO SHARED(icounts,x,y) PRIVATE(i,j,l,m) do i = 2 , nrows - 1 ! we can skip the padding do j = 2 , ncols - 1 if ( any ( i == x . and . j == y )) cycle ! skip if on path call locpt ( real ( i , wp ), real ( j , wp ), x , y , size ( x ), l , m ) if ( l == 1 ) icounts ( i , j ) = . true . ! if (i,j) is inside the polygonal path end do end do !$OMP END PARALLEL DO write ( * , * ) '10b: ' , count ( icounts ) call clk % toc ( '10' ) contains recursive subroutine move ( i , j , direction , distance , save_path ) integer , intent ( in ) :: i , j , direction integer , dimension (:,:), intent ( inout ) :: distance logical , intent ( in ) :: save_path !! to save the path coordinates integer :: inew , jnew , imove logical :: valid_move select case ( direction ) case ( 1 ); inew = i - 1 ; jnew = j ! north case ( 2 ); inew = i + 1 ; jnew = j ! south case ( 3 ); inew = i ; jnew = j + 1 ! east case ( 4 ); inew = i ; jnew = j - 1 ! west end select if ( visited ( inew , jnew ) . or . array ( inew , jnew ) == '.' ) return ! can we move in this direction? valid_move = . false . associate ( current_pipe => array ( i , j ), & current_distance => distance ( i , j ), & move_to => array ( inew , jnew ) ) select case ( current_pipe ) case ( 'S' ) ! don't know what the first pip is, so have to try them all select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '|' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south end select case ( '-' ) select case ( direction ) case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'L' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select case ( 'J' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '7' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'F' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select end select if ( valid_move ) then distance ( inew , jnew ) = current_distance + 1 visited ( inew , jnew ) = . true . do imove = 1 , 4 call move ( inew , jnew , imove , distance , save_path ) end do if ( save_path ) then x = [ x , real ( inew , wp )] ! save cordinates of point on the path y = [ y , real ( jnew , wp )] end if end if end associate end subroutine move pure character ( len = 2 ) function pipe_info ( p ) character ( len = 1 ), intent ( in ) :: p select case ( p ) case ( '|' ); pipe_info = 'NS' ! | is a vertical pipe connecting north and south. case ( '-' ); pipe_info = 'EW' ! - is a horizontal pipe connecting east and west. case ( 'L' ); pipe_info = 'NE' ! L is a 90-degree bend connecting north and east. case ( 'J' ); pipe_info = 'NW' ! J is a 90-degree bend connecting north and west. case ( '7' ); pipe_info = 'SW' ! 7 is a 90-degree bend connecting south and west. case ( 'F' ); pipe_info = 'SE' ! F is a 90-degree bend connecting south and east. end select end function pipe_info end program problem_10","tags":"","loc":"program/problem_10.html"},{"title":"problem_6 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_6~~UsesGraph program~problem_6 problem_6 iso_fortran_env iso_fortran_env program~problem_6->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_6->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_6~~CallsGraph program~problem_6 problem_6 proc~clock_end aoc_utilities::clock%clock_end program~problem_6->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_6->proc~clock_start proc~go problem_6::go program~problem_6->proc~go Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer(kind=ip), parameter,               dimension(*) :: time_a = [60, 94, 78, 82] integer(kind=ip), parameter,               dimension(*) :: distance_a = [475, 2138, 1015, 1650] integer(kind=ip), parameter,               dimension(*) :: time_b = [60947882_ip] integer(kind=ip), parameter,               dimension(*) :: distance_b = [475213810151650_ip] Functions function go (time, distance) result(iproduct) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: time integer(kind=ip), intent(in), dimension(:) :: distance Return Value integer(kind=ip) Source Code program problem_6 use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none ! just copy and paste the inputs here: ! a integer ( ip ), dimension ( * ), parameter :: time_a = [ 60 , 94 , 78 , 82 ] integer ( ip ), dimension ( * ), parameter :: distance_a = [ 475 , 2138 , 1015 , 1650 ] ! b integer ( ip ), dimension ( * ), parameter :: time_b = [ 60947882_ip ] integer ( ip ), dimension ( * ), parameter :: distance_b = [ 475213810151650_ip ] call clk % tic () print * , '6a: ways to win:' , go ( time_a , distance_a ) print * , '6b: ways to win:' , go ( time_b , distance_b ) call clk % toc ( '6' ) contains function go ( time , distance ) result ( iproduct ) integer ( ip ), dimension (:), intent ( in ) :: time integer ( ip ), dimension (:), intent ( in ) :: distance integer ( ip ) :: iproduct integer ( ip ) :: i , ihold , iways , idistance iproduct = 1 do i = 1 , size ( time ) iways = 0 do ihold = 1 , time ( i ) ! time to hold the button idistance = ihold * ( time ( i ) - ihold ) if ( idistance > distance ( i )) iways = iways + 1 end do iproduct = iproduct * iways end do end function go end program problem_6","tags":"","loc":"program/problem_6.html"},{"title":"problem_11 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_11~~UsesGraph program~problem_11 problem_11 iso_fortran_env iso_fortran_env program~problem_11->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_11->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_11~~CallsGraph program~problem_11 problem_11 proc~clock_end aoc_utilities::clock%clock_end program~problem_11->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_11->proc~clock_start proc~go~2 problem_11::go program~problem_11->proc~go~2 proc~dist problem_11::dist proc~go~2->proc~dist proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~go~2->proc~read_file_to_char_array proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Functions function go (expansion_factor) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: expansion_factor Return Value integer(kind=ip) pure function dist (x1, y1, x2, y2) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: x1 integer(kind=ip), intent(in) :: y1 integer(kind=ip), intent(in) :: x2 integer(kind=ip), intent(in) :: y2 Return Value integer Source Code program problem_11 use iso_fortran_env , ip => int64 , wp => real64 use aoc_utilities implicit none call clk % tic () write ( * , * ) '11a: ' , go ( 2_ip ) write ( * , * ) '11b: ' , go ( 1000000_ip ) call clk % toc ( '11' ) contains integer ( ip ) function go ( expansion_factor ) integer ( ip ), intent ( in ) :: expansion_factor integer :: i , j , nrows , ncols , n_galaxies , n , k character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:,:), allocatable :: idists integer ( ip ), dimension (:), allocatable :: igal , jgal integer ( ip ), dimension (:,:), allocatable :: ix , iy ! array = read_file_to_char_array('inputs/day11_test.txt') array = read_file_to_char_array ( 'inputs/day11.txt' ) nrows = size ( array , 1 ); ncols = size ( array , 2 ) n_galaxies = count ( array == '#' ) ! track the real indices after expansion ix = transpose ( spread ([( i , i = 1 , ncols )], 1 , nrows )) ! row indices iy = spread ([( i , i = 1 , nrows )], 1 , ncols ) ! col indices igal = pack ( ix , array == '#' ) ! indices of galaxies jgal = pack ( iy , array == '#' ) ! expand the array, keeping track of the new row indices do i = 1 , nrows ! add rows if necessary if ( all ( array ( i ,:) == '.' )) ix ( i :,:) = ix ( i :,:) + expansion_factor - 1 ! new row end do do j = 1 , ncols ! add cols if necessary if ( all ( array (:, j ) == '.' )) iy (:, j :) = iy (:, j :) + expansion_factor - 1 ! new column end do ! now compute all the distances: allocate ( idists ( n_galaxies , n_galaxies )); idists = 0 do i = 1 , n_galaxies do j = 1 , n_galaxies if ( j <= i ) cycle ! only need the lower diagonal idists ( i , j ) = dist ( ix ( igal ( i ), jgal ( i )), iy ( igal ( i ), jgal ( i )),& ix ( igal ( j ), jgal ( j )), iy ( igal ( j ), jgal ( j ))) end do end do go = sum ( idists ) end function go pure integer function dist ( x1 , y1 , x2 , y2 ) ! Manhattan distance integer ( ip ), intent ( in ) :: x1 , y1 , x2 , y2 dist = abs ( x1 - x2 ) + abs ( y1 - y2 ) end function dist end program problem_11","tags":"","loc":"program/problem_11.html"},{"title":"problem_2 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_2~~UsesGraph program~problem_2 problem_2 iso_fortran_env iso_fortran_env program~problem_2->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_2->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_2~~CallsGraph program~problem_2 problem_2 interface~split aoc_utilities::split program~problem_2->interface~split proc~clock_end aoc_utilities::clock%clock_end program~problem_2->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_2->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_2->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_2->proc~read_line proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit logical :: status_ok logical :: game_possible character(len=:), allocatable :: line character(len=:), allocatable :: color integer :: n_lines integer :: id integer :: j integer :: k integer :: ipossible integer :: inum integer :: min_red integer :: min_green integer :: min_blue integer :: power type( string ), dimension(:), allocatable :: vals type( string ), dimension(:), allocatable :: trys type( string ), dimension(:), allocatable :: cubes type( string ), dimension(:), allocatable :: num_color integer, parameter :: n_red = 12 integer, parameter :: n_green = 13 integer, parameter :: n_blue = 14 Source Code program problem_2 use iso_fortran_env use aoc_utilities implicit none integer :: iunit logical :: status_ok , game_possible character ( len = :), allocatable :: line , color integer :: n_lines , id , j , k , ipossible , inum , min_red , min_green , min_blue , power type ( string ), dimension (:), allocatable :: vals , trys , cubes , num_color integer , parameter :: n_red = 12 integer , parameter :: n_green = 13 integer , parameter :: n_blue = 14 call clk % tic () !example: Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green open ( newunit = iunit , file = 'inputs/day2.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) ! will parse the line with successive splits ipossible = 0 power = 0 main : do id = 1 , n_lines game_possible = . true . min_red = 0 ; min_green = 0 ; min_blue = 0 line = read_line ( iunit , status_ok ) vals = split ( line , ': ' ) trys = split ( vals ( 2 ), '; ' ) do j = 1 , size ( trys ) cubes = split ( trys ( j ), ', ' ) do k = 1 , size ( cubes ) num_color = split ( cubes ( k ), ' ' ) inum = int ( num_color ( 1 )% str ) color = num_color ( 2 )% str select case ( color ) case ( 'red' ) if ( inum > n_red ) game_possible = . false . if ( inum > min_red ) min_red = inum case ( 'green' ) if ( inum > n_green ) game_possible = . false . if ( inum > min_green ) min_green = inum case ( 'blue' ) if ( inum > n_blue ) game_possible = . false . if ( inum > min_blue ) min_blue = inum end select end do end do power = power + ( min_red * min_green * min_blue ) if ( game_possible ) ipossible = ipossible + id end do main write ( * , * ) '2a: result   :' , ipossible write ( * , * ) '2b: power sum:' , power close ( iunit ) call clk % toc ( '2' ) end program problem_2","tags":"","loc":"program/problem_2.html"},{"title":"problem_5 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_5~~UsesGraph program~problem_5 problem_5 iso_fortran_env iso_fortran_env program~problem_5->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_5->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_5~~CallsGraph program~problem_5 problem_5 interface~startswith aoc_utilities::startswith program~problem_5->interface~startswith proc~clock_end aoc_utilities::clock%clock_end program~problem_5->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_5->proc~clock_start proc~in_seed_list problem_5::in_seed_list program~problem_5->proc~in_seed_list proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_5->proc~number_of_lines_in_file proc~parse_ints64 aoc_utilities::parse_ints64 program~problem_5->proc~parse_ints64 proc~populate problem_5::populate program~problem_5->proc~populate proc~read_line aoc_utilities::read_line program~problem_5->proc~read_line proc~traverse problem_5::traverse program~problem_5->proc~traverse proc~startswith_cc aoc_utilities::startswith_cc interface~startswith->proc~startswith_cc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~map problem_5::map proc~traverse->proc~map proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: iunit integer :: n_lines character(len=:), allocatable :: line type( string ), dimension(:), allocatable :: vals integer(kind=ip), dimension(:), allocatable :: seeds_list integer(kind=ip) :: ilocation_min integer(kind=ip) :: ilocation integer(kind=ip) :: iseed integer(kind=ip), dimension(:), allocatable :: ilocation_min_parallel integer, parameter :: NSTAGES = 7 type( mapping ), dimension(NSTAGES) :: mappings integer :: parsing_state Derived Types type :: mapping Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(:), allocatable :: dest_start integer(kind=ip), public, dimension(:), allocatable :: dest_end integer(kind=ip), public, dimension(:), allocatable :: src_start integer(kind=ip), public, dimension(:), allocatable :: src_end Functions function in_seed_list (iseed) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: iseed Return Value logical pure function map (ival, m, reverse) result(idest) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: ival type( mapping ), intent(in) :: m logical, intent(in) :: reverse Return Value integer(kind=ip) pure function traverse (iseed, reverse) result(ilocation) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: iseed logical, intent(in) :: reverse if reverse, then ilocation -> iseed Return Value integer(kind=ip) Subroutines subroutine populate (nums, m) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(3) :: nums type( mapping ), intent(inout) :: m Source Code program problem_5 use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none integer :: i , iunit , n_lines character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals integer ( ip ), dimension (:), allocatable :: seeds_list integer ( ip ) :: ilocation_min , ilocation , iseed integer ( ip ), dimension (:), allocatable :: ilocation_min_parallel type :: mapping ! save the source and destination start and end values integer ( ip ), dimension (:), allocatable :: dest_start , dest_end , src_start , src_end end type mapping integer , parameter :: NSTAGES = 7 type ( mapping ), dimension ( NSTAGES ) :: mappings ! seed_to_soil, soil_to_fertilizer, fertilizer_to_water, water_to_light, ! light_to_temperature, temperature_to_humidity, humidity_to_location integer :: parsing_state ! index in mappings (1 to NSTAGES) call clk % tic () do i = 1 , NSTAGES allocate ( mappings ( i )% dest_start ( 0 ), mappings ( i )% dest_end ( 0 ),& mappings ( i )% src_start ( 0 ), mappings ( i )% src_end ( 0 )) end do ! open(newunit=iunit, file='inputs/day5_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day5.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) parsing_state = 0 do i = 1 , n_lines line = read_line ( iunit ) if ( line == '' ) cycle ! blank line if ( startswith ( line , 'seeds:' )) then ; seeds_list = parse_ints64 ( line ( 7 :)) else if ( index ( line , 'map:' ) > 0 ) then ; parsing_state = parsing_state + 1 ! one of the 7 stages else ! parse the numbers for the given state: call populate ( parse_ints64 ( line ), mappings ( parsing_state )) end if end do close ( iunit ) ! ------------ part 1 ----------------- ilocation_min = huge ( 1 ) do i = 1 , size ( seeds_list ) ilocation = traverse ( seeds_list ( i ),. false .) if ( ilocation < ilocation_min ) ilocation_min = ilocation end do print * , '5a: ' , ilocation_min ! ------------ part 2 ----------------- !  so it doesn't run in the CI !! if (. false .) then ! brute force, openMP version. just run the part a algorithm for all the seeds. ! takes a minute or so on my computer. allocate ( ilocation_min_parallel ( size ( seeds_list ) / 2 )) ilocation_min_parallel = huge ( 1 ) !$OMP PARALLEL DO SHARED(ilocation_min_parallel) PRIVATE(i,iseed,ilocation) do i = 1 , size ( seeds_list ), 2 do iseed = seeds_list ( i ), seeds_list ( i ) + seeds_list ( i + 1 ) - 1 ilocation = traverse ( iseed , . false .) if ( ilocation < ilocation_min_parallel (( i + 1 ) / 2 )) ilocation_min_parallel (( i + 1 ) / 2 ) = ilocation end do end do !$OMP END PARALLEL DO print * , '5b: ' , minval ( ilocation_min_parallel ) end if ! ------------ part 2 ----------------- ! Alternate version, go backwards from the location to the seed ! and see if it is contained in the seed set. ! this one is pretty fast (< 1 sec) do ilocation = minval ( mappings ( 7 )% dest_start ), maxval ( mappings ( 7 )% dest_end ) ! up to the max ilocation value iseed = traverse ( ilocation , reverse = . true .) ! from ilocation to iseed if ( in_seed_list ( iseed )) exit ! found the min end do print * , '5b: ' , ilocation call clk % toc ( '5' ) contains logical function in_seed_list ( iseed ) ! for part b, is the seed in the initial list integer ( ip ), intent ( in ) :: iseed integer :: i do i = 1 , size ( seeds_list ), 2 if ( iseed >= seeds_list ( i ) . and . iseed <= seeds_list ( i ) + seeds_list ( i + 1 ) - 1 ) then in_seed_list = . true . return end if end do in_seed_list = . false . end function in_seed_list subroutine populate ( nums , m ) integer ( ip ), dimension ( 3 ), intent ( in ) :: nums ! the three numbers from the line: ! [dest range start, src range start, range length type ( mapping ), intent ( inout ) :: m ! structure to add this data to associate ( dest => nums ( 1 ), source => nums ( 2 ), range => nums ( 3 ) ) m % dest_start = [ m % dest_start , dest ] m % dest_end = [ m % dest_end , dest + range - 1 ] m % src_start = [ m % src_start , source ] m % src_end = [ m % src_end , source + range - 1 ] end associate end subroutine populate pure function map ( ival , m , reverse ) result ( idest ) integer ( ip ), intent ( in ) :: ival type ( mapping ), intent ( in ) :: m logical , intent ( in ) :: reverse ! if reversed, go from: dest -> src integer ( ip ) :: idest integer :: i if ( reverse ) then do i = 1 , size ( m % src_start ) ! locate ival (dest) in the dest start:end range if ( ival >= m % dest_start ( i ) . and . ival <= m % dest_end ( i )) then ! found it, map to dest idest = m % src_start ( i ) + ( ival - m % dest_start ( i )) ! this is the resultant isource return end if end do else do i = 1 , size ( m % src_start ) ! locate ival (source) in the source start:end range if ( ival >= m % src_start ( i ) . and . ival <= m % src_end ( i )) then ! found it, map to dest idest = m % dest_start ( i ) + ( ival - m % src_start ( i )) return end if end do end if idest = ival ! if not found in any of the sets end function map pure function traverse ( iseed , reverse ) result ( ilocation ) integer ( ip ), intent ( in ) :: iseed logical , intent ( in ) :: reverse !! if reverse, then ilocation -> iseed integer ( ip ) :: ilocation integer :: i ilocation = iseed ! initialize if ( reverse ) then do i = NSTAGES , 1 , - 1 ilocation = map ( ilocation , mappings ( i ), reverse ) ! this is really iseed end do else do i = 1 , NSTAGES ilocation = map ( ilocation , mappings ( i ), reverse ) end do end if end function traverse end program problem_5","tags":"","loc":"program/problem_5.html"},{"title":"problem_4 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_4~~UsesGraph program~problem_4 problem_4 iso_fortran_env iso_fortran_env program~problem_4->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_4->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_4~~CallsGraph program~problem_4 problem_4 interface~split aoc_utilities::split program~problem_4->interface~split proc~clock_end aoc_utilities::clock%clock_end program~problem_4->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_4->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_4->proc~number_of_lines_in_file proc~parse_ints aoc_utilities::parse_ints program~problem_4->proc~parse_ints proc~read_line aoc_utilities::read_line program~problem_4->proc~read_line proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit integer :: n_lines integer :: i integer :: points integer :: j integer :: iwin type( string ), dimension(:), allocatable :: vals type( string ), dimension(:), allocatable :: vals2 integer, dimension(:), allocatable :: iwinning integer, dimension(:), allocatable :: ihave integer, dimension(:), allocatable :: n_matches character(len=:), allocatable :: line integer, dimension(:,:), allocatable :: card_matrix Source Code program problem_4 use iso_fortran_env use aoc_utilities implicit none integer :: iunit , n_lines , i , points , j , iwin type ( string ), dimension (:), allocatable :: vals , vals2 integer , dimension (:), allocatable :: iwinning , ihave , n_matches character ( len = :), allocatable :: line integer , dimension (:,:), allocatable :: card_matrix call clk % tic () ! open(newunit=iunit, file='inputs/day4_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day4.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( n_matches ( n_lines )) ! for part 2 allocate ( card_matrix ( 0 : n_lines , n_lines )) ! for part 2 ! Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53 points = 0 do i = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ': ' ) vals2 = split ( vals ( 2 ), ' | ' ) iwinning = parse_ints ( vals2 ( 1 )% str ) ! winning list ihave = parse_ints ( vals2 ( 2 )% str ) ! ones you have ! count the number of ones you have in the winning set: iwin = 0 do j = 1 , size ( ihave ) iwin = iwin + count ( ihave ( j ) == iwinning ) end do n_matches ( i ) = iwin points = points + 2 ** ( iwin - 1 ) end do close ( iunit ) write ( * , * ) '4a : points : ' , points card_matrix = 0 card_matrix ( 0 ,:) = 1 ! start with one card each do i = 1 , n_lines associate ( n => n_matches ( i )) if ( n > 0 ) card_matrix ( i , i + 1 : i + n ) = sum ( card_matrix (:, i )) end associate end do write ( * , * ) '4b : scratchcards :' , sum ( card_matrix ) call clk % toc ( '4' ) end program problem_4","tags":"","loc":"program/problem_4.html"},{"title":"problem_1 – AoC-2023","text":"Uses aoc_utilities iso_fortran_env program~~problem_1~~UsesGraph program~problem_1 problem_1 iso_fortran_env iso_fortran_env program~problem_1->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_1->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_1~~CallsGraph program~problem_1 problem_1 proc~clock_end aoc_utilities::clock%clock_end program~problem_1->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_1->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_1->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_1->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit logical :: status_ok character(len=:), allocatable :: line integer :: n_lines integer :: i integer :: j integer :: k integer :: n integer :: isum integer :: ifirst integer :: ilast integer :: idxfirst integer :: idxlast character(len=*), parameter,               dimension(9) :: ichars = ['one&nbsp;&nbsp;', 'two&nbsp;&nbsp;', 'three', 'four ', 'five ', 'six&nbsp;&nbsp;', 'seven', 'eight', 'nine '] Source Code program problem_1 use iso_fortran_env use aoc_utilities implicit none integer :: iunit logical :: status_ok character ( len = :), allocatable :: line integer :: n_lines integer :: i , j , k , n , isum , ifirst , ilast , idxfirst , idxlast character ( len =* ), dimension ( 9 ), parameter :: ichars = [ & 'one  ' , & 'two  ' , & 'three' , & 'four ' , & 'five ' , & 'six  ' , & 'seven' , & 'eight' , & 'nine ' ] call clk % tic () isum = 0 open ( newunit = iunit , file = 'inputs/day1.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) do i = 1 , n_lines ! remove all the chars before the first and after the last number line = read_line ( iunit , status_ok ) n = len ( line ) do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) exit ! done line ( j : j ) = ' ' end do do j = n , 1 , - 1 if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) exit ! done line ( j : j ) = ' ' end do line = trim ( adjustl ( line )) n = len ( line ) isum = isum + 10 * int ( line ( 1 : 1 )) + int ( line ( n : n )) end do write ( * , * ) '1a: sum:' , isum close ( iunit ) ! -------- part 2 ----------- open ( newunit = iunit , file = 'inputs/day1.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do i = 1 , n_lines line = read_line ( iunit , status_ok ) n = len ( line ) ! keep track of the index of the first and last number (digit or string) ifirst = huge ( 1 ) idxfirst = huge ( 1 ) do j = 1 , size ( ichars ) k = min ( index ( line , trim ( ichars ( j ))), index ( line , trim ( ichars ( j )), back = . true .) ) ! accounts for duplicates if ( k > 0 . and . k <= idxfirst ) then ifirst = j idxfirst = k end if end do do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) then if ( j <= idxfirst ) then ifirst = int ( line ( j : j )) idxfirst = j end if end if end do ilast = 0 idxlast = 0 do j = 1 , size ( ichars ) k = max ( index ( line , trim ( ichars ( j ))), index ( line , trim ( ichars ( j )), back = . true .) ) ! accounts for duplicates if ( k > 0 . and . k >= idxlast ) then ilast = j idxlast = k end if end do do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) then if ( j >= idxlast ) then ilast = int ( line ( j : j )) idxlast = j end if end if end do isum = isum + 10 * ifirst + ilast end do write ( * , * ) '1b: sum:' , isum call clk % toc ( '1' ) end program problem_1","tags":"","loc":"program/problem_1.html"},{"title":"problem_07.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_07.f90~~EfferentGraph sourcefile~problem_07.f90 problem_07.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_07.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_7 use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none integer :: i , iunit , n_lines , icase character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals logical :: done type :: hand character ( len = 1 ), dimension ( 5 ) :: cards !! the cards in a hand integer ( ip ) :: bid = 0 ! the bit for the hand integer :: type = 0 ! the hand type end type hand type ( hand ), dimension (:), allocatable :: hands !! array of hands character ( len = 1 ), dimension ( 2 ), parameter :: cases = [ 'a' , 'b' ] character ( len = 1 ), dimension ( * ), parameter :: cards = [ 'A' , 'K' , 'Q' , 'J' , 'T' , & '9' , '8' , '7' , '6' , '5' , & '4' , '3' , '2' ] character ( len = 1 ), dimension ( * ), parameter :: cards_with_joker = [ 'A' , 'K' , 'Q' , 'T' , & '9' , '8' , '7' , '6' , '5' , & '4' , '3' , '2' , 'J' ] integer , parameter :: FIVE_OF_A_KIND = 1 ! the hand types integer , parameter :: FOUR_OF_A_KIND = 2 integer , parameter :: FULL_HOUSE = 3 integer , parameter :: THREE_OF_A_KIND = 4 integer , parameter :: TWO_PAIR = 5 integer , parameter :: ONE_PAIR = 6 integer , parameter :: HIGH_CARD = 7 call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day7_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day7.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( hands ( n_lines )) do i = 1 , n_lines line = read_line ( iunit ); vals = split ( line , ' ' ) hands ( i )% cards = str_to_array ( vals ( 1 )% str ) hands ( i )% bid = int ( vals ( 2 )) end do close ( iunit ) do icase = 1 , 2 ! first time normally, second time processing the jokers ! sort the list from worst to best to determinte the rank of each hand hands % type = 0 ! reinitialize since they need to be recomputed do ! bubble sort ! done = . true . do i = 1 , n_lines - 1 if ( beats ( hands ( i ), hands ( i + 1 ), icase == 2 )) then call swap_hands ( hands ( i ), hands ( i + 1 )); done = . false . end if end do if ( done ) exit end do write ( * , * ) '7' // cases ( icase ) // ':' , sum ( hands % bid * [( i , i = 1 , n_lines )]) end do call clk % toc ( '7' ) contains integer function hand_type ( me , with_jokers ) !! returns the type of hand class ( hand ), intent ( in ) :: me logical , intent ( in ) :: with_jokers !! if considering jokers integer , dimension ( 5 ) :: i integer , dimension (:), allocatable :: u integer :: n_jokers , n_unique character ( len = 1 ), dimension ( 5 ) :: h h = me % cards i = ichar ( h ) ! convert to code u = unique ( i ) ! unique elements n_unique = size ( u ) if ( with_jokers . and . any ( h == 'J' )) then ! have to pick best hand for all jokers ! just do it by inspection n_jokers = count ( h == 'J' ) select case ( n_jokers ) case ( 5 ) hand_type = FIVE_OF_A_KIND !jjjjj case ( 4 ) hand_type = FIVE_OF_A_KIND !jjjja case ( 3 ) ! can always turn to 4 or 5 of a kind if ( n_unique == 2 ) then !jjjaa hand_type = FIVE_OF_A_KIND else ! jjjab hand_type = FOUR_OF_A_KIND end if case ( 2 ) if ( n_unique == 2 ) then !jjaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then !jjaab hand_type = FOUR_OF_A_KIND else !jjabc hand_type = THREE_OF_A_KIND end if case ( 1 ) if ( n_unique == 2 ) then !jaaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then if ( any ([ count ( i == u ( 1 )) == 3 , & count ( i == u ( 2 )) == 3 , & count ( i == u ( 3 )) == 3 ]) ) then !jaaab hand_type = FOUR_OF_A_KIND elseif ( ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 ) . or . & ( count ( i == u ( 2 )) == 2 . and . count ( i == u ( 2 )) == 2 ) ) then !jaabb hand_type = FULL_HOUSE end if else if ( n_unique == 4 ) then !jaabc hand_type = THREE_OF_A_KIND else if ( n_unique == 5 ) then !jabcd hand_type = ONE_PAIR end if end select else !Every hand is exactly one type. From strongest to weakest, they are: select case ( n_unique ) case ( 1 ) ! aaaaa hand_type = FIVE_OF_A_KIND case ( 2 ) ! aaaab, aaabb if (( count ( i == u ( 1 )) == 4 . and . count ( i == u ( 2 )) == 1 ) . or . & ( count ( i == u ( 1 )) == 1 . and . count ( i == u ( 2 )) == 4 ) ) then hand_type = FOUR_OF_A_KIND else if (( count ( i == u ( 1 )) == 3 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 3 ) ) then hand_type = FULL_HOUSE end if case ( 3 ) ! aaabc, aabcc if ( any ([ count ( i == u ( 1 )) == 3 , count ( i == u ( 2 )) == 3 , count ( i == u ( 3 )) == 3 ]) ) then hand_type = THREE_OF_A_KIND else if ( any ([ count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 , & count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 , & count ( i == u ( 2 )) == 2 . and . count ( i == u ( 3 )) == 2 ]) ) then hand_type = TWO_PAIR end if case ( 4 ) !aabcd hand_type = ONE_PAIR case ( 5 ) !abcde hand_type = HIGH_CARD ! High card, where all cards' labels are distinct: 23456 end select end if end function hand_type logical function beats ( hand1 , hand2 , with_jokers ) !! return true if hand1 beats hand2 (has a higher score) class ( hand ), intent ( inout ) :: hand1 , hand2 logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i associate ( h1 => hand1 % cards , h2 => hand2 % cards ) ! recompute type if it hasn't already been computed if ( hand1 % type == 0 ) hand1 % type = hand_type ( hand1 , with_jokers ) if ( hand2 % type == 0 ) hand2 % type = hand_type ( hand2 , with_jokers ) if ( hand1 % type == hand2 % type ) then ! lower index is stronger do i = 1 , 5 if ( h1 ( i ) /= h2 ( i )) then beats = index_in_cards ( h1 ( i ), with_jokers ) < & index_in_cards ( h2 ( i ), with_jokers ) ! lower is stronger return end if end do else ! one hand beat the other beats = hand1 % type < hand2 % type ! lower score is better (1-7) end if end associate end function beats integer function index_in_cards ( c , with_jokers ) character ( len = 1 ), intent ( in ) :: c logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i do i = 1 , size ( cards_with_joker ) if ( with_jokers ) then if ( c == cards_with_joker ( i )) then index_in_cards = i return end if else if ( c == cards ( i )) then index_in_cards = i return end if end if end do error stop 'card not found' end function index_in_cards pure elemental subroutine swap_hands ( i1 , i2 ) !! swap function for hand type type ( hand ), intent ( inout ) :: i1 type ( hand ), intent ( inout ) :: i2 type ( hand ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_hands end program problem_7","tags":"","loc":"sourcefile/problem_07.f90.html"},{"title":"problem_03.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_03.f90~~EfferentGraph sourcefile~problem_03.f90 problem_03.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_03.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_3 use iso_fortran_env use aoc_utilities implicit none integer :: n_lines , i , j , n_cols , jstart , jend logical :: adjacent , tmp integer ( int64 ) :: isum character ( len = 1 ), dimension (:,:), allocatable :: array integer ( int64 ), dimension (:), allocatable :: ivals call clk % tic () ! read file: ! pad around with blanks to simplify logic below array = read_file_to_char_array ( 'inputs/day3.txt' , border = '.' ) n_lines = size ( array , 1 ) n_cols = size ( array , 2 ) !----------------- part 1 ----------------- isum = 0 do i = 1 , n_lines ! is this character adjacent to a symbol? jend = 0 do j = 1 , n_cols if ( is_not_number ( array ( i , j ))) cycle if ( j <= jend ) cycle ! skip the cols that we already have jend = 0 adjacent = is_symbol ( array ( i - 1 , j ) ) . or . & is_symbol ( array ( i - 1 , j - 1 )) . or . & is_symbol ( array ( i - 1 , j + 1 )) . or . & is_symbol ( array ( i , j - 1 ) ) . or . & is_symbol ( array ( i , j + 1 ) ) . or . & is_symbol ( array ( i + 1 , j ) ) . or . & is_symbol ( array ( i + 1 , j - 1 )) . or . & is_symbol ( array ( i + 1 , j + 1 )) if ( adjacent ) isum = isum + get_number ( i , j ) ! note: this sets jend end do end do write ( * , * ) '3a: sum :' , isum !----------------- part 2 ----------------- ! now look for '*' and find adjacent numbers .... isum = 0 do i = 1 , n_lines do j = 1 , n_cols if ( array ( i , j ) == '*' ) then ! look for 2 adjacent numbers. if ( allocated ( ivals )) deallocate ( ivals ); allocate ( ivals ( 0 )) ! above tmp = check ( i - 1 , j ) ! if only one on top if (. not . tmp ) then tmp = check ( i - 1 , j - 1 ) tmp = check ( i - 1 , j + 1 ) end if tmp = check ( i , j - 1 ) ! left and right tmp = check ( i , j + 1 ) ! below tmp = check ( i + 1 , j ) ! if only one below if (. not . tmp ) then tmp = check ( i + 1 , j - 1 ) tmp = check ( i + 1 , j + 1 ) end if if ( size ( ivals ) == 2 ) isum = isum + product ( ivals ) ! sum gear ratio end if end do end do write ( * , * ) '3b: result :' , isum call clk % toc ( '3' ) contains logical function check ( i , j ) !! if the char is part of a number, then get it and append to ivals integer , intent ( in ) :: i , j check = is_number ( array ( i , j )) if ( check ) ivals = [ ivals , get_number ( i , j )] end function check logical function is_symbol ( c ) character ( len = 1 ), intent ( in ) :: c is_symbol = is_not_number ( c ) . and . c /= '.' end function is_symbol integer ( int64 ) function get_number ( i , j ) !! get the full number contining the character at i,j integer , intent ( in ) :: i , j jstart = j jend = j do if ( array ( i , jstart - 1 ) == '.' . or . is_symbol ( array ( i , jstart - 1 ))) exit jstart = jstart - 1 end do do if ( array ( i , jend + 1 ) == '.' . or . is_symbol ( array ( i , jend + 1 ))) exit jend = jend + 1 end do get_number = int ( array ( i , jstart : jend )) end function get_number end program problem_3","tags":"","loc":"sourcefile/problem_03.f90.html"},{"title":"problem_08.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_08.f90~~EfferentGraph sourcefile~problem_08.f90 problem_08.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_08.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_8 use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none integer :: iunit , n_lines character ( len = :), allocatable :: line , instructions type ( string ), dimension (:), allocatable :: vals integer ( ip ) :: i , j , idx , idx_zzz , imoves , ias , izs integer ( ip ), dimension (:), allocatable :: instructions_ints integer ( ip ), dimension (:), allocatable :: idx_vec , idx_zzz_vec integer ( ip ), dimension (:), allocatable :: imoves_vec type :: node character ( len = 3 ) :: name = '' character ( len = 3 ), dimension ( 2 ) :: lr integer , dimension ( 2 ) :: lr_idx ! the indices in the nodes array of the l,r nodes end type node type ( node ), dimension (:), allocatable :: nodes call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day8_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day8.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( nodes ( n_lines - 2 )) instructions = read_line ( iunit ) allocate ( instructions_ints ( len ( instructions ))) do i = 1 , len ( instructions ) select case ( instructions ( i : i )) ! make an int array for easier access case ( 'L' ); instructions_ints ( i ) = 1 case ( 'R' ); instructions_ints ( i ) = 2 end select end do do i = 0 , n_lines - 1 line = read_line ( iunit ) if ( line == '' ) cycle read ( line , \"(A3,1X,1X,1X,1X,A3,1X,1X,A3,1X)\" ) nodes ( i )% name , nodes ( i )% lr ( 1 ), nodes ( i )% lr ( 2 ) end do close ( iunit ) ! compute all the lr indices: do i = 1 , size ( nodes ) nodes ( i )% lr_idx ( 1 ) = find_node ( nodes ( i )% lr ( 1 )) nodes ( i )% lr_idx ( 2 ) = find_node ( nodes ( i )% lr ( 2 )) end do !******************************************** imoves = moves ( find_node ( 'AAA' ), find_node ( 'ZZZ' )) write ( * , * ) '8a : number of moves:' , imoves !******************************************** ! get indices of the ones that end in A and Z: allocate ( idx_vec ( 0 ), idx_zzz_vec ( 0 )) do i = 1 , size ( nodes ) if ( nodes ( i )% name ( 3 : 3 ) == 'A' ) idx_vec = [ idx_vec , i ] if ( nodes ( i )% name ( 3 : 3 ) == 'Z' ) idx_zzz_vec = [ idx_zzz_vec , i ] end do if ( size ( idx_vec ) /= size ( idx_zzz_vec )) error stop 'error: they need to be the same size?' allocate ( imoves_vec ( size ( idx_vec ))) ! for EACH start, find the number of moves that it takes to get to ONE of the ends. do i = 1 , size ( idx_vec ) imoves_vec ( i ) = moves_any_z ( idx_vec ( i ), idx_zzz_vec ) end do ! don't know why this works ¯\\_(ツ)_/¯ ! I think it's a feature of the specific data given ! (it's a repeating cycle once it gets to the end) write ( * , * ) '8b : number of moves: ' , lcm ( lcm ( lcm ( lcm ( lcm ( imoves_vec ( 1 ),& imoves_vec ( 2 )),& imoves_vec ( 3 )),& imoves_vec ( 4 )),& imoves_vec ( 5 )),& imoves_vec ( 6 )) ! ! ! ! brute force. run all the moves in parallel until they are all done. ! ! ! i = 0 ! imoves = 0 ! do !     if (all_in_set(idx_vec, idx_zzz_vec)) exit !     imoves = imoves + 1 ! another move !     i = i + 1 !     if (i>len(instructions)) i = 1 !     do concurrent (j = 1 : size(idx_vec)) !         idx_vec(j) = nodes(idx_vec(j))%lr_idx(instructions_ints(i)) !     end do ! end do ! write(*,*) '8b : number of moves:', imoves call clk % toc ( '8' ) contains pure function moves ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart , iend !! indices for start and end nodes integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( idx == iend ) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves pure function moves_any_z ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart !! indices for start and end nodes integer ( ip ), dimension (:), intent ( in ) :: iend integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( any ( idx == iend )) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves_any_z pure logical function all_in_set ( ivals , iset ) !! returns true if all the elements of ivals are in the set iset integer ( ip ), dimension (:), intent ( in ) :: ivals , iset integer :: i all_in_set = . true . do i = 1 , size ( ivals ) if (. not . any ( ivals ( i ) == iset )) then all_in_set = . false . exit end if end do end function all_in_set pure integer ( ip ) function find_node ( name ) character ( len =* ), intent ( in ) :: name integer ( ip ) :: i do i = 1 , size ( nodes ) if ( name == nodes ( i )% name ) then find_node = i return end if end do error stop 'could not find node' end function find_node end program problem_8","tags":"","loc":"sourcefile/problem_08.f90.html"},{"title":"problem_09.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_09.f90~~EfferentGraph sourcefile~problem_09.f90 problem_09.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_09.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_9 use iso_fortran_env , ip => int64 ! use long ints use aoc_utilities implicit none integer :: i , iunit , n_lines integer ( ip ) :: isum call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day9_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day9.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = sum ([( extrapolate ( parse ( read_line ( iunit ))), i = 1 , n_lines )]) close ( iunit ) write ( * , * ) '9a: sum: ' , isum open ( newunit = iunit , file = 'inputs/day9.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = sum ([( extrapolate ( reverse ( parse ( read_line ( iunit )))), i = 1 , n_lines )]) close ( iunit ) write ( * , * ) '9b: sum: ' , isum call clk % toc ( '9' ) contains pure function extrapolate ( ivals ) result ( iextrap ) !! extrapolate the next value in the sequence using !! a difference table. Straightfoward implemention: !! create the full table, and then evaluate it. integer ( ip ), dimension (:), intent ( in ) :: ivals integer ( ip ) :: iextrap integer :: i , n type ( int64_vec ), dimension (:), allocatable :: diff_table !! difference table (vector of vectors) ! create the difference table: diff_table = [ int64_vec ( ivals )]; n = 1 do n = n + 1 diff_table = [ diff_table , int64_vec ( diff ( diff_table ( n - 1 )% vals ))] ! next line is diff of previous line if ( all ( diff_table ( n )% vals == 0 )) exit end do ! extrapolate iextrap = 0 do i = n - 1 , 1 , - 1 associate ( ilast => diff_table ( i )% vals ( size ( diff_table ( i )% vals )) ) iextrap = iextrap + ilast end associate end do end function extrapolate end program problem_9","tags":"","loc":"sourcefile/problem_09.f90.html"},{"title":"problem_10.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_10.f90~~EfferentGraph sourcefile~problem_10.f90 problem_10.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_10.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_10 use iso_fortran_env , ip => int64 , wp => real64 use aoc_utilities implicit none integer :: i , j , nrows , ncols , imove , l , m logical , dimension (:,:), allocatable :: icounts character ( len = 1 ), dimension (:,:), allocatable :: array integer , dimension (:,:), allocatable :: distance , distance_reverse logical , dimension (:,:), allocatable :: visited real ( wp ), dimension (:), allocatable :: x , y !! path cooidinates integer , dimension ( 2 ) :: Sij !! i,j of the S char in array call clk % tic () array = read_file_to_char_array ( 'inputs/day10.txt' , '.' ) ! pad with . to simplify edge logic nrows = size ( array , 1 ) ncols = size ( array , 2 ) allocate ( distance ( nrows , ncols )); distance = - 1 allocate ( distance_reverse ( nrows , ncols )); distance_reverse = - 1 allocate ( visited ( nrows , ncols )) ! start at the S coordinate: Sij = findloc ( array , 'S' ) x = [ Sij ( 1 )] ! to store the path for part b y = [ Sij ( 2 )] ! traverse the maze: visited = . false .; visited ( Sij ( 1 ), Sij ( 2 )) = . true .; distance ( Sij ( 1 ), Sij ( 2 )) = 0 do imove = 1 , 4 call move ( Sij ( 1 ), Sij ( 2 ), imove , distance , . true .) end do ! traverse the maze again in reverse: visited = . false .; visited ( Sij ( 1 ), Sij ( 2 )) = . true .; distance_reverse ( Sij ( 1 ), Sij ( 2 )) = 0 do imove = 4 , 1 , - 1 call move ( Sij ( 1 ), Sij ( 2 ), imove , distance_reverse , . false .) end do ! where they match is the distance furthest away from the start write ( * , * ) '10a: ' , pack ( distance , mask = ( distance == distance_reverse . and . distance > 0 )) ! for part b, use locpt to test all the points ! allow openmp to be used here to do each row in parallel allocate ( icounts ( nrows , ncols )); icounts = . false . !$OMP PARALLEL DO SHARED(icounts,x,y) PRIVATE(i,j,l,m) do i = 2 , nrows - 1 ! we can skip the padding do j = 2 , ncols - 1 if ( any ( i == x . and . j == y )) cycle ! skip if on path call locpt ( real ( i , wp ), real ( j , wp ), x , y , size ( x ), l , m ) if ( l == 1 ) icounts ( i , j ) = . true . ! if (i,j) is inside the polygonal path end do end do !$OMP END PARALLEL DO write ( * , * ) '10b: ' , count ( icounts ) call clk % toc ( '10' ) contains recursive subroutine move ( i , j , direction , distance , save_path ) integer , intent ( in ) :: i , j , direction integer , dimension (:,:), intent ( inout ) :: distance logical , intent ( in ) :: save_path !! to save the path coordinates integer :: inew , jnew , imove logical :: valid_move select case ( direction ) case ( 1 ); inew = i - 1 ; jnew = j ! north case ( 2 ); inew = i + 1 ; jnew = j ! south case ( 3 ); inew = i ; jnew = j + 1 ! east case ( 4 ); inew = i ; jnew = j - 1 ! west end select if ( visited ( inew , jnew ) . or . array ( inew , jnew ) == '.' ) return ! can we move in this direction? valid_move = . false . associate ( current_pipe => array ( i , j ), & current_distance => distance ( i , j ), & move_to => array ( inew , jnew ) ) select case ( current_pipe ) case ( 'S' ) ! don't know what the first pip is, so have to try them all select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '|' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south end select case ( '-' ) select case ( direction ) case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'L' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select case ( 'J' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '7' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'F' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select end select if ( valid_move ) then distance ( inew , jnew ) = current_distance + 1 visited ( inew , jnew ) = . true . do imove = 1 , 4 call move ( inew , jnew , imove , distance , save_path ) end do if ( save_path ) then x = [ x , real ( inew , wp )] ! save cordinates of point on the path y = [ y , real ( jnew , wp )] end if end if end associate end subroutine move pure character ( len = 2 ) function pipe_info ( p ) character ( len = 1 ), intent ( in ) :: p select case ( p ) case ( '|' ); pipe_info = 'NS' ! | is a vertical pipe connecting north and south. case ( '-' ); pipe_info = 'EW' ! - is a horizontal pipe connecting east and west. case ( 'L' ); pipe_info = 'NE' ! L is a 90-degree bend connecting north and east. case ( 'J' ); pipe_info = 'NW' ! J is a 90-degree bend connecting north and west. case ( '7' ); pipe_info = 'SW' ! 7 is a 90-degree bend connecting south and west. case ( 'F' ); pipe_info = 'SE' ! F is a 90-degree bend connecting south and east. end select end function pipe_info end program problem_10","tags":"","loc":"sourcefile/problem_10.f90.html"},{"title":"problem_06.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_06.f90~~EfferentGraph sourcefile~problem_06.f90 problem_06.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_06.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_6 use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none ! just copy and paste the inputs here: ! a integer ( ip ), dimension ( * ), parameter :: time_a = [ 60 , 94 , 78 , 82 ] integer ( ip ), dimension ( * ), parameter :: distance_a = [ 475 , 2138 , 1015 , 1650 ] ! b integer ( ip ), dimension ( * ), parameter :: time_b = [ 60947882_ip ] integer ( ip ), dimension ( * ), parameter :: distance_b = [ 475213810151650_ip ] call clk % tic () print * , '6a: ways to win:' , go ( time_a , distance_a ) print * , '6b: ways to win:' , go ( time_b , distance_b ) call clk % toc ( '6' ) contains function go ( time , distance ) result ( iproduct ) integer ( ip ), dimension (:), intent ( in ) :: time integer ( ip ), dimension (:), intent ( in ) :: distance integer ( ip ) :: iproduct integer ( ip ) :: i , ihold , iways , idistance iproduct = 1 do i = 1 , size ( time ) iways = 0 do ihold = 1 , time ( i ) ! time to hold the button idistance = ihold * ( time ( i ) - ihold ) if ( idistance > distance ( i )) iways = iways + 1 end do iproduct = iproduct * iways end do end function go end program problem_6","tags":"","loc":"sourcefile/problem_06.f90.html"},{"title":"problem_11.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_11.f90~~EfferentGraph sourcefile~problem_11.f90 problem_11.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_11.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_11 use iso_fortran_env , ip => int64 , wp => real64 use aoc_utilities implicit none call clk % tic () write ( * , * ) '11a: ' , go ( 2_ip ) write ( * , * ) '11b: ' , go ( 1000000_ip ) call clk % toc ( '11' ) contains integer ( ip ) function go ( expansion_factor ) integer ( ip ), intent ( in ) :: expansion_factor integer :: i , j , nrows , ncols , n_galaxies , n , k character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:,:), allocatable :: idists integer ( ip ), dimension (:), allocatable :: igal , jgal integer ( ip ), dimension (:,:), allocatable :: ix , iy ! array = read_file_to_char_array('inputs/day11_test.txt') array = read_file_to_char_array ( 'inputs/day11.txt' ) nrows = size ( array , 1 ); ncols = size ( array , 2 ) n_galaxies = count ( array == '#' ) ! track the real indices after expansion ix = transpose ( spread ([( i , i = 1 , ncols )], 1 , nrows )) ! row indices iy = spread ([( i , i = 1 , nrows )], 1 , ncols ) ! col indices igal = pack ( ix , array == '#' ) ! indices of galaxies jgal = pack ( iy , array == '#' ) ! expand the array, keeping track of the new row indices do i = 1 , nrows ! add rows if necessary if ( all ( array ( i ,:) == '.' )) ix ( i :,:) = ix ( i :,:) + expansion_factor - 1 ! new row end do do j = 1 , ncols ! add cols if necessary if ( all ( array (:, j ) == '.' )) iy (:, j :) = iy (:, j :) + expansion_factor - 1 ! new column end do ! now compute all the distances: allocate ( idists ( n_galaxies , n_galaxies )); idists = 0 do i = 1 , n_galaxies do j = 1 , n_galaxies if ( j <= i ) cycle ! only need the lower diagonal idists ( i , j ) = dist ( ix ( igal ( i ), jgal ( i )), iy ( igal ( i ), jgal ( i )),& ix ( igal ( j ), jgal ( j )), iy ( igal ( j ), jgal ( j ))) end do end do go = sum ( idists ) end function go pure integer function dist ( x1 , y1 , x2 , y2 ) ! Manhattan distance integer ( ip ), intent ( in ) :: x1 , y1 , x2 , y2 dist = abs ( x1 - x2 ) + abs ( y1 - y2 ) end function dist end program problem_11","tags":"","loc":"sourcefile/problem_11.f90.html"},{"title":"problem_02.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_02.f90~~EfferentGraph sourcefile~problem_02.f90 problem_02.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_02.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_2 use iso_fortran_env use aoc_utilities implicit none integer :: iunit logical :: status_ok , game_possible character ( len = :), allocatable :: line , color integer :: n_lines , id , j , k , ipossible , inum , min_red , min_green , min_blue , power type ( string ), dimension (:), allocatable :: vals , trys , cubes , num_color integer , parameter :: n_red = 12 integer , parameter :: n_green = 13 integer , parameter :: n_blue = 14 call clk % tic () !example: Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green open ( newunit = iunit , file = 'inputs/day2.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) ! will parse the line with successive splits ipossible = 0 power = 0 main : do id = 1 , n_lines game_possible = . true . min_red = 0 ; min_green = 0 ; min_blue = 0 line = read_line ( iunit , status_ok ) vals = split ( line , ': ' ) trys = split ( vals ( 2 ), '; ' ) do j = 1 , size ( trys ) cubes = split ( trys ( j ), ', ' ) do k = 1 , size ( cubes ) num_color = split ( cubes ( k ), ' ' ) inum = int ( num_color ( 1 )% str ) color = num_color ( 2 )% str select case ( color ) case ( 'red' ) if ( inum > n_red ) game_possible = . false . if ( inum > min_red ) min_red = inum case ( 'green' ) if ( inum > n_green ) game_possible = . false . if ( inum > min_green ) min_green = inum case ( 'blue' ) if ( inum > n_blue ) game_possible = . false . if ( inum > min_blue ) min_blue = inum end select end do end do power = power + ( min_red * min_green * min_blue ) if ( game_possible ) ipossible = ipossible + id end do main write ( * , * ) '2a: result   :' , ipossible write ( * , * ) '2b: power sum:' , power close ( iunit ) call clk % toc ( '2' ) end program problem_2","tags":"","loc":"sourcefile/problem_02.f90.html"},{"title":"problem_05.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_05.f90~~EfferentGraph sourcefile~problem_05.f90 problem_05.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_05.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_5 use iso_fortran_env , only : ip => int64 ! use long ints use aoc_utilities implicit none integer :: i , iunit , n_lines character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals integer ( ip ), dimension (:), allocatable :: seeds_list integer ( ip ) :: ilocation_min , ilocation , iseed integer ( ip ), dimension (:), allocatable :: ilocation_min_parallel type :: mapping ! save the source and destination start and end values integer ( ip ), dimension (:), allocatable :: dest_start , dest_end , src_start , src_end end type mapping integer , parameter :: NSTAGES = 7 type ( mapping ), dimension ( NSTAGES ) :: mappings ! seed_to_soil, soil_to_fertilizer, fertilizer_to_water, water_to_light, ! light_to_temperature, temperature_to_humidity, humidity_to_location integer :: parsing_state ! index in mappings (1 to NSTAGES) call clk % tic () do i = 1 , NSTAGES allocate ( mappings ( i )% dest_start ( 0 ), mappings ( i )% dest_end ( 0 ),& mappings ( i )% src_start ( 0 ), mappings ( i )% src_end ( 0 )) end do ! open(newunit=iunit, file='inputs/day5_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day5.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) parsing_state = 0 do i = 1 , n_lines line = read_line ( iunit ) if ( line == '' ) cycle ! blank line if ( startswith ( line , 'seeds:' )) then ; seeds_list = parse_ints64 ( line ( 7 :)) else if ( index ( line , 'map:' ) > 0 ) then ; parsing_state = parsing_state + 1 ! one of the 7 stages else ! parse the numbers for the given state: call populate ( parse_ints64 ( line ), mappings ( parsing_state )) end if end do close ( iunit ) ! ------------ part 1 ----------------- ilocation_min = huge ( 1 ) do i = 1 , size ( seeds_list ) ilocation = traverse ( seeds_list ( i ),. false .) if ( ilocation < ilocation_min ) ilocation_min = ilocation end do print * , '5a: ' , ilocation_min ! ------------ part 2 ----------------- !  so it doesn't run in the CI !! if (. false .) then ! brute force, openMP version. just run the part a algorithm for all the seeds. ! takes a minute or so on my computer. allocate ( ilocation_min_parallel ( size ( seeds_list ) / 2 )) ilocation_min_parallel = huge ( 1 ) !$OMP PARALLEL DO SHARED(ilocation_min_parallel) PRIVATE(i,iseed,ilocation) do i = 1 , size ( seeds_list ), 2 do iseed = seeds_list ( i ), seeds_list ( i ) + seeds_list ( i + 1 ) - 1 ilocation = traverse ( iseed , . false .) if ( ilocation < ilocation_min_parallel (( i + 1 ) / 2 )) ilocation_min_parallel (( i + 1 ) / 2 ) = ilocation end do end do !$OMP END PARALLEL DO print * , '5b: ' , minval ( ilocation_min_parallel ) end if ! ------------ part 2 ----------------- ! Alternate version, go backwards from the location to the seed ! and see if it is contained in the seed set. ! this one is pretty fast (< 1 sec) do ilocation = minval ( mappings ( 7 )% dest_start ), maxval ( mappings ( 7 )% dest_end ) ! up to the max ilocation value iseed = traverse ( ilocation , reverse = . true .) ! from ilocation to iseed if ( in_seed_list ( iseed )) exit ! found the min end do print * , '5b: ' , ilocation call clk % toc ( '5' ) contains logical function in_seed_list ( iseed ) ! for part b, is the seed in the initial list integer ( ip ), intent ( in ) :: iseed integer :: i do i = 1 , size ( seeds_list ), 2 if ( iseed >= seeds_list ( i ) . and . iseed <= seeds_list ( i ) + seeds_list ( i + 1 ) - 1 ) then in_seed_list = . true . return end if end do in_seed_list = . false . end function in_seed_list subroutine populate ( nums , m ) integer ( ip ), dimension ( 3 ), intent ( in ) :: nums ! the three numbers from the line: ! [dest range start, src range start, range length type ( mapping ), intent ( inout ) :: m ! structure to add this data to associate ( dest => nums ( 1 ), source => nums ( 2 ), range => nums ( 3 ) ) m % dest_start = [ m % dest_start , dest ] m % dest_end = [ m % dest_end , dest + range - 1 ] m % src_start = [ m % src_start , source ] m % src_end = [ m % src_end , source + range - 1 ] end associate end subroutine populate pure function map ( ival , m , reverse ) result ( idest ) integer ( ip ), intent ( in ) :: ival type ( mapping ), intent ( in ) :: m logical , intent ( in ) :: reverse ! if reversed, go from: dest -> src integer ( ip ) :: idest integer :: i if ( reverse ) then do i = 1 , size ( m % src_start ) ! locate ival (dest) in the dest start:end range if ( ival >= m % dest_start ( i ) . and . ival <= m % dest_end ( i )) then ! found it, map to dest idest = m % src_start ( i ) + ( ival - m % dest_start ( i )) ! this is the resultant isource return end if end do else do i = 1 , size ( m % src_start ) ! locate ival (source) in the source start:end range if ( ival >= m % src_start ( i ) . and . ival <= m % src_end ( i )) then ! found it, map to dest idest = m % dest_start ( i ) + ( ival - m % src_start ( i )) return end if end do end if idest = ival ! if not found in any of the sets end function map pure function traverse ( iseed , reverse ) result ( ilocation ) integer ( ip ), intent ( in ) :: iseed logical , intent ( in ) :: reverse !! if reverse, then ilocation -> iseed integer ( ip ) :: ilocation integer :: i ilocation = iseed ! initialize if ( reverse ) then do i = NSTAGES , 1 , - 1 ilocation = map ( ilocation , mappings ( i ), reverse ) ! this is really iseed end do else do i = 1 , NSTAGES ilocation = map ( ilocation , mappings ( i ), reverse ) end do end if end function traverse end program problem_5","tags":"","loc":"sourcefile/problem_05.f90.html"},{"title":"problem_04.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_04.f90~~EfferentGraph sourcefile~problem_04.f90 problem_04.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_04.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_4 use iso_fortran_env use aoc_utilities implicit none integer :: iunit , n_lines , i , points , j , iwin type ( string ), dimension (:), allocatable :: vals , vals2 integer , dimension (:), allocatable :: iwinning , ihave , n_matches character ( len = :), allocatable :: line integer , dimension (:,:), allocatable :: card_matrix call clk % tic () ! open(newunit=iunit, file='inputs/day4_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day4.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( n_matches ( n_lines )) ! for part 2 allocate ( card_matrix ( 0 : n_lines , n_lines )) ! for part 2 ! Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53 points = 0 do i = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ': ' ) vals2 = split ( vals ( 2 ), ' | ' ) iwinning = parse_ints ( vals2 ( 1 )% str ) ! winning list ihave = parse_ints ( vals2 ( 2 )% str ) ! ones you have ! count the number of ones you have in the winning set: iwin = 0 do j = 1 , size ( ihave ) iwin = iwin + count ( ihave ( j ) == iwinning ) end do n_matches ( i ) = iwin points = points + 2 ** ( iwin - 1 ) end do close ( iunit ) write ( * , * ) '4a : points : ' , points card_matrix = 0 card_matrix ( 0 ,:) = 1 ! start with one card each do i = 1 , n_lines associate ( n => n_matches ( i )) if ( n > 0 ) card_matrix ( i , i + 1 : i + n ) = sum ( card_matrix (:, i )) end associate end do write ( * , * ) '4b : scratchcards :' , sum ( card_matrix ) call clk % toc ( '4' ) end program problem_4","tags":"","loc":"sourcefile/problem_04.f90.html"},{"title":"problem_01.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_01.f90~~EfferentGraph sourcefile~problem_01.f90 problem_01.f90 sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_01.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_1 use iso_fortran_env use aoc_utilities implicit none integer :: iunit logical :: status_ok character ( len = :), allocatable :: line integer :: n_lines integer :: i , j , k , n , isum , ifirst , ilast , idxfirst , idxlast character ( len =* ), dimension ( 9 ), parameter :: ichars = [ & 'one  ' , & 'two  ' , & 'three' , & 'four ' , & 'five ' , & 'six  ' , & 'seven' , & 'eight' , & 'nine ' ] call clk % tic () isum = 0 open ( newunit = iunit , file = 'inputs/day1.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) do i = 1 , n_lines ! remove all the chars before the first and after the last number line = read_line ( iunit , status_ok ) n = len ( line ) do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) exit ! done line ( j : j ) = ' ' end do do j = n , 1 , - 1 if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) exit ! done line ( j : j ) = ' ' end do line = trim ( adjustl ( line )) n = len ( line ) isum = isum + 10 * int ( line ( 1 : 1 )) + int ( line ( n : n )) end do write ( * , * ) '1a: sum:' , isum close ( iunit ) ! -------- part 2 ----------- open ( newunit = iunit , file = 'inputs/day1.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do i = 1 , n_lines line = read_line ( iunit , status_ok ) n = len ( line ) ! keep track of the index of the first and last number (digit or string) ifirst = huge ( 1 ) idxfirst = huge ( 1 ) do j = 1 , size ( ichars ) k = min ( index ( line , trim ( ichars ( j ))), index ( line , trim ( ichars ( j )), back = . true .) ) ! accounts for duplicates if ( k > 0 . and . k <= idxfirst ) then ifirst = j idxfirst = k end if end do do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) then if ( j <= idxfirst ) then ifirst = int ( line ( j : j )) idxfirst = j end if end if end do ilast = 0 idxlast = 0 do j = 1 , size ( ichars ) k = max ( index ( line , trim ( ichars ( j ))), index ( line , trim ( ichars ( j )), back = . true .) ) ! accounts for duplicates if ( k > 0 . and . k >= idxlast ) then ilast = j idxlast = k end if end do do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) then if ( j >= idxlast ) then ilast = int ( line ( j : j )) idxlast = j end if end if end do isum = isum + 10 * ifirst + ilast end do write ( * , * ) '1b: sum:' , isum call clk % toc ( '1' ) end program problem_1","tags":"","loc":"sourcefile/problem_01.f90.html"},{"title":"aoc_utilities.f90 – AoC-2023","text":"Files dependent on this one sourcefile~~aoc_utilities.f90~~AfferentGraph sourcefile~aoc_utilities.f90 aoc_utilities.f90 sourcefile~problem_01.f90 problem_01.f90 sourcefile~problem_01.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_02.f90 problem_02.f90 sourcefile~problem_02.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_03.f90 problem_03.f90 sourcefile~problem_03.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_04.f90 problem_04.f90 sourcefile~problem_04.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_05.f90 problem_05.f90 sourcefile~problem_05.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_06.f90 problem_06.f90 sourcefile~problem_06.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_07.f90 problem_07.f90 sourcefile~problem_07.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_08.f90 problem_08.f90 sourcefile~problem_08.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_09.f90 problem_09.f90 sourcefile~problem_09.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_10.f90 problem_10.f90 sourcefile~problem_10.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_11.f90 problem_11.f90 sourcefile~problem_11.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !************************************************************************************************ !> !  Helper classes and routines for Advent of Code ! !### Author !  * Jacob Williams module aoc_utilities use iso_fortran_env , wp => real64 implicit none private integer , parameter :: chunk_size = 100 !! for dynamic allocations type , public :: clock private integer ( int64 ) :: begin , end , rate contains procedure , public :: tic => clock_start procedure , public :: toc => clock_end end type clock type ( clock ), public :: clk !! a public clock to use for timing in the problems type , public :: string !! a type containing an allocatable character string. !! so we can have an array of strings of different lengths. character ( len = :), allocatable :: str contains procedure , public :: to_int => string_to_int !! convert to integer procedure , public :: to_int_64 => string_to_int_64 end type string type , public :: int64_vec !! an type that contains an allocatable int64 array. !! so we can have an array of these. integer ( int64 ), dimension (:), allocatable :: vals end type int64_vec public :: read_file_to_integer_array , & read_file_to_integer64_array , & read_file_to_char_array public :: number_of_lines_in_file public :: read_line public :: parse_ints , parse_ints64 public :: is_number , is_not_number public :: str_to_array public :: lcm public :: reverse public :: diff public :: locpt interface sort procedure :: sort_ascending , sort_ascending_64 end interface sort public :: sort interface parse procedure :: parse_nums64 end interface parse public :: parse interface split procedure :: split1 , split2 end interface split public :: split interface int procedure :: string_to_int , & char_to_int , char_to_int64 , & char_array_to_int end interface int public :: int interface unique procedure :: unique32 , unique64 end interface unique public :: unique interface startswith !! test if a string starts with a specified substring procedure :: startswith_cc , startswith_ss , startswith_sc , startswith_cs end interface startswith public :: startswith interface swap procedure :: swap32 , swap64 , swap_str end interface swap public :: swap contains !************************************************************************************************ !**************************************************************** !> !  Start the clock subroutine clock_start ( me ) class ( clock ), intent ( inout ) :: me call system_clock ( me % begin , me % rate ) end subroutine clock_start !**************************************************************** !**************************************************************** !> !  Print runtime in milliseconds form the start of the clock. subroutine clock_end ( me , case_str ) class ( clock ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: case_str !! description of the case integer :: itime !! time in integer milliseconds call system_clock ( me % end ) itime = int ( 1000 * ( me % end - me % begin ) / real ( me % rate , wp )) write ( * , '(a,I4,a)' ) trim ( case_str ) // ' runtime: ' , itime , ' ms' write ( * , '(a)' ) '---------------------------' write ( * , * ) '' end subroutine clock_end !**************************************************************** !**************************************************************** !> !  Basic string to integer routine pure function char_to_int ( str ) result ( i ) character ( len =* ), intent ( in ) :: str integer :: i read ( str , * ) i end function char_to_int !**************************************************************** !**************************************************************** !> !  Basic string to integer routine pure elemental function string_to_int ( me ) result ( i ) class ( string ), intent ( in ) :: me integer :: i i = int ( me % str ) end function string_to_int !**************************************************************** !**************************************************************** !> !  Basic string to integer routine pure elemental function string_to_int_64 ( me ) result ( i ) class ( string ), intent ( in ) :: me integer ( int64 ) :: i i = int ( me % str ) end function string_to_int_64 !**************************************************************** !**************************************************************** !> !  Basic string to integer(ip) routine. !  Hacky hack just so we can overload as int() pure function char_to_int64 ( str , kind ) result ( i ) character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: kind integer ( int64 ) :: i if ( kind /= int64 ) error stop 'error' read ( str , * ) i end function char_to_int64 !**************************************************************** !**************************************************************** !> !  Character array to integer routine pure function char_array_to_int ( str_array ) result ( i ) character ( len = 1 ), dimension (:), intent ( in ) :: str_array !! example ['1','3'] --> 13 integer :: i character ( len = :), allocatable :: str integer :: k str = '' do k = 1 , size ( str_array ) str = str // str_array ( k ) end do i = char_to_int ( str ) end function char_array_to_int !**************************************************************** !**************************************************************** !> !  Read a file into a 2d character array. function read_file_to_char_array ( filename , border ) result ( array ) character ( len =* ), intent ( in ) :: filename character ( len = 1 ), intent ( in ), optional :: border !! if true, extra border is added with this char character ( len = 1 ), dimension (:,:), allocatable :: array integer :: i , j , iunit , n_lines , n_cols character ( len = :), allocatable :: line open ( newunit = iunit , file = filename , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) line = read_line ( iunit ); n_cols = len ( line ) rewind ( iunit ) if ( present ( border )) then allocate ( array ( 0 : n_lines + 1 , 0 : n_cols + 1 )) ! padding with border array = border else allocate ( array ( n_lines , n_cols )) end if do i = 1 , n_lines line = read_line ( iunit ) do j = 1 , n_cols array ( i , j ) = line ( j : j ) end do end do close ( iunit ) end function read_file_to_char_array !**************************************************************** !**************************************************************** !> !  Read a file into an integer array (one element per line) function read_file_to_integer_array ( filename ) result ( iarray ) character ( len =* ), intent ( in ) :: filename integer , dimension (:), allocatable :: iarray integer :: i , iunit , n_lines , istat open ( newunit = iunit , file = filename , iostat = istat ) if ( istat /= 0 ) error stop ' error reading file' n_lines = number_of_lines_in_file ( iunit ) allocate ( iarray ( n_lines )) do i = 1 , n_lines read ( iunit , '(I10)' ) iarray ( i ) end do close ( iunit ) end function read_file_to_integer_array !**************************************************************** !**************************************************************** !> !  Read a file into an int64 integer array (one element per line) function read_file_to_integer64_array ( filename ) result ( iarray ) character ( len =* ), intent ( in ) :: filename integer ( int64 ), dimension (:), allocatable :: iarray integer :: i , iunit , n_lines , istat open ( newunit = iunit , file = filename , iostat = istat ) if ( istat /= 0 ) error stop ' error reading file' n_lines = number_of_lines_in_file ( iunit ) allocate ( iarray ( n_lines )) do i = 1 , n_lines read ( iunit , * ) iarray ( i ) end do close ( iunit ) end function read_file_to_integer64_array !**************************************************************** !**************************************************************** !> !  Returns the number of lines in a file (assumed to be open) function number_of_lines_in_file ( iunit ) result ( n_lines ) integer , intent ( in ) :: iunit !! the file unit number !! (assumed to be open) integer :: n_lines !! the number of lines in the file character ( len = 1 ) :: tmp integer :: istat rewind ( iunit ) n_lines = 0 do read ( iunit , fmt = '(A1)' , iostat = istat ) tmp if ( is_iostat_end ( istat )) exit n_lines = n_lines + 1 end do rewind ( iunit ) end function number_of_lines_in_file !**************************************************************** !**************************************************************** !> !  Sorts an integer array `ivec` in increasing order. !  Uses a basic recursive quicksort !  (with insertion sort for partitions with \\le 20 elements). subroutine sort_ascending ( ivec ) integer , dimension (:), intent ( inout ) :: ivec integer , parameter :: max_size_for_insertion_sort = 20 !! max size for using insertion sort. call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending !**************************************************************** !**************************************************************** !> subroutine sort_ascending_64 ( ivec ) integer ( int64 ), dimension (:), intent ( inout ) :: ivec integer ( int64 ), parameter :: max_size_for_insertion_sort = 20 !! max size for using insertion sort. call quicksort ( 1_int64 , size ( ivec , kind = int64 )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array integer ( int64 ), intent ( in ) :: ilow integer ( int64 ), intent ( in ) :: ihigh integer ( int64 ) :: ipivot !! pivot element integer ( int64 ) :: i !! counter integer ( int64 ) :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap64 ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer ( int64 ), intent ( in ) :: ilow integer ( int64 ), intent ( in ) :: ihigh integer ( int64 ), intent ( out ) :: ipivot integer ( int64 ) :: i , ip call swap64 ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap64 ( ivec ( ip ), ivec ( i )) end if end do call swap64 ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending_64 !**************************************************************** !**************************************************************** !> !  Swap two integer values. pure elemental subroutine swap32 ( i1 , i2 ) integer , intent ( inout ) :: i1 integer , intent ( inout ) :: i2 integer :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap32 !**************************************************************** !**************************************************************** !> !  Swap two integer values. pure elemental subroutine swap64 ( i1 , i2 ) integer ( int64 ), intent ( inout ) :: i1 integer ( int64 ), intent ( inout ) :: i2 integer ( int64 ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap64 !**************************************************************** !**************************************************************** !> !  Swap two character string values pure elemental subroutine swap_str ( i1 , i2 ) character ( len =* ), intent ( inout ) :: i1 character ( len =* ), intent ( inout ) :: i2 character ( len = len ( i1 )) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_str !**************************************************************** !**************************************************************** !> !  Split a `string`, given a token. pure function split2 ( s , token ) result ( vals ) implicit none type ( string ), intent ( in ) :: s character ( len =* ), intent ( in ) :: token type ( string ), dimension (:), allocatable :: vals if ( allocated ( s % str )) then vals = split1 ( s % str , token ) else error stop 'error: string not allocated' end if end function split2 !**************************************************************** !**************************************************************** !> !  Split a character string using a token. !  This routine is inspired by the Python split function. ! !### Example !````Fortran !   character(len=:),allocatable :: s !   type(string),dimension(:),allocatable :: vals !   s = '1,2,3,4,5' !   call split(s,',',vals) !```` pure function split1 ( str , token ) result ( vals ) implicit none character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ) :: token type ( string ), dimension (:), allocatable :: vals integer :: i !! counter integer :: len_str !! significant length of `str` integer :: len_token !! length of the token integer :: n_tokens !! number of tokens integer :: i1 !! index integer :: i2 !! index integer :: j !! counters integer , dimension (:), allocatable :: itokens !! start indices of the !! token locations in `str` len_token = len ( token ) ! length of the token n_tokens = 0 ! initialize the token counter j = 0 ! index to start looking for the next token ! first, count the number of times the token ! appears in the string, and get the token indices. ! ! Examples: !  ',         '    --> 1 !  '1234,67,90'    --> 5,8 !  '123,      '    --> 4 ! length of the string if ( token == ' ' ) then ! in this case, we can't ignore trailing space len_str = len ( str ) else ! safe to ignore trailing space when looking for tokens len_str = len_trim ( str ) end if j = 1 n_tokens = 0 do if ( j > len_str ) exit ! end of string, finished i = index ( str ( j :), token ) ! index of next token in remaining string if ( i <= 0 ) exit ! no more tokens found call expand_vector ( itokens , n_tokens , i + j - 1 ) ! save the token location j = j + i + ( len_token - 1 ) end do call expand_vector ( itokens , n_tokens , finished = . true .) ! resize the vector allocate ( vals ( n_tokens + 1 )) if ( n_tokens > 0 ) then len_str = len ( str ) i1 = 1 i2 = itokens ( 1 ) - 1 if ( i2 >= i1 ) then vals ( 1 )% str = str ( i1 : i2 ) else vals ( 1 )% str = '' !the first character is a token end if !      1 2 3 !    'a,b,c,d' do i = 2 , n_tokens i1 = itokens ( i - 1 ) + len_token i2 = itokens ( i ) - 1 if ( i2 >= i1 ) then vals ( i )% str = str ( i1 : i2 ) else vals ( i )% str = '' !empty element (e.g., 'abc,,def') end if end do i1 = itokens ( n_tokens ) + len_token i2 = len_str if ( itokens ( n_tokens ) + len_token <= len_str ) then vals ( n_tokens + 1 )% str = str ( i1 : i2 ) else vals ( n_tokens + 1 )% str = '' !the last character was a token end if else !no tokens present, so just return the original string: vals ( 1 )% str = str end if end function split1 !**************************************************************** !**************************************************************** !> !  Add elements to the integer vector in chunks. pure subroutine expand_vector ( vec , n , val , finished ) integer , dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) integer , dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector !**************************************************************** !**************************************************************** !> !  Reads the next line from a file. function read_line ( iunit , status_ok ) result ( line ) integer , intent ( in ) :: iunit character ( len = :), allocatable :: line logical , intent ( out ), optional :: status_ok !! true if no problems integer :: nread !! character count specifier for read statement integer :: istat !! file read io status flag character ( len = chunk_size ) :: buffer !! the file read buffer nread = 0 buffer = '' line = '' if ( present ( status_ok )) status_ok = . true . do ! read in the next block of text from the line: read ( iunit , fmt = '(A)' , advance = 'NO' , size = nread , iostat = istat ) buffer if ( IS_IOSTAT_END ( istat ) . or . IS_IOSTAT_EOR ( istat )) then ! add the last block of text before the end of record if ( nread > 0 ) line = line // buffer ( 1 : nread ) exit else if ( istat == 0 ) then ! all the characters were read line = line // buffer ! add this block of text to the string else ! some kind of error if ( present ( status_ok )) then status_ok = . false . exit else error stop 'Read error' end if end if end do end function read_line !**************************************************************** !**************************************************************** !> !  Return only the unique values from vec. function unique32 ( vec ) result ( vec_unique ) integer , dimension (:), intent ( in ) :: vec integer , dimension (:), allocatable :: vec_unique integer :: i , num logical , dimension ( size ( vec )) :: mask mask = . false . do i = 1 , size ( vec ) !count the number of occurrences of this element: num = count ( vec ( i ) == vec ) if ( num == 1 ) then !there is only one, flag it: mask ( i ) = . true . else !flag this value only if it hasn't already been flagged: if (. not . any ( vec ( i ) == vec . and . mask ) ) mask ( i ) = . true . end if end do !return only flagged elements: allocate ( vec_unique ( count ( mask )) ) vec_unique = pack ( vec , mask ) ! also sort it: call sort ( vec_unique ) end function unique32 !**************************************************************** !**************************************************************** !> !  Return only the unique values from vec. function unique64 ( vec ) result ( vec_unique ) integer ( int64 ), dimension (:), intent ( in ) :: vec integer ( int64 ), dimension (:), allocatable :: vec_unique integer ( int64 ) :: i , num logical , dimension ( size ( vec )) :: mask mask = . false . do i = 1 , size ( vec ) !count the number of occurrences of this element: num = count ( vec ( i ) == vec ) if ( num == 1 ) then !there is only one, flag it: mask ( i ) = . true . else !flag this value only if it hasn't already been flagged: if (. not . any ( vec ( i ) == vec . and . mask ) ) mask ( i ) = . true . end if end do !return only flagged elements: allocate ( vec_unique ( count ( mask )) ) vec_unique = pack ( vec , mask ) ! also sort it: call sort ( vec_unique ) end function unique64 !**************************************************************** !**************************************************************** !> !  parse positive ints from a string that also includes text function parse_ints ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer , dimension (:), allocatable :: ints ! array of integers integer :: i , j , n integer :: istart character ( len =* ), parameter :: tokens = '0123456789' n = len ( line ) istart = 0 allocate ( ints ( 0 )) do i = 1 , n if ( index ( tokens , line ( i : i )) > 0 ) then if ( istart == 0 ) istart = i else if ( istart /= 0 ) ints = [ ints , int ( line ( istart : i - 1 ))] ! get previous int istart = 0 end if end do if ( istart /= 0 ) ints = [ ints , int ( line ( istart : n ))] ! get last int end function parse_ints !**************************************************************** !**************************************************************** !> !  Parse positive ints from a string that also includes text function parse_ints64 ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer ( int64 ), dimension (:), allocatable :: ints ! array of integers integer ( int64 ) :: i , j , n integer ( int64 ) :: istart character ( len =* ), parameter :: tokens = '0123456789' n = len ( line ) istart = 0 allocate ( ints ( 0 )) do i = 1 , n if ( index ( tokens , line ( i : i )) > 0 ) then if ( istart == 0 ) istart = i else if ( istart /= 0 ) ints = [ ints , int ( line ( istart : i - 1 ), kind = int64 )] ! get previous int istart = 0 end if end do if ( istart /= 0 ) ints = [ ints , int ( line ( istart : n ), kind = int64 )] ! get last int end function parse_ints64 !**************************************************************** !**************************************************************** !> !  parse space-deliminated int64 sequence (positive or negative) function parse_nums64 ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer ( int64 ), dimension (:), allocatable :: ints ! array of integers ints = int ( split ( line , ' ' )) end function parse_nums64 !**************************************************************** !> !  starts with function for strings pure logical function startswith_cc ( str , substring ) character ( len =* ), intent ( in ) :: str , substring startswith_cc = index ( str , substring ) == 1 end function startswith_cc pure logical function startswith_ss ( str , substring ) type ( string ), intent ( in ) :: str , substring startswith_ss = startswith ( str % str , substring % str ) end function startswith_ss pure logical function startswith_sc ( str , substring ) type ( string ), intent ( in ) :: str character ( len =* ), intent ( in ) :: substring startswith_sc = startswith ( str % str , substring ) end function startswith_sc pure logical function startswith_cs ( str , substring ) character ( len =* ), intent ( in ) :: str type ( string ), intent ( in ) :: substring startswith_cs = startswith ( str , substring % str ) end function startswith_cs !**************************************************************** !**************************************************************** !> !  returns true if the character is a number from 0 to 9. logical function is_number ( c ) character ( len = 1 ), intent ( in ) :: c is_number = c >= '0' . and . c <= '9' end function is_number !**************************************************************** !**************************************************************** !> !  returns true if the character is not a number. logical function is_not_number ( c ) character ( len = 1 ), intent ( in ) :: c is_not_number = . not . is_number ( c ) end function is_not_number !**************************************************************** !**************************************************************** !> !  convert the character string to an array of characters function str_to_array ( s ) result ( a ) character ( len =* ), intent ( in ) :: s character ( len = 1 ), dimension ( len ( s )) :: a integer :: i do i = 1 , len ( s ) ! transfer a ( i ) = s ( i : i ) end do end function str_to_array !**************************************************************** !**************************************************************** !> !  LCM. based on code from NCAR Command Language pure integer ( int64 ) function lcm ( i , j ) integer ( int64 ), intent ( in ) :: i , j integer ( int64 ) :: rem , m , n m = abs ( i ) n = abs ( j ) lcm = 0 if ( m <= 0 . or . n <= 0 ) return do rem = mod ( m , n ) if ( rem <= 0 ) exit m = n n = rem end do lcm = abs ( i * j / n ) end function lcm !**************************************************************** !**************************************************************** !> !  Reverse an int64 vector pure function reverse ( ivals ) result ( ireverse ) integer ( int64 ), dimension (:), intent ( in ) :: ivals integer ( int64 ), dimension ( size ( ivals )) :: ireverse integer :: i ireverse = [( ivals ( i ), i = size ( ivals ), 1 , - 1 )] end function reverse !**************************************************************** !**************************************************************** !> !  Difference int64 vector pure function diff ( ivals ) result ( idiff ) integer ( int64 ), dimension (:), intent ( in ) :: ivals integer ( int64 ), dimension (:), allocatable :: idiff integer :: i !! counter idiff = [( ivals ( i + 1 ) - ivals ( i ), i = 1 , size ( ivals ) - 1 )] end function diff !**************************************************************** ! the following routine is from the Fortran Astrodynamics Toolkit !***************************************************************************************** !> !  given a polygonal line connecting the vertices (x(i),y(i)) !  (i = 1,...,n) taken in this order. it is assumed that the !  polygonal path is a loop, where (x(n),y(n)) = (x(1),y(1)) !  or there is an arc from (x(n),y(n)) to (x(1),y(1)). ! !  (x0,y0) is an arbitrary point and l and m are variables. !  l and m are assigned the following values: ! !     l = -1   if (x0,y0) is outside the polygonal path !     l =  0   if (x0,y0) lies on the polygonal path !     l =  1   if (x0,y0) is inside the polygonal path ! !  m = 0 if (x0,y0) is on or outside the path. if (x0,y0) !  is inside the path then m is the winding number of the !  path around the point (x0,y0). ! !# History !  * Original version from the NSWC Library !  * Modified by J. Williams : 08/04/2012 : refactored to modern Fortran pure subroutine locpt ( x0 , y0 , x , y , n , l , m ) implicit none !arguments: integer , intent ( in ) :: n real ( wp ), intent ( in ) :: x0 real ( wp ), intent ( in ) :: y0 real ( wp ), dimension ( n ), intent ( in ) :: x real ( wp ), dimension ( n ), intent ( in ) :: y integer , intent ( out ) :: l integer , intent ( out ) :: m !constants: real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) real ( wp ), parameter :: pi = atan2 ( 0.0_wp , - 1.0_wp ) real ( wp ), parameter :: pi2 = 2.0_wp * pi real ( wp ), parameter :: tol = 4.0_wp * eps * pi !local variables: integer :: i , n0 real ( wp ) :: u , v , theta1 , sum , theta , angle , thetai n0 = n if ( x ( 1 ) == x ( n ) . and . y ( 1 ) == y ( n )) n0 = n - 1 l = - 1 m = 0 u = x ( 1 ) - x0 v = y ( 1 ) - y0 if ( u == 0.0_wp . and . v == 0.0_wp ) then l = 0 !(x0, y0) is on the boundary of the path else if ( n0 >= 2 ) then theta1 = atan2 ( v , u ) sum = 0.0_wp theta = theta1 do i = 2 , n0 u = x ( i ) - x0 v = y ( i ) - y0 if ( u == 0.0_wp . and . v == 0.0_wp ) then l = 0 !(x0, y0) is on the boundary of the path exit end if thetai = atan2 ( v , u ) angle = abs ( thetai - theta ) if ( abs ( angle - pi ) < tol ) then l = 0 !(x0, y0) is on the boundary of the path exit end if if ( angle > pi ) angle = angle - pi2 if ( theta > thetai ) angle = - angle sum = sum + angle theta = thetai end do if ( l /= 0 ) then angle = abs ( theta1 - theta ) if ( abs ( angle - pi ) < tol ) then l = 0 !(x0, y0) is on the boundary of the path else if ( angle > pi ) angle = angle - pi2 if ( theta > theta1 ) angle = - angle sum = sum + angle !sum = 2*pi*m where m is the winding number m = abs ( sum ) / pi2 + 0.2_wp if ( m /= 0 ) then l = 1 if ( sum < 0.0_wp ) m = - m end if end if end if end if end if end subroutine locpt !***************************************************************************************** !************************************************************************************************ end module aoc_utilities !************************************************************************************************","tags":"","loc":"sourcefile/aoc_utilities.f90.html"}]}