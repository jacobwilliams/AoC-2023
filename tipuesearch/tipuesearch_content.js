var tipuesearch = {"pages":[{"title":" AoC-2023 ","text":"AoC-2023 Advent of Code 2023 with Modern Fortran. Compiling All the cases can be compiled and run using the Fortran Package Manager . to run individual cases: fpm run --profile release problem_01 to run them all: fpm run --profile release --all Current status Problem Stars Solution Runtime 1 ⭐⭐ problem_01.f90 12 ms 2 ⭐⭐ problem_02.f90 4 ms 3 ⭐⭐ problem_03.f90 2 ms 4 ⭐⭐ problem_04.f90 5 ms 5 ⭐⭐ problem_05.f90 622 ms 6 ⭐⭐ problem_06.f90 45 ms 7 ⭐⭐ problem_07.f90 17 ms 8 ⭐⭐ problem_08.f90 11 ms 9 ⭐⭐ problem_09.f90 23 ms 10 ⭐⭐ problem_10.f90 708 ms † 11 ⭐⭐ problem_11.f90 1 ms 12 ⭐⭐ problem_12.f90 + problem_12b.f90 754 ms + 232 ms 13 ⭐⭐ problem_13.f90 3 ms 14 ⭐⭐ problem_14.f90 257 ms 15 ⭐⭐ problem_15.f90 3 ms 16 ⭐⭐ problem_16.f90 27 ms 17 ⭐⭐ problem_17.f90 + problem_17b.f90 minutes 18 ⭐⭐ problem_18.f90 2 ms 19 ⭐⭐ problem_19.f90 + problem_19b.f90 44 ms + 47 ms 20 ☆☆ problem_20.f90 21 ⭐☆ problem_21.f90 1 ms 22 ☆☆ problem_22.f90 23 ⭐⭐ problem_23.f90 3689 ms 24 ☆☆ problem_24.f90 25 ☆☆ problem_25.f90 † With OpenMP enabled (i.e, add --flag \"-fopenmp\" to the FPM call). Previous Years AoC-2020 AoC-2021 AoC-2022 AoC-2023 ## Documentation The API documentation for the current master branch can be found here .  This is generated by processing the source files with FORD . Developer Info Jacob Williams","tags":"home","loc":"index.html"},{"title":"clock – AoC-2023 ","text":"type, public :: clock Components Type Visibility Attributes Name Initial integer(kind=ip), private :: begin integer(kind=ip), private :: end integer(kind=ip), private :: rate Type-Bound Procedures procedure, public :: tic => clock_start private  subroutine clock_start (me) Start the clock Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me procedure, public :: toc => clock_end private  subroutine clock_end (me, case_str) Print runtime in milliseconds form the start of the clock. Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me character(len=*), intent(in) :: case_str description of the case Source Code type , public :: clock private integer ( ip ) :: begin , end , rate contains procedure , public :: tic => clock_start procedure , public :: toc => clock_end end type clock","tags":"","loc":"type/clock.html"},{"title":"string – AoC-2023 ","text":"type, public :: string a type containing an allocatable character string.\nso we can have an array of strings of different lengths. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: str Type-Bound Procedures procedure, public :: to_int => string_to_int convert to integer private pure elemental function string_to_int (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer procedure, public :: to_int_64 => string_to_int_64 private pure elemental function string_to_int_64 (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer(kind=ip) Source Code type , public :: string !! a type containing an allocatable character string. !! so we can have an array of strings of different lengths. character ( len = :), allocatable :: str contains procedure , public :: to_int => string_to_int !! convert to integer procedure , public :: to_int_64 => string_to_int_64 end type string","tags":"","loc":"type/string.html"},{"title":"int64_vec – AoC-2023 ","text":"type, public :: int64_vec an type that contains an allocatable ip array.\nso we can have an array of these. Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(:), allocatable :: vals Source Code type , public :: int64_vec !! an type that contains an allocatable ip array. !! so we can have an array of these. integer ( ip ), dimension (:), allocatable :: vals end type int64_vec","tags":"","loc":"type/int64_vec.html"},{"title":"fx – AoC-2023 ","text":"type, private :: fx an [x,f(x)] cached pair. Inherited by type~~fx~2~~InheritedByGraph type~fx~2 fx type~function_cache~2 function_cache type~function_cache~2->type~fx~2 c type~numdiff_type numdiff_type type~numdiff_type->type~function_cache~2 cache Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:), allocatable :: x vector of input values real(kind=wp), private, dimension(:), allocatable :: f vector of output functions f(x) note: only the elements indicated by ifs will have valid values. The others will\nbe dummy values. integer, private, dimension(:), allocatable :: ifs elements of f present in the cache\n(this is just an array of the indices\npresent in f ) Source Code type :: fx !! an [x,f(x)] cached pair. private real ( wp ), dimension (:), allocatable :: x !! vector of input values real ( wp ), dimension (:), allocatable :: f !! vector of output functions `f(x)` !! note: only the elements indicated by `ifs` !! will have valid values. The others will !! be dummy values. integer , dimension (:), allocatable :: ifs !! elements of `f` present in the cache !! (this is just an array of the indices !! present in `f`) end type fx","tags":"","loc":"type/fx~2.html"},{"title":"function_cache – AoC-2023 ","text":"type, public :: function_cache a vector function cache. Inherits type~~function_cache~2~~InheritsGraph type~function_cache~2 function_cache type~fx~2 fx type~function_cache~2->type~fx~2 c Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~function_cache~2~~InheritedByGraph type~function_cache~2 function_cache type~numdiff_type numdiff_type type~numdiff_type->type~function_cache~2 cache Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, private :: n = 0 size of x integer, private :: m = 0 size of f type( fx ), private, dimension(:), allocatable :: c the cache of f(x) integer, private :: chunk_size = 100 for resizing vectors\nin the unique function Type-Bound Procedures procedure, public :: initialize => initialize_cache private  subroutine initialize_cache (me, isize, n, m, chunk_size) Initialize the cache. Must be called first before use. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: isize the size of the hash table integer, intent(in) :: n number of independant variables (x) integer, intent(in) :: m number of functions (f) integer, intent(in), optional :: chunk_size chunk size to speed up reallocation\nof arrays. A good value is a guess for\nthe actual number of elements of f that\nwill be saved per value of x [default is 100] procedure, public :: get => get_from_cache private  subroutine get_from_cache (me, x, ifs, i, f, xfound, ffound) Check if the x vector is in the cache, if so return f .\nNote that only some of the elements may be present, so it will return\nthe ones there are there, and indicate which ones were found. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x independant variable vector integer, intent(in), dimension(:) :: ifs elements of f needed integer, intent(out) :: i index in the hash table real(kind=wp), intent(out), dimension(:) :: f f(x) from the cache (if it was found) logical, intent(out) :: xfound if x was found in the cache logical, intent(out), dimension(size(ifs)) :: ffound which ifs were found in the cache procedure, public :: put => put_in_cache private  subroutine put_in_cache (me, i, x, f, ifs) Put a value into the cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: i index in the hash table real(kind=wp), intent(in), dimension(:) :: x independant variable vector (dimension n ) real(kind=wp), intent(in), dimension(:) :: f function vector f(x) (dimension m ) integer, intent(in), dimension(:) :: ifs elements of f to add (should all be >0, <=m ) procedure, public :: destroy => destroy_cache private  subroutine destroy_cache (me) Destroy a cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(out) :: me procedure, public :: print => print_cache private  subroutine print_cache (me, iunit) Print the contents of the cache. Used for debugging. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: iunit file unit for writing\n(assumed to be opened) Source Code type , public :: function_cache !! a vector function cache. private integer :: n = 0 !! size of `x` integer :: m = 0 !! size of `f` type ( fx ), dimension (:), allocatable :: c !! the cache of `f(x)` integer :: chunk_size = 100 !! for resizing vectors !! in the [[unique]] function contains private procedure , public :: initialize => initialize_cache procedure , public :: get => get_from_cache procedure , public :: put => put_in_cache procedure , public :: destroy => destroy_cache procedure , public :: print => print_cache end type function_cache","tags":"","loc":"type/function_cache~2.html"},{"title":"hand – AoC-2023 ","text":"type :: hand Components Type Visibility Attributes Name Initial character(len=1), public, dimension(5) :: cards the cards in a hand integer(kind=ip), public :: bid = 0 integer, public :: type = 0 Source Code type :: hand character ( len = 1 ), dimension ( 5 ) :: cards !! the cards in a hand integer ( ip ) :: bid = 0 ! the bit for the hand integer :: type = 0 ! the hand type end type hand","tags":"","loc":"type/hand.html"},{"title":"vertex – AoC-2023 ","text":"type, private :: vertex a vertex of a directed acyclic graph (DAG) Inherited by type~~vertex~~InheritedByGraph type~vertex vertex type~dag dag type~dag->type~vertex vertices Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, private, dimension(:), allocatable :: edges these are the vertices that this vertex depends on integer, private :: ivertex = 0 vertex number logical, private :: checking = .false. used for toposort logical, private :: marked = .false. used for toposort character(len=:), private, allocatable :: label used for diagraph character(len=:), private, allocatable :: attributes used for diagraph Type-Bound Procedures generic, public :: set_edges => set_edge_vector , add_edge private  subroutine set_edge_vector (me, edges) specify the edge indices for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in), dimension(:) :: edges private  subroutine add_edge (me, edge) add an edge index for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in) :: edge procedure, public :: set_edge_vector private  subroutine set_edge_vector (me, edges) specify the edge indices for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in), dimension(:) :: edges procedure, public :: add_edge private  subroutine add_edge (me, edge) add an edge index for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in) :: edge Source Code type :: vertex !! a vertex of a directed acyclic graph (DAG) private integer , dimension (:), allocatable :: edges !! these are the vertices that this vertex depends on integer :: ivertex = 0 !! vertex number logical :: checking = . false . !! used for toposort logical :: marked = . false . !! used for toposort character ( len = :), allocatable :: label !! used for diagraph character ( len = :), allocatable :: attributes !! used for diagraph contains generic :: set_edges => set_edge_vector , add_edge procedure :: set_edge_vector procedure :: add_edge end type vertex","tags":"","loc":"type/vertex.html"},{"title":"dag – AoC-2023 ","text":"type, public :: dag a directed acyclic graph (DAG) Inherits type~~dag~~InheritsGraph type~dag dag type~vertex vertex type~dag->type~vertex vertices Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, private :: n = 0 number of vertices type( vertex ), private, dimension(:), allocatable :: vertices the vertices in the DAG. Type-Bound Procedures procedure, public :: set_vertices => dag_set_vertices private  subroutine dag_set_vertices (me, nvertices) set the number of vertices in the dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: nvertices number of vertices procedure, public :: set_edges => dag_set_edges private  subroutine dag_set_edges (me, ivertex, edges) set the edges for a vertex in a dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: ivertex vertex number integer, intent(in), dimension(:) :: edges procedure, public :: set_vertex_info => dag_set_vertex_info private  subroutine dag_set_vertex_info (me, ivertex, label, attributes) set info about a vertex in a dag. Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: ivertex vertex number character(len=*), intent(in), optional :: label if a label is not set,\nthen the integer vertex\nnumber is used. character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. procedure, public :: toposort => dag_toposort private  subroutine dag_toposort (me, order, istat) Main toposort routine Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: order the toposort order integer, intent(out) :: istat Status flag: Read more… procedure, public :: generate_digraph => dag_generate_digraph private  function dag_generate_digraph (me, rankdir, dpi) result(str) Generate a Graphviz digraph structure for the DAG. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer, intent(in), optional :: dpi resolution (e.g. 300) Return Value character(len=:), allocatable procedure, public :: generate_dependency_matrix => dag_generate_dependency_matrix private  subroutine dag_generate_dependency_matrix (me, mat) Generate the dependency matrix for the DAG. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me logical, intent(out), dimension(:,:), allocatable :: mat dependency matrix procedure, public :: save_digraph => dag_save_digraph private  subroutine dag_save_digraph (me, filename, rankdir, dpi) Generate a Graphviz digraph structure for the DAG and write it to a file. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: filename file name for diagraph character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer, intent(in), optional :: dpi resolution (e.g. 300) procedure, public :: get_edges => dag_get_edges private pure function dag_get_edges (me, ivertex) result(edges) get the edges for the vertex (all the the vertices\nthat this vertex depends on). Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer, intent(in) :: ivertex Return Value integer, dimension(:), allocatable procedure, public :: get_dependencies => dag_get_dependencies private pure function dag_get_dependencies (me, ivertex) result(dep) get all the vertices that depend on this vertex. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer, intent(in) :: ivertex Return Value integer, dimension(:), allocatable the set of all vertices\nthan depend on ivertex procedure, public :: destroy => dag_destroy private  subroutine dag_destroy (me) Destroy the dag . Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me Source Code type , public :: dag !! a directed acyclic graph (DAG) private integer :: n = 0 !! number of `vertices` type ( vertex ), dimension (:), allocatable :: vertices !! the vertices in the DAG. contains procedure , public :: set_vertices => dag_set_vertices procedure , public :: set_edges => dag_set_edges procedure , public :: set_vertex_info => dag_set_vertex_info procedure , public :: toposort => dag_toposort procedure , public :: generate_digraph => dag_generate_digraph procedure , public :: generate_dependency_matrix => dag_generate_dependency_matrix procedure , public :: save_digraph => dag_save_digraph procedure , public :: get_edges => dag_get_edges procedure , public :: get_dependencies => dag_get_dependencies procedure , public :: destroy => dag_destroy end type dag","tags":"","loc":"type/dag.html"},{"title":"nlesolver_type – AoC-2023 ","text":"type, public :: nlesolver_type Nonlinear equations solver class. Components Type Visibility Attributes Name Initial integer, private :: n = 0 number of opt vars integer, private :: m = 0 number of constraints integer, private :: max_iter = 100 maximum number of iterations real(kind=wp), private :: tol = 1.0e-6_wp convergence tolerance for function values real(kind=wp), private :: alpha = 1.0_wp step length (when specified constant) real(kind=wp), private :: alpha_min = 0.1_wp minimum step length (when allowed to vary) real(kind=wp), private :: alpha_max = 1.0_wp maximum step length (when allowed to vary) real(kind=wp), private :: tolx = 1.0e-8_wp convergence tolerance for x real(kind=wp), private :: c = 0.5_wp backtracking linesearch parameter (0,1) real(kind=wp), private :: tau = 0.5_wp backtracking linesearch parameter (0,1) real(kind=wp), private :: fmin_tol = 1.0e-5_wp tolerance for \"exact\" linesearch integer, private :: n_intervals = 2 number of intervals for fixed point linesearch logical, private :: use_broyden = .false. if true, a Broyden update is used\nrather than computing the Jacobian\nat every step. The grad function is\nonly called for the initial evaluation. integer, private :: broyden_update_n = 4 if this value is >0 , the Broyden update\nis computed at most this many times before\nthe full Jacobian is recomputed. integer, private :: n_uphill_max = 5 maximum number of consecutive steps\nto allow where the value of f increases logical, private :: verbose = .false. verbose output printing integer, private :: iunit = output_unit output unit for printing (assumed to be open). character(len=:), private, allocatable :: message latest status message integer, private :: istat = -999 latest status message procedure( func_func ), private, pointer :: func => null() user-supplied routine to compute the function procedure( export_func ), private, pointer :: export_iteration => null() user-supplied routine to export iterations procedure( wait_func ), private, pointer :: user_input_check => null() user-supplied routine to enable user to stop iterations procedure( linesearch_func ), private, pointer :: linesearch => null() line search method (determined by step_mode user input in initialize ) integer, private :: sparsity_mode = 1 sparsity mode: 1 - assume dense (use dense solver) 2 - assume sparse (use LSQR sparse solver). 3 - assume sparse (use LUSOL sparse solver). integer, private :: n_nonzeros = -1 number of nonzero Jacobian elements (used for sparsity_mode > 1 ) integer, private, dimension(:), allocatable :: irow sparsity pattern nonzero elements row indices. integer, private, dimension(:), allocatable :: icol sparsity pattern nonzero elements column indices real(kind=wp), private :: atol = zero relative error in definition of A real(kind=wp), private :: btol = zero relative error in definition of b real(kind=wp), private :: conlim = zero An upper limit on cond(Abar) , the apparent\ncondition number of the matrix Abar . integer, private :: itnlim = 100 max iterations integer, private :: nout = 0 output unit for printing real(kind=wp), private :: damp = zero damp parameter for LSQR integer, private :: lusol_method = 0 procedure( grad_func ), private, pointer :: grad => null() user-supplied routine to compute the gradient of the function (dense version) procedure( grad_func_sparse ), private, pointer :: grad_sparse => null() user-supplied routine to compute the gradient of the function (sparse version) Type-Bound Procedures procedure, public :: initialize => initialize_nlesolver_variables private  subroutine initialize_nlesolver_variables (me, n, m, max_iter, tol, alpha, alpha_min, alpha_max, tolx, fmin_tol, backtrack_c, backtrack_tau, use_broyden, broyden_update_n, step_mode, func, grad, grad_sparse, export_iteration, user_input_check, verbose, iunit, n_uphill_max, n_intervals, sparsity_mode, irow, icol, atol, btol, conlim, damp, itnlim, nout, lusol_method) Constructor for the class. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me integer, intent(in) :: n number of optimization variables integer, intent(in) :: m number of constraints integer, intent(in) :: max_iter maximum number of iterations real(kind=wp), intent(in) :: tol function convergence tolerance real(kind=wp), intent(in), optional :: alpha constant step length for step_mode=1 (0,1] real(kind=wp), intent(in), optional :: alpha_min minimum step length (0,1] real(kind=wp), intent(in), optional :: alpha_max maximum step length (0,1] real(kind=wp), intent(in), optional :: tolx convergence tolerance for changes in x real(kind=wp), intent(in), optional :: fmin_tol convergence tolerance for fmin (used when step_mode=3 ) real(kind=wp), intent(in), optional :: backtrack_c backtracking linesearch parameter (0,1) real(kind=wp), intent(in), optional :: backtrack_tau backtracking linesearch parameter (0,1) logical, intent(in), optional :: use_broyden use a Broyden update (default is False) integer, intent(in), optional :: broyden_update_n For Broyden mode, update the full Jacobian\nat most every this many iterations (must be >1)\nIf <=1 then Jacobian is only computed on the\nfirst iteration. integer, intent(in), optional :: step_mode step mode: Read more… procedure( func_func ) :: func computes the function vector procedure( grad_func ), optional :: grad computes the jacobian [required for dense mode: sparsity_mode=1 ] procedure( grad_func_sparse ), optional :: grad_sparse computes the jacobian [required for sparse mode: sparsity_mode>1 ] procedure( export_func ), optional :: export_iteration function to export each iteration procedure( wait_func ), optional :: user_input_check check for user input (to stop solver if necessary) logical, intent(in), optional :: verbose for verbose status printing integer, intent(in), optional :: iunit unit for verbose printing (assumed to be open).\nby default this is output_unit . integer, intent(in), optional :: n_uphill_max maximum number of consecutive steps\nto allow where the value of f increases integer, intent(in), optional :: n_intervals number of intervals for fixed point linesearch integer, intent(in), optional :: sparsity_mode sparsity mode: Read more… integer, intent(in), optional, dimension(:) :: irow sparsity pattern nonzero elements row indices.\nmust be specified with icol and be the same length ( n_nonzeros ). integer, intent(in), optional, dimension(:) :: icol sparsity pattern nonzero elements column indices\nmust be specified with icol and be the same length ( n_nonzeros ). real(kind=wp), intent(in), optional :: atol LSQR: relative error in definition of A real(kind=wp), intent(in), optional :: btol LSQR: relative error in definition of b real(kind=wp), intent(in), optional :: conlim condition number of the matrix Abar . real(kind=wp), intent(in), optional :: damp LSQR: damp factor integer, intent(in), optional :: itnlim LSQR: max iterations integer, intent(in), optional :: nout LSQR: output unit for printing integer, intent(in), optional :: lusol_method procedure, public :: solve => nlesolver_solver private  subroutine nlesolver_solver (me, x) Main solver. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x procedure, public :: destroy => destroy_nlesolver_variables private  subroutine destroy_nlesolver_variables (me) Destructor Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(out) :: me procedure, public :: status => get_status private  subroutine get_status (me, istat, message) Return the status code and message from the nlesolver_type class. Read more… Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me integer, intent(out), optional :: istat Integer status code. character(len=:), intent(out), optional, allocatable :: message Text status message procedure, private :: set_status private  subroutine set_status (me, istat, string, i, r) Set status flag and message. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me integer, intent(in) :: istat status code character(len=*), intent(in) :: string status message integer, intent(in), optional :: i an integer value to append real(kind=wp), intent(in), optional :: r a real value to append Source Code type , public :: nlesolver_type !! Nonlinear equations solver class. private integer :: n = 0 !! number of opt vars integer :: m = 0 !! number of constraints integer :: max_iter = 100 !! maximum number of iterations real ( wp ) :: tol = 1.0e-6_wp !! convergence tolerance for function values real ( wp ) :: alpha = 1.0_wp !! step length (when specified constant) real ( wp ) :: alpha_min = 0.1_wp !! minimum step length (when allowed to vary) real ( wp ) :: alpha_max = 1.0_wp !! maximum step length (when allowed to vary) real ( wp ) :: tolx = 1.0e-8_wp !! convergence tolerance for `x` real ( wp ) :: c = 0.5_wp !! backtracking linesearch parameter (0,1) real ( wp ) :: tau = 0.5_wp !! backtracking linesearch parameter (0,1) real ( wp ) :: fmin_tol = 1.0e-5_wp !! tolerance for \"exact\" linesearch integer :: n_intervals = 2 !! number of intervals for fixed point linesearch logical :: use_broyden = . false . !! if true, a Broyden update is used !! rather than computing the Jacobian !! at every step. The `grad` function is !! only called for the initial evaluation. integer :: broyden_update_n = 4 !! if this value is `>0`, the Broyden update !! is computed at most this many times before !! the full Jacobian is recomputed. integer :: n_uphill_max = 5 !! maximum number of consecutive steps !! to allow where the value of `f` increases logical :: verbose = . false . !! verbose output printing integer :: iunit = output_unit !! output unit for printing (assumed to be open). character ( len = :), allocatable :: message !! latest status message integer :: istat = - 999 !! latest status message procedure ( func_func ), pointer :: func => null () !! user-supplied routine to compute the function procedure ( export_func ), pointer :: export_iteration => null () !! user-supplied routine to export iterations procedure ( wait_func ), pointer :: user_input_check => null () !! user-supplied routine to enable user to stop iterations procedure ( linesearch_func ), pointer :: linesearch => null () !! line search method (determined by `step_mode` user input in [[nlesolver_type:initialize]]) ! sparsity options: integer :: sparsity_mode = 1 !! sparsity mode: !! !! * 1 - assume dense (use dense solver) !! * 2 - assume sparse (use LSQR sparse solver). !! * 3 - assume sparse (use LUSOL sparse solver). integer :: n_nonzeros = - 1 !! number of nonzero Jacobian elements (used for `sparsity_mode > 1`) integer , dimension (:), allocatable :: irow !! sparsity pattern nonzero elements row indices. integer , dimension (:), allocatable :: icol !! sparsity pattern nonzero elements column indices ! LSQR parameters: real ( wp ) :: atol = zero !! relative error in definition of `A` real ( wp ) :: btol = zero !! relative error in definition of `b` real ( wp ) :: conlim = zero !! An upper limit on `cond(Abar)`, the apparent !! condition number of the matrix `Abar`. integer :: itnlim = 100 !! max iterations integer :: nout = 0 !! output unit for printing real ( wp ) :: damp = zero !! damp parameter for LSQR ! LUSOL parameters: integer :: lusol_method = 0 ! dense version: procedure ( grad_func ), pointer :: grad => null () !! user-supplied routine to compute the gradient of the function (dense version) ! sparse version: procedure ( grad_func_sparse ), pointer :: grad_sparse => null () !! user-supplied routine to compute the gradient of the function (sparse version) contains private procedure , public :: initialize => initialize_nlesolver_variables procedure , public :: solve => nlesolver_solver procedure , public :: destroy => destroy_nlesolver_variables procedure , public :: status => get_status procedure :: set_status end type nlesolver_type","tags":"","loc":"type/nlesolver_type.html"},{"title":"item – AoC-2023 ","text":"type :: item Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(NSTATE) :: state = 0 state: [i, j, direction, and # of moves] integer(kind=ip), public :: dist = huge(1) distance for this one logical, public :: visited = .false. if this one is done integer(kind=ip), public :: iprev = -1 index in the queue of the previous one Source Code type :: item integer ( ip ), dimension ( NSTATE ) :: state = 0 !! state: [i, j, direction, and # of moves] integer ( ip ) :: dist = huge ( 1 ) !! distance for this one logical :: visited = . false . !! if this one is done integer ( ip ) :: iprev = - 1 !! index in the queue of the previous one end type item","tags":"","loc":"type/item.html"},{"title":"item – AoC-2023 ","text":"type :: item Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(NSTATE) :: state = 0 state: [i, j, direction, and # of moves] integer(kind=ip), public :: dist = huge(1) distance for this one logical, public :: visited = .false. if this one is done integer(kind=ip), public :: iprev = -1 index in the queue of the previous one Source Code type :: item integer ( ip ), dimension ( NSTATE ) :: state = 0 !! state: [i, j, direction, and # of moves] integer ( ip ) :: dist = huge ( 1 ) !! distance for this one logical :: visited = . false . !! if this one is done integer ( ip ) :: iprev = - 1 !! index in the queue of the previous one end type item","tags":"","loc":"type/item~2.html"},{"title":"node_t – AoC-2023 ","text":"type :: node_t Components Type Visibility Attributes Name Initial integer, public, dimension(:), allocatable :: connections the ones connected to this one Source Code type :: node_t !character(len=3) :: name = '' integer , dimension (:), allocatable :: connections !! the ones connected to this one end type node_t","tags":"","loc":"type/node_t.html"},{"title":"interval – AoC-2023 ","text":"type :: interval Inherited by type~~interval~~InheritedByGraph type~interval interval type~part part type~part->type~interval xmas Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(2) :: v [start, end] of the interval Source Code type :: interval integer ( ip ), dimension ( 2 ) :: v !! [start, end] of the interval end type interval","tags":"","loc":"type/interval.html"},{"title":"part – AoC-2023 ","text":"type :: part Inherits type~~part~~InheritsGraph type~part part type~interval interval type~part->type~interval xmas Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( interval ), public, dimension(4) :: xmas Source Code type :: part type ( interval ), dimension ( 4 ) :: xmas ! [x,m,a,s] ranges end type part","tags":"","loc":"type/part.html"},{"title":"rule – AoC-2023 ","text":"type :: rule Inherited by type~~rule~~InheritedByGraph type~rule rule type~workflow workflow type~workflow->type~rule rules Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, public :: accept = .false. logical, public :: reject = .false. integer, public :: operator = 0 integer, public :: operator_arg = 0 integer, public :: operator_val = 0 character(len=:), public, allocatable :: goto Source Code type :: rule logical :: accept = . false . logical :: reject = . false . integer :: operator = 0 ! 1:<, 2:> integer :: operator_arg = 0 ! 1:x, 2:m, 3:a, 4:s integer :: operator_val = 0 ! value to compare to character ( len = :), allocatable :: goto ! where to next (workflow name) end type rule","tags":"","loc":"type/rule.html"},{"title":"workflow – AoC-2023 ","text":"type :: workflow Inherits type~~workflow~~InheritsGraph type~workflow workflow type~rule rule type~workflow->type~rule rules Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name type( rule ), public, dimension(:), allocatable :: rules Source Code type :: workflow character ( len = :), allocatable :: name type ( rule ), dimension (:), allocatable :: rules end type workflow","tags":"","loc":"type/workflow.html"},{"title":"diff_func – AoC-2023 ","text":"type, public :: diff_func class to define the function for diff Components Type Visibility Attributes Name Initial logical, private :: stop = .false. procedure( func ), private, pointer :: f => null() Type-Bound Procedures procedure, private :: faccur private  subroutine faccur (me, h0, h1, facc, x0, twoinf, f0, f1, ifail) This procedure attempts to estimate the level of rounding errors in\nthe calculated function values near the point x0+h0 by fitting a\nleast-squares straight-line approximation to the function at the\nsix points x0+h0-j*h1 , ( j = 0,1,3,5,7,9 ), and then setting facc to\ntwice the largest deviation of the function values from this line. hi is adjusted if necessary so that it is approximately 8 times the\nsmallest spacing at which the function values are unequal near x0+h0 . Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me real(kind=wp), intent(inout) :: h0 real(kind=wp), intent(inout) :: h1 real(kind=wp), intent(out) :: facc real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: twoinf real(kind=wp), intent(in) :: f0 real(kind=wp), intent(in) :: f1 integer, intent(out) :: ifail 0 if no error, -1 if user termination. procedure, public :: set_function private  subroutine set_function (me, f) Author Jacob Williams Date 12/27/2015 Set the function in a diff_func .\nMust be called before diff . Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me procedure( func ) :: f procedure, public :: compute_derivative => diff private  subroutine diff (me, iord, x0, xmin, xmax, eps, accr, deriv, error, ifail) the procedure diff calculates the first, second or\nthird order derivative of a function by using neville's process to\nextrapolate from a sequence of simple polynomial approximations based on\ninterpolating points distributed symmetrically about x0 (or lying only on\none side of x0 should this be necessary).  if the specified tolerance is\nnon-zero then the procedure attempts to satisfy this absolute or relative\naccuracy requirement, while if it is unsuccessful or if the tolerance is\nset to zero then the result having the minimum achievable estimated error\nis returned instead. Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me integer, intent(in) :: iord 1, 2 or 3 specifies that the first, second or third order\nderivative,respectively, is required. real(kind=wp), intent(in) :: x0 the point at which the derivative of the function is to be calculated. real(kind=wp), intent(in) :: xmin xmin , xmax restrict the interpolating points to lie in [ xmin , xmax ], which\nshould be the largest interval including x0 in which the function is\ncalculable and continuous. real(kind=wp), intent(in) :: xmax xmin , xmax restrict the interpolating points to lie in [ xmin , xmax ], which\nshould be the largest interval including x0 in which the function is\ncalculable and continuous. real(kind=wp), intent(in) :: eps denotes the tolerance, either absolute or relative. eps=0 specifies that\nthe error is to be minimised, while eps>0 or eps<0 specifies that the\nabsolute or relative error, respectively, must not exceed abs(eps) if\npossible.  the accuracy requirement should not be made stricter than\nnecessary, since the amount of computation tends to increase as\nthe magnitude of eps decreases, and is particularly high when eps=0 . real(kind=wp), intent(in) :: accr denotes that the absolute ( accr>0 ) or relative ( accr<0 ) errors in the\ncomputed values of the function are most unlikely to exceed abs(accr) , which\nshould be as small as possible.  if the user cannot estimate accr with\ncomplete confidence, then it should be set to zero. real(kind=wp), intent(out) :: deriv the calculated value of the derivative real(kind=wp), intent(out) :: error an estimated upper bound on the magnitude of the absolute error in\nthe calculated result.  it should always be examined, since in extreme case\nmay indicate that there are no correct significant digits in the value\nreturned for derivative. integer, intent(out) :: ifail will have one of the following values on exit: 0 the procedure was successful. 1 the estimated error in the result exceeds the (non-zero) requested\n     error, but the most accurate result possible has been returned. 2 input data incorrect (derivative and error will be undefined). 3 the interval [ xmin , xmax ] is too small (derivative and error will be\n     undefined). -1 stopped by the user. procedure, public :: terminate private  subroutine terminate (me) Can be called by the user in the function to terminate the computation.\nThis will set ifail=-1 . Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me Source Code type , public :: diff_func !! class to define the function for [[diff]] private logical :: stop = . false . procedure ( func ), pointer :: f => null () contains private procedure :: faccur procedure , public :: set_function procedure , public :: compute_derivative => diff procedure , public :: terminate end type diff_func","tags":"","loc":"type/diff_func.html"},{"title":"fx – AoC-2023 ","text":"type, private :: fx an [x,f(x)] cached pair.\nx is a vector and f is a vector. Inherited by type~~fx~~InheritedByGraph type~fx fx type~function_cache function_cache type~function_cache->type~fx c Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer(kind=ip), private, dimension(:), allocatable :: x vector of input values integer(kind=ip), private, dimension(:), allocatable :: f output functions Source Code type :: fx !! an [x,f(x)] cached pair. !! x is a vector and f is a vector. private integer ( ip ), dimension (:), allocatable :: x !! vector of input values integer ( ip ), dimension (:), allocatable :: f !! output functions end type fx","tags":"","loc":"type/fx.html"},{"title":"function_cache – AoC-2023 ","text":"type, public :: function_cache a vector function cache. Inherits type~~function_cache~~InheritsGraph type~function_cache function_cache type~fx fx type~function_cache->type~fx c Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( fx ), private, dimension(:), allocatable :: c the cache of f(x) integer, private :: chunk_size = 100 for resizing vectors\nin the unique function Type-Bound Procedures procedure, public :: initialize => initialize_cache private  subroutine initialize_cache (me, isize, chunk_size) Initialize the cache. Must be called first before use. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: isize the size of the hash table integer, intent(in), optional :: chunk_size chunk size to speed up reallocation\nof arrays. A good value is a guess for\nthe actual number of elements of f that\nwill be saved per value of x [default is 100] procedure, public :: get => get_from_cache private  subroutine get_from_cache (me, x, i, f, found) Check if the x vector is in the cache, if so return f .\nNote that only some of the elements may be present, so it will return\nthe ones there are there, and indicate which ones were found. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer(kind=ip), intent(in), dimension(:) :: x independant variable vector integer(kind=ip), intent(out) :: i index in the hash table integer(kind=ip), intent(out), dimension(:), allocatable :: f f(x) from the cache (if it was found) logical, intent(out) :: found if x was found in the cache procedure, public :: put => put_in_cache private  subroutine put_in_cache (me, i, x, f) Put a value into the cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer(kind=ip), intent(in) :: i index in the hash table integer(kind=ip), intent(in), dimension(:) :: x independant variable vector integer(kind=ip), intent(in), dimension(:) :: f function procedure, public :: destroy => destroy_cache private  subroutine destroy_cache (me) Destroy a cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(out) :: me Source Code type , public :: function_cache !! a vector function cache. private type ( fx ), dimension (:), allocatable :: c !! the cache of `f(x)` integer :: chunk_size = 100 !! for resizing vectors !! in the [[unique]] function contains private procedure , public :: initialize => initialize_cache procedure , public :: get => get_from_cache procedure , public :: put => put_in_cache procedure , public :: destroy => destroy_cache end type function_cache","tags":"","loc":"type/function_cache.html"},{"title":"lens – AoC-2023 ","text":"type, public :: lens Inherited by type~~lens~~InheritedByGraph type~lens lens type~box box type~box->type~lens lenses Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: label integer(kind=ip), public :: focal_length = 0 Source Code type :: lens character ( len = :), allocatable :: label integer ( ip ) :: focal_length = 0 end type lens","tags":"","loc":"type/lens.html"},{"title":"box – AoC-2023 ","text":"type, public :: box Inherits type~~box~~InheritsGraph type~box box type~lens lens type~box->type~lens lenses Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( lens ), public, dimension(:), allocatable :: lenses the lenses in the box Type-Bound Procedures procedure, public :: add_lens public  subroutine add_lens (me, l) Arguments Type Intent Optional Attributes Name class( box ), intent(inout) :: me type( lens ), intent(in) :: l lense to add procedure, public :: remove_lens public  subroutine remove_lens (me, label) remove the lens with the label (if present) Arguments Type Intent Optional Attributes Name class( box ), intent(inout) :: me character(len=*), intent(in) :: label Source Code type :: box type ( lens ), dimension (:), allocatable :: lenses !! the lenses in the box contains procedure :: add_lens procedure :: remove_lens end type box","tags":"","loc":"type/box.html"},{"title":"test_solver – AoC-2023 ","text":"type, private, extends( lsqr_solver ) :: test_solver Inherits type~~test_solver~~InheritsGraph type~test_solver test_solver type~lsqr_solver lsqr_solver type~test_solver->type~lsqr_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: nout = -1 output unit for printing real(kind=wp), public, dimension(lenrw) :: rw workspace array Type-Bound Procedures procedure, public :: lsqr => LSQR main solver routine private  subroutine LSQR (me, m, n, damp, wantse, u, v, w, x, se, atol, btol, conlim, itnlim, nout, istop, itn, anorm, acond, rnorm, arnorm, xnorm) LSQR finds a solution to the following problems: Read more… Arguments Type Intent Optional Attributes Name class( lsqr_solver ), intent(inout) :: me integer, intent(in) :: m the number of rows in A . integer, intent(in) :: n the number of columns in A . real(kind=wp), intent(in) :: damp The damping parameter for problem 3 above.\n(damp should be 0.0 for problems 1 and 2.)\nIf the system A*x = b is incompatible, values\nof damp in the range 0 to sqrt(relpr)*norm(A) will probably have a negligible effect.\nLarger values of damp will tend to decrease\nthe norm of x and reduce the number of\niterations required by LSQR. Read more… logical, intent(in) :: wantse A logical variable to say if the array se(*) of standard error estimates should be computed.\nIf m > n or damp > 0 ,  the system is\noverdetermined and the standard errors may be\nuseful.  (See the first LSQR reference.)\nOtherwise ( m <= n and damp = 0 ) they do not\nmean much.  Some time and storage can be saved\nby setting wantse = .false. and using any\nconvenient array for se(*) , which won't be\ntouched. real(kind=wp), intent(inout) :: u (m) The rhs vector b .  Beware that u is\nover-written by LSQR. real(kind=wp), intent(inout) :: v (n) workspace real(kind=wp), intent(inout) :: w (n) workspace real(kind=wp), intent(out) :: x (n) Returns the computed solution x . real(kind=wp), intent(out), dimension(*) :: se If wantse is true, the dimension of se must be n or more. se(*) then returns standard error\nestimates for the components of x .\nFor each i , se(i) is set to the value rnorm * sqrt( sigma(i,i) / t ) ,\nwhere sigma(i,i) is an estimate of the i-th\ndiagonal of the inverse of Abar(transpose)*Abar and:\n* t = 1      if  m <= n * t = m - n  if  m > n  and  damp = 0 * t = m      if  damp /= 0 Read more… real(kind=wp), intent(in) :: atol An estimate of the relative error in the data\ndefining the matrix A .  For example,\nif A is accurate to about 6 digits, set atol = 1.0e-6 . real(kind=wp), intent(in) :: btol An estimate of the relative error in the data\ndefining the rhs vector b .  For example,\nif b is accurate to about 6 digits, set btol = 1.0e-6 . real(kind=wp), intent(in) :: conlim An upper limit on cond(Abar) , the apparent\ncondition number of the matrix Abar .\nIterations will be terminated if a computed\nestimate of cond(Abar) exceeds conlim .\nThis is intended to prevent certain small or\nzero singular values of A or Abar from\ncoming into effect and causing unwanted growth\nin the computed solution. Read more… integer, intent(in) :: itnlim An upper limit on the number of iterations.\nSuggested value:\n* itnlim = n/2 for well-conditioned systems\n  with clustered singular values,\n* itnlim = 4*n otherwise. integer, intent(in) :: nout File number for printed output.  If nonzero,\na summary will be printed on file nout . integer, intent(out) :: istop An integer giving the reason for termination: Read more… integer, intent(out) :: itn The number of iterations performed. real(kind=wp), intent(out) :: anorm An estimate of the Frobenius norm of Abar .\nThis is the square-root of the sum of squares\nof the elements of Abar .\nIf damp is small and if the columns of A have all been scaled to have length 1.0, anorm should increase to roughly sqrt(n) .\nA radically different value for anorm may\nindicate an error in subroutine aprod (there\nmay be an inconsistency between modes 1 and 2). real(kind=wp), intent(out) :: acond An estimate of cond(Abar) , the condition\nnumber of Abar .  A very high value of acond may again indicate an error in aprod . real(kind=wp), intent(out) :: rnorm An estimate of the final value of norm(rbar) ,\nthe function being minimized (see notation\nabove).  This will be small if A*x = b has\na solution. real(kind=wp), intent(out) :: arnorm An estimate of the final value of norm( Abar(transpose)*rbar ) , the norm of\nthe residual for the usual normal equations.\nThis should be small in all cases.  (arnorm\nwill often be smaller than the true value\ncomputed from the output vector x .) real(kind=wp), intent(out) :: xnorm An estimate of the norm of the final\nsolution vector x . procedure, public :: acheck private  subroutine acheck (me, m, n, nout, eps, v, w, x, y, inform) Checks the two modes of aprod for LSQR . Read more… Arguments Type Intent Optional Attributes Name class( lsqr_solver ), intent(inout) :: me integer, intent(in) :: m No. of rows of A. integer, intent(in) :: n No. of columns of A. integer, intent(in) :: nout A file number for printed output. real(kind=wp), intent(in) :: eps The machine precision. real(kind=wp) :: v (n) real(kind=wp) :: w (m) real(kind=wp) :: x (n) real(kind=wp) :: y (m) integer, intent(out) :: inform Error indicator.\ninform = 0 if aprod seems to be\nconsistent.\ninform = 1 otherwise. procedure, public :: xcheck private  subroutine xcheck (me, m, n, nout, anorm, damp, eps, b, u, v, w, x, inform, test1, test2, test3) Tests if x solves a certain least-squares problem. Read more… Arguments Type Intent Optional Attributes Name class( lsqr_solver ), intent(inout) :: me integer, intent(in) :: m The number of rows in A. integer, intent(in) :: n The number of columns in A. integer, intent(in) :: nout A file number for printed output.\nIf nout = 0, nothing is printed. real(kind=wp), intent(in) :: anorm An estimate of norm(A) or\nnorm( A, delta*I ) if delta > 0.\nNormally this will be available\nfrom LSQR or CRAIG. real(kind=wp), intent(in) :: damp Possibly defines a damped problem. real(kind=wp), intent(in) :: eps Machine precision. real(kind=wp), intent(in) :: b (m) The right-hand side of Ax = b etc. real(kind=wp), intent(out) :: u (m) On exit, u = r (where r = b - Ax). real(kind=wp), intent(out) :: v (n) On exit, v = A'r. real(kind=wp), intent(out) :: w (n) On exit, w = A'r - damp&#94;2 x. real(kind=wp), intent(in) :: x (n) The given estimate of a solution. integer, intent(out) :: inform inform = 0 if b = 0 and x = 0.\ninform = 1, 2 or 3 if x seems to\nsolve systems 1 2 or 3 above. real(kind=wp), intent(out) :: test1 These are dimensionless quantities\nthat should be \"small\" if x does\nseem to solve one of the systems.\n\"small\" means less than\ntol = eps**power, where power is\ndefined as a parameter below. real(kind=wp), intent(out) :: test2 These are dimensionless quantities\nthat should be \"small\" if x does\nseem to solve one of the systems.\n\"small\" means less than\ntol = eps**power, where power is\ndefined as a parameter below. real(kind=wp), intent(out) :: test3 These are dimensionless quantities\nthat should be \"small\" if x does\nseem to solve one of the systems.\n\"small\" means less than\ntol = eps**power, where power is\ndefined as a parameter below. procedure, public :: aprod => aprod_test_solver private  subroutine aprod_test_solver (me, mode, m, n, x, y) This is the matrix-vector product routine required by subroutines\nLSQR and CRAIG for a test matrix of the form  A = HY D HZ.\nThe quantities defining D, HY, HZ are in the work array rw,\nfollowed by a work array w.  These are passed to aprod1 and aprod2\nin order to make the code readable. Arguments Type Intent Optional Attributes Name class( test_solver ), intent(inout) :: me integer, intent(in) :: mode integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout), dimension(:) :: x dimension n real(kind=wp), intent(inout), dimension(:) :: y dimension m procedure, public :: test private  subroutine test (me, m, n, nduplc, npower, damp) This is an example driver routine for running LSQR.\n  It generates a test problem, solves it, and examines the results.\n  Note that subroutine aprod must be declared external\n  if it is used only in the call to LSQR (and acheck). Read more… Arguments Type Intent Optional Attributes Name class( test_solver ), intent(inout) :: me integer :: m integer :: n integer :: nduplc integer :: npower real(kind=wp) :: damp procedure, public :: aprod1 private  subroutine aprod1 (me, m, n, maxmn, minmn, x, y, d, hy, hz, w) aprod1  computes  y = y + A x  for subroutine aprod,\nwhere A is a test matrix of the form  A = HY D*HZ,\nand the latter matrices HY, D, HZ are represented by\ninput vectors with the same name. Arguments Type Intent Optional Attributes Name class( test_solver ), intent(inout) :: me integer :: m integer :: n integer :: maxmn integer :: minmn real(kind=wp) :: x (n) real(kind=wp) :: y (m) real(kind=wp) :: d (minmn) real(kind=wp) :: hy (m) real(kind=wp) :: hz (n) real(kind=wp) :: w (maxmn) procedure, public :: aprod2 private  subroutine aprod2 (me, m, n, maxmn, minmn, x, y, d, hy, hz, w) aprod2  computes  x = x + A(t) y  for subroutine aprod,\nwhere  A  is a test matrix of the form  A = HY D*HZ,\nand the latter matrices  HY, D, HZ  are represented by\ninput vectors with the same name. Arguments Type Intent Optional Attributes Name class( test_solver ), intent(inout) :: me integer :: m integer :: n integer :: maxmn integer :: minmn real(kind=wp) :: x (n) real(kind=wp) :: y (m) real(kind=wp) :: d (minmn) real(kind=wp) :: hy (m) real(kind=wp) :: hz (n) real(kind=wp) :: w (maxmn) procedure, public :: lstp private  subroutine lstp (me, m, n, maxmn, minmn, nduplc, npower, damp, x, b, d, hy, hz, w, acond, rnorm) lstp  generate a sparse least-squares test problem of the form\n           (   A    ) x = ( b )\n           ( damp I )     ( 0 )\nfor solution by LSQR, or a sparse underdetermined system\n              Ax + damp s = b\nfor solution by CRAIG.  The matrix A is m by n and is\nconstructed in the form  A = HY D*HZ,  where D is an m by n\ndiagonal matrix, and HY and HZ are Householder transformations. Read more… Arguments Type Intent Optional Attributes Name class( test_solver ), intent(inout) :: me integer :: m integer :: n integer :: maxmn integer :: minmn integer :: nduplc integer :: npower real(kind=wp) :: damp real(kind=wp) :: x (n) real(kind=wp) :: b (m) real(kind=wp) :: d (minmn) real(kind=wp) :: hy (m) real(kind=wp) :: hz (n) real(kind=wp) :: w (maxmn) real(kind=wp) :: acond real(kind=wp) :: rnorm","tags":"","loc":"type/test_solver.html"},{"title":"node – AoC-2023 ","text":"type :: node Components Type Visibility Attributes Name Initial character(len=3), public :: name = '' character(len=3), public, dimension(2) :: lr integer, public, dimension(2) :: lr_idx Source Code type :: node character ( len = 3 ) :: name = '' character ( len = 3 ), dimension ( 2 ) :: lr integer , dimension ( 2 ) :: lr_idx ! the indices in the nodes array of the l,r nodes end type node","tags":"","loc":"type/node~2.html"},{"title":"finite_diff_method – AoC-2023 ","text":"type, public :: finite_diff_method defines the finite difference method\nused to compute the Jacobian. See: get_finite_difference_method for the different methods. Inherited by type~~finite_diff_method~~InheritedByGraph type~finite_diff_method finite_diff_method type~meth_array meth_array type~meth_array->type~finite_diff_method meth type~numdiff_type numdiff_type type~numdiff_type->type~finite_diff_method meth type~numdiff_type->type~meth_array class_meths Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, private :: id = 0 unique ID for the method character(len=:), private, allocatable :: name the name of the method integer, private :: class = 0 2=backward diffs, 3=central diffs, etc... real(kind=wp), private, dimension(:), allocatable :: dx_factors multiplicative factors for dx perturbation real(kind=wp), private, dimension(:), allocatable :: df_factors multiplicative factors for accumulating function evaluations real(kind=wp), private :: df_den_factor = zero denominator factor for finite difference equation (times dx ) Constructor public        interface finite_diff_method constructor private  function initialize_finite_difference_method (id, name, class, dx_factors, df_factors, df_den_factor) result(me) Constructor for a finite_diff_method . Note factors are input as integers for convenience, but are converted\n      to reals for the actual computations. (note: this means we can't\n      currently define methods that have non-integer factors). Arguments Type Intent Optional Attributes Name integer, intent(in) :: id unique ID for the method character(len=*), intent(in) :: name the name of the method integer, intent(in) :: class 2=backward diffs, 3=central diffs, etc... integer, intent(in), dimension(:) :: dx_factors multiplicative factors for dx perturbation integer, intent(in), dimension(:) :: df_factors multiplicative factors for accumulating function evaluations integer, intent(in) :: df_den_factor denominator factor for finite difference equation (times dx) Return Value type( finite_diff_method ) Type-Bound Procedures procedure, public :: get_formula private  subroutine get_formula (me, formula) Return a string with the finite difference formula. Read more… Arguments Type Intent Optional Attributes Name class( finite_diff_method ), intent(in) :: me character(len=:), intent(out), allocatable :: formula procedure, public :: print => print_finite_difference_method private  subroutine print_finite_difference_method (me, iunit) Print the contents of a finite_diff_method . Used for debugging. Arguments Type Intent Optional Attributes Name class( finite_diff_method ), intent(in) :: me integer, intent(in) :: iunit file unit for printing\n(assumed to be opened) Source Code type , public :: finite_diff_method !! defines the finite difference method !! used to compute the Jacobian. !! !! See: [[get_finite_difference_method]] !! for the different methods. private integer :: id = 0 !! unique ID for the method character ( len = :), allocatable :: name !! the name of the method integer :: class = 0 !! 2=backward diffs, 3=central diffs, etc... real ( wp ), dimension (:), allocatable :: dx_factors !! multiplicative factors for `dx` perturbation real ( wp ), dimension (:), allocatable :: df_factors !! multiplicative factors for accumulating function evaluations real ( wp ) :: df_den_factor = zero !! denominator factor for finite difference equation (times `dx`) contains private procedure , public :: get_formula procedure , public :: print => print_finite_difference_method end type finite_diff_method","tags":"","loc":"type/finite_diff_method.html"},{"title":"meth_array – AoC-2023 ","text":"type, public :: meth_array to store an array of finite_diff_method types\nthis is used when the mode=2 option is used\nin numdiff_type Inherits type~~meth_array~~InheritsGraph type~meth_array meth_array type~finite_diff_method finite_diff_method type~meth_array->type~finite_diff_method meth Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~meth_array~~InheritedByGraph type~meth_array meth_array type~numdiff_type numdiff_type type~numdiff_type->type~meth_array class_meths Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( finite_diff_method ), private, dimension(:), allocatable :: meth Source Code type , public :: meth_array !! to store an array of [[finite_diff_method]] types !! this is used when the `mode=2` option is used !! in [[numdiff_type]] private type ( finite_diff_method ), dimension (:), allocatable :: meth end type meth_array","tags":"","loc":"type/meth_array.html"},{"title":"sparsity_pattern – AoC-2023 ","text":"type, public :: sparsity_pattern A sparsity pattern Inherited by type~~sparsity_pattern~~InheritedByGraph type~sparsity_pattern sparsity_pattern type~numdiff_type numdiff_type type~numdiff_type->type~sparsity_pattern sparsity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, private :: sparsity_computed = .false. has the sparsity pattern already been computed? integer, private :: num_nonzero_elements = 0 number of nonzero elements in the jacobian\n(will be the dimension of irow and icol ) integer, private, dimension(:), allocatable :: irow sparsity pattern - rows of non-zero elements integer, private, dimension(:), allocatable :: icol sparsity pattern - columns of non-zero elements logical, private :: linear_sparsity_computed = .false. if the linear pattern has been populated integer, private :: num_nonzero_linear_elements = 0 number of constant elements in the jacobian integer, private, dimension(:), allocatable :: linear_irow linear sparsity pattern - rows of non-zero elements integer, private, dimension(:), allocatable :: linear_icol linear sparsity pattern - columns of non-zero elements real(kind=wp), private, dimension(:), allocatable :: linear_vals linear elements of the jacobian integer, private, dimension(:), allocatable :: indices index vector [1,2,...,num_nonzero_elements] for putting df into jac integer, private :: maxgrp = 0 the number of groups in the partition\nof the columns of a . integer, private, dimension(:), allocatable :: ngrp specifies the partition of the columns of a .\ncolumn jcol belongs to group ngrp(jcol) . size(n) Type-Bound Procedures procedure, private :: dsm_wrapper private  subroutine dsm_wrapper (me, n, m, info) Wrapper for dsm to compute the sparsity pattern partition. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(inout) :: me integer, intent(in) :: n number of columns of jacobian matrix integer, intent(in) :: m number of rows of jacobian matrix integer, intent(out) :: info status output from dsm procedure, private :: compute_indices private  subroutine compute_indices (me) Computes the indices vector in the class. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(inout) :: me procedure, public :: destroy => destroy_sparsity private  subroutine destroy_sparsity (me) destroy a sparsity_pattern type. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(out) :: me procedure, public :: print => print_sparsity private  subroutine print_sparsity (me, n, m, iunit, dense) Print the sparsity pattern. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(in) :: me integer, intent(in) :: n number of variables (columns of jacobian) integer, intent(in) :: m number of functions (rows of jacobian) integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) logical, intent(in), optional :: dense if present and true, the matrix form\nof the sparsity pattern is printed\n(default is vector form) procedure, public :: columns_in_partition_group private  subroutine columns_in_partition_group (me, igroup, n_cols, cols, nonzero_rows, indices, status_ok) Returns the columns in a sparsity partition group. Read more… Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(in) :: me integer, intent(in) :: igroup group number. Should be >0 and <=me%mxgrp integer, intent(out) :: n_cols number of columns in the igroup group. integer, intent(out), dimension(:), allocatable :: cols the column numbers in the igroup group.\n(if none, then it is not allocated) integer, intent(out), dimension(:), allocatable :: nonzero_rows the row numbers of all the nonzero\nJacobian elements in this group integer, intent(out), dimension(:), allocatable :: indices nonzero indices in jac for a group logical, intent(out) :: status_ok true if the partition is valid Source Code type , public :: sparsity_pattern !! A sparsity pattern private logical :: sparsity_computed = . false . !! has the sparsity pattern already been computed? integer :: num_nonzero_elements = 0 !! number of nonzero elements in the jacobian !! (will be the dimension of `irow` and `icol`) integer , dimension (:), allocatable :: irow !! sparsity pattern - rows of non-zero elements integer , dimension (:), allocatable :: icol !! sparsity pattern - columns of non-zero elements logical :: linear_sparsity_computed = . false . !! if the linear pattern has been populated integer :: num_nonzero_linear_elements = 0 !! number of constant elements in the jacobian integer , dimension (:), allocatable :: linear_irow !! linear sparsity pattern - rows of non-zero elements integer , dimension (:), allocatable :: linear_icol !! linear sparsity pattern - columns of non-zero elements real ( wp ), dimension (:), allocatable :: linear_vals !! linear elements of the jacobian integer , dimension (:), allocatable :: indices !! index vector !! `[1,2,...,num_nonzero_elements]` !! for putting `df` into `jac` integer :: maxgrp = 0 !! the number of groups in the partition !! of the columns of `a`. integer , dimension (:), allocatable :: ngrp !! specifies the partition of the columns of `a`. !! column `jcol` belongs to group `ngrp(jcol)`. !! `size(n)` contains private procedure :: dsm_wrapper procedure :: compute_indices procedure , public :: destroy => destroy_sparsity procedure , public :: print => print_sparsity procedure , public :: columns_in_partition_group end type sparsity_pattern","tags":"","loc":"type/sparsity_pattern.html"},{"title":"numdiff_type – AoC-2023 ","text":"type, public :: numdiff_type base type for sparsity and Jacobian computations. Inherits type~~numdiff_type~~InheritsGraph type~numdiff_type numdiff_type type~finite_diff_method finite_diff_method type~numdiff_type->type~finite_diff_method meth type~function_cache~2 function_cache type~numdiff_type->type~function_cache~2 cache type~meth_array meth_array type~numdiff_type->type~meth_array class_meths type~sparsity_pattern sparsity_pattern type~numdiff_type->type~sparsity_pattern sparsity type~fx~2 fx type~function_cache~2->type~fx~2 c type~meth_array->type~finite_diff_method meth Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, private :: exception_raised = .false. if true, an exception has been raised integer, private :: istat = 0 a non-zero value will cause all routine to exit.\nthis can be set to -1 by calling terminate . character(len=:), private, allocatable :: error_msg error message (if istat/=0 ) integer, private :: n = 0 number of x variables integer, private :: m = 0 number of f functions real(kind=wp), private, dimension(:), allocatable :: xlow lower bounds on x real(kind=wp), private, dimension(:), allocatable :: xhigh upper bounds on x logical, private :: print_messages = .true. if true, warning messages are printed\nto the error_unit for any errors. integer, private :: chunk_size = 100 chuck size for allocating the arrays (>0) integer, private :: perturb_mode = 1 perturbation mode: 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), private, dimension(:), allocatable :: dpert perturbation vector for x logical, private :: partition_sparsity_pattern = .false. to partition the sparsity pattern using dsm type( sparsity_pattern ), private :: sparsity the sparsity pattern real(kind=wp), private, dimension(:), allocatable :: xlow_for_sparsity lower bounds on x for computing sparsity (optional) real(kind=wp), private, dimension(:), allocatable :: xhigh_for_sparsity upper bounds on x for computing sparsity (optional) real(kind=wp), private, dimension(:), allocatable :: dpert_for_sparsity perturbation vector for x when computing\nsparsity for sparsity_mode=4 integer, private :: num_sparsity_points = 3 for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern.\nSee compute_sparsity_random_2 integer, private :: sparsity_perturb_mode = 1 perturbation mode (if sparsity_mode=4 ): 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) logical, private :: compute_linear_sparsity_pattern = .false. to also compute the linear sparsity pattern real(kind=wp), private :: linear_sparsity_tol = epsilon(1.0_wp) the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), private :: function_precision_tol = epsilon(1.0_wp) the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, private :: mode = 1 1 = use meth (specified methods), 2 = use class (specified class, method is selected on-the-fly). type( finite_diff_method ), private, dimension(:), allocatable :: meth the finite difference method to use\ncompute the n th column of the Jacobian size(n) .  Either this or class is used integer, private, dimension(:), allocatable :: class the class of method to use to\ncompute the n th column of the Jacobian size(n) . Either this or meth is used type( meth_array ), private, dimension(:), allocatable :: class_meths array of methods for the specified classes.\nused with class when mode=2 real(kind=wp), private :: eps = 1.0e-9_wp tolerance parameter for diff real(kind=wp), private :: acc = 0.0_wp tolerance parameter for diff type( function_cache ), private :: cache if using the function cache logical, private :: use_diff = .false. if we are using the Neville's process method,\nrather than finite differences procedure( func ), private, pointer :: problem_func => null() the user-defined function procedure( func ), private, pointer :: compute_function => null() compute the user-defined function\nthis can point to the problem_func or, if using\nthe cache, it points to compute_function_with_cache . procedure( spars_f ), private, pointer :: compute_sparsity => null() for computing the sparsity pattern procedure( info_f ), private, pointer :: info_function => null() an optional function the user can define\nwhich is called when each column of the jacobian is computed.\nIt can be used to perform any setup operations. procedure( jacobian_f ), private, pointer :: jacobian_function => null() the low-level function called by compute_jacobian that actually computes the jacobian. Type-Bound Procedures procedure, public :: initialize => initialize_numdiff initialize the class private  subroutine initialize_numdiff (me, n, m, xlow, xhigh, perturb_mode, dpert, problem_func, sparsity_mode, jacobian_method, jacobian_methods, class, classes, info, chunk_size, partition_sparsity_pattern, cache_size, xlow_for_sparsity, xhigh_for_sparsity, dpert_for_sparsity, sparsity_perturb_mode, linear_sparsity_tol, function_precision_tol, num_sparsity_points) Initialize a numdiff_type class. This must be called first. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: n number of x variables integer, intent(in) :: m number of f functions real(kind=wp), intent(in), dimension(n) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(n) :: xhigh upper bounds on x integer, intent(in) :: perturb_mode perturbation mode: 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), dimension(n) :: dpert perturbation vector for x procedure( func ) :: problem_func the user function that defines the problem\n(returns m functions) integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. integer, intent(in), optional :: jacobian_method id code for the finite difference method\nto use for all n variables.\nsee get_finite_difference_method integer, intent(in), optional, dimension(n) :: jacobian_methods id codes for the finite difference method\nto use for each variable.\nsee get_finite_difference_method integer, intent(in), optional :: class method class for the finite difference method\nto use for all n variables.\nsee get_finite_difference_method integer, intent(in), optional, dimension(n) :: classes method class for the finite difference methods\nto use for each variable.\nsee get_finite_difference_method procedure( info_f ), optional :: info a function the user can define\nwhich is called when each column\nof the jacobian is computed.\nIt can be used to perform any\nsetup operations. integer, intent(in), optional :: chunk_size chunk size for allocating the arrays\n(must be >0) [default is 100] logical, intent(in), optional :: partition_sparsity_pattern if the sparisty pattern is to\nbe partitioned using DSM [default is False] integer, intent(in), optional :: cache_size if present, this is the cache size\nfor the function cache\n(default is not to enable cache) real(kind=wp), intent(in), optional, dimension(n) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(n) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. real(kind=wp), intent(in), optional, dimension(n) :: dpert_for_sparsity for sparsity_mode=4 , the perturbation integer, intent(in), optional :: sparsity_perturb_mode perturbation mode (required if sparsity_mode=4 ): 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), optional :: linear_sparsity_tol the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), intent(in), optional :: function_precision_tol the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, intent(in), optional :: num_sparsity_points for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern. procedure, public :: diff_initialize => initialize_numdiff_for_diff initialize the class private  subroutine initialize_numdiff_for_diff (me, n, m, xlow, xhigh, problem_func, sparsity_mode, info, chunk_size, eps, acc, cache_size, xlow_for_sparsity, xhigh_for_sparsity, dpert_for_sparsity, sparsity_perturb_mode, linear_sparsity_tol, function_precision_tol, num_sparsity_points, print_messages) Alternate version of initialize_numdiff routine when\nusing diff to compute the Jacobian. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: n number of x variables integer, intent(in) :: m number of f functions real(kind=wp), intent(in), dimension(n) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(n) :: xhigh upper bounds on x procedure( func ) :: problem_func the user function that defines the problem\n(returns m functions) integer, intent(in) :: sparsity_mode the sparsity computation method: Read more… procedure( info_f ), optional :: info a function the user can define\nwhich is called when each column\nof the jacobian is computed.\nIt can be used to perform any\nsetup operations. integer, intent(in), optional :: chunk_size chunk size for allocating the arrays\n(must be >0) [default is 100] real(kind=wp), intent(in), optional :: eps tolerance parameter for diff if not present, default is 1.0e-9_wp real(kind=wp), intent(in), optional :: acc tolerance parameter for diff if not present, default is 0.0_wp integer, intent(in), optional :: cache_size if present, this is the cache size\nfor the function cache\n(default is not to enable cache) real(kind=wp), intent(in), optional, dimension(n) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(n) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. real(kind=wp), intent(in), optional, dimension(n) :: dpert_for_sparsity required if sparsity_mode=4 integer, intent(in), optional :: sparsity_perturb_mode perturbation mode (required if sparsity_mode=4 ): Read more… real(kind=wp), intent(in), optional :: linear_sparsity_tol the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), intent(in), optional :: function_precision_tol the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, intent(in), optional :: num_sparsity_points for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern. logical, intent(in), optional :: print_messages if true, print error messages to error_unit .\ndefault is True. procedure, public :: compute_jacobian main routine to compute the Jacobian\nusing the selected options. It\nreturns the sparse (vector) form. private  subroutine compute_jacobian (me, x, jac) Compute the Jacobian. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:), allocatable :: jac sparse jacobian vector procedure, public :: compute_jacobian_dense return the dense size(m,n) matrix form of the Jacobian. private  subroutine compute_jacobian_dense (me, x, jac) just a wrapper for compute_jacobian , that returns a dense ( m x n ) matrix. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:,:), allocatable :: jac the jacobian matrix procedure, public :: compute_jacobian_times_vector returns the product of the Jacobian\nmatrix and an input vector private  subroutine compute_jacobian_times_vector (me, x, v, z) Returns the product J*v , where J is the m x n Jacobian matrix\n  and v is an n x 1 vector. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(:) :: v vector (size n ) real(kind=wp), intent(out), dimension(:) :: z The product J*v (size m ) procedure, public :: destroy => destroy_numdiff_type destroy the class private  subroutine destroy_numdiff_type (me) destroy the numdiff_type class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(out) :: me procedure, public :: print_sparsity_pattern print the sparsity pattern in vector form to a file private  subroutine print_sparsity_pattern (me, iunit) Print the sparsity pattern in vector form ( irow , icol ). Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) procedure, public :: print_sparsity_matrix print the sparsity pattern in matrix form to a file private  subroutine print_sparsity_matrix (me, iunit) Print the sparsity pattern in matrix form. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) procedure, public :: set_sparsity_pattern manually set the sparsity pattern private  subroutine set_sparsity_pattern (me, irow, icol, linear_irow, linear_icol, linear_vals, maxgrp, ngrp) To specify the sparsity pattern directly if it is already known. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in), dimension(:) :: irow sparsity pattern nonzero elements row indices integer, intent(in), dimension(:) :: icol sparsity pattern nonzero elements column indices integer, intent(in), optional, dimension(:) :: linear_irow linear sparsity pattern nonzero elements row indices integer, intent(in), optional, dimension(:) :: linear_icol linear sparsity pattern nonzero elements column indices real(kind=wp), intent(in), optional, dimension(:) :: linear_vals linear sparsity values (constant elements of the Jacobian) integer, intent(in), optional :: maxgrp DSM sparsity partition\n[only used if me%partition_sparsity_pattern=True ] integer, intent(in), optional, dimension(:) :: ngrp DSM sparsity partition (size n )\n[only used if me%partition_sparsity_pattern=True ] procedure, public :: select_finite_diff_method select a method in a specified class so\nthat the variable bounds are not violated\nwhen by the perturbations. private  subroutine select_finite_diff_method (me, x, xlow, xhigh, dx, list_of_methods, fd, status_ok) Select a finite diff method of a given class so that the perturbations\nof x will not violate the variable bounds. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in) :: x the variable value real(kind=wp), intent(in) :: xlow the variable lower bound real(kind=wp), intent(in) :: xhigh the variable upper bound real(kind=wp), intent(in) :: dx the perturbation value (>0) type( meth_array ), intent(in) :: list_of_methods list of available methods to choose from type( finite_diff_method ), intent(out) :: fd this method can be used logical, intent(out) :: status_ok true if it really doesn't violate the bounds\n(say, the bounds are very close to each other)\nif status_ok=False , then the first method in\nthe given class is returned in fd . procedure, public :: select_finite_diff_method_for_partition_group version of select_finite_diff_method for partitioned sparsity pattern. private  subroutine select_finite_diff_method_for_partition_group (me, x, xlow, xhigh, dx, list_of_methods, fd, status_ok) Select a finite diff method of a given class so that the perturbations\nof x will not violate the variable bounds for any variable in the group. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x the variable values real(kind=wp), intent(in), dimension(:) :: xlow the variable lower bounds real(kind=wp), intent(in), dimension(:) :: xhigh the variable upper bounds real(kind=wp), intent(in), dimension(:) :: dx the perturbation values (>0) type( meth_array ), intent(in) :: list_of_methods list of available methods to choose from type( finite_diff_method ), intent(out) :: fd this method can be used logical, intent(out) :: status_ok true if it really doesn't violate the bounds\n(say, the bounds are very close to each other)\nif status_ok=False , then the first method in\nthe given class is returned in fd . procedure, public :: set_numdiff_bounds can be called to change the variable bounds. private  subroutine set_numdiff_bounds (me, xlow, xhigh) Change the variable bounds in a numdiff_type . Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(:) :: xhigh upper bounds on x procedure, public :: compute_sparsity_pattern if the user needs to compute the sparsity pattern manually.\n(otherwise it will be done the first time the Jacobian is computed) private  subroutine compute_sparsity_pattern (me, x, irow, icol, linear_irow, linear_icol, linear_vals) Computes the sparsity pattern and return it.\nUses the settings currently in the class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) integer, intent(out), dimension(:), allocatable :: irow sparsity pattern nonzero elements row indices integer, intent(out), dimension(:), allocatable :: icol sparsity pattern nonzero elements column indices integer, intent(out), optional, dimension(:), allocatable :: linear_irow linear sparsity pattern\nnonzero elements row indices integer, intent(out), optional, dimension(:), allocatable :: linear_icol linear sparsity pattern nonzero\nelements column indices real(kind=wp), intent(out), optional, dimension(:), allocatable :: linear_vals linear sparsity values (constant\nelements of the Jacobian) procedure, public :: get_sparsity_pattern returns the sparsity pattern (if it is allocated) private  subroutine get_sparsity_pattern (me, irow, icol, linear_irow, linear_icol, linear_vals, maxgrp, ngrp) Returns the sparsity pattern from the class.\nIf it hasn't been computed, the output arrays will not be allocated. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: irow sparsity pattern nonzero elements row indices integer, intent(out), dimension(:), allocatable :: icol sparsity pattern nonzero elements column indices integer, intent(out), optional, dimension(:), allocatable :: linear_irow linear sparsity pattern\nnonzero elements row indices integer, intent(out), optional, dimension(:), allocatable :: linear_icol linear sparsity pattern nonzero\nelements column indices real(kind=wp), intent(out), optional, dimension(:), allocatable :: linear_vals linear sparsity values (constant\nelements of the Jacobian) integer, intent(out), optional :: maxgrp DSM sparsity partition integer, intent(out), optional, dimension(:), allocatable :: ngrp DSM sparsity partition procedure, public :: terminate can be called by user to stop the computation private  subroutine terminate (me) A user-callable routine. When called, it will terminate\nall computations and return. The istat return code will be\nset to -1 . This can be called in the function or the info function. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me procedure, public :: failed to check if an exception was raised. private pure function failed (me) Returns True if an exception has been raised. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(in) :: me Return Value logical procedure, public :: get_error_status the status of error condition private  subroutine get_error_status (me, istat, error_msg) Returns the current error code and message. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(in) :: me integer, intent(out), optional :: istat error code ( istat=0 means no errors). character(len=:), intent(out), optional, allocatable :: error_msg error message string. procedure, private :: destroy_sparsity_pattern destroy the sparsity pattern private  subroutine destroy_sparsity_pattern (me) Destroy the sparsity pattern in the class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me procedure, private :: compute_perturb_vector private  subroutine compute_perturb_vector (me, x, dpert, perturb_mode, dx) Compute dx , the perturbation vector for x Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dpert integer, intent(in) :: perturb_mode real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable procedure, private :: compute_perturbation_vector computes the variable perturbation factor private  subroutine compute_perturbation_vector (me, x, dx) Compute dx , the perturbation vector for x used\nwhen computing the gradients. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable procedure, private :: compute_sparsity_perturbation_vector private  subroutine compute_sparsity_perturbation_vector (me, x, dx) Compute dx , the perturbation vector for x used\nwhen computing the sparsity pattern. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable procedure, private :: perturb_x_and_compute_f private  subroutine perturb_x_and_compute_f (me, x, dx_factor, dx, df_factor, column, idx, df) Perturb the specified optimization variable, and compute the function.\nThis routine is designed so that df is accumulated as each function\nevaluation is done, to avoid having to allocate more temporary storage. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x nominal variable vector real(kind=wp), intent(in) :: dx_factor factor to multiply dx real(kind=wp), intent(in), dimension(:) :: dx the perturbation value for this column real(kind=wp), intent(in) :: df_factor factor to multiply function value integer, intent(in) :: column the variable to perturb integer, intent(in), dimension(:) :: idx the elements in this\ncolumn of the Jacobian\nto compute (passed to function) real(kind=wp), intent(inout), dimension(me%m) :: df the accumulated function value\nnote: for the first call, this\nshould be set to zero procedure, private :: perturb_x_and_compute_f_partitioned private  subroutine perturb_x_and_compute_f_partitioned (me, x, dx_factor, dx, df_factor, columns, idx, df) Perturb the specified optimization variable, and compute the function.\nThis routine is designed so that df is accumulated as each function\nevaluation is done, to avoid having to allocate more temporary storage. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x nominal variable vector real(kind=wp), intent(in) :: dx_factor factor to multiply dx real(kind=wp), intent(in), dimension(:) :: dx the perturbation value for this column real(kind=wp), intent(in) :: df_factor factor to multiply function value integer, intent(in), dimension(:) :: columns the variables to perturb integer, intent(in), dimension(:) :: idx the elements in this\ncolumn of the Jacobian\nto compute (passed to function) real(kind=wp), intent(inout), dimension(me%m) :: df the accumulated function value\nnote: for the first call, this\nshould be set to zero procedure, private :: set_numdiff_sparsity_bounds private  subroutine set_numdiff_sparsity_bounds (me, xlow, xhigh) Sets the variable bounds for sparsity in a numdiff_type .\n  These are only used for sparsity_mode=2 . Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), optional, dimension(:) :: xlow lower bounds on x to be used for\nsparsity computation. If not present,\nthen then xlow values in the class are used. real(kind=wp), intent(in), optional, dimension(:) :: xhigh upper bounds on x to be used for\nsparsity computation. If not present,\nthen then xhigh values in the class are used. procedure, private :: set_sparsity_mode private  subroutine set_sparsity_mode (me, sparsity_mode, xlow_for_sparsity, xhigh_for_sparsity) Set sparsity mode. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. real(kind=wp), intent(in), optional, dimension(:) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(:) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. procedure, private :: generate_dense_sparsity_partition private  subroutine generate_dense_sparsity_partition (me) Generate a \"dense\" sparsity partition. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me procedure, private :: compute_jacobian_for_sparsity private  subroutine compute_jacobian_for_sparsity (me, i, class_meths, x, jac) A separate version of compute_jacobian to be used only when\n  computing the sparsity pattern in compute_sparsity_random_2 .\n  It uses class_meths and the sparsity dperts and bounds. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: i the column being computed type( meth_array ), intent(in) :: class_meths set of finite diff methods to use real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:), allocatable :: jac sparse jacobian vector procedure, private :: resize_sparsity_vectors private  subroutine resize_sparsity_vectors (me, n_icol, n_irow, n_linear_icol, n_linear_irow, n_linear_vals) Resize the sparsity arrays after accumulating them. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(inout) :: n_icol integer, intent(inout) :: n_irow integer, intent(inout) :: n_linear_icol integer, intent(inout) :: n_linear_irow integer, intent(inout) :: n_linear_vals procedure, private :: raise_exception private  subroutine raise_exception (me, istat, routine, error_msg) Raise an exception. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: istat error code. character(len=*), intent(in) :: routine the routine where the error was raised. character(len=*), intent(in) :: error_msg error message string. procedure, private :: clear_exceptions private  subroutine clear_exceptions (me) Clear all exceptions. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me Source Code type , public :: numdiff_type !! base type for sparsity and Jacobian computations. private logical :: exception_raised = . false . !! if true, an exception has been raised integer :: istat = 0 !! a non-zero value will cause all routine to exit. !! this can be set to `-1` by calling [[terminate]]. character ( len = :), allocatable :: error_msg !! error message (if `istat/=0`) integer :: n = 0 !! number of `x` variables integer :: m = 0 !! number of `f` functions real ( wp ), dimension (:), allocatable :: xlow !! lower bounds on `x` real ( wp ), dimension (:), allocatable :: xhigh !! upper bounds on `x` logical :: print_messages = . true . !! if true, warning messages are printed !! to the `error_unit` for any errors. integer :: chunk_size = 100 !! chuck size for allocating the arrays (>0) integer :: perturb_mode = 1 !! perturbation mode: !! !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` real ( wp ), dimension (:), allocatable :: dpert !! perturbation vector for `x` logical :: partition_sparsity_pattern = . false . !! to partition the sparsity pattern using [[dsm]] type ( sparsity_pattern ) :: sparsity !! the sparsity pattern real ( wp ), dimension (:), allocatable :: xlow_for_sparsity !! lower bounds on `x` for computing sparsity (optional) real ( wp ), dimension (:), allocatable :: xhigh_for_sparsity !! upper bounds on `x` for computing sparsity (optional) real ( wp ), dimension (:), allocatable :: dpert_for_sparsity !! perturbation vector for `x` when computing !! sparsity for `sparsity_mode=4` integer :: num_sparsity_points = 3 !! for `sparsity_mode=4`, the number of jacobian !! evaluations used to estimate the sparsity pattern. !! See [[compute_sparsity_random_2]] integer :: sparsity_perturb_mode = 1 !! perturbation mode (if `sparsity_mode=4`): !! !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` ! if computing the sparsity pattern, we also have an option to ! compute the linear pattern, which indicates constant elements ! of the jacobian. these elements don't need to be computed again. logical :: compute_linear_sparsity_pattern = . false . !! to also compute the linear sparsity pattern real ( wp ) :: linear_sparsity_tol = epsilon ( 1.0_wp ) !! the equality tolerance for derivatives to !! indicate a constant jacobian element (linear sparsity) real ( wp ) :: function_precision_tol = epsilon ( 1.0_wp ) !! the function precision. two functions values !! that are the within this tolerance are !! considered the same value. This is used !! when estimating the sparsity pattern when !! `sparsity_mode=2` in [[compute_sparsity_random]] integer :: mode = 1 !! **1** = use `meth` (specified methods), !! **2** = use `class` (specified class, method is selected on-the-fly). type ( finite_diff_method ), dimension (:), allocatable :: meth !! the finite difference method to use !! compute the `n`th column of the Jacobian !! `size(n)`.  Either this or `class` is used integer , dimension (:), allocatable :: class !! the class of method to use to !! compute the `n`th column of the Jacobian !! `size(n)`. Either this or `meth` is used type ( meth_array ), dimension (:), allocatable :: class_meths !! array of methods for the specified classes. !! used with `class` when `mode=2` ! parameters when using diff: real ( wp ) :: eps = 1.0e-9_wp !! tolerance parameter for [[diff]] real ( wp ) :: acc = 0.0_wp !! tolerance parameter for [[diff]] type ( function_cache ) :: cache !! if using the function cache logical :: use_diff = . false . !! if we are using the Neville's process method, !! rather than finite differences procedure ( func ), pointer :: problem_func => null () !! the user-defined function ! these are required to be defined by the user: procedure ( func ), pointer :: compute_function => null () !! compute the user-defined function !! this can point to the `problem_func` or, if using !! the cache, it points to [[compute_function_with_cache]]. procedure ( spars_f ), pointer :: compute_sparsity => null () !! for computing the sparsity pattern procedure ( info_f ), pointer :: info_function => null () !! an optional function the user can define !! which is called when each column of the jacobian is computed. !! It can be used to perform any setup operations. procedure ( jacobian_f ), pointer :: jacobian_function => null () !! the low-level function called by [[compute_jacobian]] !! that actually computes the jacobian. contains private procedure , public :: initialize => initialize_numdiff !! initialize the class procedure , public :: diff_initialize => initialize_numdiff_for_diff !! initialize the class procedure , public :: compute_jacobian !! main routine to compute the Jacobian !! using the selected options. It !! returns the sparse (vector) form. procedure , public :: compute_jacobian_dense !! return the dense `size(m,n)` !! matrix form of the Jacobian. procedure , public :: compute_jacobian_times_vector !! returns the product of the Jacobian !! matrix and an input vector procedure , public :: destroy => destroy_numdiff_type !! destroy the class procedure , public :: print_sparsity_pattern !! print the sparsity pattern in vector form to a file procedure , public :: print_sparsity_matrix !! print the sparsity pattern in matrix form to a file procedure , public :: set_sparsity_pattern !! manually set the sparsity pattern procedure , public :: select_finite_diff_method !! select a method in a specified class so !! that the variable bounds are not violated !! when by the perturbations. procedure , public :: select_finite_diff_method_for_partition_group !! version of [[select_finite_diff_method]] !! for partitioned sparsity pattern. procedure , public :: set_numdiff_bounds !! can be called to change the variable bounds. procedure , public :: compute_sparsity_pattern !! if the user needs to compute the sparsity pattern manually. !! (otherwise it will be done the first time the Jacobian is computed) procedure , public :: get_sparsity_pattern !! returns the sparsity pattern (if it is allocated) procedure , public :: terminate !! can be called by user to stop the computation procedure , public :: failed !! to check if an exception was raised. procedure , public :: get_error_status !! the status of error condition ! internal routines: procedure :: destroy_sparsity_pattern !! destroy the sparsity pattern procedure :: compute_perturb_vector procedure :: compute_perturbation_vector !! computes the variable perturbation factor procedure :: compute_sparsity_perturbation_vector procedure :: perturb_x_and_compute_f procedure :: perturb_x_and_compute_f_partitioned procedure :: set_numdiff_sparsity_bounds procedure :: set_sparsity_mode procedure :: generate_dense_sparsity_partition procedure :: compute_jacobian_for_sparsity procedure :: resize_sparsity_vectors procedure :: raise_exception procedure :: clear_exceptions end type numdiff_type","tags":"","loc":"type/numdiff_type.html"},{"title":"lusol_settings – AoC-2023 ","text":"type, public :: lusol_settings Components Type Visibility Attributes Name Initial integer(kind=ip), public :: nout = 6 integer(kind=ip), public :: lprint = 0 integer(kind=ip), public :: maxcol = 5 integer(kind=ip), public :: method = 0 integer(kind=ip), public :: keepLU = 1 real(kind=rp), public :: Ltol1 = 100.0_rp real(kind=rp), public :: Ltol2 = 10.0_rp real(kind=rp), public :: small = epsilon(1.0_rp)**0.8_rp real(kind=rp), public :: Utol1 = epsilon(1.0_rp)**0.67_rp real(kind=rp), public :: Utol2 = epsilon(1.0_rp)**0.67_rp real(kind=rp), public :: Uspace = 3.0_rp real(kind=rp), public :: dens1 = 0.3_rp real(kind=rp), public :: dens2 = 0.5_rp integer(kind=ip), public :: mode = 5 Source Code type , public :: lusol_settings integer ( ip ) :: nout = 6 integer ( ip ) :: lprint = 0 integer ( ip ) :: maxcol = 5 integer ( ip ) :: method = 0 ! TPP integer ( ip ) :: keepLU = 1 real ( rp ) :: Ltol1 = 10 0.0_rp real ( rp ) :: Ltol2 = 1 0.0_rp real ( rp ) :: small = epsilon ( 1.0_rp ) ** 0.8_rp real ( rp ) :: Utol1 = epsilon ( 1.0_rp ) ** 0.67_rp real ( rp ) :: Utol2 = epsilon ( 1.0_rp ) ** 0.67_rp real ( rp ) :: Uspace = 3.0_rp real ( rp ) :: dens1 = 0.3_rp real ( rp ) :: dens2 = 0.5_rp integer ( ip ) :: mode = 5 ! for [[lu6sol]] : `w` solves `A w = v`. end type lusol_settings","tags":"","loc":"type/lusol_settings.html"},{"title":"node – AoC-2023 ","text":"type :: node Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(:), allocatable :: inext the node connected to this one integer(kind=ip), public, dimension(:), allocatable :: idist distance to inext nodes Source Code type :: node integer ( ip ), dimension (:), allocatable :: inext !! the node connected to this one integer ( ip ), dimension (:), allocatable :: idist !! distance to inext nodes end type node","tags":"","loc":"type/node.html"},{"title":"lsqr_solver – AoC-2023 ","text":"type, public, abstract :: lsqr_solver main class to access the lsqr solver. You can use this class directory by extending it\nand specifying aprod , or you can use the lsqr_solver_ez class that has an easier\ninterface. Inherited by type~~lsqr_solver~~InheritedByGraph type~lsqr_solver lsqr_solver type~lsqr_solver_ez lsqr_solver_ez type~lsqr_solver_ez->type~lsqr_solver type~test_solver test_solver type~test_solver->type~lsqr_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Type-Bound Procedures procedure( aprod_func ), public, deferred :: aprod User function to access the sparse matrix A . subroutine aprod_func(me, mode, m, n, x, y) Prototype User function to access the sparse matrix A . Arguments Type Intent Optional Attributes Name class( lsqr_solver ), intent(inout) :: me integer, intent(in) :: mode If mode = 1 , compute y = y + A*x . y should be altered without changing x. If mode = 2 , compute x = x + A(transpose)*y . x should be altered without changing y . integer, intent(in) :: m number of rows in A matrix integer, intent(in) :: n number of columns in A matrix real(kind=wp), intent(inout), dimension(:) :: x real(kind=wp), intent(inout), dimension(:) :: y procedure, public :: lsqr => LSQR main solver routine private  subroutine LSQR (me, m, n, damp, wantse, u, v, w, x, se, atol, btol, conlim, itnlim, nout, istop, itn, anorm, acond, rnorm, arnorm, xnorm) LSQR finds a solution to the following problems: Read more… Arguments Type Intent Optional Attributes Name class( lsqr_solver ), intent(inout) :: me integer, intent(in) :: m the number of rows in A . integer, intent(in) :: n the number of columns in A . real(kind=wp), intent(in) :: damp The damping parameter for problem 3 above.\n(damp should be 0.0 for problems 1 and 2.)\nIf the system A*x = b is incompatible, values\nof damp in the range 0 to sqrt(relpr)*norm(A) will probably have a negligible effect.\nLarger values of damp will tend to decrease\nthe norm of x and reduce the number of\niterations required by LSQR. Read more… logical, intent(in) :: wantse A logical variable to say if the array se(*) of standard error estimates should be computed.\nIf m > n or damp > 0 ,  the system is\noverdetermined and the standard errors may be\nuseful.  (See the first LSQR reference.)\nOtherwise ( m <= n and damp = 0 ) they do not\nmean much.  Some time and storage can be saved\nby setting wantse = .false. and using any\nconvenient array for se(*) , which won't be\ntouched. real(kind=wp), intent(inout) :: u (m) The rhs vector b .  Beware that u is\nover-written by LSQR. real(kind=wp), intent(inout) :: v (n) workspace real(kind=wp), intent(inout) :: w (n) workspace real(kind=wp), intent(out) :: x (n) Returns the computed solution x . real(kind=wp), intent(out), dimension(*) :: se If wantse is true, the dimension of se must be n or more. se(*) then returns standard error\nestimates for the components of x .\nFor each i , se(i) is set to the value rnorm * sqrt( sigma(i,i) / t ) ,\nwhere sigma(i,i) is an estimate of the i-th\ndiagonal of the inverse of Abar(transpose)*Abar and:\n* t = 1      if  m <= n * t = m - n  if  m > n  and  damp = 0 * t = m      if  damp /= 0 Read more… real(kind=wp), intent(in) :: atol An estimate of the relative error in the data\ndefining the matrix A .  For example,\nif A is accurate to about 6 digits, set atol = 1.0e-6 . real(kind=wp), intent(in) :: btol An estimate of the relative error in the data\ndefining the rhs vector b .  For example,\nif b is accurate to about 6 digits, set btol = 1.0e-6 . real(kind=wp), intent(in) :: conlim An upper limit on cond(Abar) , the apparent\ncondition number of the matrix Abar .\nIterations will be terminated if a computed\nestimate of cond(Abar) exceeds conlim .\nThis is intended to prevent certain small or\nzero singular values of A or Abar from\ncoming into effect and causing unwanted growth\nin the computed solution. Read more… integer, intent(in) :: itnlim An upper limit on the number of iterations.\nSuggested value:\n* itnlim = n/2 for well-conditioned systems\n  with clustered singular values,\n* itnlim = 4*n otherwise. integer, intent(in) :: nout File number for printed output.  If nonzero,\na summary will be printed on file nout . integer, intent(out) :: istop An integer giving the reason for termination: Read more… integer, intent(out) :: itn The number of iterations performed. real(kind=wp), intent(out) :: anorm An estimate of the Frobenius norm of Abar .\nThis is the square-root of the sum of squares\nof the elements of Abar .\nIf damp is small and if the columns of A have all been scaled to have length 1.0, anorm should increase to roughly sqrt(n) .\nA radically different value for anorm may\nindicate an error in subroutine aprod (there\nmay be an inconsistency between modes 1 and 2). real(kind=wp), intent(out) :: acond An estimate of cond(Abar) , the condition\nnumber of Abar .  A very high value of acond may again indicate an error in aprod . real(kind=wp), intent(out) :: rnorm An estimate of the final value of norm(rbar) ,\nthe function being minimized (see notation\nabove).  This will be small if A*x = b has\na solution. real(kind=wp), intent(out) :: arnorm An estimate of the final value of norm( Abar(transpose)*rbar ) , the norm of\nthe residual for the usual normal equations.\nThis should be small in all cases.  (arnorm\nwill often be smaller than the true value\ncomputed from the output vector x .) real(kind=wp), intent(out) :: xnorm An estimate of the norm of the final\nsolution vector x . procedure, public :: acheck private  subroutine acheck (me, m, n, nout, eps, v, w, x, y, inform) Checks the two modes of aprod for LSQR . Read more… Arguments Type Intent Optional Attributes Name class( lsqr_solver ), intent(inout) :: me integer, intent(in) :: m No. of rows of A. integer, intent(in) :: n No. of columns of A. integer, intent(in) :: nout A file number for printed output. real(kind=wp), intent(in) :: eps The machine precision. real(kind=wp) :: v (n) real(kind=wp) :: w (m) real(kind=wp) :: x (n) real(kind=wp) :: y (m) integer, intent(out) :: inform Error indicator.\ninform = 0 if aprod seems to be\nconsistent.\ninform = 1 otherwise. procedure, public :: xcheck private  subroutine xcheck (me, m, n, nout, anorm, damp, eps, b, u, v, w, x, inform, test1, test2, test3) Tests if x solves a certain least-squares problem. Read more… Arguments Type Intent Optional Attributes Name class( lsqr_solver ), intent(inout) :: me integer, intent(in) :: m The number of rows in A. integer, intent(in) :: n The number of columns in A. integer, intent(in) :: nout A file number for printed output.\nIf nout = 0, nothing is printed. real(kind=wp), intent(in) :: anorm An estimate of norm(A) or\nnorm( A, delta*I ) if delta > 0.\nNormally this will be available\nfrom LSQR or CRAIG. real(kind=wp), intent(in) :: damp Possibly defines a damped problem. real(kind=wp), intent(in) :: eps Machine precision. real(kind=wp), intent(in) :: b (m) The right-hand side of Ax = b etc. real(kind=wp), intent(out) :: u (m) On exit, u = r (where r = b - Ax). real(kind=wp), intent(out) :: v (n) On exit, v = A'r. real(kind=wp), intent(out) :: w (n) On exit, w = A'r - damp&#94;2 x. real(kind=wp), intent(in) :: x (n) The given estimate of a solution. integer, intent(out) :: inform inform = 0 if b = 0 and x = 0.\ninform = 1, 2 or 3 if x seems to\nsolve systems 1 2 or 3 above. real(kind=wp), intent(out) :: test1 These are dimensionless quantities\nthat should be \"small\" if x does\nseem to solve one of the systems.\n\"small\" means less than\ntol = eps**power, where power is\ndefined as a parameter below. real(kind=wp), intent(out) :: test2 These are dimensionless quantities\nthat should be \"small\" if x does\nseem to solve one of the systems.\n\"small\" means less than\ntol = eps**power, where power is\ndefined as a parameter below. real(kind=wp), intent(out) :: test3 These are dimensionless quantities\nthat should be \"small\" if x does\nseem to solve one of the systems.\n\"small\" means less than\ntol = eps**power, where power is\ndefined as a parameter below. Source Code type , abstract , public :: lsqr_solver !! main class to access the [[lsqr]] solver. !! !! You can use this class directory by extending it !! and specifying `aprod`, or you can use the !! [[lsqr_solver_ez]] class that has an easier !! interface. private contains private procedure ( aprod_func ), deferred , public :: aprod !! User function to access the sparse matrix `A`. procedure , public :: lsqr !! main solver routine procedure , public :: acheck procedure , public :: xcheck end type lsqr_solver","tags":"","loc":"type/lsqr_solver.html"},{"title":"lsqr_solver_ez – AoC-2023 ","text":"type, public, extends( lsqr_solver ) :: lsqr_solver_ez a simplier version of lsqr_solver where\nthe aprod function is provided internally.\nTo use, first call the initialize method\nto set the matrix and other inputs. Inherits type~~lsqr_solver_ez~~InheritsGraph type~lsqr_solver_ez lsqr_solver_ez type~lsqr_solver lsqr_solver type~lsqr_solver_ez->type~lsqr_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, private :: m = 0 number of rows in A matrix integer, private :: n = 0 number of columns in A matrix integer, private :: num_nonzero_elements = 0 number of nonzero elements in A matrix integer, private, dimension(:), allocatable :: irow sparsity row indices integer, private, dimension(:), allocatable :: icol sparsity column indices real(kind=wp), private, dimension(:), allocatable :: a sparse A matrix real(kind=wp), private :: atol = zero relative error in definition of A real(kind=wp), private :: btol = zero relative error in definition of b real(kind=wp), private :: conlim = zero An upper limit on cond(Abar) , the apparent\ncondition number of the matrix Abar . integer, private :: itnlim = 100 max iterations integer, private :: nout = 0 output unit for printing real(kind=wp), private, dimension(:), allocatable :: Ax A*x (dimension m) real(kind=wp), private, dimension(:), allocatable :: Aty A(transpose)*y (dimension n) real(kind=wp), private, dimension(:), allocatable :: v workspace array (dimension n) real(kind=wp), private, dimension(:), allocatable :: w workspace array (dimension n) Type-Bound Procedures procedure, public :: lsqr => LSQR main solver routine private  subroutine LSQR (me, m, n, damp, wantse, u, v, w, x, se, atol, btol, conlim, itnlim, nout, istop, itn, anorm, acond, rnorm, arnorm, xnorm) LSQR finds a solution to the following problems: Read more… Arguments Type Intent Optional Attributes Name class( lsqr_solver ), intent(inout) :: me integer, intent(in) :: m the number of rows in A . integer, intent(in) :: n the number of columns in A . real(kind=wp), intent(in) :: damp The damping parameter for problem 3 above.\n(damp should be 0.0 for problems 1 and 2.)\nIf the system A*x = b is incompatible, values\nof damp in the range 0 to sqrt(relpr)*norm(A) will probably have a negligible effect.\nLarger values of damp will tend to decrease\nthe norm of x and reduce the number of\niterations required by LSQR. Read more… logical, intent(in) :: wantse A logical variable to say if the array se(*) of standard error estimates should be computed.\nIf m > n or damp > 0 ,  the system is\noverdetermined and the standard errors may be\nuseful.  (See the first LSQR reference.)\nOtherwise ( m <= n and damp = 0 ) they do not\nmean much.  Some time and storage can be saved\nby setting wantse = .false. and using any\nconvenient array for se(*) , which won't be\ntouched. real(kind=wp), intent(inout) :: u (m) The rhs vector b .  Beware that u is\nover-written by LSQR. real(kind=wp), intent(inout) :: v (n) workspace real(kind=wp), intent(inout) :: w (n) workspace real(kind=wp), intent(out) :: x (n) Returns the computed solution x . real(kind=wp), intent(out), dimension(*) :: se If wantse is true, the dimension of se must be n or more. se(*) then returns standard error\nestimates for the components of x .\nFor each i , se(i) is set to the value rnorm * sqrt( sigma(i,i) / t ) ,\nwhere sigma(i,i) is an estimate of the i-th\ndiagonal of the inverse of Abar(transpose)*Abar and:\n* t = 1      if  m <= n * t = m - n  if  m > n  and  damp = 0 * t = m      if  damp /= 0 Read more… real(kind=wp), intent(in) :: atol An estimate of the relative error in the data\ndefining the matrix A .  For example,\nif A is accurate to about 6 digits, set atol = 1.0e-6 . real(kind=wp), intent(in) :: btol An estimate of the relative error in the data\ndefining the rhs vector b .  For example,\nif b is accurate to about 6 digits, set btol = 1.0e-6 . real(kind=wp), intent(in) :: conlim An upper limit on cond(Abar) , the apparent\ncondition number of the matrix Abar .\nIterations will be terminated if a computed\nestimate of cond(Abar) exceeds conlim .\nThis is intended to prevent certain small or\nzero singular values of A or Abar from\ncoming into effect and causing unwanted growth\nin the computed solution. Read more… integer, intent(in) :: itnlim An upper limit on the number of iterations.\nSuggested value:\n* itnlim = n/2 for well-conditioned systems\n  with clustered singular values,\n* itnlim = 4*n otherwise. integer, intent(in) :: nout File number for printed output.  If nonzero,\na summary will be printed on file nout . integer, intent(out) :: istop An integer giving the reason for termination: Read more… integer, intent(out) :: itn The number of iterations performed. real(kind=wp), intent(out) :: anorm An estimate of the Frobenius norm of Abar .\nThis is the square-root of the sum of squares\nof the elements of Abar .\nIf damp is small and if the columns of A have all been scaled to have length 1.0, anorm should increase to roughly sqrt(n) .\nA radically different value for anorm may\nindicate an error in subroutine aprod (there\nmay be an inconsistency between modes 1 and 2). real(kind=wp), intent(out) :: acond An estimate of cond(Abar) , the condition\nnumber of Abar .  A very high value of acond may again indicate an error in aprod . real(kind=wp), intent(out) :: rnorm An estimate of the final value of norm(rbar) ,\nthe function being minimized (see notation\nabove).  This will be small if A*x = b has\na solution. real(kind=wp), intent(out) :: arnorm An estimate of the final value of norm( Abar(transpose)*rbar ) , the norm of\nthe residual for the usual normal equations.\nThis should be small in all cases.  (arnorm\nwill often be smaller than the true value\ncomputed from the output vector x .) real(kind=wp), intent(out) :: xnorm An estimate of the norm of the final\nsolution vector x . procedure, public :: acheck private  subroutine acheck (me, m, n, nout, eps, v, w, x, y, inform) Checks the two modes of aprod for LSQR . Read more… Arguments Type Intent Optional Attributes Name class( lsqr_solver ), intent(inout) :: me integer, intent(in) :: m No. of rows of A. integer, intent(in) :: n No. of columns of A. integer, intent(in) :: nout A file number for printed output. real(kind=wp), intent(in) :: eps The machine precision. real(kind=wp) :: v (n) real(kind=wp) :: w (m) real(kind=wp) :: x (n) real(kind=wp) :: y (m) integer, intent(out) :: inform Error indicator.\ninform = 0 if aprod seems to be\nconsistent.\ninform = 1 otherwise. procedure, public :: xcheck private  subroutine xcheck (me, m, n, nout, anorm, damp, eps, b, u, v, w, x, inform, test1, test2, test3) Tests if x solves a certain least-squares problem. Read more… Arguments Type Intent Optional Attributes Name class( lsqr_solver ), intent(inout) :: me integer, intent(in) :: m The number of rows in A. integer, intent(in) :: n The number of columns in A. integer, intent(in) :: nout A file number for printed output.\nIf nout = 0, nothing is printed. real(kind=wp), intent(in) :: anorm An estimate of norm(A) or\nnorm( A, delta*I ) if delta > 0.\nNormally this will be available\nfrom LSQR or CRAIG. real(kind=wp), intent(in) :: damp Possibly defines a damped problem. real(kind=wp), intent(in) :: eps Machine precision. real(kind=wp), intent(in) :: b (m) The right-hand side of Ax = b etc. real(kind=wp), intent(out) :: u (m) On exit, u = r (where r = b - Ax). real(kind=wp), intent(out) :: v (n) On exit, v = A'r. real(kind=wp), intent(out) :: w (n) On exit, w = A'r - damp&#94;2 x. real(kind=wp), intent(in) :: x (n) The given estimate of a solution. integer, intent(out) :: inform inform = 0 if b = 0 and x = 0.\ninform = 1, 2 or 3 if x seems to\nsolve systems 1 2 or 3 above. real(kind=wp), intent(out) :: test1 These are dimensionless quantities\nthat should be \"small\" if x does\nseem to solve one of the systems.\n\"small\" means less than\ntol = eps**power, where power is\ndefined as a parameter below. real(kind=wp), intent(out) :: test2 These are dimensionless quantities\nthat should be \"small\" if x does\nseem to solve one of the systems.\n\"small\" means less than\ntol = eps**power, where power is\ndefined as a parameter below. real(kind=wp), intent(out) :: test3 These are dimensionless quantities\nthat should be \"small\" if x does\nseem to solve one of the systems.\n\"small\" means less than\ntol = eps**power, where power is\ndefined as a parameter below. procedure, public :: initialize => initialize_ez Constructor. Must be call first. private  subroutine initialize_ez (me, m, n, a, irow, icol, atol, btol, conlim, itnlim, nout) Constructor for lsqr_solver_ez . Arguments Type Intent Optional Attributes Name class( lsqr_solver_ez ), intent(out) :: me integer, intent(in) :: m number of rows in A matrix integer, intent(in) :: n number of columns in A matrix real(kind=wp), intent(in), dimension(:) :: a nonzero elements of A integer, intent(in), dimension(:) :: irow row indices of nonzero elements of A integer, intent(in), dimension(:) :: icol column indices of nonzero elements of A real(kind=wp), intent(in), optional :: atol relative error in definition of A real(kind=wp), intent(in), optional :: btol relative error in definition of b real(kind=wp), intent(in), optional :: conlim An upper limit on cond(Abar) , the apparent\ncondition number of the matrix Abar . integer, intent(in), optional :: itnlim max iterations integer, intent(in), optional :: nout output unit for printing procedure, public :: solve => solve_ez private  subroutine solve_ez (me, b, damp, x, istop, se, itn, anorm, acond, rnorm, arnorm, xnorm) Wrapper for LSQR for the easy version of the class. Arguments Type Intent Optional Attributes Name class( lsqr_solver_ez ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%m) :: b real(kind=wp), intent(in) :: damp real(kind=wp), intent(out), dimension(me%n) :: x the computed solution x . integer, intent(out) :: istop exit code (see LSQR ). real(kind=wp), intent(out), optional, dimension(me%n) :: se integer, intent(out), optional :: itn real(kind=wp), intent(out), optional :: anorm real(kind=wp), intent(out), optional :: acond real(kind=wp), intent(out), optional :: rnorm real(kind=wp), intent(out), optional :: arnorm real(kind=wp), intent(out), optional :: xnorm procedure, public :: aprod => aprod_ez internal routine private  subroutine aprod_ez (me, mode, m, n, x, y) The internal aprod function for the lsqr_solver_ez class. Arguments Type Intent Optional Attributes Name class( lsqr_solver_ez ), intent(inout) :: me integer, intent(in) :: mode Read more… integer, intent(in) :: m number of rows in A matrix integer, intent(in) :: n number of columns in A matrix real(kind=wp), intent(inout), dimension(:) :: x [n] real(kind=wp), intent(inout), dimension(:) :: y [m] Source Code type , public , extends ( lsqr_solver ) :: lsqr_solver_ez !! a simplier version of [[lsqr_solver]] where !! the `aprod` function is provided internally. !! To use, first call the `initialize` method !! to set the matrix and other inputs. private integer :: m = 0 !! number of rows in `A` matrix integer :: n = 0 !! number of columns in `A` matrix integer :: num_nonzero_elements = 0 !! number of nonzero elements in `A` matrix integer , dimension (:), allocatable :: irow !! sparsity row indices integer , dimension (:), allocatable :: icol !! sparsity column indices real ( wp ), dimension (:), allocatable :: a !! sparse `A` matrix real ( wp ) :: atol = zero !! relative error in definition of `A` real ( wp ) :: btol = zero !! relative error in definition of `b` real ( wp ) :: conlim = zero !! An upper limit on `cond(Abar)`, the apparent !! condition number of the matrix `Abar`. integer :: itnlim = 100 !! max iterations integer :: nout = 0 !! output unit for printing ! used in aprod_ez: real ( wp ), dimension (:), allocatable :: Ax !! `A*x` (dimension m) real ( wp ), dimension (:), allocatable :: Aty !! `A(transpose)*y` (dimension n) real ( wp ), dimension (:), allocatable :: v !! workspace array (dimension n) real ( wp ), dimension (:), allocatable :: w !! workspace array (dimension n) contains private procedure , public :: initialize => initialize_ez !! Constructor. Must be call first. procedure , public :: solve => solve_ez procedure , public :: aprod => aprod_ez !! internal routine end type lsqr_solver_ez","tags":"","loc":"type/lsqr_solver_ez.html"},{"title":"mapping – AoC-2023 ","text":"type :: mapping Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(:), allocatable :: dest_start integer(kind=ip), public, dimension(:), allocatable :: dest_end integer(kind=ip), public, dimension(:), allocatable :: src_start integer(kind=ip), public, dimension(:), allocatable :: src_end Source Code type :: mapping ! save the source and destination start and end values integer ( ip ), dimension (:), allocatable :: dest_start , dest_end , src_start , src_end end type mapping","tags":"","loc":"type/mapping.html"},{"title":"part – AoC-2023 ","text":"type :: part Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(4) :: xmas Source Code type :: part integer ( ip ), dimension ( 4 ) :: xmas ! [x,m,a,s] end type part","tags":"","loc":"type/part~2.html"},{"title":"rule – AoC-2023 ","text":"type :: rule Inherited by type~~rule~2~~InheritedByGraph type~rule~2 rule type~workflow~2 workflow type~workflow~2->type~rule~2 rules Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, public :: accept = .false. logical, public :: reject = .false. integer, public :: operator = 0 integer, public :: operator_arg = 0 integer, public :: operator_val = 0 character(len=:), public, allocatable :: goto Source Code type :: rule logical :: accept = . false . logical :: reject = . false . integer :: operator = 0 ! 1:<, 2:> integer :: operator_arg = 0 ! 1:x, 2:m, 3:a, 4:s integer :: operator_val = 0 ! value to compare to character ( len = :), allocatable :: goto ! where to next (workflow name) end type rule","tags":"","loc":"type/rule~2.html"},{"title":"workflow – AoC-2023 ","text":"type :: workflow Inherits type~~workflow~2~~InheritsGraph type~workflow~2 workflow type~rule~2 rule type~workflow~2->type~rule~2 rules Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name type( rule ), public, dimension(:), allocatable :: rules Source Code type :: workflow character ( len = :), allocatable :: name type ( rule ), dimension (:), allocatable :: rules end type workflow","tags":"","loc":"type/workflow~2.html"},{"title":"func – AoC-2023","text":"interface private  function func(x) result(f) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x indep. variable Return Value real(kind=wp) function value f(x) Description interface for user function","tags":"","loc":"interface/func.html"},{"title":"func_func – AoC-2023","text":"interface private  subroutine func_func(me, x, f) Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: f Description compute the function","tags":"","loc":"interface/func_func.html"},{"title":"grad_func – AoC-2023","text":"interface private  subroutine grad_func(me, x, g) Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:,:) :: g Description compute the gradient of the function (Jacobian). Dense version.","tags":"","loc":"interface/grad_func.html"},{"title":"grad_func_sparse – AoC-2023","text":"interface private  subroutine grad_func_sparse(me, x, g) Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: g sparse jacobian. length is n_nonzeros Description compute the gradient of the function (Jacobian). Sparse version.","tags":"","loc":"interface/grad_func_sparse.html"},{"title":"export_func – AoC-2023","text":"interface private  subroutine export_func(me, x, f, iter) Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: f integer, intent(in) :: iter iteration number Description export an iteration:","tags":"","loc":"interface/export_func.html"},{"title":"wait_func – AoC-2023","text":"interface private  subroutine wait_func(me, user_stop) Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me logical, intent(out) :: user_stop Description enable a user-triggered stop of the iterations:","tags":"","loc":"interface/wait_func.html"},{"title":"linesearch_func – AoC-2023","text":"interface private  subroutine linesearch_func(me, xold, p, x, f, fvec, fjac, fjac_sparse) Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: xold previous value of x real(kind=wp), intent(in), dimension(me%n) :: p search direction real(kind=wp), intent(out), dimension(me%n) :: x new x real(kind=wp), intent(inout) :: f real(kind=wp), intent(inout), dimension(me%m) :: fvec real(kind=wp), intent(in), optional, dimension(:,:) :: fjac jacobian matrix [dense] real(kind=wp), intent(in), optional, dimension(:) :: fjac_sparse jacobian matrix [sparse] Description line search method. Note that not all inputs/outputs are\nused by all methods.","tags":"","loc":"interface/linesearch_func.html"},{"title":"func – AoC-2023","text":"interface private  function func(me, x) result(fx) Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me real(kind=wp), intent(in) :: x Return Value real(kind=wp) Description interface to function for diff","tags":"","loc":"interface/func~2.html"},{"title":"func – AoC-2023","text":"interface private  subroutine func(me, x, f, funcs_to_compute) Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x array of variables (size n ) real(kind=wp), intent(out), dimension(:) :: f array of functions (size m ) integer, intent(in), dimension(:) :: funcs_to_compute the elements of the\nfunction vector that need\nto be computed (the other\nare ignored) Description The function (vector array of output functions f , computed\nfrom a vector of input variables x ).\nThis must be defined for all computations.","tags":"","loc":"interface/func~3.html"},{"title":"spars_f – AoC-2023","text":"interface private  subroutine spars_f(me, x) Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) Description The function to compute the sparsity pattern.\nIt populates the irow and icol variables in the class.","tags":"","loc":"interface/spars_f.html"},{"title":"info_f – AoC-2023","text":"interface private  subroutine info_f(me, column, i, x) Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in), dimension(:) :: column the columns being computed. integer, intent(in) :: i perturbing these columns for the i th time (1,2,...) real(kind=wp), intent(in), dimension(:) :: x the nominal variable vector Description User-defined info function (optional).\nInforms user what is being done during Jacobian computation.\nIt can be used to perform any setup operations that need to\ndone on the user's end.","tags":"","loc":"interface/info_f.html"},{"title":"jacobian_f – AoC-2023","text":"interface private  subroutine jacobian_f(me, x, dx, jac) Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0) for each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector (size num_nonzero_elements ) Description Actual function for computing the Jacobian\ncalled by compute_jacobian .","tags":"","loc":"interface/jacobian_f.html"},{"title":"aprod_func – AoC-2023","text":"interface private  subroutine aprod_func(me, mode, m, n, x, y) Arguments Type Intent Optional Attributes Name class( lsqr_solver ), intent(inout) :: me integer, intent(in) :: mode If mode = 1 , compute y = y + A*x . y should be altered without changing x. If mode = 2 , compute x = x + A(transpose)*y . x should be altered without changing y . integer, intent(in) :: m number of rows in A matrix integer, intent(in) :: n number of columns in A matrix real(kind=wp), intent(inout), dimension(:) :: x real(kind=wp), intent(inout), dimension(:) :: y Description User function to access the sparse matrix A .","tags":"","loc":"interface/aprod_func.html"},{"title":"char_to_int – AoC-2023","text":"private pure function char_to_int(str) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer Called by proc~~char_to_int~~CalledByGraph proc~char_to_int aoc_utilities::char_to_int interface~int aoc_utilities::int interface~int->proc~char_to_int proc~char_array_to_int aoc_utilities::char_array_to_int interface~int->proc~char_array_to_int proc~char_array_to_int->proc~char_to_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function char_to_int ( str ) result ( i ) character ( len =* ), intent ( in ) :: str integer :: i read ( str , * ) i end function char_to_int","tags":"","loc":"proc/char_to_int.html"},{"title":"string_to_int – AoC-2023","text":"private pure elemental function string_to_int(me) result(i) Basic string to integer routine Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer Called by proc~~string_to_int~~CalledByGraph proc~string_to_int aoc_utilities::string%string_to_int interface~int aoc_utilities::int interface~int->proc~string_to_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental function string_to_int ( me ) result ( i ) class ( string ), intent ( in ) :: me integer :: i i = int ( me % str ) end function string_to_int","tags":"","loc":"proc/string_to_int.html"},{"title":"string_to_int_64 – AoC-2023","text":"private pure elemental function string_to_int_64(me) result(i) Basic string to integer routine Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer(kind=ip) Source Code pure elemental function string_to_int_64 ( me ) result ( i ) class ( string ), intent ( in ) :: me integer ( ip ) :: i i = int ( me % str , ip ) end function string_to_int_64","tags":"","loc":"proc/string_to_int_64.html"},{"title":"char_to_int64 – AoC-2023","text":"private pure function char_to_int64(str, kind) result(i) Basic string to integer(ip) routine.\nHacky hack just so we can overload as int() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: kind Return Value integer(kind=ip) Called by proc~~char_to_int64~~CalledByGraph proc~char_to_int64 aoc_utilities::char_to_int64 interface~int aoc_utilities::int interface~int->proc~char_to_int64 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function char_to_int64 ( str , kind ) result ( i ) character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: kind integer ( ip ) :: i if ( kind /= ip ) error stop 'error' read ( str , * ) i end function char_to_int64","tags":"","loc":"proc/char_to_int64.html"},{"title":"char_array_to_int – AoC-2023","text":"private pure function char_array_to_int(str_array) result(i) Character array to integer routine Arguments Type Intent Optional Attributes Name character(len=1), intent(in), dimension(:) :: str_array example ['1','3'] --> 13 Return Value integer Calls proc~~char_array_to_int~~CallsGraph proc~char_array_to_int aoc_utilities::char_array_to_int proc~char_to_int aoc_utilities::char_to_int proc~char_array_to_int->proc~char_to_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~char_array_to_int~~CalledByGraph proc~char_array_to_int aoc_utilities::char_array_to_int interface~int aoc_utilities::int interface~int->proc~char_array_to_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function char_array_to_int ( str_array ) result ( i ) character ( len = 1 ), dimension (:), intent ( in ) :: str_array !! example ['1','3'] --> 13 integer :: i character ( len = :), allocatable :: str integer :: k str = '' do k = 1 , size ( str_array ) str = str // str_array ( k ) end do i = char_to_int ( str ) end function char_array_to_int","tags":"","loc":"proc/char_array_to_int.html"},{"title":"int_array_to_char_array – AoC-2023","text":"public pure function int_array_to_char_array(iarray) result(carray) integer array to Character array Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: iarray Return Value character(len=1), dimension(:,:), allocatable Source Code pure function int_array_to_char_array ( iarray ) result ( carray ) integer , dimension (:,:), intent ( in ) :: iarray character ( len = 1 ), dimension (:,:), allocatable :: carray integer :: i , j allocate ( carray ( size ( iarray , 1 ), size ( iarray , 2 ))) do i = 1 , size ( iarray , 1 ) do j = 1 , size ( iarray , 2 ) write ( carray ( i , j ), '(I1)' ) iarray ( i , j ) end do end do end function int_array_to_char_array","tags":"","loc":"proc/int_array_to_char_array.html"},{"title":"read_file_to_char_array – AoC-2023","text":"public  function read_file_to_char_array(filename, border) result(array) Read a file into a 2d character array. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=1), intent(in), optional :: border if true, extra border is added with this char Return Value character(len=1), dimension(:,:), allocatable Calls proc~~read_file_to_char_array~~CallsGraph proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_file_to_char_array~~CalledByGraph proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~go~4 problem_23::go proc~go~4->proc~read_file_to_char_array proc~go~7 problem_11::go proc~go~7->proc~read_file_to_char_array program~problem_10 problem_10 program~problem_10->proc~read_file_to_char_array program~problem_16 problem_16 program~problem_16->proc~read_file_to_char_array program~problem_21 problem_21 program~problem_21->proc~read_file_to_char_array program~problem_3 problem_3 program~problem_3->proc~read_file_to_char_array program~problem_11 problem_11 program~problem_11->proc~go~7 program~problem_23 problem_23 program~problem_23->proc~go~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function read_file_to_char_array ( filename , border ) result ( array ) character ( len =* ), intent ( in ) :: filename character ( len = 1 ), intent ( in ), optional :: border !! if true, extra border is added with this char character ( len = 1 ), dimension (:,:), allocatable :: array integer :: i , j , iunit , n_lines , n_cols character ( len = :), allocatable :: line open ( newunit = iunit , file = filename , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) line = read_line ( iunit ); n_cols = len ( line ) rewind ( iunit ) if ( present ( border )) then allocate ( array ( 0 : n_lines + 1 , 0 : n_cols + 1 )) ! padding with border array = border else allocate ( array ( n_lines , n_cols )) end if do i = 1 , n_lines line = read_line ( iunit ) do j = 1 , n_cols array ( i , j ) = line ( j : j ) end do end do close ( iunit ) end function read_file_to_char_array","tags":"","loc":"proc/read_file_to_char_array.html"},{"title":"read_file_to_int_array – AoC-2023","text":"public  function read_file_to_int_array(filename) result(array) Read a file into a 2d character array. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer, dimension(:,:), allocatable Calls proc~~read_file_to_int_array~~CallsGraph proc~read_file_to_int_array aoc_utilities::read_file_to_int_array proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_int_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_int_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_file_to_int_array~~CalledByGraph proc~read_file_to_int_array aoc_utilities::read_file_to_int_array program~problem_17 problem_17 program~problem_17->proc~read_file_to_int_array program~problem_17~2 problem_17 program~problem_17~2->proc~read_file_to_int_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function read_file_to_int_array ( filename ) result ( array ) character ( len =* ), intent ( in ) :: filename integer , dimension (:,:), allocatable :: array integer :: i , iunit , n_lines , n_cols character ( len = :), allocatable :: line open ( newunit = iunit , file = filename , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) line = read_line ( iunit ) n_cols = len ( line ) rewind ( iunit ) allocate ( array ( n_lines , n_cols )) do i = 1 , n_lines line = read_line ( iunit ) read ( line , '(*(I1))' ) array ( i , 1 : n_cols ) end do close ( iunit ) end function read_file_to_int_array","tags":"","loc":"proc/read_file_to_int_array.html"},{"title":"read_file_to_integer_array – AoC-2023","text":"public  function read_file_to_integer_array(filename) result(iarray) Read a file into an integer array (one element per line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer, dimension(:), allocatable Calls proc~~read_file_to_integer_array~~CallsGraph proc~read_file_to_integer_array aoc_utilities::read_file_to_integer_array proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_integer_array->proc~number_of_lines_in_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function read_file_to_integer_array ( filename ) result ( iarray ) character ( len =* ), intent ( in ) :: filename integer , dimension (:), allocatable :: iarray integer :: i , iunit , n_lines , istat open ( newunit = iunit , file = filename , iostat = istat ) if ( istat /= 0 ) error stop ' error reading file' n_lines = number_of_lines_in_file ( iunit ) allocate ( iarray ( n_lines )) do i = 1 , n_lines read ( iunit , '(I10)' ) iarray ( i ) end do close ( iunit ) end function read_file_to_integer_array","tags":"","loc":"proc/read_file_to_integer_array.html"},{"title":"read_file_to_integer64_array – AoC-2023","text":"public  function read_file_to_integer64_array(filename) result(iarray) Read a file into an ip integer array (one element per line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer(kind=ip), dimension(:), allocatable Calls proc~~read_file_to_integer64_array~~CallsGraph proc~read_file_to_integer64_array aoc_utilities::read_file_to_integer64_array proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_integer64_array->proc~number_of_lines_in_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function read_file_to_integer64_array ( filename ) result ( iarray ) character ( len =* ), intent ( in ) :: filename integer ( ip ), dimension (:), allocatable :: iarray integer :: i , iunit , n_lines , istat open ( newunit = iunit , file = filename , iostat = istat ) if ( istat /= 0 ) error stop ' error reading file' n_lines = number_of_lines_in_file ( iunit ) allocate ( iarray ( n_lines )) do i = 1 , n_lines read ( iunit , * ) iarray ( i ) end do close ( iunit ) end function read_file_to_integer64_array","tags":"","loc":"proc/read_file_to_integer64_array.html"},{"title":"number_of_lines_in_file – AoC-2023","text":"public  function number_of_lines_in_file(iunit) result(n_lines) Returns the number of lines in a file (assumed to be open) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit the file unit number\n(assumed to be open) Return Value integer the number of lines in the file Called by proc~~number_of_lines_in_file~~CalledByGraph proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~go~3 problem_18::go proc~go~3->proc~number_of_lines_in_file proc~go~6 problem_12::go proc~go~6->proc~number_of_lines_in_file proc~initialize problem_22::initialize proc~initialize->proc~number_of_lines_in_file proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_file_to_int_array aoc_utilities::read_file_to_int_array proc~read_file_to_int_array->proc~number_of_lines_in_file proc~read_file_to_integer64_array aoc_utilities::read_file_to_integer64_array proc~read_file_to_integer64_array->proc~number_of_lines_in_file proc~read_file_to_integer_array aoc_utilities::read_file_to_integer_array proc~read_file_to_integer_array->proc~number_of_lines_in_file program~problem_1 problem_1 program~problem_1->proc~number_of_lines_in_file program~problem_12b problem_12b program~problem_12b->proc~number_of_lines_in_file program~problem_13 problem_13 program~problem_13->proc~number_of_lines_in_file program~problem_19 problem_19 program~problem_19->proc~number_of_lines_in_file program~problem_19b problem_19b program~problem_19b->proc~number_of_lines_in_file program~problem_2 problem_2 program~problem_2->proc~number_of_lines_in_file program~problem_25 problem_25 program~problem_25->proc~number_of_lines_in_file program~problem_4 problem_4 program~problem_4->proc~number_of_lines_in_file program~problem_5 problem_5 program~problem_5->proc~number_of_lines_in_file program~problem_7 problem_7 program~problem_7->proc~number_of_lines_in_file program~problem_8 problem_8 program~problem_8->proc~number_of_lines_in_file program~problem_9 problem_9 program~problem_9->proc~number_of_lines_in_file proc~go~4 problem_23::go proc~go~4->proc~read_file_to_char_array proc~go~7 problem_11::go proc~go~7->proc~read_file_to_char_array program~problem_10 problem_10 program~problem_10->proc~read_file_to_char_array program~problem_12 problem_12 program~problem_12->proc~go~6 program~problem_16 problem_16 program~problem_16->proc~read_file_to_char_array program~problem_17 problem_17 program~problem_17->proc~read_file_to_int_array program~problem_17~2 problem_17 program~problem_17~2->proc~read_file_to_int_array program~problem_18 problem_18 program~problem_18->proc~go~3 program~problem_21 problem_21 program~problem_21->proc~read_file_to_char_array program~problem_22 problem_22 program~problem_22->proc~initialize program~problem_3 problem_3 program~problem_3->proc~read_file_to_char_array program~problem_11 problem_11 program~problem_11->proc~go~7 program~problem_23 problem_23 program~problem_23->proc~go~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function number_of_lines_in_file ( iunit ) result ( n_lines ) integer , intent ( in ) :: iunit !! the file unit number !! (assumed to be open) integer :: n_lines !! the number of lines in the file character ( len = 1 ) :: tmp integer :: istat rewind ( iunit ) n_lines = 0 do read ( iunit , fmt = '(A1)' , iostat = istat ) tmp if ( is_iostat_end ( istat )) exit n_lines = n_lines + 1 end do rewind ( iunit ) end function number_of_lines_in_file","tags":"","loc":"proc/number_of_lines_in_file.html"},{"title":"split2 – AoC-2023","text":"private pure function split2(s, token) result(vals) Split a string , given a token. Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: s character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable Calls proc~~split2~~CallsGraph proc~split2 aoc_utilities::split2 proc~split1 aoc_utilities::split1 proc~split2->proc~split1 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~split2~~CalledByGraph proc~split2 aoc_utilities::split2 interface~split aoc_utilities::split interface~split->proc~split2 proc~go~3 problem_18::go proc~go~3->interface~split proc~go~6 problem_12::go proc~go~6->interface~split proc~initialize problem_22::initialize proc~initialize->interface~split proc~parse_nums64 aoc_utilities::parse_nums64 proc~parse_nums64->interface~split proc~parse_rule problem_19b::parse_rule proc~parse_rule->interface~split proc~parse_rule~2 problem_19::parse_rule proc~parse_rule~2->interface~split program~problem_12b problem_12b program~problem_12b->interface~split program~problem_15 problem_15 program~problem_15->interface~split program~problem_19 problem_19 program~problem_19->interface~split program~problem_19->proc~parse_rule~2 program~problem_19b problem_19b program~problem_19b->interface~split program~problem_19b->proc~parse_rule program~problem_2 problem_2 program~problem_2->interface~split program~problem_25 problem_25 program~problem_25->interface~split program~problem_4 problem_4 program~problem_4->interface~split program~problem_7 problem_7 program~problem_7->interface~split interface~parse aoc_utilities::parse interface~parse->proc~parse_nums64 program~problem_12 problem_12 program~problem_12->proc~go~6 program~problem_18 problem_18 program~problem_18->proc~go~3 program~problem_22 problem_22 program~problem_22->proc~initialize program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function split2 ( s , token ) result ( vals ) implicit none type ( string ), intent ( in ) :: s character ( len =* ), intent ( in ) :: token type ( string ), dimension (:), allocatable :: vals if ( allocated ( s % str )) then vals = split1 ( s % str , token ) else error stop 'error: string not allocated' end if end function split2","tags":"","loc":"proc/split2.html"},{"title":"split1 – AoC-2023","text":"private pure function split1(str, token) result(vals) Split a character string using a token.\n  This routine is inspired by the Python split function. Example character ( len = :), allocatable :: s type ( string ), dimension (:), allocatable :: vals s = '1,2,3,4,5' call split ( s , ',' , vals ) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable Calls proc~~split1~~CallsGraph proc~split1 aoc_utilities::split1 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~split1~~CalledByGraph proc~split1 aoc_utilities::split1 interface~split aoc_utilities::split interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~split2->proc~split1 proc~go~3 problem_18::go proc~go~3->interface~split proc~go~6 problem_12::go proc~go~6->interface~split proc~initialize problem_22::initialize proc~initialize->interface~split proc~parse_nums64 aoc_utilities::parse_nums64 proc~parse_nums64->interface~split proc~parse_rule problem_19b::parse_rule proc~parse_rule->interface~split proc~parse_rule~2 problem_19::parse_rule proc~parse_rule~2->interface~split program~problem_12b problem_12b program~problem_12b->interface~split program~problem_15 problem_15 program~problem_15->interface~split program~problem_19 problem_19 program~problem_19->interface~split program~problem_19->proc~parse_rule~2 program~problem_19b problem_19b program~problem_19b->interface~split program~problem_19b->proc~parse_rule program~problem_2 problem_2 program~problem_2->interface~split program~problem_25 problem_25 program~problem_25->interface~split program~problem_4 problem_4 program~problem_4->interface~split program~problem_7 problem_7 program~problem_7->interface~split interface~parse aoc_utilities::parse interface~parse->proc~parse_nums64 program~problem_12 problem_12 program~problem_12->proc~go~6 program~problem_18 problem_18 program~problem_18->proc~go~3 program~problem_22 problem_22 program~problem_22->proc~initialize program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function split1 ( str , token ) result ( vals ) implicit none character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ) :: token type ( string ), dimension (:), allocatable :: vals integer :: i !! counter integer :: len_str !! significant length of `str` integer :: len_token !! length of the token integer :: n_tokens !! number of tokens integer :: i1 !! index integer :: i2 !! index integer :: j !! counters integer , dimension (:), allocatable :: itokens !! start indices of the !! token locations in `str` len_token = len ( token ) ! length of the token n_tokens = 0 ! initialize the token counter j = 0 ! index to start looking for the next token ! first, count the number of times the token ! appears in the string, and get the token indices. ! ! Examples: !  ',         '    --> 1 !  '1234,67,90'    --> 5,8 !  '123,      '    --> 4 ! length of the string if ( token == ' ' ) then ! in this case, we can't ignore trailing space len_str = len ( str ) else ! safe to ignore trailing space when looking for tokens len_str = len_trim ( str ) end if j = 1 n_tokens = 0 do if ( j > len_str ) exit ! end of string, finished i = index ( str ( j :), token ) ! index of next token in remaining string if ( i <= 0 ) exit ! no more tokens found call expand_vector ( itokens , n_tokens , i + j - 1 ) ! save the token location j = j + i + ( len_token - 1 ) end do call expand_vector ( itokens , n_tokens , finished = . true .) ! resize the vector allocate ( vals ( n_tokens + 1 )) if ( n_tokens > 0 ) then len_str = len ( str ) i1 = 1 i2 = itokens ( 1 ) - 1 if ( i2 >= i1 ) then vals ( 1 )% str = str ( i1 : i2 ) else vals ( 1 )% str = '' !the first character is a token end if !      1 2 3 !    'a,b,c,d' do i = 2 , n_tokens i1 = itokens ( i - 1 ) + len_token i2 = itokens ( i ) - 1 if ( i2 >= i1 ) then vals ( i )% str = str ( i1 : i2 ) else vals ( i )% str = '' !empty element (e.g., 'abc,,def') end if end do i1 = itokens ( n_tokens ) + len_token i2 = len_str if ( itokens ( n_tokens ) + len_token <= len_str ) then vals ( n_tokens + 1 )% str = str ( i1 : i2 ) else vals ( n_tokens + 1 )% str = '' !the last character was a token end if else !no tokens present, so just return the original string: vals ( 1 )% str = str end if end function split1","tags":"","loc":"proc/split1.html"},{"title":"read_line – AoC-2023","text":"public  function read_line(iunit, status_ok) result(line) Reads the next line from a file. Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit logical, intent(out), optional :: status_ok true if no problems Return Value character(len=:), allocatable Called by proc~~read_line~~CalledByGraph proc~read_line aoc_utilities::read_line proc~go~3 problem_18::go proc~go~3->proc~read_line proc~go~6 problem_12::go proc~go~6->proc~read_line proc~initialize problem_22::initialize proc~initialize->proc~read_line proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~read_file_to_char_array->proc~read_line proc~read_file_to_int_array aoc_utilities::read_file_to_int_array proc~read_file_to_int_array->proc~read_line program~problem_1 problem_1 program~problem_1->proc~read_line program~problem_12b problem_12b program~problem_12b->proc~read_line program~problem_13 problem_13 program~problem_13->proc~read_line program~problem_15 problem_15 program~problem_15->proc~read_line program~problem_19 problem_19 program~problem_19->proc~read_line program~problem_19b problem_19b program~problem_19b->proc~read_line program~problem_2 problem_2 program~problem_2->proc~read_line program~problem_25 problem_25 program~problem_25->proc~read_line program~problem_4 problem_4 program~problem_4->proc~read_line program~problem_5 problem_5 program~problem_5->proc~read_line program~problem_7 problem_7 program~problem_7->proc~read_line program~problem_8 problem_8 program~problem_8->proc~read_line program~problem_9 problem_9 program~problem_9->proc~read_line proc~go~4 problem_23::go proc~go~4->proc~read_file_to_char_array proc~go~7 problem_11::go proc~go~7->proc~read_file_to_char_array program~problem_10 problem_10 program~problem_10->proc~read_file_to_char_array program~problem_12 problem_12 program~problem_12->proc~go~6 program~problem_16 problem_16 program~problem_16->proc~read_file_to_char_array program~problem_17 problem_17 program~problem_17->proc~read_file_to_int_array program~problem_17~2 problem_17 program~problem_17~2->proc~read_file_to_int_array program~problem_18 problem_18 program~problem_18->proc~go~3 program~problem_21 problem_21 program~problem_21->proc~read_file_to_char_array program~problem_22 problem_22 program~problem_22->proc~initialize program~problem_3 problem_3 program~problem_3->proc~read_file_to_char_array program~problem_11 problem_11 program~problem_11->proc~go~7 program~problem_23 problem_23 program~problem_23->proc~go~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function read_line ( iunit , status_ok ) result ( line ) integer , intent ( in ) :: iunit character ( len = :), allocatable :: line logical , intent ( out ), optional :: status_ok !! true if no problems integer :: nread !! character count specifier for read statement integer :: istat !! file read io status flag character ( len = chunk_size ) :: buffer !! the file read buffer nread = 0 buffer = '' line = '' if ( present ( status_ok )) status_ok = . true . do ! read in the next block of text from the line: read ( iunit , fmt = '(A)' , advance = 'NO' , size = nread , iostat = istat ) buffer if ( IS_IOSTAT_END ( istat ) . or . IS_IOSTAT_EOR ( istat )) then ! add the last block of text before the end of record if ( nread > 0 ) line = line // buffer ( 1 : nread ) exit else if ( istat == 0 ) then ! all the characters were read line = line // buffer ! add this block of text to the string else ! some kind of error if ( present ( status_ok )) then status_ok = . false . exit else error stop 'Read error' end if end if end do end function read_line","tags":"","loc":"proc/read_line.html"},{"title":"unique32 – AoC-2023","text":"private  function unique32(vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec Return Value integer, dimension(:), allocatable Calls proc~~unique32~~CallsGraph proc~unique32 aoc_utilities::unique32 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~unique32~~CalledByGraph proc~unique32 aoc_utilities::unique32 interface~unique aoc_utilities::unique interface~unique->proc~unique32 proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->interface~unique proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->interface~unique proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_pieces_above->interface~unique proc~get_pieces_below->interface~unique proc~hand_type problem_7::hand_type proc~hand_type->interface~unique program~problem_25 problem_25 program~problem_25->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_22->proc~get_pieces_above program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down program~problem_7 problem_7 program~problem_7->proc~beats proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function unique32 ( vec ) result ( vec_unique ) integer , dimension (:), intent ( in ) :: vec integer , dimension (:), allocatable :: vec_unique integer :: i , num logical , dimension ( size ( vec )) :: mask mask = . false . do i = 1 , size ( vec ) !count the number of occurrences of this element: num = count ( vec ( i ) == vec ) if ( num == 1 ) then !there is only one, flag it: mask ( i ) = . true . else !flag this value only if it hasn't already been flagged: if (. not . any ( vec ( i ) == vec . and . mask ) ) mask ( i ) = . true . end if end do !return only flagged elements: allocate ( vec_unique ( count ( mask )) ) vec_unique = pack ( vec , mask ) ! also sort it: call sort ( vec_unique ) end function unique32","tags":"","loc":"proc/unique32.html"},{"title":"unique64 – AoC-2023","text":"private  function unique64(vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: vec Return Value integer(kind=ip), dimension(:), allocatable Calls proc~~unique64~~CallsGraph proc~unique64 aoc_utilities::unique64 interface~sort aoc_utilities::sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~unique64~~CalledByGraph proc~unique64 aoc_utilities::unique64 interface~unique aoc_utilities::unique interface~unique->proc~unique64 proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->interface~unique proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->interface~unique proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_pieces_above->interface~unique proc~get_pieces_below->interface~unique proc~hand_type problem_7::hand_type proc~hand_type->interface~unique program~problem_25 problem_25 program~problem_25->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_22->proc~get_pieces_above program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down program~problem_7 problem_7 program~problem_7->proc~beats proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function unique64 ( vec ) result ( vec_unique ) integer ( ip ), dimension (:), intent ( in ) :: vec integer ( ip ), dimension (:), allocatable :: vec_unique integer ( ip ) :: i , num logical , dimension ( size ( vec )) :: mask mask = . false . do i = 1 , size ( vec ) !count the number of occurrences of this element: num = count ( vec ( i ) == vec ) if ( num == 1 ) then !there is only one, flag it: mask ( i ) = . true . else !flag this value only if it hasn't already been flagged: if (. not . any ( vec ( i ) == vec . and . mask ) ) mask ( i ) = . true . end if end do !return only flagged elements: allocate ( vec_unique ( count ( mask )) ) vec_unique = pack ( vec , mask ) ! also sort it: call sort ( vec_unique ) end function unique64","tags":"","loc":"proc/unique64.html"},{"title":"parse_ints – AoC-2023","text":"public  function parse_ints(line) result(ints) parse positive ints from a string that also includes text Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer, dimension(:), allocatable Called by proc~~parse_ints~~CalledByGraph proc~parse_ints aoc_utilities::parse_ints proc~go~6 problem_12::go proc~go~6->proc~parse_ints program~problem_12b problem_12b program~problem_12b->proc~parse_ints program~problem_4 problem_4 program~problem_4->proc~parse_ints program~problem_12 problem_12 program~problem_12->proc~go~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function parse_ints ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer , dimension (:), allocatable :: ints ! array of integers integer :: i , j , n integer :: istart character ( len =* ), parameter :: tokens = '0123456789' n = len ( line ) istart = 0 allocate ( ints ( 0 )) do i = 1 , n if ( index ( tokens , line ( i : i )) > 0 ) then if ( istart == 0 ) istart = i else if ( istart /= 0 ) ints = [ ints , int ( line ( istart : i - 1 ))] ! get previous int istart = 0 end if end do if ( istart /= 0 ) ints = [ ints , int ( line ( istart : n ))] ! get last int end function parse_ints","tags":"","loc":"proc/parse_ints.html"},{"title":"parse_ints64 – AoC-2023","text":"public  function parse_ints64(line) result(ints) Parse positive ints from a string that also includes text Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=ip), dimension(:), allocatable Called by proc~~parse_ints64~~CalledByGraph proc~parse_ints64 aoc_utilities::parse_ints64 program~problem_5 problem_5 program~problem_5->proc~parse_ints64 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function parse_ints64 ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer ( ip ), dimension (:), allocatable :: ints ! array of integers integer ( ip ) :: i , j , n integer ( ip ) :: istart character ( len =* ), parameter :: tokens = '0123456789' n = len ( line ) istart = 0 allocate ( ints ( 0 )) do i = 1 , n if ( index ( tokens , line ( i : i )) > 0 ) then if ( istart == 0 ) istart = i else if ( istart /= 0 ) ints = [ ints , int ( line ( istart : i - 1 ), kind = ip )] ! get previous int istart = 0 end if end do if ( istart /= 0 ) ints = [ ints , int ( line ( istart : n ), kind = ip )] ! get last int end function parse_ints64","tags":"","loc":"proc/parse_ints64.html"},{"title":"parse_nums64 – AoC-2023","text":"private  function parse_nums64(line) result(ints) parse space-deliminated ip sequence (positive or negative) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=ip), dimension(:), allocatable Calls proc~~parse_nums64~~CallsGraph proc~parse_nums64 aoc_utilities::parse_nums64 interface~split aoc_utilities::split proc~parse_nums64->interface~split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~parse_nums64~~CalledByGraph proc~parse_nums64 aoc_utilities::parse_nums64 interface~parse aoc_utilities::parse interface~parse->proc~parse_nums64 program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function parse_nums64 ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer ( ip ), dimension (:), allocatable :: ints ! array of integers ints = int ( split ( line , ' ' )) end function parse_nums64","tags":"","loc":"proc/parse_nums64.html"},{"title":"startswith_cc – AoC-2023","text":"private pure function startswith_cc(str, substring) starts with function for strings Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical Called by proc~~startswith_cc~~CalledByGraph proc~startswith_cc aoc_utilities::startswith_cc interface~startswith aoc_utilities::startswith interface~startswith->proc~startswith_cc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith program~problem_5 problem_5 program~problem_5->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function startswith_cc ( str , substring ) character ( len =* ), intent ( in ) :: str , substring startswith_cc = index ( str , substring ) == 1 end function startswith_cc","tags":"","loc":"proc/startswith_cc.html"},{"title":"startswith_ss – AoC-2023","text":"private pure function startswith_ss(str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str type( string ), intent(in) :: substring Return Value logical Calls proc~~startswith_ss~~CallsGraph proc~startswith_ss aoc_utilities::startswith_ss interface~startswith aoc_utilities::startswith proc~startswith_ss->interface~startswith interface~startswith->proc~startswith_ss proc~startswith_cc aoc_utilities::startswith_cc interface~startswith->proc~startswith_cc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~startswith_ss~~CalledByGraph proc~startswith_ss aoc_utilities::startswith_ss interface~startswith aoc_utilities::startswith proc~startswith_ss->interface~startswith interface~startswith->proc~startswith_ss proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith program~problem_5 problem_5 program~problem_5->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function startswith_ss ( str , substring ) type ( string ), intent ( in ) :: str , substring startswith_ss = startswith ( str % str , substring % str ) end function startswith_ss","tags":"","loc":"proc/startswith_ss.html"},{"title":"startswith_sc – AoC-2023","text":"private pure function startswith_sc(str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical Calls proc~~startswith_sc~~CallsGraph proc~startswith_sc aoc_utilities::startswith_sc interface~startswith aoc_utilities::startswith proc~startswith_sc->interface~startswith interface~startswith->proc~startswith_sc proc~startswith_cc aoc_utilities::startswith_cc interface~startswith->proc~startswith_cc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_cs->interface~startswith proc~startswith_ss->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~startswith_sc~~CalledByGraph proc~startswith_sc aoc_utilities::startswith_sc interface~startswith aoc_utilities::startswith proc~startswith_sc->interface~startswith interface~startswith->proc~startswith_sc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_cs->interface~startswith proc~startswith_ss->interface~startswith program~problem_5 problem_5 program~problem_5->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function startswith_sc ( str , substring ) type ( string ), intent ( in ) :: str character ( len =* ), intent ( in ) :: substring startswith_sc = startswith ( str % str , substring ) end function startswith_sc","tags":"","loc":"proc/startswith_sc.html"},{"title":"startswith_cs – AoC-2023","text":"private pure function startswith_cs(str, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str type( string ), intent(in) :: substring Return Value logical Calls proc~~startswith_cs~~CallsGraph proc~startswith_cs aoc_utilities::startswith_cs interface~startswith aoc_utilities::startswith proc~startswith_cs->interface~startswith interface~startswith->proc~startswith_cs proc~startswith_cc aoc_utilities::startswith_cc interface~startswith->proc~startswith_cc proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~startswith_cs~~CalledByGraph proc~startswith_cs aoc_utilities::startswith_cs interface~startswith aoc_utilities::startswith proc~startswith_cs->interface~startswith interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith program~problem_5 problem_5 program~problem_5->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function startswith_cs ( str , substring ) character ( len =* ), intent ( in ) :: str type ( string ), intent ( in ) :: substring startswith_cs = startswith ( str , substring % str ) end function startswith_cs","tags":"","loc":"proc/startswith_cs.html"},{"title":"is_number – AoC-2023","text":"public  function is_number(c) returns true if the character is a number from 0 to 9. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical Called by proc~~is_number~~CalledByGraph proc~is_number aoc_utilities::is_number proc~check~2 problem_3::check proc~check~2->proc~is_number proc~get_number problem_3::get_number proc~check~2->proc~get_number proc~is_not_number aoc_utilities::is_not_number proc~is_not_number->proc~is_number proc~is_symbol problem_3::is_symbol proc~is_symbol->proc~is_not_number program~problem_3 problem_3 program~problem_3->proc~check~2 program~problem_3->proc~is_not_number program~problem_3->proc~is_symbol program~problem_3->proc~get_number proc~get_number->proc~is_symbol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function is_number ( c ) character ( len = 1 ), intent ( in ) :: c is_number = c >= '0' . and . c <= '9' end function is_number","tags":"","loc":"proc/is_number.html"},{"title":"is_not_number – AoC-2023","text":"public  function is_not_number(c) returns true if the character is not a number. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical Calls proc~~is_not_number~~CallsGraph proc~is_not_number aoc_utilities::is_not_number proc~is_number aoc_utilities::is_number proc~is_not_number->proc~is_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~is_not_number~~CalledByGraph proc~is_not_number aoc_utilities::is_not_number proc~is_symbol problem_3::is_symbol proc~is_symbol->proc~is_not_number program~problem_3 problem_3 program~problem_3->proc~is_not_number program~problem_3->proc~is_symbol proc~get_number problem_3::get_number program~problem_3->proc~get_number proc~check~2 problem_3::check program~problem_3->proc~check~2 proc~get_number->proc~is_symbol proc~check~2->proc~get_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function is_not_number ( c ) character ( len = 1 ), intent ( in ) :: c is_not_number = . not . is_number ( c ) end function is_not_number","tags":"","loc":"proc/is_not_number.html"},{"title":"str_to_array – AoC-2023","text":"public  function str_to_array(s) result(a) convert the character string to an array of characters Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value character(len=1), dimension(len(s)) Called by proc~~str_to_array~~CalledByGraph proc~str_to_array aoc_utilities::str_to_array program~problem_7 problem_7 program~problem_7->proc~str_to_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function str_to_array ( s ) result ( a ) character ( len =* ), intent ( in ) :: s character ( len = 1 ), dimension ( len ( s )) :: a integer :: i do i = 1 , len ( s ) ! transfer a ( i ) = s ( i : i ) end do end function str_to_array","tags":"","loc":"proc/str_to_array.html"},{"title":"lcm – AoC-2023","text":"public pure function lcm(i, j) LCM. based on code from NCAR Command Language Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value integer(kind=ip) Called by proc~~lcm~~CalledByGraph proc~lcm aoc_utilities::lcm program~problem_8 problem_8 program~problem_8->proc~lcm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer ( ip ) function lcm ( i , j ) integer ( ip ), intent ( in ) :: i , j integer ( ip ) :: rem , m , n m = abs ( i ) n = abs ( j ) lcm = 0 if ( m <= 0 . or . n <= 0 ) return do rem = mod ( m , n ) if ( rem <= 0 ) exit m = n n = rem end do lcm = abs ( i * j / n ) end function lcm","tags":"","loc":"proc/lcm.html"},{"title":"reverse – AoC-2023","text":"public pure function reverse(ivals) result(ireverse) Reverse an ip vector Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals Return Value integer(kind=ip), dimension(size(ivals)) Called by proc~~reverse~~CalledByGraph proc~reverse aoc_utilities::reverse program~problem_9 problem_9 program~problem_9->proc~reverse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function reverse ( ivals ) result ( ireverse ) integer ( ip ), dimension (:), intent ( in ) :: ivals integer ( ip ), dimension ( size ( ivals )) :: ireverse integer :: i ireverse = [( ivals ( i ), i = size ( ivals ), 1 , - 1 )] end function reverse","tags":"","loc":"proc/reverse.html"},{"title":"diff – AoC-2023","text":"public pure function diff(ivals) result(idiff) Difference ip vector Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals Return Value integer(kind=ip), dimension(:), allocatable Called by proc~~diff~~CalledByGraph proc~diff aoc_utilities::diff proc~extrapolate problem_9::extrapolate proc~extrapolate->proc~diff program~problem_9 problem_9 program~problem_9->proc~extrapolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function diff ( ivals ) result ( idiff ) integer ( ip ), dimension (:), intent ( in ) :: ivals integer ( ip ), dimension (:), allocatable :: idiff integer :: i !! counter idiff = [( ivals ( i + 1 ) - ivals ( i ), i = 1 , size ( ivals ) - 1 )] end function diff","tags":"","loc":"proc/diff.html"},{"title":"parea – AoC-2023","text":"public  function parea(x, y, nb) given a sequence of nb points (x(i),y(i)). parea computes\nthe area bounded by the closed polygonal curve which passes\nthrough the points in the order that they are indexed. the\nfinal point of the curve is assumed to be the first point\ngiven. therefore, it need not be listed at the end of x and\ny. the curve is not required to be simple. Original version from the NSWC Library Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (nb) real(kind=wp), intent(in) :: y (nb) integer, intent(in) :: nb Return Value real(kind=wp) Called by proc~~parea~~CalledByGraph proc~parea aoc_utilities::parea proc~go~3 problem_18::go proc~go~3->proc~parea program~problem_18 problem_18 program~problem_18->proc~go~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code real ( wp ) function parea ( x , y , nb ) real ( wp ), intent ( in ) :: x ( nb ), y ( nb ) integer , intent ( in ) :: nb real ( wp ) :: a integer :: n , nm1 , i n = nb if ( x ( 1 ) == x ( n ) . and . y ( 1 ) == y ( n )) n = n - 1 if ( n - 3 < 0 ) then parea = 0.0_wp else if ( n - 3 == 0 ) then parea = 0.5_wp * (( x ( 2 ) - x ( 1 )) * ( y ( 3 ) - y ( 1 )) - ( x ( 3 ) - x ( 1 )) * ( y ( 2 ) - y ( 1 ))) else nm1 = n - 1 a = x ( 1 ) * ( y ( 2 ) - y ( n )) + x ( n ) * ( y ( 1 ) - y ( nm1 )) do i = 2 , nm1 a = a + x ( i ) * ( y ( i + 1 ) - y ( i - 1 )) end do parea = 0.5_wp * a end if end function parea","tags":"","loc":"proc/parea.html"},{"title":"manhatten_distance_64 – AoC-2023","text":"private pure function manhatten_distance_64(x1, y1, x2, y2) Manhattan distance between two ip points. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: x1 integer(kind=ip), intent(in) :: y1 integer(kind=ip), intent(in) :: x2 integer(kind=ip), intent(in) :: y2 Return Value integer(kind=ip) Called by proc~~manhatten_distance_64~~CalledByGraph proc~manhatten_distance_64 aoc_utilities::manhatten_distance_64 interface~manhatten_distance aoc_utilities::manhatten_distance interface~manhatten_distance->proc~manhatten_distance_64 proc~go~7 problem_11::go proc~go~7->interface~manhatten_distance program~problem_11 problem_11 program~problem_11->proc~go~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer ( ip ) function manhatten_distance_64 ( x1 , y1 , x2 , y2 ) integer ( ip ), intent ( in ) :: x1 , y1 , x2 , y2 manhatten_distance_64 = abs ( x1 - x2 ) + abs ( y1 - y2 ) end function manhatten_distance_64","tags":"","loc":"proc/manhatten_distance_64.html"},{"title":"str_to_int_array_with_mapping – AoC-2023","text":"public pure function str_to_int_array_with_mapping(str, ichars, iints) result(array) Convert a string to a numeric array by mapping characters to integers (user-specified) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=1), intent(in), dimension(:) :: ichars characters to process integer, intent(in), dimension(:) :: iints int values of the chars Return Value integer, dimension(:), allocatable Called by proc~~str_to_int_array_with_mapping~~CalledByGraph proc~str_to_int_array_with_mapping aoc_utilities::str_to_int_array_with_mapping proc~go~6 problem_12::go proc~go~6->proc~str_to_int_array_with_mapping program~problem_13 problem_13 program~problem_13->proc~str_to_int_array_with_mapping program~problem_12 problem_12 program~problem_12->proc~go~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function str_to_int_array_with_mapping ( str , ichars , iints ) result ( array ) character ( len =* ), intent ( in ) :: str character ( len = 1 ), dimension (:), intent ( in ) :: ichars !! characters to process integer , dimension (:), intent ( in ) :: iints !! int values of the chars integer , dimension (:), allocatable :: array integer :: i integer , dimension ( 1 ) :: iloc allocate ( array ( len ( str ))) do i = 1 , len ( str ) iloc = findloc ( ichars , str ( i : i )) if ( iloc ( 1 ) > 0 ) then array ( i ) = iints ( iloc ( 1 )) else error stop 'error: could not map character: ' // str ( i : i ) end if end do end function str_to_int_array_with_mapping","tags":"","loc":"proc/str_to_int_array_with_mapping.html"},{"title":"str_to_int64_array_with_mapping – AoC-2023","text":"public pure function str_to_int64_array_with_mapping(str, ichars, iints) result(array) Convert a string to a numeric array by mapping characters to integers (user-specified) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=1), intent(in), dimension(:) :: ichars characters to process integer(kind=ip), intent(in), dimension(:) :: iints int values of the chars Return Value integer(kind=ip), dimension(:), allocatable Called by proc~~str_to_int64_array_with_mapping~~CalledByGraph proc~str_to_int64_array_with_mapping aoc_utilities::str_to_int64_array_with_mapping program~problem_12b problem_12b program~problem_12b->proc~str_to_int64_array_with_mapping Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function str_to_int64_array_with_mapping ( str , ichars , iints ) result ( array ) character ( len =* ), intent ( in ) :: str character ( len = 1 ), dimension (:), intent ( in ) :: ichars !! characters to process integer ( ip ), dimension (:), intent ( in ) :: iints !! int values of the chars integer ( ip ), dimension (:), allocatable :: array integer :: i integer , dimension ( 1 ) :: iloc allocate ( array ( len ( str ))) do i = 1 , len ( str ) iloc = findloc ( ichars , str ( i : i )) if ( iloc ( 1 ) > 0 ) then array ( i ) = iints ( iloc ( 1 )) else error stop 'error: could not map character: ' // str ( i : i ) end if end do end function str_to_int64_array_with_mapping","tags":"","loc":"proc/str_to_int64_array_with_mapping.html"},{"title":"hex2int – AoC-2023","text":"public pure function hex2int(hex) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: hex Return Value integer Called by proc~~hex2int~~CalledByGraph proc~hex2int aoc_utilities::hex2int proc~go~3 problem_18::go proc~go~3->proc~hex2int program~problem_18 problem_18 program~problem_18->proc~go~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer function hex2int ( hex ) character ( len =* ), intent ( in ) :: hex integer :: i , n , ipower ! 70c71 -> 461937 n = len ( hex ) hex2int = 0 !base 16 (0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f) ipower = - 1 do i = n , 1 , - 1 ipower = ipower + 1 associate ( c => hex ( i : i )) if ( c >= 'a' . and . c <= 'f' ) then hex2int = hex2int + ( 10 + iachar ( c ) - iachar ( 'a' )) * ( 16 ** ipower ) else hex2int = hex2int + ( iachar ( c ) - iachar ( '0' )) * ( 16 ** ipower ) end if end associate end do end function hex2int","tags":"","loc":"proc/hex2int.html"},{"title":"cross – AoC-2023","text":"public pure function cross(r, v) result(c) Cross product of two real 3x1 vectors Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r real(kind=wp), intent(in), dimension(3) :: v Return Value real(kind=wp), dimension(3) Source Code pure function cross ( r , v ) result ( c ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r real ( wp ), dimension ( 3 ), intent ( in ) :: v real ( wp ), dimension ( 3 ) :: c c ( 1 ) = r ( 2 ) * v ( 3 ) - v ( 2 ) * r ( 3 ) c ( 2 ) = r ( 3 ) * v ( 1 ) - v ( 3 ) * r ( 1 ) c ( 3 ) = r ( 1 ) * v ( 2 ) - v ( 1 ) * r ( 2 ) end function cross","tags":"","loc":"proc/cross.html"},{"title":"clock_start – AoC-2023","text":"private  subroutine clock_start(me) Start the clock Type Bound clock Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me Called by proc~~clock_start~~CalledByGraph proc~clock_start aoc_utilities::clock%clock_start program~problem_1 problem_1 program~problem_1->proc~clock_start program~problem_10 problem_10 program~problem_10->proc~clock_start program~problem_11 problem_11 program~problem_11->proc~clock_start program~problem_12 problem_12 program~problem_12->proc~clock_start program~problem_12b problem_12b program~problem_12b->proc~clock_start program~problem_13 problem_13 program~problem_13->proc~clock_start program~problem_15 problem_15 program~problem_15->proc~clock_start program~problem_16 problem_16 program~problem_16->proc~clock_start program~problem_17 problem_17 program~problem_17->proc~clock_start program~problem_17~2 problem_17 program~problem_17~2->proc~clock_start program~problem_18 problem_18 program~problem_18->proc~clock_start program~problem_19 problem_19 program~problem_19->proc~clock_start program~problem_19b problem_19b program~problem_19b->proc~clock_start program~problem_2 problem_2 program~problem_2->proc~clock_start program~problem_21 problem_21 program~problem_21->proc~clock_start program~problem_22 problem_22 program~problem_22->proc~clock_start program~problem_23 problem_23 program~problem_23->proc~clock_start program~problem_25 problem_25 program~problem_25->proc~clock_start program~problem_3 problem_3 program~problem_3->proc~clock_start program~problem_4 problem_4 program~problem_4->proc~clock_start program~problem_5 problem_5 program~problem_5->proc~clock_start program~problem_6 problem_6 program~problem_6->proc~clock_start program~problem_7 problem_7 program~problem_7->proc~clock_start program~problem_8 problem_8 program~problem_8->proc~clock_start program~problem_9 problem_9 program~problem_9->proc~clock_start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine clock_start ( me ) class ( clock ), intent ( inout ) :: me call system_clock ( me % begin , me % rate ) end subroutine clock_start","tags":"","loc":"proc/clock_start.html"},{"title":"clock_end – AoC-2023","text":"private  subroutine clock_end(me, case_str) Print runtime in milliseconds form the start of the clock. Type Bound clock Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me character(len=*), intent(in) :: case_str description of the case Called by proc~~clock_end~~CalledByGraph proc~clock_end aoc_utilities::clock%clock_end program~problem_1 problem_1 program~problem_1->proc~clock_end program~problem_10 problem_10 program~problem_10->proc~clock_end program~problem_11 problem_11 program~problem_11->proc~clock_end program~problem_12 problem_12 program~problem_12->proc~clock_end program~problem_12b problem_12b program~problem_12b->proc~clock_end program~problem_13 problem_13 program~problem_13->proc~clock_end program~problem_15 problem_15 program~problem_15->proc~clock_end program~problem_16 problem_16 program~problem_16->proc~clock_end program~problem_17 problem_17 program~problem_17->proc~clock_end program~problem_17~2 problem_17 program~problem_17~2->proc~clock_end program~problem_18 problem_18 program~problem_18->proc~clock_end program~problem_19 problem_19 program~problem_19->proc~clock_end program~problem_19b problem_19b program~problem_19b->proc~clock_end program~problem_2 problem_2 program~problem_2->proc~clock_end program~problem_21 problem_21 program~problem_21->proc~clock_end program~problem_22 problem_22 program~problem_22->proc~clock_end program~problem_23 problem_23 program~problem_23->proc~clock_end program~problem_25 problem_25 program~problem_25->proc~clock_end program~problem_3 problem_3 program~problem_3->proc~clock_end program~problem_4 problem_4 program~problem_4->proc~clock_end program~problem_5 problem_5 program~problem_5->proc~clock_end program~problem_6 problem_6 program~problem_6->proc~clock_end program~problem_7 problem_7 program~problem_7->proc~clock_end program~problem_8 problem_8 program~problem_8->proc~clock_end program~problem_9 problem_9 program~problem_9->proc~clock_end Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine clock_end ( me , case_str ) class ( clock ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: case_str !! description of the case integer :: itime !! time in integer milliseconds call system_clock ( me % end ) itime = int ( 1000 * ( me % end - me % begin ) / real ( me % rate , wp )) write ( * , '(a,I4,a)' ) trim ( case_str ) // ' runtime: ' , itime , ' ms' write ( * , '(a)' ) '---------------------------' write ( * , * ) '' end subroutine clock_end","tags":"","loc":"proc/clock_end.html"},{"title":"sort_ascending – AoC-2023","text":"private  subroutine sort_ascending(ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec Calls proc~~sort_ascending~~CallsGraph proc~sort_ascending aoc_utilities::sort_ascending interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap64 aoc_utilities::swap64 interface~swap->proc~swap64 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sort_ascending~~CalledByGraph proc~sort_ascending aoc_utilities::sort_ascending interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->interface~unique proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->interface~unique proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_pieces_above->interface~unique proc~get_pieces_below->interface~unique proc~hand_type problem_7::hand_type proc~hand_type->interface~unique program~problem_25 problem_25 program~problem_25->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_22->proc~get_pieces_above program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down program~problem_7 problem_7 program~problem_7->proc~beats proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine sort_ascending ( ivec ) integer , dimension (:), intent ( inout ) :: ivec integer , parameter :: max_size_for_insertion_sort = 20 !! max size for using insertion sort. call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending","tags":"","loc":"proc/sort_ascending.html"},{"title":"sort_ascending_64 – AoC-2023","text":"private  subroutine sort_ascending_64(ivec) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout), dimension(:) :: ivec Calls proc~~sort_ascending_64~~CallsGraph proc~sort_ascending_64 aoc_utilities::sort_ascending_64 proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sort_ascending_64~~CalledByGraph proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending_64 proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->interface~unique proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->interface~unique proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_pieces_above->interface~unique proc~get_pieces_below->interface~unique proc~hand_type problem_7::hand_type proc~hand_type->interface~unique program~problem_25 problem_25 program~problem_25->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_22->proc~get_pieces_above program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down program~problem_7 problem_7 program~problem_7->proc~beats proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine sort_ascending_64 ( ivec ) integer ( ip ), dimension (:), intent ( inout ) :: ivec integer ( ip ), parameter :: max_size_for_insertion_sort = 20 !! max size for using insertion sort. call quicksort ( 1_ip , size ( ivec , kind = ip )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array integer ( ip ), intent ( in ) :: ilow integer ( ip ), intent ( in ) :: ihigh integer ( ip ) :: ipivot !! pivot element integer ( ip ) :: i !! counter integer ( ip ) :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap64 ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer ( ip ), intent ( in ) :: ilow integer ( ip ), intent ( in ) :: ihigh integer ( ip ), intent ( out ) :: ipivot integer ( ip ) :: i , ip call swap64 ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap64 ( ivec ( ip ), ivec ( i )) end if end do call swap64 ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending_64","tags":"","loc":"proc/sort_ascending_64.html"},{"title":"swap32 – AoC-2023","text":"private pure elemental subroutine swap32(i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 Called by proc~~swap32~~CalledByGraph proc~swap32 aoc_utilities::swap32 interface~swap aoc_utilities::swap interface~swap->proc~swap32 proc~sort_ascending aoc_utilities::sort_ascending proc~sort_ascending->interface~swap interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->interface~unique proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->interface~unique proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_pieces_above->interface~unique proc~get_pieces_below->interface~unique proc~hand_type problem_7::hand_type proc~hand_type->interface~unique program~problem_25 problem_25 program~problem_25->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_22->proc~get_pieces_above program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down program~problem_7 problem_7 program~problem_7->proc~beats proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap32 ( i1 , i2 ) integer , intent ( inout ) :: i1 integer , intent ( inout ) :: i2 integer :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap32","tags":"","loc":"proc/swap32.html"},{"title":"swap64 – AoC-2023","text":"private pure elemental subroutine swap64(i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: i1 integer(kind=ip), intent(inout) :: i2 Called by proc~~swap64~~CalledByGraph proc~swap64 aoc_utilities::swap64 interface~swap aoc_utilities::swap interface~swap->proc~swap64 proc~sort_ascending_64 aoc_utilities::sort_ascending_64 proc~sort_ascending_64->proc~swap64 interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending_64 proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending->interface~swap proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->interface~unique proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->interface~unique proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_pieces_above->interface~unique proc~get_pieces_below->interface~unique proc~hand_type problem_7::hand_type proc~hand_type->interface~unique program~problem_25 problem_25 program~problem_25->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_22->proc~get_pieces_above program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down program~problem_7 problem_7 program~problem_7->proc~beats proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap64 ( i1 , i2 ) integer ( ip ), intent ( inout ) :: i1 integer ( ip ), intent ( inout ) :: i2 integer ( ip ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap64","tags":"","loc":"proc/swap64.html"},{"title":"swap_str – AoC-2023","text":"private pure elemental subroutine swap_str(i1, i2) Swap two character string values Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: i1 character(len=*), intent(inout) :: i2 Called by proc~~swap_str~~CalledByGraph proc~swap_str aoc_utilities::swap_str interface~swap aoc_utilities::swap interface~swap->proc~swap_str proc~sort_ascending aoc_utilities::sort_ascending proc~sort_ascending->interface~swap interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->interface~unique proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->interface~unique proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_pieces_above->interface~unique proc~get_pieces_below->interface~unique proc~hand_type problem_7::hand_type proc~hand_type->interface~unique program~problem_25 problem_25 program~problem_25->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_22->proc~get_pieces_above program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down program~problem_7 problem_7 program~problem_7->proc~beats proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap_str ( i1 , i2 ) character ( len =* ), intent ( inout ) :: i1 character ( len =* ), intent ( inout ) :: i2 character ( len = len ( i1 )) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_str","tags":"","loc":"proc/swap_str.html"},{"title":"expand_vector – AoC-2023","text":"private pure subroutine expand_vector(vec, n, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) Called by proc~~expand_vector~~CalledByGraph proc~expand_vector aoc_utilities::expand_vector proc~split1 aoc_utilities::split1 proc~split1->proc~expand_vector interface~split aoc_utilities::split interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~split2->proc~split1 proc~go~3 problem_18::go proc~go~3->interface~split proc~go~6 problem_12::go proc~go~6->interface~split proc~initialize problem_22::initialize proc~initialize->interface~split proc~parse_nums64 aoc_utilities::parse_nums64 proc~parse_nums64->interface~split proc~parse_rule problem_19b::parse_rule proc~parse_rule->interface~split proc~parse_rule~2 problem_19::parse_rule proc~parse_rule~2->interface~split program~problem_12b problem_12b program~problem_12b->interface~split program~problem_15 problem_15 program~problem_15->interface~split program~problem_19 problem_19 program~problem_19->interface~split program~problem_19->proc~parse_rule~2 program~problem_19b problem_19b program~problem_19b->interface~split program~problem_19b->proc~parse_rule program~problem_2 problem_2 program~problem_2->interface~split program~problem_25 problem_25 program~problem_25->interface~split program~problem_4 problem_4 program~problem_4->interface~split program~problem_7 problem_7 program~problem_7->interface~split interface~parse aoc_utilities::parse interface~parse->proc~parse_nums64 program~problem_12 problem_12 program~problem_12->proc~go~6 program~problem_18 problem_18 program~problem_18->proc~go~3 program~problem_22 problem_22 program~problem_22->proc~initialize program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine expand_vector ( vec , n , val , finished ) integer , dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) integer , dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector","tags":"","loc":"proc/expand_vector.html"},{"title":"locpt – AoC-2023","text":"public pure subroutine locpt(x0, y0, x, y, n, l, m) given a polygonal line connecting the vertices (x(i),y(i))\n  (i = 1,...,n) taken in this order. it is assumed that the\n  polygonal path is a loop, where (x(n),y(n)) = (x(1),y(1))\n  or there is an arc from (x(n),y(n)) to (x(1),y(1)). (x0,y0) is an arbitrary point and l and m are variables.\n  l and m are assigned the following values: l = - 1 if ( x0 , y0 ) is outside the polygonal path l = 0 if ( x0 , y0 ) lies on the polygonal path l = 1 if ( x0 , y0 ) is inside the polygonal path m = 0 if (x0,y0) is on or outside the path. if (x0,y0)\n  is inside the path then m is the winding number of the\n  path around the point (x0,y0). History Original version from the NSWC Library Modified by J. Williams : 08/04/2012 : refactored to modern Fortran Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: y0 real(kind=wp), intent(in), dimension(n) :: x real(kind=wp), intent(in), dimension(n) :: y integer, intent(in) :: n integer, intent(out) :: l integer, intent(out) :: m Called by proc~~locpt~~CalledByGraph proc~locpt aoc_utilities::locpt program~problem_10 problem_10 program~problem_10->proc~locpt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine locpt ( x0 , y0 , x , y , n , l , m ) implicit none !arguments: integer , intent ( in ) :: n real ( wp ), intent ( in ) :: x0 real ( wp ), intent ( in ) :: y0 real ( wp ), dimension ( n ), intent ( in ) :: x real ( wp ), dimension ( n ), intent ( in ) :: y integer , intent ( out ) :: l integer , intent ( out ) :: m !constants: real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) real ( wp ), parameter :: pi = atan2 ( 0.0_wp , - 1.0_wp ) real ( wp ), parameter :: pi2 = 2.0_wp * pi real ( wp ), parameter :: tol = 4.0_wp * eps * pi !local variables: integer :: i , n0 real ( wp ) :: u , v , theta1 , sum , theta , angle , thetai n0 = n if ( x ( 1 ) == x ( n ) . and . y ( 1 ) == y ( n )) n0 = n - 1 l = - 1 m = 0 u = x ( 1 ) - x0 v = y ( 1 ) - y0 if ( u == 0.0_wp . and . v == 0.0_wp ) then l = 0 !(x0, y0) is on the boundary of the path else if ( n0 >= 2 ) then theta1 = atan2 ( v , u ) sum = 0.0_wp theta = theta1 do i = 2 , n0 u = x ( i ) - x0 v = y ( i ) - y0 if ( u == 0.0_wp . and . v == 0.0_wp ) then l = 0 !(x0, y0) is on the boundary of the path exit end if thetai = atan2 ( v , u ) angle = abs ( thetai - theta ) if ( abs ( angle - pi ) < tol ) then l = 0 !(x0, y0) is on the boundary of the path exit end if if ( angle > pi ) angle = angle - pi2 if ( theta > thetai ) angle = - angle sum = sum + angle theta = thetai end do if ( l /= 0 ) then angle = abs ( theta1 - theta ) if ( abs ( angle - pi ) < tol ) then l = 0 !(x0, y0) is on the boundary of the path else if ( angle > pi ) angle = angle - pi2 if ( theta > theta1 ) angle = - angle sum = sum + angle !sum = 2*pi*m where m is the winding number m = abs ( sum ) / pi2 + 0.2_wp if ( m /= 0 ) then l = 1 if ( sum < 0.0_wp ) m = - m end if end if end if end if end if end subroutine locpt","tags":"","loc":"proc/locpt.html"},{"title":"inverse – AoC-2023","text":"public  subroutine inverse(a, ainv, status_ok) inverse of a 2x2 matrix. See: https: Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: a real(kind=wp), intent(out), dimension(2,2) :: ainv logical, intent(out) :: status_ok Source Code subroutine inverse ( a , ainv , status_ok ) real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: a real ( wp ), dimension ( 2 , 2 ), intent ( out ) :: ainv logical , intent ( out ) :: status_ok real ( wp ), parameter :: eps = 1.0e-10_wp real ( wp ), dimension ( 2 , 2 ) :: cofactor associate ( det => a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 2 , 1 ) ) if ( abs ( det ) <= eps ) then ainv = 0.0_wp status_ok = . false . else cofactor ( 1 , 1 ) = + a ( 2 , 2 ) cofactor ( 1 , 2 ) = - a ( 2 , 1 ) cofactor ( 2 , 1 ) = - a ( 1 , 2 ) cofactor ( 2 , 2 ) = + a ( 1 , 1 ) ainv = transpose ( cofactor ) / det status_ok = . true . end if end associate end subroutine inverse","tags":"","loc":"proc/inverse.html"},{"title":"sort – AoC-2023","text":"public interface sort Calls interface~~sort~~CallsGraph interface~sort aoc_utilities::sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~sort~~CalledByGraph interface~sort aoc_utilities::sort proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->interface~unique proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->interface~unique proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_pieces_above->interface~unique proc~get_pieces_below->interface~unique proc~hand_type problem_7::hand_type proc~hand_type->interface~unique program~problem_25 problem_25 program~problem_25->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_22->proc~get_pieces_above program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down program~problem_7 problem_7 program~problem_7->proc~beats proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine sort_ascending (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_64 (ivec) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout), dimension(:) :: ivec","tags":"","loc":"interface/sort.html"},{"title":"parse – AoC-2023","text":"public interface parse Calls interface~~parse~~CallsGraph interface~parse aoc_utilities::parse proc~parse_nums64 aoc_utilities::parse_nums64 interface~parse->proc~parse_nums64 interface~split aoc_utilities::split proc~parse_nums64->interface~split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~parse~~CalledByGraph interface~parse aoc_utilities::parse program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function parse_nums64 (line) result(ints) parse space-deliminated ip sequence (positive or negative) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=ip), dimension(:), allocatable","tags":"","loc":"interface/parse.html"},{"title":"split – AoC-2023","text":"public interface split Calls interface~~split~~CallsGraph interface~split aoc_utilities::split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~split~~CalledByGraph interface~split aoc_utilities::split proc~go~3 problem_18::go proc~go~3->interface~split proc~go~6 problem_12::go proc~go~6->interface~split proc~initialize problem_22::initialize proc~initialize->interface~split proc~parse_nums64 aoc_utilities::parse_nums64 proc~parse_nums64->interface~split proc~parse_rule problem_19b::parse_rule proc~parse_rule->interface~split proc~parse_rule~2 problem_19::parse_rule proc~parse_rule~2->interface~split program~problem_12b problem_12b program~problem_12b->interface~split program~problem_15 problem_15 program~problem_15->interface~split program~problem_19 problem_19 program~problem_19->interface~split program~problem_19->proc~parse_rule~2 program~problem_19b problem_19b program~problem_19b->interface~split program~problem_19b->proc~parse_rule program~problem_2 problem_2 program~problem_2->interface~split program~problem_25 problem_25 program~problem_25->interface~split program~problem_4 problem_4 program~problem_4->interface~split program~problem_7 problem_7 program~problem_7->interface~split interface~parse aoc_utilities::parse interface~parse->proc~parse_nums64 program~problem_12 problem_12 program~problem_12->proc~go~6 program~problem_18 problem_18 program~problem_18->proc~go~3 program~problem_22 problem_22 program~problem_22->proc~initialize program~problem_9 problem_9 program~problem_9->interface~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function split1 (str, token) result(vals) Split a character string using a token.\n  This routine is inspired by the Python split function. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable private pure function split2 (s, token) result(vals) Split a string , given a token. Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: s character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable","tags":"","loc":"interface/split.html"},{"title":"int – AoC-2023","text":"public interface int Calls interface~~int~~CallsGraph interface~int aoc_utilities::int proc~char_array_to_int aoc_utilities::char_array_to_int interface~int->proc~char_array_to_int proc~char_to_int aoc_utilities::char_to_int interface~int->proc~char_to_int proc~char_to_int64 aoc_utilities::char_to_int64 interface~int->proc~char_to_int64 proc~string_to_int aoc_utilities::string%string_to_int interface~int->proc~string_to_int proc~char_array_to_int->proc~char_to_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure elemental function string_to_int (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer private pure function char_to_int (str) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer private pure function char_to_int64 (str, kind) result(i) Basic string to integer(ip) routine.\nHacky hack just so we can overload as int() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: kind Return Value integer(kind=ip) private pure function char_array_to_int (str_array) result(i) Character array to integer routine Arguments Type Intent Optional Attributes Name character(len=1), intent(in), dimension(:) :: str_array example ['1','3'] --> 13 Return Value integer","tags":"","loc":"interface/int.html"},{"title":"unique – AoC-2023","text":"public interface unique Calls interface~~unique~~CallsGraph interface~unique aoc_utilities::unique proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~unique~~CalledByGraph interface~unique aoc_utilities::unique proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->interface~unique proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->interface~unique proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_pieces_above->interface~unique proc~get_pieces_below->interface~unique proc~hand_type problem_7::hand_type proc~hand_type->interface~unique program~problem_25 problem_25 program~problem_25->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_22->proc~get_pieces_above program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down program~problem_7 problem_7 program~problem_7->proc~beats proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function unique32 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec Return Value integer, dimension(:), allocatable private  function unique64 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: vec Return Value integer(kind=ip), dimension(:), allocatable","tags":"","loc":"interface/unique.html"},{"title":"startswith – AoC-2023","text":"public interface startswith test if a string starts with a specified substring Calls interface~~startswith~~CallsGraph interface~startswith aoc_utilities::startswith proc~startswith_cc aoc_utilities::startswith_cc interface~startswith->proc~startswith_cc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~startswith~~CalledByGraph interface~startswith aoc_utilities::startswith proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith program~problem_5 problem_5 program~problem_5->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function startswith_cc (str, substring) starts with function for strings Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_ss (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str type( string ), intent(in) :: substring Return Value logical private pure function startswith_sc (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_cs (str, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str type( string ), intent(in) :: substring Return Value logical","tags":"","loc":"interface/startswith.html"},{"title":"swap – AoC-2023","text":"public interface swap Calls interface~~swap~~CallsGraph interface~swap aoc_utilities::swap proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap64 aoc_utilities::swap64 interface~swap->proc~swap64 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~swap~~CalledByGraph interface~swap aoc_utilities::swap proc~sort_ascending aoc_utilities::sort_ascending proc~sort_ascending->interface~swap interface~sort aoc_utilities::sort interface~sort->proc~sort_ascending proc~unique32 aoc_utilities::unique32 proc~unique32->interface~sort proc~unique64 aoc_utilities::unique64 proc~unique64->interface~sort interface~unique aoc_utilities::unique interface~unique->proc~unique32 interface~unique->proc~unique64 proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->interface~unique proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->interface~unique proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_pieces_above->interface~unique proc~get_pieces_below->interface~unique proc~hand_type problem_7::hand_type proc~hand_type->interface~unique program~problem_25 problem_25 program~problem_25->interface~unique proc~beats problem_7::beats proc~beats->proc~hand_type proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_22->proc~get_pieces_above program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down program~problem_7 problem_7 program~problem_7->proc~beats proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure elemental subroutine swap32 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap64 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: i1 integer(kind=ip), intent(inout) :: i2 private pure elemental subroutine swap_str (i1, i2) Swap two character string values Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: i1 character(len=*), intent(inout) :: i2","tags":"","loc":"interface/swap.html"},{"title":"manhatten_distance – AoC-2023","text":"public interface manhatten_distance Calls interface~~manhatten_distance~~CallsGraph interface~manhatten_distance aoc_utilities::manhatten_distance proc~manhatten_distance_64 aoc_utilities::manhatten_distance_64 interface~manhatten_distance->proc~manhatten_distance_64 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~manhatten_distance~~CalledByGraph interface~manhatten_distance aoc_utilities::manhatten_distance proc~go~7 problem_11::go proc~go~7->interface~manhatten_distance program~problem_11 problem_11 program~problem_11->proc~go~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function manhatten_distance_64 (x1, y1, x2, y2) Manhattan distance between two ip points. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: x1 integer(kind=ip), intent(in) :: y1 integer(kind=ip), intent(in) :: x2 integer(kind=ip), intent(in) :: y2 Return Value integer(kind=ip)","tags":"","loc":"interface/manhatten_distance.html"},{"title":"fmin – AoC-2023","text":"public  function fmin(f, ax, bx, tol) result(xmin) An approximation x to the point where f attains a minimum on\n  the interval (ax,bx) is determined. the method used is a combination of golden section search and\n  successive parabolic interpolation. convergence is never much slower\n  than that for a fibonacci search. if f has a continuous second\n  derivative which is positive at the minimum (which is not at ax or bx ), then convergence is superlinear, and usually of the order of\n  about 1.324. the function f is never evaluated at two points closer together\n  than eps*abs(fmin) + (tol/3) , where eps is approximately the square\n  root of the relative machine precision. if f is a unimodal\n  function and the computed values of f are always unimodal when\n  separated by at least eps*abs(x) + (tol/3) , then fmin approximates\n  the abcissa of the global minimum of f on the interval ax,bx with\n  an error less than 3*eps*abs(fmin) + tol . if f is not unimodal,\n  then fmin may approximate a local, but perhaps non-global, minimum to\n  the same accuracy. Reference Richard brent, \"algorithms for minimization without derivatives\",\n    prentice - hall, inc. (1973). See also [fmin from Netlib](http: Arguments Type Intent Optional Attributes Name procedure( func ) :: f the function to minimize real(kind=wp), intent(in) :: ax left endpoint of initial interval real(kind=wp), intent(in) :: bx right endpoint of initial interval real(kind=wp), intent(in) :: tol desired length of the interval of\nuncertainty of the final result (>=0) Return Value real(kind=wp) abcissa approximating the point where\nf attains a minimum Called by proc~~fmin~~CalledByGraph proc~fmin fmin_module::fmin proc~exact_linesearch nlesolver_module::exact_linesearch proc~exact_linesearch->proc~fmin program~test test program~test->proc~fmin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function fmin ( f , ax , bx , tol ) result ( xmin ) implicit none procedure ( func ) :: f !! the function to minimize real ( wp ), intent ( in ) :: ax !! left endpoint of initial interval real ( wp ), intent ( in ) :: bx !! right endpoint of initial interval real ( wp ), intent ( in ) :: tol !! desired length of the interval of !! uncertainty of the final result (>=0) real ( wp ) :: xmin !! abcissa approximating the point where !! f attains a minimum real ( wp ) :: a , b , d , e , xm , p , q , r , tol1 , tol2 , u , v , w real ( wp ) :: fu , fv , fw , fx , x real ( wp ) :: abs , sqrt , sign real ( wp ), parameter :: c = ( 3.0_wp - sqrt ( 5.0_wp )) / 2.0_wp !! squared inverse of golden ratio real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: sqrteps = sqrt ( epsilon ( 1.0_wp )) ! initialization a = ax b = bx v = a + c * ( b - a ) w = v x = v e = 0.0_wp fx = f ( x ) fv = fx fw = fx do !  main loop starts here xm = half * ( a + b ) tol1 = sqrteps * abs ( x ) + tol / 3.0_wp tol2 = 2.0_wp * tol1 !  check stopping criterion if ( abs ( x - xm ) <= ( tol2 - half * ( b - a ))) then ! write(*,*) 'x             = ', x ! write(*,*) 'xm            = ', xm ! write(*,*) 'abs(x - xm)   = ', abs(x - xm) ! write(*,*) 'tol2          = ', tol2 ! write(*,*) 'half*(b - a)  = ', half*(b - a) exit end if ! is golden-section necessary if ( abs ( e ) <= tol1 ) then !  a golden-section step if ( x >= xm ) then e = a - x else e = b - x end if d = c * e else !  fit parabola r = ( x - w ) * ( fx - fv ) q = ( x - v ) * ( fx - fw ) p = ( x - v ) * q - ( x - w ) * r q = 2.0_wp * ( q - r ) if ( q > 0.0_wp ) p = - p q = abs ( q ) r = e e = d !  is parabola acceptable if (( abs ( p ) >= abs ( half * q * r )) . or . ( p <= q * ( a - x )) . or . ( p >= q * ( b - x ))) then !  a golden-section step if ( x >= xm ) then e = a - x else e = b - x end if d = c * e else !  a parabolic interpolation step d = p / q u = x + d !  f must not be evaluated too close to ax or bx if ((( u - a ) < tol2 ) . or . (( b - u ) < tol2 )) d = sign ( tol1 , xm - x ) end if end if !  f must not be evaluated too close to x if ( abs ( d ) >= tol1 ) then u = x + d else u = x + sign ( tol1 , d ) end if fu = f ( u ) !  update a, b, v, w, and x if ( fu <= fx ) then if ( u >= x ) a = x if ( u < x ) b = x v = w fv = fw w = x fw = fx x = u fx = fu else if ( u < x ) a = u if ( u >= x ) b = u if ( fu <= fw . or . w == x ) then v = w fv = fw w = u fw = fu else if ( fu <= fv . or . v == x . or . v == w ) then v = u fv = fu end if end if end do !  end of main loop xmin = x end function fmin","tags":"","loc":"proc/fmin.html"},{"title":"func – AoC-2023","text":"function func(x) Problem function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) Called by proc~~func~~CalledByGraph proc~func test2::func proc~my_func test2::my_func proc~my_func->proc~func Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function func ( x ) !! Problem function real ( wp ), intent ( in ) :: x real ( wp ) :: func func = x + sin ( x ) end function func","tags":"","loc":"proc/func.html"},{"title":"deriv – AoC-2023","text":"function deriv(x) Problem function true derivative Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) Called by proc~~deriv~~CalledByGraph proc~deriv test2::deriv program~test2 test2 program~test2->proc~deriv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function deriv ( x ) !! Problem function true derivative real ( wp ), intent ( in ) :: x real ( wp ) :: deriv deriv = 1.0_wp + cos ( x ) end function deriv","tags":"","loc":"proc/deriv.html"},{"title":"my_func – AoC-2023","text":"subroutine my_func(me, x, f, funcs_to_compute) Problem function interface for numdiff Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: f integer, intent(in), dimension(:) :: funcs_to_compute Calls proc~~my_func~~CallsGraph proc~my_func test2::my_func proc~func test2::func proc~my_func->proc~func Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine my_func ( me , x , f , funcs_to_compute ) !! Problem function interface for numdiff class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f integer , dimension (:), intent ( in ) :: funcs_to_compute if ( any ( funcs_to_compute == 1 )) f ( 1 ) = func ( x ( 1 )) func_evals = func_evals + 1 end subroutine my_func","tags":"","loc":"proc/my_func.html"},{"title":"vector_djb_hash – AoC-2023","text":"private pure function vector_djb_hash(r) result(hash) DJB hash algorithm for a real(wp) vector. See also J. Shahbazian, Fortran hashing algorithm, July 6, 2013 Fortran Dev Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: r the vector Return Value integer(kind=ip) the hash value Called by proc~~vector_djb_hash~~CalledByGraph proc~vector_djb_hash numdiff_cache_module::vector_djb_hash proc~get_from_cache numdiff_cache_module::function_cache%get_from_cache proc~get_from_cache->proc~vector_djb_hash proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~get_from_cache Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function vector_djb_hash ( r ) result ( hash ) real ( wp ), dimension (:), intent ( in ) :: r !! the vector integer ( ip ) :: hash !! the hash value integer :: i !! counter hash = 5381_ip do i = 1 , size ( r ) hash = ishft ( hash , 5_ip ) + hash + transfer ( r ( i ), 1_ip ) end do end function vector_djb_hash","tags":"","loc":"proc/vector_djb_hash.html"},{"title":"initialize_cache – AoC-2023","text":"private  subroutine initialize_cache(me, isize, n, m, chunk_size) Initialize the cache. Must be called first before use. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: isize the size of the hash table integer, intent(in) :: n number of independant variables (x) integer, intent(in) :: m number of functions (f) integer, intent(in), optional :: chunk_size chunk size to speed up reallocation\nof arrays. A good value is a guess for\nthe actual number of elements of f that\nwill be saved per value of x [default is 100] Calls proc~~initialize_cache~~CallsGraph proc~initialize_cache numdiff_cache_module::function_cache%initialize_cache proc~destroy_cache numdiff_cache_module::function_cache%destroy_cache proc~initialize_cache->proc~destroy_cache Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~initialize_cache~~CalledByGraph proc~initialize_cache numdiff_cache_module::function_cache%initialize_cache proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~initialize_cache proc~initialize_numdiff_for_diff numerical_differentiation_module::numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~initialize_cache program~test1 test1 program~test1->proc~initialize_numdiff program~test1->proc~initialize_numdiff_for_diff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize_cache ( me , isize , n , m , chunk_size ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: isize !! the size of the hash table integer , intent ( in ) :: n !! number of independant variables (x) integer , intent ( in ) :: m !! number of functions (f) integer , intent ( in ), optional :: chunk_size !! chunk size to speed up reallocation !! of arrays. A good value is a guess for !! the actual number of elements of `f` that !! will be saved per value of `x` [default is 100] call me % destroy () allocate ( me % c ( 0 : isize - 1 )) me % n = n me % m = m if ( present ( chunk_size )) then me % chunk_size = chunk_size else me % chunk_size = 100 end if end subroutine initialize_cache","tags":"","loc":"proc/initialize_cache.html"},{"title":"print_cache – AoC-2023","text":"private  subroutine print_cache(me, iunit) Print the contents of the cache. Used for debugging. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: iunit file unit for writing\n(assumed to be opened) Source Code subroutine print_cache ( me , iunit ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: iunit !! file unit for writing !! (assumed to be opened) integer :: i !! counter write ( iunit , '(A)' ) '' write ( iunit , '(A)' ) '------------------------' if ( allocated ( me % c )) then do i = 1 , size ( me % c ) if ( allocated ( me % c ( i )% x )) then write ( iunit , '(A)' ) '' write ( iunit , '(A,1X,I10)' ) 'Entry ' , i write ( iunit , '(A,1X,*(F27.16,1X))' ) 'x  :' , me % c ( i )% x if ( allocated ( me % c ( i )% f )) then write ( iunit , '(A,1X,*(I27,1X))' ) 'ifs:' , me % c ( i )% ifs write ( iunit , '(A,1X,*(F27.16,1X))' ) 'f  :' , me % c ( i )% f ( me % c ( i )% ifs ) end if write ( iunit , '(A)' ) '------------------------' end if end do else write ( iunit , '(A)' ) 'Cache is not initialized' write ( iunit , '(A)' ) '------------------------' end if write ( iunit , '(A)' ) '' end subroutine print_cache","tags":"","loc":"proc/print_cache.html"},{"title":"get_from_cache – AoC-2023","text":"private  subroutine get_from_cache(me, x, ifs, i, f, xfound, ffound) Check if the x vector is in the cache, if so return f .\nNote that only some of the elements may be present, so it will return\nthe ones there are there, and indicate which ones were found. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x independant variable vector integer, intent(in), dimension(:) :: ifs elements of f needed integer, intent(out) :: i index in the hash table real(kind=wp), intent(out), dimension(:) :: f f(x) from the cache (if it was found) logical, intent(out) :: xfound if x was found in the cache logical, intent(out), dimension(size(ifs)) :: ffound which ifs were found in the cache Calls proc~~get_from_cache~~CallsGraph proc~get_from_cache numdiff_cache_module::function_cache%get_from_cache proc~vector_djb_hash numdiff_cache_module::vector_djb_hash proc~get_from_cache->proc~vector_djb_hash Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_from_cache~~CalledByGraph proc~get_from_cache numdiff_cache_module::function_cache%get_from_cache proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~get_from_cache Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_from_cache ( me , x , ifs , i , f , xfound , ffound ) implicit none class ( function_cache ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! independant variable vector integer , dimension (:), intent ( in ) :: ifs !! elements of `f` needed integer , intent ( out ) :: i !! index in the hash table real ( wp ), dimension (:), intent ( out ) :: f !! `f(x)` from the cache (if it was found) logical , intent ( out ) :: xfound !! if `x` was found in the cache logical , dimension ( size ( ifs )), intent ( out ) :: ffound !! which `ifs` were found in the cache integer :: j !! counter ! initialize: xfound = . false . ffound = . false . if ( allocated ( me % c )) then ! get index in the hash table: i = mod ( abs ( vector_djb_hash ( x )), int ( size ( me % c ), ip ) ) ! check the table: if ( allocated ( me % c ( i )% x ) . and . allocated ( me % c ( i )% f )) then if ( size ( me % c ( i )% x ) == size ( x ) . and . & size ( me % c ( i )% f ) == size ( f )) then if ( all ( me % c ( i )% x == x )) then xfound = . true . ! return the elements that were found in the cache: f ( me % c ( i )% ifs ) = me % c ( i )% f ( me % c ( i )% ifs ) ! what indices are in the cache? do j = 1 , size ( ifs ) ffound ( j ) = any ( ifs ( j ) == me % c ( i )% ifs ) end do end if end if end if else error stop 'Error: the cache has not been initialized.' end if end subroutine get_from_cache","tags":"","loc":"proc/get_from_cache.html"},{"title":"put_in_cache – AoC-2023","text":"private  subroutine put_in_cache(me, i, x, f, ifs) Put a value into the cache. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: i index in the hash table real(kind=wp), intent(in), dimension(:) :: x independant variable vector (dimension n ) real(kind=wp), intent(in), dimension(:) :: f function vector f(x) (dimension m ) integer, intent(in), dimension(:) :: ifs elements of f to add (should all be >0, <=m ) Calls proc~~put_in_cache~~CallsGraph proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache interface~unique~2 numdiff_utilities_module::unique proc~put_in_cache->interface~unique~2 proc~unique_int numdiff_utilities_module::unique_int interface~unique~2->proc~unique_int proc~unique_real numdiff_utilities_module::unique_real interface~unique~2->proc~unique_real interface~expand_vector numdiff_utilities_module::expand_vector proc~unique_int->interface~expand_vector interface~sort_ascending numdiff_utilities_module::sort_ascending proc~unique_int->interface~sort_ascending proc~unique_real->interface~expand_vector proc~unique_real->interface~sort_ascending proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector->proc~expand_vector_real proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap~2 numdiff_utilities_module::swap proc~sort_ascending_int->interface~swap~2 proc~sort_ascending_real->interface~swap~2 proc~swap_int numdiff_utilities_module::swap_int interface~swap~2->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap~2->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~put_in_cache~~CalledByGraph proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine put_in_cache ( me , i , x , f , ifs ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: i !! index in the hash table real ( wp ), dimension (:), intent ( in ) :: x !! independant variable vector (dimension `n`) real ( wp ), dimension (:), intent ( in ) :: f !! function vector `f(x)` (dimension `m`) integer , dimension (:), intent ( in ) :: ifs !! elements of `f` to add (should all be `>0, <=m`) real ( wp ), parameter :: null = huge ( 1.0_wp ) !! an unusual value to initialize arrays if ( allocated ( me % c )) then if ( i <= size ( me % c )) then if ( allocated ( me % c ( i )% x )) then ! we need to check if there is an x already there, ! which may already have some function indices present. ! if same x, then add the new indices to them. ! if a different x, then replace indices. if ( all ( me % c ( i )% x == x )) then ! this x is already present in this location. ! so merge the new f,ifs into what is already there. if ( allocated ( me % c ( i )% f )) then me % c ( i )% ifs = unique ([ me % c ( i )% ifs , ifs ],& chunk_size = me % chunk_size ) else allocate ( me % c ( i )% f ( me % m )) me % c ( i )% f = null ! initialize to an unusual value me % c ( i )% ifs = ifs end if me % c ( i )% f ( ifs ) = f ( ifs ) else ! replace existing x and f. me % c ( i )% x = x me % c ( i )% ifs = ifs if ( allocated ( me % c ( i )% f )) deallocate ( me % c ( i )% f ) allocate ( me % c ( i )% f ( me % m )) me % c ( i )% f = null ! initialize to an unusual value me % c ( i )% f ( ifs ) = f ( ifs ) end if else ! new entry in the cache: me % c ( i )% x = x allocate ( me % c ( i )% f ( me % m )) me % c ( i )% f = null ! initialize to an unusual value me % c ( i )% ifs = ifs me % c ( i )% f ( ifs ) = f ( ifs ) end if else error stop 'Error: invalid index in hash table.' end if else error stop 'Error: the cache has not been initialized.' end if end subroutine put_in_cache","tags":"","loc":"proc/put_in_cache.html"},{"title":"destroy_cache – AoC-2023","text":"private  subroutine destroy_cache(me) Destroy a cache. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(out) :: me Called by proc~~destroy_cache~~CalledByGraph proc~destroy_cache numdiff_cache_module::function_cache%destroy_cache proc~initialize_cache numdiff_cache_module::function_cache%initialize_cache proc~initialize_cache->proc~destroy_cache proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~destroy_cache proc~initialize_numdiff->proc~initialize_cache proc~initialize_numdiff_for_diff numerical_differentiation_module::numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~destroy_cache proc~initialize_numdiff_for_diff->proc~initialize_cache program~test1 test1 program~test1->proc~initialize_numdiff program~test1->proc~initialize_numdiff_for_diff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy_cache ( me ) implicit none class ( function_cache ), intent ( out ) :: me end subroutine destroy_cache","tags":"","loc":"proc/destroy_cache.html"},{"title":"func – AoC-2023","text":"subroutine func(me, x, f) compute the function Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: f Source Code subroutine func ( me , x , f ) !! compute the function implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f f_evals = f_evals + 1 f ( 1 ) = x ( 1 ) ** 2 + x ( 2 ) - 0.1_wp f ( 2 ) = x ( 2 ) + 0.2_wp ! root is 5.477226E-01  -2.000000E-01 end subroutine func","tags":"","loc":"proc/func~2.html"},{"title":"grad – AoC-2023","text":"subroutine grad(me, x, g) compute the gradient of the function (Jacobian): Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:,:) :: g Called by proc~~grad~~CalledByGraph proc~grad sparse_test::grad proc~grad_sparse sparse_test::grad_sparse proc~grad_sparse->proc~grad Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine grad ( me , x , g ) !! compute the gradient of the function (Jacobian): implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:,:), intent ( out ) :: g f_evals = f_evals + 2 ! to approximate forward diff derivatives g ( 1 , 1 ) = 2.0_wp * x ( 1 ) !df(1)/dx g ( 2 , 1 ) = 0.0_wp !df(2)/dx g ( 1 , 2 ) = 1.0_wp !df(1)/dy g ( 2 , 2 ) = 1.0_wp !df(2)/dy end subroutine grad","tags":"","loc":"proc/grad.html"},{"title":"grad_sparse – AoC-2023","text":"subroutine grad_sparse(me, x, g) compute the gradient of the function (Jacobian): Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: g Calls proc~~grad_sparse~~CallsGraph proc~grad_sparse sparse_test::grad_sparse proc~grad sparse_test::grad proc~grad_sparse->proc~grad Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine grad_sparse ( me , x , g ) !! compute the gradient of the function (Jacobian): implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: g real ( wp ), dimension ( m , n ) :: g_dense ! for this example, just convert the dense ! jacobian to the sparse representation call grad ( me , x , g_dense ) g ( 1 ) = g_dense ( 1 , 1 ) g ( 2 ) = g_dense ( 1 , 2 ) g ( 3 ) = g_dense ( 2 , 2 ) f_evals = f_evals + 2 ! to approximate forward diff derivatives end subroutine grad_sparse","tags":"","loc":"proc/grad_sparse.html"},{"title":"export – AoC-2023","text":"subroutine export(me, x, f, iter) export an iteration: Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: f integer, intent(in) :: iter iteration number Source Code subroutine export ( me , x , f , iter ) !! export an iteration: implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: f integer , intent ( in ) :: iter !! iteration number write ( * , '(1P,I3,1X,A,I3,A,*(E15.6))' ) iter , '(' , f_evals , ')' , x , norm2 ( f ) end subroutine export","tags":"","loc":"proc/export.html"},{"title":"go – AoC-2023","text":"subroutine go(puzzle, ileft, iskip) compute the number of cols to left of mirror (0 if none)\ncall with transpose(puzzle) to get number of rows above. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: puzzle integer, intent(out) :: ileft integer, intent(in), optional :: iskip don't consider this column Called by proc~~go~~CalledByGraph proc~go problem_13::go program~problem_13 problem_13 program~problem_13->proc~go Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine go ( puzzle , ileft , iskip ) !! compute the number of cols to left of mirror (0 if none) !! call with transpose(puzzle) to get number of rows above. integer , dimension (:,:), intent ( in ) :: puzzle integer , intent ( out ) :: ileft integer , intent ( in ), optional :: iskip !! don't consider this column integer :: nrows , ncols , i , j logical :: mirror nrows = size ( puzzle , 1 ) ncols = size ( puzzle , 2 ) ileft = 0 do i = 1 , ncols - 1 if ( present ( iskip )) then if ( i == iskip ) cycle end if mirror = . true . do j = 1 , min ( i , ncols - i ) if ( any ( puzzle (:, i - j + 1 ) /= puzzle (:, i + j )) ) then mirror = . false . ! no mirror on this line exit end if end do if ( mirror ) then ileft = i exit end if end do end subroutine go","tags":"","loc":"proc/go.html"},{"title":"hand_type – AoC-2023","text":"function hand_type(me, with_jokers) returns the type of hand Arguments Type Intent Optional Attributes Name class( hand ), intent(in) :: me logical, intent(in) :: with_jokers if considering jokers Return Value integer Calls proc~~hand_type~~CallsGraph proc~hand_type problem_7::hand_type interface~unique aoc_utilities::unique proc~hand_type->interface~unique proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hand_type~~CalledByGraph proc~hand_type problem_7::hand_type proc~beats problem_7::beats proc~beats->proc~hand_type program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code integer function hand_type ( me , with_jokers ) !! returns the type of hand class ( hand ), intent ( in ) :: me logical , intent ( in ) :: with_jokers !! if considering jokers integer , dimension ( 5 ) :: i integer , dimension (:), allocatable :: u integer :: n_jokers , n_unique character ( len = 1 ), dimension ( 5 ) :: h h = me % cards i = ichar ( h ) ! convert to code u = unique ( i ) ! unique elements n_unique = size ( u ) if ( with_jokers . and . any ( h == 'J' )) then ! have to pick best hand for all jokers ! just do it by inspection n_jokers = count ( h == 'J' ) select case ( n_jokers ) case ( 5 ) hand_type = FIVE_OF_A_KIND !jjjjj case ( 4 ) hand_type = FIVE_OF_A_KIND !jjjja case ( 3 ) ! can always turn to 4 or 5 of a kind if ( n_unique == 2 ) then !jjjaa hand_type = FIVE_OF_A_KIND else ! jjjab hand_type = FOUR_OF_A_KIND end if case ( 2 ) if ( n_unique == 2 ) then !jjaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then !jjaab hand_type = FOUR_OF_A_KIND else !jjabc hand_type = THREE_OF_A_KIND end if case ( 1 ) if ( n_unique == 2 ) then !jaaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then if ( any ([ count ( i == u ( 1 )) == 3 , & count ( i == u ( 2 )) == 3 , & count ( i == u ( 3 )) == 3 ]) ) then !jaaab hand_type = FOUR_OF_A_KIND elseif ( ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 ) . or . & ( count ( i == u ( 2 )) == 2 . and . count ( i == u ( 2 )) == 2 ) ) then !jaabb hand_type = FULL_HOUSE end if else if ( n_unique == 4 ) then !jaabc hand_type = THREE_OF_A_KIND else if ( n_unique == 5 ) then !jabcd hand_type = ONE_PAIR end if end select else !Every hand is exactly one type. From strongest to weakest, they are: select case ( n_unique ) case ( 1 ) ! aaaaa hand_type = FIVE_OF_A_KIND case ( 2 ) ! aaaab, aaabb if (( count ( i == u ( 1 )) == 4 . and . count ( i == u ( 2 )) == 1 ) . or . & ( count ( i == u ( 1 )) == 1 . and . count ( i == u ( 2 )) == 4 ) ) then hand_type = FOUR_OF_A_KIND else if (( count ( i == u ( 1 )) == 3 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 3 ) ) then hand_type = FULL_HOUSE end if case ( 3 ) ! aaabc, aabcc if ( any ([ count ( i == u ( 1 )) == 3 , count ( i == u ( 2 )) == 3 , count ( i == u ( 3 )) == 3 ]) ) then hand_type = THREE_OF_A_KIND else if ( any ([ count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 , & count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 , & count ( i == u ( 2 )) == 2 . and . count ( i == u ( 3 )) == 2 ]) ) then hand_type = TWO_PAIR end if case ( 4 ) !aabcd hand_type = ONE_PAIR case ( 5 ) !abcde hand_type = HIGH_CARD ! High card, where all cards' labels are distinct: 23456 end select end if end function hand_type","tags":"","loc":"proc/hand_type.html"},{"title":"beats – AoC-2023","text":"function beats(hand1, hand2, with_jokers) return true if hand1 beats hand2 (has a higher score) Arguments Type Intent Optional Attributes Name class( hand ), intent(inout) :: hand1 class( hand ), intent(inout) :: hand2 logical, intent(in) :: with_jokers if considering jokers Return Value logical Calls proc~~beats~~CallsGraph proc~beats problem_7::beats proc~hand_type problem_7::hand_type proc~beats->proc~hand_type proc~index_in_cards problem_7::index_in_cards proc~beats->proc~index_in_cards interface~unique aoc_utilities::unique proc~hand_type->interface~unique proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~beats~~CalledByGraph proc~beats problem_7::beats program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function beats ( hand1 , hand2 , with_jokers ) !! return true if hand1 beats hand2 (has a higher score) class ( hand ), intent ( inout ) :: hand1 , hand2 logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i associate ( h1 => hand1 % cards , h2 => hand2 % cards ) ! recompute type if it hasn't already been computed if ( hand1 % type == 0 ) hand1 % type = hand_type ( hand1 , with_jokers ) if ( hand2 % type == 0 ) hand2 % type = hand_type ( hand2 , with_jokers ) if ( hand1 % type == hand2 % type ) then ! lower index is stronger do i = 1 , 5 if ( h1 ( i ) /= h2 ( i )) then beats = index_in_cards ( h1 ( i ), with_jokers ) < & index_in_cards ( h2 ( i ), with_jokers ) ! lower is stronger return end if end do else ! one hand beat the other beats = hand1 % type < hand2 % type ! lower score is better (1-7) end if end associate end function beats","tags":"","loc":"proc/beats.html"},{"title":"index_in_cards – AoC-2023","text":"function index_in_cards(c, with_jokers) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c logical, intent(in) :: with_jokers if considering jokers Return Value integer Called by proc~~index_in_cards~~CalledByGraph proc~index_in_cards problem_7::index_in_cards proc~beats problem_7::beats proc~beats->proc~index_in_cards program~problem_7 problem_7 program~problem_7->proc~beats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code integer function index_in_cards ( c , with_jokers ) character ( len = 1 ), intent ( in ) :: c logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i do i = 1 , size ( cards_with_joker ) if ( with_jokers ) then if ( c == cards_with_joker ( i )) then index_in_cards = i return end if else if ( c == cards ( i )) then index_in_cards = i return end if end if end do error stop 'card not found' end function index_in_cards","tags":"","loc":"proc/index_in_cards.html"},{"title":"swap_hands – AoC-2023","text":"pure elemental subroutine swap_hands(i1, i2) swap function for hand type Arguments Type Intent Optional Attributes Name type( hand ), intent(inout) :: i1 type( hand ), intent(inout) :: i2 Called by proc~~swap_hands~~CalledByGraph proc~swap_hands problem_7::swap_hands program~problem_7 problem_7 program~problem_7->proc~swap_hands Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap_hands ( i1 , i2 ) !! swap function for hand type type ( hand ), intent ( inout ) :: i1 type ( hand ), intent ( inout ) :: i2 type ( hand ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_hands","tags":"","loc":"proc/swap_hands.html"},{"title":"func – AoC-2023","text":"subroutine func(me, x, f) compute the function Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: f Source Code subroutine func ( me , x , f ) !! compute the function implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f f_evals = f_evals + 1 f ( 1 ) = x ( 1 ) ** 2 + x ( 2 ) - 0.1_wp f ( 2 ) = x ( 2 ) + 0.2_wp ! root is 5.477226E-01  -2.000000E-01 end subroutine func","tags":"","loc":"proc/func~3.html"},{"title":"grad – AoC-2023","text":"subroutine grad(me, x, g) compute the gradient of the function (Jacobian): Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:,:) :: g Source Code subroutine grad ( me , x , g ) !! compute the gradient of the function (Jacobian): implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:,:), intent ( out ) :: g f_evals = f_evals + 2 ! to approximate forward diff derivatives g ( 1 , 1 ) = 2.0_wp * x ( 1 ) !df(1)/dx g ( 2 , 1 ) = 0.0_wp !df(2)/dx g ( 1 , 2 ) = 1.0_wp !df(1)/dy g ( 2 , 2 ) = 1.0_wp !df(2)/dy end subroutine grad","tags":"","loc":"proc/grad~2.html"},{"title":"export – AoC-2023","text":"subroutine export(me, x, f, iter) export an iteration: Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: f integer, intent(in) :: iter iteration number Source Code subroutine export ( me , x , f , iter ) !! export an iteration: implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: f integer , intent ( in ) :: iter !! iteration number write ( * , '(1P,I3,1X,A,I3,A,*(E15.6))' ) iter , '(' , f_evals , ')' , x , norm2 ( f ) end subroutine export","tags":"","loc":"proc/export~2.html"},{"title":"test_1 – AoC-2023","text":"subroutine test_1() Arguments None Calls proc~~test_1~~CallsGraph proc~test_1 main::test_1 proc~solve lusol_ez_module::solve proc~test_1->proc~solve proc~lu1fac lusol::lu1fac proc~solve->proc~lu1fac proc~lu6sol lusol::lu6sol proc~solve->proc~lu6sol proc~lu1fad lusol::lu1fad proc~lu1fac->proc~lu1fad proc~lu1or1 lusol::lu1or1 proc~lu1fac->proc~lu1or1 proc~lu1or2 lusol::lu1or2 proc~lu1fac->proc~lu1or2 proc~lu1or3 lusol::lu1or3 proc~lu1fac->proc~lu1or3 proc~lu1or4 lusol::lu1or4 proc~lu1fac->proc~lu1or4 proc~lu1pq1 lusol::lu1pq1 proc~lu1fac->proc~lu1pq1 proc~lu1slk lusol::lu1slk proc~lu1fac->proc~lu1slk proc~lu6chk lusol::lu6chk proc~lu1fac->proc~lu6chk proc~lu6l lusol::lu6L proc~lu6sol->proc~lu6l proc~lu6ld lusol::lu6LD proc~lu6sol->proc~lu6ld proc~lu6lt lusol::lu6Lt proc~lu6sol->proc~lu6lt proc~lu6u lusol::lu6U proc~lu6sol->proc~lu6u proc~lu6ut lusol::lu6Ut proc~lu6sol->proc~lu6ut proc~hbuild lusol::Hbuild proc~lu1fad->proc~hbuild proc~hchange lusol::Hchange proc~lu1fad->proc~hchange proc~hdelete lusol::Hdelete proc~lu1fad->proc~hdelete proc~lu1ful lusol::lu1ful proc~lu1fad->proc~lu1ful proc~lu1gau lusol::lu1gau proc~lu1fad->proc~lu1gau proc~lu1mar lusol::lu1mar proc~lu1fad->proc~lu1mar proc~lu1mrp lusol::lu1mRP proc~lu1fad->proc~lu1mrp proc~lu1msp lusol::lu1mSP proc~lu1fad->proc~lu1msp proc~lu1mxc lusol::lu1mxc proc~lu1fad->proc~lu1mxc proc~lu1mxr lusol::lu1mxr proc~lu1fad->proc~lu1mxr proc~lu1pen lusol::lu1pen proc~lu1fad->proc~lu1pen proc~lu1pq2 lusol::lu1pq2 proc~lu1fad->proc~lu1pq2 proc~lu1pq3 lusol::lu1pq3 proc~lu1fad->proc~lu1pq3 proc~lu1rec lusol::lu1rec proc~lu1fad->proc~lu1rec proc~hinsert lusol::Hinsert proc~hbuild->proc~hinsert proc~hdown lusol::Hdown proc~hchange->proc~hdown proc~hup lusol::Hup proc~hchange->proc~hup proc~hdelete->proc~hchange proc~lu1dcp lusol::lu1DCP proc~lu1ful->proc~lu1dcp proc~lu1dpp lusol::lu1DPP proc~lu1ful->proc~lu1dpp proc~hinsert->proc~hup proc~jdamax lusol::jdamax proc~lu1dcp->proc~jdamax proc~lu1dpp->proc~jdamax Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~test_1~~CalledByGraph proc~test_1 main::test_1 program~main main program~main->proc~test_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine test_1 () ! define a 3x3 dense system to solve: integer , parameter :: m = 3 !! number of rows in `A` matrix integer , parameter :: n = 3 !! number of columns in `A` matrix real ( wp ), dimension ( m ), parameter :: b = real ([ 1 , 2 , 3 ], wp ) integer , dimension ( m * n ), parameter :: icol = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ] integer , dimension ( m * n ), parameter :: irow = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] real ( wp ), dimension ( m * n ), parameter :: a = real ([ 1 , 4 , 7 , 2 , 5 , 88 , 3 , 66 , 9 ], wp ) real ( wp ), dimension ( m , 1 ), parameter :: b_vec = reshape ( b ,[ m , 1 ]) real ( wp ), dimension ( m , n ), parameter :: a_mat = reshape ( a ,[ 3 , 3 ]) real ( wp ), dimension ( n ) :: x real ( wp ), dimension ( n , 1 ) :: x_vec integer :: istat write ( * , * ) '' write ( * , * ) '***** test 1' write ( * , * ) '' call solve ( n , m , m * n , irow , icol , a , b , x , istat ) x_vec ( 1 : 3 , 1 ) = x write ( * , * ) '' write ( * , * ) 'istop = ' , istat write ( * , * ) '' write ( * , '(1P,A,*(E16.6))' ) 'x       = ' , x write ( * , '(1P,A,*(E16.6))' ) 'A*x     = ' , matmul ( a_mat , x_vec ) write ( * , '(1P,A,*(E16.6))' ) 'A*x - b = ' , matmul ( a_mat , x_vec ) - b_vec if ( any ( abs ( matmul ( a_mat , x_vec ) - b_vec ) > 1.0e-12 )) error stop 'TEST FAILED' end subroutine test_1","tags":"","loc":"proc/test_1.html"},{"title":"test_2 – AoC-2023","text":"subroutine test_2() >>> a\n array([[  4. ,   5. ,  66. ,   0.1],\n        [  1. ,  -3. ,   8. ,  -9. ],\n        [ 11. ,   3. , -87. ,   2. ]])\n >>> b\n array([1, 2, 3])\n >>> scipy.sparse.linalg.lsqr(a, b)\n (array([ 0.26437473,  0.04901579, -0.00426183, -0.21297414]), 1, 3, 5.5785963493386424e-12, 5.5785963493386424e-12, 110.70234866523838, 15.316189089999897, 6.119548932941366e-10, 0.343034538979173, array([0., 0., 0., 0.]))\n >>> Arguments None Calls proc~~test_2~~CallsGraph proc~test_2 main::test_2 proc~solve lusol_ez_module::solve proc~test_2->proc~solve proc~lu1fac lusol::lu1fac proc~solve->proc~lu1fac proc~lu6sol lusol::lu6sol proc~solve->proc~lu6sol proc~lu1fad lusol::lu1fad proc~lu1fac->proc~lu1fad proc~lu1or1 lusol::lu1or1 proc~lu1fac->proc~lu1or1 proc~lu1or2 lusol::lu1or2 proc~lu1fac->proc~lu1or2 proc~lu1or3 lusol::lu1or3 proc~lu1fac->proc~lu1or3 proc~lu1or4 lusol::lu1or4 proc~lu1fac->proc~lu1or4 proc~lu1pq1 lusol::lu1pq1 proc~lu1fac->proc~lu1pq1 proc~lu1slk lusol::lu1slk proc~lu1fac->proc~lu1slk proc~lu6chk lusol::lu6chk proc~lu1fac->proc~lu6chk proc~lu6l lusol::lu6L proc~lu6sol->proc~lu6l proc~lu6ld lusol::lu6LD proc~lu6sol->proc~lu6ld proc~lu6lt lusol::lu6Lt proc~lu6sol->proc~lu6lt proc~lu6u lusol::lu6U proc~lu6sol->proc~lu6u proc~lu6ut lusol::lu6Ut proc~lu6sol->proc~lu6ut proc~hbuild lusol::Hbuild proc~lu1fad->proc~hbuild proc~hchange lusol::Hchange proc~lu1fad->proc~hchange proc~hdelete lusol::Hdelete proc~lu1fad->proc~hdelete proc~lu1ful lusol::lu1ful proc~lu1fad->proc~lu1ful proc~lu1gau lusol::lu1gau proc~lu1fad->proc~lu1gau proc~lu1mar lusol::lu1mar proc~lu1fad->proc~lu1mar proc~lu1mrp lusol::lu1mRP proc~lu1fad->proc~lu1mrp proc~lu1msp lusol::lu1mSP proc~lu1fad->proc~lu1msp proc~lu1mxc lusol::lu1mxc proc~lu1fad->proc~lu1mxc proc~lu1mxr lusol::lu1mxr proc~lu1fad->proc~lu1mxr proc~lu1pen lusol::lu1pen proc~lu1fad->proc~lu1pen proc~lu1pq2 lusol::lu1pq2 proc~lu1fad->proc~lu1pq2 proc~lu1pq3 lusol::lu1pq3 proc~lu1fad->proc~lu1pq3 proc~lu1rec lusol::lu1rec proc~lu1fad->proc~lu1rec proc~hinsert lusol::Hinsert proc~hbuild->proc~hinsert proc~hdown lusol::Hdown proc~hchange->proc~hdown proc~hup lusol::Hup proc~hchange->proc~hup proc~hdelete->proc~hchange proc~lu1dcp lusol::lu1DCP proc~lu1ful->proc~lu1dcp proc~lu1dpp lusol::lu1DPP proc~lu1ful->proc~lu1dpp proc~hinsert->proc~hup proc~jdamax lusol::jdamax proc~lu1dcp->proc~jdamax proc~lu1dpp->proc~jdamax Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~test_2~~CalledByGraph proc~test_2 main::test_2 program~main main program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine test_2 () ! another test case (with n>m). compare to scipy. !!``` !! >>> a !! array([[  4. ,   5. ,  66. ,   0.1], !!        [  1. ,  -3. ,   8. ,  -9. ], !!        [ 11. ,   3. , -87. ,   2. ]]) !! >>> b !! array([1, 2, 3]) !! >>> scipy.sparse.linalg.lsqr(a, b) !! (array([ 0.26437473,  0.04901579, -0.00426183, -0.21297414]), 1, 3, 5.5785963493386424e-12, 5.5785963493386424e-12, 110.70234866523838, 15.316189089999897, 6.119548932941366e-10, 0.343034538979173, array([0., 0., 0., 0.])) !! >>> !!``` integer , parameter :: m = 3 !! number of rows in `A` matrix integer , parameter :: n = 4 !! number of columns in `A` matrix real ( wp ), dimension ( m ), parameter :: b = real ([ 1 , 2 , 3 ], wp ) integer , dimension ( m * n ), parameter :: icol = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 ] integer , dimension ( m * n ), parameter :: irow = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] real ( wp ), dimension ( m * n ), parameter :: a = [ 4.1_wp , 1.1_wp , 1 1.1_wp ,& 5.1_wp , - 3.1_wp , 3.1_wp ,& 6 6.1_wp , 8.1_wp , - 8 7.1_wp ,& 0.1_wp , - 9.1_wp , 2.1_wp ] real ( wp ), dimension ( m , 1 ), parameter :: b_vec = reshape ( b ,[ m , 1 ]) real ( wp ), dimension ( m , n ), parameter :: a_mat = reshape ( a ,[ 3 , 4 ]) real ( wp ), dimension ( n ) :: x real ( wp ), dimension ( n , 1 ) :: x_vec integer :: istat write ( * , * ) '' write ( * , * ) '***** test 2' write ( * , * ) '' call solve ( n , m , m * n , irow , icol , a , b , x , istat ) x_vec ( 1 : 4 , 1 ) = x write ( * , * ) '' write ( * , * ) 'istop = ' , istat write ( * , * ) '' write ( * , '(1P,A,*(E16.6))' ) 'x       = ' , x write ( * , '(1P,A,*(E16.6))' ) 'A*x     = ' , matmul ( a_mat , x_vec ) write ( * , '(1P,A,*(E16.6))' ) 'A*x - b = ' , matmul ( a_mat , x_vec ) - b_vec if ( any ( abs ( matmul ( a_mat , x_vec ) - b_vec ) > 1.0e-12 )) error stop 'TEST FAILED' end subroutine test_2","tags":"","loc":"proc/test_2.html"},{"title":"dag_get_edges – AoC-2023","text":"private pure function dag_get_edges(me, ivertex) result(edges) get the edges for the vertex (all the the vertices\nthat this vertex depends on). Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer, intent(in) :: ivertex Return Value integer, dimension(:), allocatable Source Code pure function dag_get_edges ( me , ivertex ) result ( edges ) implicit none class ( dag ), intent ( in ) :: me integer , intent ( in ) :: ivertex integer , dimension (:), allocatable :: edges if ( ivertex > 0 . and . ivertex <= me % n ) then edges = me % vertices ( ivertex )% edges ! auto LHS allocation end if end function dag_get_edges","tags":"","loc":"proc/dag_get_edges.html"},{"title":"dag_get_dependencies – AoC-2023","text":"private pure function dag_get_dependencies(me, ivertex) result(dep) get all the vertices that depend on this vertex. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer, intent(in) :: ivertex Return Value integer, dimension(:), allocatable the set of all vertices\nthan depend on ivertex Source Code pure function dag_get_dependencies ( me , ivertex ) result ( dep ) implicit none class ( dag ), intent ( in ) :: me integer , intent ( in ) :: ivertex integer , dimension (:), allocatable :: dep !! the set of all vertices !! than depend on `ivertex` integer :: i !! vertex counter if ( ivertex > 0 . and . ivertex <= me % n ) then ! have to check all the vertices: do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then if ( any ( me % vertices ( i )% edges == ivertex )) then if ( allocated ( dep )) then dep = [ dep , i ] ! auto LHS allocation else dep = [ i ] ! auto LHS allocation end if end if end if end do end if end function dag_get_dependencies","tags":"","loc":"proc/dag_get_dependencies.html"},{"title":"dag_generate_digraph – AoC-2023","text":"private  function dag_generate_digraph(me, rankdir, dpi) result(str) Generate a Graphviz digraph structure for the DAG. Example To convert this to a PDF using dot : dot -Tpdf -o test.pdf test.dot ,\n    where test.dot is str written to a file. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer, intent(in), optional :: dpi resolution (e.g. 300) Return Value character(len=:), allocatable Calls proc~~dag_generate_digraph~~CallsGraph proc~dag_generate_digraph dag_module::dag%dag_generate_digraph proc~integer_to_string dag_module::integer_to_string proc~dag_generate_digraph->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dag_generate_digraph~~CalledByGraph proc~dag_generate_digraph dag_module::dag%dag_generate_digraph proc~dag_save_digraph dag_module::dag%dag_save_digraph proc~dag_save_digraph->proc~dag_generate_digraph program~dag_example dag_example program~dag_example->proc~dag_save_digraph program~problem_25 problem_25 program~problem_25->proc~dag_save_digraph Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function dag_generate_digraph ( me , rankdir , dpi ) result ( str ) implicit none class ( dag ), intent ( in ) :: me character ( len = :), allocatable :: str character ( len =* ), intent ( in ), optional :: rankdir !! right to left orientation (e.g. 'RL') integer , intent ( in ), optional :: dpi !! resolution (e.g. 300) integer :: i , j !! counter integer :: n_edges !! number of edges character ( len = :), allocatable :: attributes , label logical :: has_label , has_attributes character ( len =* ), parameter :: tab = '  ' !! for indenting character ( len =* ), parameter :: newline = new_line ( ' ' ) !! line break character if ( me % n == 0 ) return str = 'digraph G {' // newline // newline if ( present ( rankdir )) & str = str // tab // 'rankdir=' // rankdir // newline // newline if ( present ( dpi )) & str = str // tab // 'graph [ dpi = ' // integer_to_string ( dpi ) // ' ]' // newline // newline ! define the vertices: do i = 1 , me % n has_label = allocated ( me % vertices ( i )% label ) has_attributes = allocated ( me % vertices ( i )% attributes ) if ( has_label ) label = 'label=\"' // trim ( adjustl ( me % vertices ( i )% label )) // '\"' if ( has_label . and . has_attributes ) then attributes = '[' // trim ( adjustl ( me % vertices ( i )% attributes )) // ',' // label // ']' elseif ( has_label . and . . not . has_attributes ) then attributes = '[' // label // ']' elseif (. not . has_label . and . has_attributes ) then attributes = '[' // trim ( adjustl ( me % vertices ( i )% attributes )) // ']' else ! neither attributes = '' end if str = str // tab // integer_to_string ( i ) // ' ' // attributes // newline if ( i == me % n ) str = str // newline end do ! define the dependencies: do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then n_edges = size ( me % vertices ( i )% edges ) str = str // tab // integer_to_string ( i ) // merge ( ' -> ' , '    ' , n_edges /= 0 ) do j = 1 , n_edges ! comma-separated list: str = str // integer_to_string ( me % vertices ( i )% edges ( j )) if ( n_edges > 1 . and . j < n_edges ) str = str // ',' end do str = str // ';' // newline end if end do str = str // newline // '}' end function dag_generate_digraph","tags":"","loc":"proc/dag_generate_digraph.html"},{"title":"integer_to_string – AoC-2023","text":"private pure function integer_to_string(i) result(s) Integer to allocatable string. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=:), allocatable Called by proc~~integer_to_string~~CalledByGraph proc~integer_to_string dag_module::integer_to_string proc~dag_generate_digraph dag_module::dag%dag_generate_digraph proc~dag_generate_digraph->proc~integer_to_string proc~dag_set_vertex_info dag_module::dag%dag_set_vertex_info proc~dag_set_vertex_info->proc~integer_to_string proc~dag_save_digraph dag_module::dag%dag_save_digraph proc~dag_save_digraph->proc~dag_generate_digraph program~dag_example dag_example program~dag_example->proc~dag_set_vertex_info program~dag_example->proc~dag_save_digraph program~problem_25 problem_25 program~problem_25->proc~dag_set_vertex_info program~problem_25->proc~dag_save_digraph Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function integer_to_string ( i ) result ( s ) implicit none integer , intent ( in ) :: i character ( len = :), allocatable :: s integer :: istat allocate ( character ( len = 64 ) :: s ) ! should be big enough write ( s , fmt = '(ss,I0)' , iostat = istat ) i if ( istat == 0 ) then s = trim ( adjustl ( s )) else s = '***' end if end function integer_to_string","tags":"","loc":"proc/integer_to_string.html"},{"title":"dag_destroy – AoC-2023","text":"private  subroutine dag_destroy(me) Destroy the dag . Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me Called by proc~~dag_destroy~~CalledByGraph proc~dag_destroy dag_module::dag%dag_destroy program~dag_example dag_example program~dag_example->proc~dag_destroy program~problem_25 problem_25 program~problem_25->proc~dag_destroy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_destroy ( me ) class ( dag ), intent ( inout ) :: me me % n = 0 if ( allocated ( me % vertices )) deallocate ( me % vertices ) end subroutine dag_destroy","tags":"","loc":"proc/dag_destroy.html"},{"title":"set_edge_vector – AoC-2023","text":"private  subroutine set_edge_vector(me, edges) specify the edge indices for this vertex Type Bound vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in), dimension(:) :: edges Calls proc~~set_edge_vector~~CallsGraph proc~set_edge_vector dag_module::vertex%set_edge_vector proc~add_edge dag_module::vertex%add_edge proc~set_edge_vector->proc~add_edge Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_edge_vector~~CalledByGraph proc~set_edge_vector dag_module::vertex%set_edge_vector none~set_edges dag_module::vertex%set_edges none~set_edges->proc~set_edge_vector proc~dag_set_edges dag_module::dag%dag_set_edges proc~dag_set_edges->none~set_edges program~dag_example dag_example program~dag_example->proc~dag_set_edges program~problem_25 problem_25 program~problem_25->proc~dag_set_edges Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_edge_vector ( me , edges ) class ( vertex ), intent ( inout ) :: me integer , dimension (:), intent ( in ) :: edges integer :: i !! counter if ( allocated ( me % edges )) then do i = 1 , size ( edges ) call me % add_edge ( edges ( i )) end do else allocate ( me % edges ( size ( edges ))) ! note: not checking for uniqueness here. me % edges = edges end if end subroutine set_edge_vector","tags":"","loc":"proc/set_edge_vector.html"},{"title":"add_edge – AoC-2023","text":"private  subroutine add_edge(me, edge) add an edge index for this vertex Type Bound vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in) :: edge Called by proc~~add_edge~~CalledByGraph proc~add_edge dag_module::vertex%add_edge none~set_edges dag_module::vertex%set_edges none~set_edges->proc~add_edge proc~set_edge_vector dag_module::vertex%set_edge_vector none~set_edges->proc~set_edge_vector proc~set_edge_vector->proc~add_edge proc~dag_set_edges dag_module::dag%dag_set_edges proc~dag_set_edges->none~set_edges program~dag_example dag_example program~dag_example->proc~dag_set_edges program~problem_25 problem_25 program~problem_25->proc~dag_set_edges Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine add_edge ( me , edge ) class ( vertex ), intent ( inout ) :: me integer , intent ( in ) :: edge if ( allocated ( me % edges )) then if (. not . any ( edge == me % edges )) then me % edges = [ me % edges , edge ] ! auto lhs reallocation end if else allocate ( me % edges ( 1 )) me % edges = [ edge ] end if end subroutine add_edge","tags":"","loc":"proc/add_edge.html"},{"title":"dag_set_vertices – AoC-2023","text":"private  subroutine dag_set_vertices(me, nvertices) set the number of vertices in the dag Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: nvertices number of vertices Called by proc~~dag_set_vertices~~CalledByGraph proc~dag_set_vertices dag_module::dag%dag_set_vertices program~dag_example dag_example program~dag_example->proc~dag_set_vertices program~problem_25 problem_25 program~problem_25->proc~dag_set_vertices Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_set_vertices ( me , nvertices ) class ( dag ), intent ( inout ) :: me integer , intent ( in ) :: nvertices !! number of vertices integer :: i me % n = nvertices allocate ( me % vertices ( nvertices )) me % vertices % ivertex = [( i , i = 1 , nvertices )] end subroutine dag_set_vertices","tags":"","loc":"proc/dag_set_vertices.html"},{"title":"dag_set_vertex_info – AoC-2023","text":"private  subroutine dag_set_vertex_info(me, ivertex, label, attributes) set info about a vertex in a dag. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: ivertex vertex number character(len=*), intent(in), optional :: label if a label is not set,\nthen the integer vertex\nnumber is used. character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. Calls proc~~dag_set_vertex_info~~CallsGraph proc~dag_set_vertex_info dag_module::dag%dag_set_vertex_info proc~integer_to_string dag_module::integer_to_string proc~dag_set_vertex_info->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dag_set_vertex_info~~CalledByGraph proc~dag_set_vertex_info dag_module::dag%dag_set_vertex_info program~dag_example dag_example program~dag_example->proc~dag_set_vertex_info program~problem_25 problem_25 program~problem_25->proc~dag_set_vertex_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_set_vertex_info ( me , ivertex , label , attributes ) class ( dag ), intent ( inout ) :: me integer , intent ( in ) :: ivertex !! vertex number character ( len =* ), intent ( in ), optional :: label !! if a label is not set, !! then the integer vertex !! number is used. character ( len =* ), intent ( in ), optional :: attributes !! other attributes when !! saving as a diagraph. if ( present ( label )) then me % vertices ( ivertex )% label = label else ! just use the vertex number me % vertices ( ivertex )% label = integer_to_string ( ivertex ) end if if ( present ( attributes )) then me % vertices ( ivertex )% attributes = attributes end if end subroutine dag_set_vertex_info","tags":"","loc":"proc/dag_set_vertex_info.html"},{"title":"dag_set_edges – AoC-2023","text":"private  subroutine dag_set_edges(me, ivertex, edges) set the edges for a vertex in a dag Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: ivertex vertex number integer, intent(in), dimension(:) :: edges Calls proc~~dag_set_edges~~CallsGraph proc~dag_set_edges dag_module::dag%dag_set_edges none~set_edges dag_module::vertex%set_edges proc~dag_set_edges->none~set_edges proc~add_edge dag_module::vertex%add_edge none~set_edges->proc~add_edge proc~set_edge_vector dag_module::vertex%set_edge_vector none~set_edges->proc~set_edge_vector proc~set_edge_vector->proc~add_edge Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dag_set_edges~~CalledByGraph proc~dag_set_edges dag_module::dag%dag_set_edges program~dag_example dag_example program~dag_example->proc~dag_set_edges program~problem_25 problem_25 program~problem_25->proc~dag_set_edges Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_set_edges ( me , ivertex , edges ) class ( dag ), intent ( inout ) :: me integer , intent ( in ) :: ivertex !! vertex number integer , dimension (:), intent ( in ) :: edges call me % vertices ( ivertex )% set_edges ( edges ) end subroutine dag_set_edges","tags":"","loc":"proc/dag_set_edges.html"},{"title":"dag_toposort – AoC-2023","text":"private  subroutine dag_toposort(me, order, istat) Main toposort routine Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: order the toposort order integer, intent(out) :: istat Status flag: 0 if no errors -1 if circular dependency\n (in this case, order will not be allocated) Called by proc~~dag_toposort~~CalledByGraph proc~dag_toposort dag_module::dag%dag_toposort program~dag_example dag_example program~dag_example->proc~dag_toposort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_toposort ( me , order , istat ) class ( dag ), intent ( inout ) :: me integer , dimension (:), allocatable , intent ( out ) :: order !! the toposort order integer , intent ( out ) :: istat !! Status flag: !! !! * 0 if no errors !! * -1 if circular dependency !!  (in this case, `order` will not be allocated) integer :: i , iorder if ( me % n == 0 ) return allocate ( order ( me % n )) iorder = 0 ! index in order array istat = 0 ! no errors so far do i = 1 , me % n if (. not . me % vertices ( i )% marked ) call dfs ( me % vertices ( i )) if ( istat ==- 1 ) exit end do if ( istat ==- 1 ) deallocate ( order ) contains recursive subroutine dfs ( v ) !! depth-first graph traversal type ( vertex ), intent ( inout ) :: v integer :: j if ( istat ==- 1 ) return if ( v % checking ) then ! error: circular dependency istat = - 1 else if (. not . v % marked ) then v % checking = . true . if ( allocated ( v % edges )) then do j = 1 , size ( v % edges ) call dfs ( me % vertices ( v % edges ( j ))) if ( istat ==- 1 ) return end do end if v % checking = . false . v % marked = . true . iorder = iorder + 1 order ( iorder ) = v % ivertex end if end if end subroutine dfs end subroutine dag_toposort","tags":"","loc":"proc/dag_toposort.html"},{"title":"dag_generate_dependency_matrix – AoC-2023","text":"private  subroutine dag_generate_dependency_matrix(me, mat) Generate the dependency matrix for the DAG. This is an matrix with elements ,\nsuch that is true if vertex depends on vertex . Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me logical, intent(out), dimension(:,:), allocatable :: mat dependency matrix Called by proc~~dag_generate_dependency_matrix~~CalledByGraph proc~dag_generate_dependency_matrix dag_module::dag%dag_generate_dependency_matrix program~dag_example dag_example program~dag_example->proc~dag_generate_dependency_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_generate_dependency_matrix ( me , mat ) implicit none class ( dag ), intent ( in ) :: me logical , dimension (:,:), intent ( out ), allocatable :: mat !! dependency matrix integer :: i !! vertex counter if ( me % n > 0 ) then allocate ( mat ( me % n , me % n )) mat = . false . do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then mat ( i , me % vertices ( i )% edges ) = . true . end if end do end if end subroutine dag_generate_dependency_matrix","tags":"","loc":"proc/dag_generate_dependency_matrix.html"},{"title":"dag_save_digraph – AoC-2023","text":"private  subroutine dag_save_digraph(me, filename, rankdir, dpi) Generate a Graphviz digraph structure for the DAG and write it to a file. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: filename file name for diagraph character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer, intent(in), optional :: dpi resolution (e.g. 300) Calls proc~~dag_save_digraph~~CallsGraph proc~dag_save_digraph dag_module::dag%dag_save_digraph proc~dag_generate_digraph dag_module::dag%dag_generate_digraph proc~dag_save_digraph->proc~dag_generate_digraph proc~integer_to_string dag_module::integer_to_string proc~dag_generate_digraph->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dag_save_digraph~~CalledByGraph proc~dag_save_digraph dag_module::dag%dag_save_digraph program~dag_example dag_example program~dag_example->proc~dag_save_digraph program~problem_25 problem_25 program~problem_25->proc~dag_save_digraph Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_save_digraph ( me , filename , rankdir , dpi ) implicit none class ( dag ), intent ( in ) :: me character ( len =* ), intent ( in ), optional :: filename !! file name for diagraph character ( len =* ), intent ( in ), optional :: rankdir !! right to left orientation (e.g. 'RL') integer , intent ( in ), optional :: dpi !! resolution (e.g. 300) integer :: iunit , istat character ( len = :), allocatable :: diagraph diagraph = me % generate_digraph ( rankdir , dpi ) open ( newunit = iunit , file = filename , status = 'REPLACE' , iostat = istat ) if ( istat == 0 ) then write ( iunit , fmt = '(A)' , iostat = istat ) diagraph else write ( * , * ) 'error opening ' // trim ( filename ) end if close ( iunit , iostat = istat ) end subroutine dag_save_digraph","tags":"","loc":"proc/dag_save_digraph.html"},{"title":"step – AoC-2023","text":"recursive subroutine step(array) take all valid steps from any # elements in array Arguments Type Intent Optional Attributes Name character(len=1), intent(inout), dimension(:,:), allocatable :: array Called by proc~~step~~CalledByGraph proc~step problem_21::step program~problem_21 problem_21 program~problem_21->proc~step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine step ( array ) !! take all valid steps from any # elements in array character ( len = 1 ), dimension (:,:), intent ( inout ), allocatable :: array integer :: i , j logical :: steped character ( len = 1 ), dimension (:,:), allocatable :: tmp tmp = array do i = 1 , nrows do j = 1 , ncols if ( array ( i , j ) == 'O' ) then steped = . false . ! try a step in each direction: if ( array ( i - 1 , j ) == '.' ) then tmp ( i - 1 , j ) = 'O' ; steped = . true . end if if ( array ( i + 1 , j ) == '.' ) then tmp ( i + 1 , j ) = 'O' ; steped = . true . end if if ( array ( i , j - 1 ) == '.' ) then tmp ( i , j - 1 ) = 'O' ; steped = . true . end if if ( array ( i , j + 1 ) == '.' ) then tmp ( i , j + 1 ) = 'O' ; steped = . true . end if if ( steped ) tmp ( i , j ) = '.' end if end do end do call move_alloc ( tmp , array ) end subroutine step","tags":"","loc":"proc/step.html"},{"title":"set_status – AoC-2023","text":"private  subroutine set_status(me, istat, string, i, r) Set status flag and message. Type Bound nlesolver_type Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me integer, intent(in) :: istat status code character(len=*), intent(in) :: string status message integer, intent(in), optional :: i an integer value to append real(kind=wp), intent(in), optional :: r a real value to append Called by proc~~set_status~~CalledByGraph proc~set_status nlesolver_module::nlesolver_type%set_status proc~initialize_nlesolver_variables nlesolver_module::nlesolver_type%initialize_nlesolver_variables proc~initialize_nlesolver_variables->proc~set_status proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver proc~nlesolver_solver->proc~set_status program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->proc~initialize_nlesolver_variables program~nlesolver_test_1->proc~nlesolver_solver program~sparse_test sparse_test program~sparse_test->proc~initialize_nlesolver_variables program~sparse_test->proc~nlesolver_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_status ( me , istat , string , i , r ) implicit none class ( nlesolver_type ), intent ( inout ) :: me integer , intent ( in ) :: istat !! status code character ( len =* ), intent ( in ) :: string !! status message integer , intent ( in ), optional :: i !! an integer value to append real ( wp ), intent ( in ), optional :: r !! a real value to append character ( len = 256 ) :: numstr !! for number fo string conversion character ( len = :), allocatable :: message !! the full message to log integer :: iostat !! write `iostat` code message = trim ( string ) if ( present ( i )) then numstr = '' write ( numstr , fmt =* , iostat = iostat ) i if ( iostat /= 0 ) numstr = '****' message = message // ' ' // trim ( adjustl ( numstr )) end if if ( present ( r )) then numstr = '' write ( numstr , fmt =* , iostat = iostat ) r if ( iostat /= 0 ) numstr = '****' message = message // ' ' // trim ( adjustl ( numstr )) end if if ( me % verbose ) then write ( me % iunit , '(A)' , iostat = iostat ) message end if ! store in the class: me % istat = istat me % message = message end subroutine set_status","tags":"","loc":"proc/set_status.html"},{"title":"get_status – AoC-2023","text":"private  subroutine get_status(me, istat, message) Return the status code and message from the nlesolver_type class. Status codes -1   -- Error: Invalid alpha -2   -- Error: Invalid alpha_min -3   -- Error: Invalid alpha_max -4   -- Error: Alpha_min must be < alpha_max -5   -- Error: Invalid step_mode -6   -- Error solving linear system -7   -- Error: More than 5 steps in the uphill direction -8   -- Error: Divide by zero when computing Broyden update -9   -- Error: Out of memory -10  -- Error: function routine is not associated -11  -- Error: gradient routine is not associated -12  -- Error: backtracking linesearch c must be in range (0, 1) -13  -- Error: backtracking linesearch tau must be in range (0, 1) -14  -- Error: must specify grad_sparse, irow, and icol for sparsity_mode > 1 -15  -- Error: irow and icol must be the same length -999 -- Error: class has not been initialized 0    -- Class successfully initialized in initialize 1    -- Required accuracy achieved 2    -- Solution cannot be improved 3    -- Maximum number of iterations reached 4    -- Stopped by the user Type Bound nlesolver_type Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me integer, intent(out), optional :: istat Integer status code. character(len=:), intent(out), optional, allocatable :: message Text status message Called by proc~~get_status~~CalledByGraph proc~get_status nlesolver_module::nlesolver_type%get_status program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->proc~get_status program~sparse_test sparse_test program~sparse_test->proc~get_status Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_status ( me , istat , message ) implicit none class ( nlesolver_type ), intent ( inout ) :: me integer , intent ( out ), optional :: istat !! Integer status code. character ( len = :), allocatable , intent ( out ), optional :: message !! Text status message if ( present ( istat )) istat = me % istat if ( present ( message )) then if ( allocated ( me % message )) then message = trim ( me % message ) else message = 'Error: class has not been initialized' end if end if end subroutine get_status","tags":"","loc":"proc/get_status.html"},{"title":"initialize_nlesolver_variables – AoC-2023","text":"private  subroutine initialize_nlesolver_variables(me, n, m, max_iter, tol, alpha, alpha_min, alpha_max, tolx, fmin_tol, backtrack_c, backtrack_tau, use_broyden, broyden_update_n, step_mode, func, grad, grad_sparse, export_iteration, user_input_check, verbose, iunit, n_uphill_max, n_intervals, sparsity_mode, irow, icol, atol, btol, conlim, damp, itnlim, nout, lusol_method) Constructor for the class. Type Bound nlesolver_type Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me integer, intent(in) :: n number of optimization variables integer, intent(in) :: m number of constraints integer, intent(in) :: max_iter maximum number of iterations real(kind=wp), intent(in) :: tol function convergence tolerance real(kind=wp), intent(in), optional :: alpha constant step length for step_mode=1 (0,1] real(kind=wp), intent(in), optional :: alpha_min minimum step length (0,1] real(kind=wp), intent(in), optional :: alpha_max maximum step length (0,1] real(kind=wp), intent(in), optional :: tolx convergence tolerance for changes in x real(kind=wp), intent(in), optional :: fmin_tol convergence tolerance for fmin (used when step_mode=3 ) real(kind=wp), intent(in), optional :: backtrack_c backtracking linesearch parameter (0,1) real(kind=wp), intent(in), optional :: backtrack_tau backtracking linesearch parameter (0,1) logical, intent(in), optional :: use_broyden use a Broyden update (default is False) integer, intent(in), optional :: broyden_update_n For Broyden mode, update the full Jacobian\nat most every this many iterations (must be >1)\nIf <=1 then Jacobian is only computed on the\nfirst iteration. integer, intent(in), optional :: step_mode step mode: 1 = use the specified alpha (0,1] 2 = backtracking linesearch (between alpha_min and alpha_max ) 3 = exact linesearch (between alpha_min and alpha_max ) 4 = evaluate function at specified fixed points  (between alpha_min and alpha_max ) procedure( func_func ) :: func computes the function vector procedure( grad_func ), optional :: grad computes the jacobian [required for dense mode: sparsity_mode=1 ] procedure( grad_func_sparse ), optional :: grad_sparse computes the jacobian [required for sparse mode: sparsity_mode>1 ] procedure( export_func ), optional :: export_iteration function to export each iteration procedure( wait_func ), optional :: user_input_check check for user input (to stop solver if necessary) logical, intent(in), optional :: verbose for verbose status printing integer, intent(in), optional :: iunit unit for verbose printing (assumed to be open).\nby default this is output_unit . integer, intent(in), optional :: n_uphill_max maximum number of consecutive steps\nto allow where the value of f increases integer, intent(in), optional :: n_intervals number of intervals for fixed point linesearch integer, intent(in), optional :: sparsity_mode sparsity mode: 1 - assume dense (use dense solver)\n  Must specify grad for this mode. 2 - assume sparse (use LSQR sparse solver). 3 - assume sparse (use LUSOL sparse solver).\nMust also specify grad_sparse and the irow and icol sparsity pattern for mode>1 . integer, intent(in), optional, dimension(:) :: irow sparsity pattern nonzero elements row indices.\nmust be specified with icol and be the same length ( n_nonzeros ). integer, intent(in), optional, dimension(:) :: icol sparsity pattern nonzero elements column indices\nmust be specified with icol and be the same length ( n_nonzeros ). real(kind=wp), intent(in), optional :: atol LSQR: relative error in definition of A real(kind=wp), intent(in), optional :: btol LSQR: relative error in definition of b real(kind=wp), intent(in), optional :: conlim condition number of the matrix Abar . real(kind=wp), intent(in), optional :: damp LSQR: damp factor integer, intent(in), optional :: itnlim LSQR: max iterations integer, intent(in), optional :: nout LSQR: output unit for printing integer, intent(in), optional :: lusol_method Calls proc~~initialize_nlesolver_variables~~CallsGraph proc~initialize_nlesolver_variables nlesolver_module::nlesolver_type%initialize_nlesolver_variables proc~set_status nlesolver_module::nlesolver_type%set_status proc~initialize_nlesolver_variables->proc~set_status Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~initialize_nlesolver_variables~~CalledByGraph proc~initialize_nlesolver_variables nlesolver_module::nlesolver_type%initialize_nlesolver_variables program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->proc~initialize_nlesolver_variables program~sparse_test sparse_test program~sparse_test->proc~initialize_nlesolver_variables Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize_nlesolver_variables ( me ,& n , m , max_iter , tol , alpha , alpha_min , alpha_max , tolx , fmin_tol ,& backtrack_c , backtrack_tau ,& use_broyden , broyden_update_n , step_mode ,& func , grad , grad_sparse ,& export_iteration , user_input_check ,& verbose , iunit , n_uphill_max , n_intervals ,& sparsity_mode , irow , icol ,& atol , btol , conlim , damp , itnlim , nout ,& lusol_method ) implicit none class ( nlesolver_type ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of optimization variables integer , intent ( in ) :: m !! number of constraints integer , intent ( in ) :: max_iter !! maximum number of iterations real ( wp ), intent ( in ) :: tol !! function convergence tolerance procedure ( func_func ) :: func !! computes the function vector procedure ( grad_func ), optional :: grad !! computes the jacobian [required for dense mode: `sparsity_mode=1`] procedure ( grad_func_sparse ), optional :: grad_sparse !! computes the jacobian [required for sparse mode: `sparsity_mode>1`] integer , intent ( in ), optional :: step_mode !! step mode: !! !!  * 1 = use the specified `alpha` (0,1] !!  * 2 = backtracking linesearch (between `alpha_min` and `alpha_max`) !!  * 3 = exact linesearch (between `alpha_min` and `alpha_max`) !!  * 4 = evaluate function at specified fixed points  (between `alpha_min` and `alpha_max`) real ( wp ), intent ( in ), optional :: alpha !! constant step length for `step_mode=1` (0,1] real ( wp ), intent ( in ), optional :: alpha_min !! minimum step length (0,1] real ( wp ), intent ( in ), optional :: alpha_max !! maximum step length (0,1] real ( wp ), intent ( in ), optional :: tolx !! convergence tolerance for changes in `x` real ( wp ), intent ( in ), optional :: fmin_tol !! convergence tolerance for [[fmin]] (used when `step_mode=3`) real ( wp ), intent ( in ), optional :: backtrack_c !! backtracking linesearch parameter (0,1) real ( wp ), intent ( in ), optional :: backtrack_tau !! backtracking linesearch parameter (0,1) logical , intent ( in ), optional :: use_broyden !! use a Broyden update (default is False) integer , intent ( in ), optional :: broyden_update_n !! For Broyden mode, update the full Jacobian !! at most every this many iterations (must be >1) !! If <=1 then Jacobian is only computed on the !! first iteration. procedure ( export_func ), optional :: export_iteration !! function to export each iteration procedure ( wait_func ), optional :: user_input_check !! check for user input (to stop solver if necessary) logical , intent ( in ), optional :: verbose !! for verbose status printing integer , intent ( in ), optional :: iunit !! unit for verbose printing (assumed to be open). !! by default this is `output_unit`. integer , intent ( in ), optional :: n_uphill_max !! maximum number of consecutive steps !! to allow where the value of `f` increases integer , intent ( in ), optional :: n_intervals !! number of intervals for fixed point linesearch integer , intent ( in ), optional :: sparsity_mode !! sparsity mode: !! !! * 1 - assume dense (use dense solver) !!   Must specify `grad` for this mode. !! * 2 - assume sparse (use LSQR sparse solver). !! * 3 - assume sparse (use LUSOL sparse solver). !! Must also specify `grad_sparse` and the `irow` and `icol` !! sparsity pattern for `mode>1`. integer , dimension (:), intent ( in ), optional :: irow !! sparsity pattern nonzero elements row indices. !! must be specified with `icol` and be the same length (`n_nonzeros`). integer , dimension (:), intent ( in ), optional :: icol !! sparsity pattern nonzero elements column indices !! must be specified with `icol` and be the same length (`n_nonzeros`). real ( wp ), intent ( in ), optional :: atol !! LSQR: relative error in definition of `A` real ( wp ), intent ( in ), optional :: btol !! LSQR: relative error in definition of `b` real ( wp ), intent ( in ), optional :: conlim !! LSQR: An upper limit on `cond(Abar)`, the apparent !! condition number of the matrix `Abar`. real ( wp ), intent ( in ), optional :: damp !! LSQR: damp factor integer , intent ( in ), optional :: itnlim !! LSQR: max iterations integer , intent ( in ), optional :: nout !! LSQR: output unit for printing integer , intent ( in ), optional :: lusol_method logical :: status_ok !! true if there were no errors status_ok = . true . !required: me % n = abs ( n ) me % m = abs ( m ) me % max_iter = abs ( max_iter ) me % tol = abs ( tol ) me % func => func if ( present ( grad )) me % grad => grad if ( present ( grad_sparse )) me % grad_sparse => grad_sparse !optional: if ( present ( step_mode )) then select case ( step_mode ) case ( 1 ) ! = use the specified `alpha` (0,1] me % linesearch => simple_step case ( 2 ) ! = backtracking linesearch (between `alpha_min` and `alpha_max`) me % linesearch => backtracking_linesearch case ( 3 ) ! = exact linesearch (between `alpha_min` and `alpha_max`) me % linesearch => exact_linesearch case ( 4 ) ! = evaluate function at specified fixed points (between `alpha_min` and `alpha_max`) me % linesearch => fixed_point_linesearch case default status_ok = . false . call me % set_status ( istat = - 5 , string = 'Error: invalid step_mode:' , i = step_mode ) return end select else me % linesearch => simple_step end if if ( present ( alpha )) me % alpha = abs ( alpha ) if ( present ( alpha_min )) me % alpha_min = abs ( alpha_min ) if ( present ( alpha_max )) me % alpha_max = abs ( alpha_max ) if ( present ( tolx )) me % tolx = abs ( tolx ) if ( present ( backtrack_c )) me % c = abs ( backtrack_c ) if ( present ( backtrack_tau )) me % tau = abs ( backtrack_tau ) if ( present ( use_broyden )) me % use_broyden = use_broyden if ( present ( broyden_update_n )) me % broyden_update_n = abs ( broyden_update_n ) if ( present ( verbose )) me % verbose = verbose if ( present ( iunit )) me % iunit = iunit if ( present ( n_uphill_max )) me % n_uphill_max = abs ( n_uphill_max ) if ( present ( n_intervals )) me % n_intervals = max ( abs ( n_intervals ), 1 ) if ( present ( fmin_tol )) me % fmin_tol = abs ( fmin_tol ) if ( present ( export_iteration )) me % export_iteration => export_iteration if ( present ( user_input_check )) me % user_input_check => user_input_check ! error checks: if ( me % alpha < zero . or . me % alpha > one ) then status_ok = . false . call me % set_status ( istat = - 1 , string = 'Error: invalid alpha:' , r = me % alpha ) return end if if ( me % alpha_min < zero . or . me % alpha_min > one ) then status_ok = . false . call me % set_status ( istat = - 2 , string = 'Error: invalid alpha_min:' , r = me % alpha_min ) return end if if ( me % alpha_max < zero . or . me % alpha_max > one ) then status_ok = . false . call me % set_status ( istat = - 3 , string = 'Error: invalid alpha_max:' , r = me % alpha_max ) return end if if ( me % alpha_max <= me % alpha_min ) then status_ok = . false . call me % set_status ( istat = - 4 , string = 'Error: alpha_min must be < alpha_max' ) return end if if ( me % c < zero . or . me % c > one ) then status_ok = . false . call me % set_status ( istat = - 12 , string = 'Error: backtracking linesearch c must be in range (0, 1):' , r = me % c ) return end if if ( me % tau < zero . or . me % tau > one ) then status_ok = . false . call me % set_status ( istat = - 13 , string = 'Error: backtracking linesearch tau must be in range (0, 1):' , r = me % tau ) return end if ! initialize: me % n_nonzeros = - 1 ! not used if ( allocated ( me % irow )) deallocate ( me % irow ) if ( allocated ( me % icol )) deallocate ( me % icol ) if ( present ( sparsity_mode )) then me % sparsity_mode = sparsity_mode if ( sparsity_mode > 1 ) then ! sparse solver method if ( present ( irow ) . and . present ( icol ) . and . present ( grad_sparse )) then if ( size ( irow ) == size ( icol )) then me % n_nonzeros = size ( irow ) me % irow = irow me % icol = icol else call me % set_status ( istat = - 15 , string = 'Error: irow and icol must be the same length' ) return end if else call me % set_status ( istat = - 14 , string = 'Error: must specify grad_sparse, irow, and icol for sparsity_mode > 1' ) return end if ! LSQR optional inputs: if ( present ( atol )) me % atol = atol if ( present ( btol )) me % btol = btol if ( present ( conlim )) me % conlim = conlim if ( present ( damp )) me % damp = damp if ( present ( itnlim )) me % itnlim = itnlim if ( present ( nout )) me % nout = nout ! LUSOL method if ( present ( nout )) me % lusol_method = lusol_method ! now now, some options are not available for sparse mode !...see if this is possible in sparse mode... TODO if ( me % use_broyden ) then call me % set_status ( istat = - 16 , string = 'Error: broyden method not available for sparse solver' ) return end if end if end if if ( status_ok ) then call me % set_status ( istat = 0 , string = 'Class successfully initialized' ) end if end subroutine initialize_nlesolver_variables","tags":"","loc":"proc/initialize_nlesolver_variables.html"},{"title":"nlesolver_solver – AoC-2023","text":"private  subroutine nlesolver_solver(me, x) Uses lusol_ez_module lsqr_module proc~~nlesolver_solver~~UsesGraph proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver module~lsqr_module lsqr_module proc~nlesolver_solver->module~lsqr_module module~lusol_ez_module lusol_ez_module proc~nlesolver_solver->module~lusol_ez_module module~lsqpblas_module lsqpblas_module module~lsqr_module->module~lsqpblas_module module~lsqr_kinds lsqr_kinds module~lsqr_module->module~lsqr_kinds module~lusol lusol module~lusol_ez_module->module~lusol module~lusol_precision lusol_precision module~lusol_ez_module->module~lusol_precision module~lsqpblas_module->module~lsqr_kinds iso_fortran_env iso_fortran_env module~lsqr_kinds->iso_fortran_env module~lusol->module~lusol_precision module~lusol_precision->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Main solver. Type Bound nlesolver_type Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x Calls proc~~nlesolver_solver~~CallsGraph proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver proc~initialize_ez lsqr_module::lsqr_solver_ez%initialize_ez proc~nlesolver_solver->proc~initialize_ez proc~linear_solver nlesolver_module::linear_solver proc~nlesolver_solver->proc~linear_solver proc~set_status nlesolver_module::nlesolver_type%set_status proc~nlesolver_solver->proc~set_status proc~solve_ez lsqr_module::lsqr_solver_ez%solve_ez proc~nlesolver_solver->proc~solve_ez proc~lsqr lsqr_module::lsqr_solver%LSQR proc~solve_ez->proc~lsqr aprod aprod proc~lsqr->aprod proc~d2norm lsqr_module::d2norm proc~lsqr->proc~d2norm proc~dcopy lsqpblas_module::dcopy proc~lsqr->proc~dcopy proc~dnrm2 lsqpblas_module::dnrm2 proc~lsqr->proc~dnrm2 proc~dscal lsqpblas_module::dscal proc~lsqr->proc~dscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~nlesolver_solver~~CalledByGraph proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->proc~nlesolver_solver program~sparse_test sparse_test program~sparse_test->proc~nlesolver_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine nlesolver_solver ( me , x ) use lsqr_module , only : lsqr_solver_ez use lusol_ez_module , only : solve , lusol_settings implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( inout ) :: x real ( wp ), dimension (:) , allocatable :: fvec !! function vector real ( wp ), dimension (:,:), allocatable :: fjac !! jacobian matrix [dense] real ( wp ), dimension (:), allocatable :: fjac_sparse !! jacobian matrix [sparse] real ( wp ), dimension (:) , allocatable :: rhs !! linear system right-hand side real ( wp ), dimension (:) , allocatable :: p !! search direction real ( wp ), dimension (:) , allocatable :: xold !! previous value of `x` real ( wp ), dimension (:) , allocatable :: prev_fvec !! previous function vector real ( wp ), dimension (:,:), allocatable :: prev_fjac !! previous jacobian matrix real ( wp ), dimension (:,:), allocatable :: delf !! used for Broyden (rank 2 for `matmul`) real ( wp ), dimension (:,:), allocatable :: delx !! used for Broyden (rank 2 for `matmul`) logical :: user_stop !! user stop button flag integer :: info !! status flag from the [[linear_solver]] integer :: iter !! iteration counter real ( wp ) :: f !! magnitude of `fvec` real ( wp ) :: fold !! previous value of `f` integer :: n_uphill !! number of steps taken in the \"uphill\" direction !! (where `f` is increasing) real ( wp ) :: delxmag2 !! used for Broyden logical :: recompute_jac !! if using Broyden, and we want to call the user !! jacobian routine instead integer :: broyden_counter !! number of times the broyden update has been used integer :: alloc_stat !! allocation status flag type ( lsqr_solver_ez ) :: sparse_solver !! sparse LSQR solver class type ( lusol_settings ) :: lusol_options if ( me % istat < 0 ) return ! class was not initialized properly if (. not . associated ( me % func )) then call me % set_status ( istat = - 10 , string = 'Error: function routine is not associated' ) return end if if ( me % sparsity_mode == 1 . and . . not . associated ( me % grad )) then call me % set_status ( istat = - 11 , string = 'Error: gradient routine is not associated' ) return end if if ( me % sparsity_mode > 1 . and . . not . associated ( me % grad_sparse )) then call me % set_status ( istat = - 11 , string = 'Error: gradient routine is not associated' ) return end if ! initialize: iter = 0 n_uphill = 0 recompute_jac = . false . broyden_counter = 0 ! allocate the arrays: alloc_stat = 0 if ( alloc_stat == 0 ) allocate ( fvec ( me % m ) , stat = alloc_stat ) if ( me % sparsity_mode == 1 ) then ! dense if ( alloc_stat == 0 ) allocate ( fjac ( me % m , me % n ) , stat = alloc_stat ) else ! sparse if ( alloc_stat == 0 ) allocate ( fjac_sparse ( me % n_nonzeros ) , stat = alloc_stat ) end if if ( alloc_stat == 0 ) allocate ( rhs ( me % m ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( p ( me % n ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( xold ( me % n ) , stat = alloc_stat ) if ( me % use_broyden ) then ! only need these for broyden: if ( alloc_stat == 0 ) allocate ( prev_fvec ( me % m ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( prev_fjac ( me % m , me % n ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( delf ( me % m , 1 ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( delx ( me % n , 1 ) , stat = alloc_stat ) end if if ( alloc_stat /= 0 ) then call me % set_status ( istat = - 9 , string = 'Error: Out of memory' ) return else me % istat = - 998 me % message = 'Unknown error' end if ! evaluate the function: call me % func ( x , fvec ) f = norm2 ( fvec ) ! check to see if initial guess is a root: if ( f <= me % tol ) then call me % set_status ( istat = 1 , string = 'Required accuracy achieved' ) else ! main iteration loop: do iter = 1 , me % max_iter ! Export the current iteration: if ( associated ( me % export_iteration )) call me % export_iteration ( x , fvec , iter ) ! Check for user stop: if ( associated ( me % user_input_check )) then call me % user_input_check ( user_stop ) if ( user_stop ) then call me % set_status ( istat = 4 , string = 'Stopped by the user' ) exit end if end if if ( me % use_broyden . and . . not . recompute_jac ) then if ( iter == 1 ) then ! always compute Jacobian on the first iteration call me % grad ( x , fjac ) broyden_counter = 0 else ! and use Broyden update to estimate Jacobian ! for subsequent iterations. ! note: fvec was computed the last iteration delx (:, 1 ) = x - xold delf (:, 1 ) = fvec - prev_fvec delxmag2 = dot_product ( delx (:, 1 ), delx (:, 1 )) if ( delxmag2 < eps ) then call me % set_status ( istat = - 8 , & string = 'Error: Divide by zero when computing Broyden update' ) exit end if ! Jacobian estimate: fjac = prev_fjac + & matmul (( delf - matmul ( prev_fjac , delx )),& transpose ( delx )) / delxmag2 broyden_counter = broyden_counter + 1 end if prev_fjac = fjac prev_fvec = fvec else ! compute the jacobian: select case ( me % sparsity_mode ) case ( 1 ) call me % grad ( x , fjac ) case ( 2 :) call me % grad_sparse ( x , fjac_sparse ) end select recompute_jac = . false . ! for broyden broyden_counter = 0 end if xold = x fold = f ! compute the search direction p by solving linear system: rhs = - fvec ! RHS of the linear system select case ( me % sparsity_mode ) case ( 1 ) ! use dense solver call linear_solver ( me % m , me % n , fjac , rhs , p , info ) case ( 2 ) ! initialize the LSQR sparse solver call sparse_solver % initialize ( me % m , me % n , fjac_sparse , me % irow , me % icol ,& atol = me % atol , & btol = me % btol , & conlim = me % conlim , & itnlim = me % itnlim , & nout = me % nout ) call sparse_solver % solve ( rhs , me % damp , p , info ) ! solve the linear system ! check convergence: select case ( info ) case ( 4 ) call me % set_status ( istat = - 1004 , & string = 'LSQR Error: The system appears to be ill-conditioned. istop =' , i = info ) exit case ( 5 ) call me % set_status ( istat = - 1005 , & string = 'LSQR Error: The iteration limit was reached. istop =' , i = info ) exit case default info = 0 end select case ( 3 ) ! use lusol solver lusol_options % method = me % lusol_method ! 0    =>  TPP: Threshold Partial   Pivoting. ! 1    =>  TRP: Threshold Rook      Pivoting. ! 2    =>  TCP: Threshold Complete  Pivoting. call solve ( me % n , me % m , me % n_nonzeros , me % irow , me % icol , fjac_sparse , rhs , p , info ,& settings = lusol_options ) end select ! check for errors: if ( info /= 0 ) then call me % set_status ( istat = - 6 , string = 'Error solving linear system. info =' , i = info ) exit else ! next step, using the specified method: call me % linesearch ( xold , p , x , f , fvec , fjac , fjac_sparse ) ! keep track of the number of steps in the \"uphill\" direction: if ( f > fold ) then n_uphill = n_uphill + 1 else n_uphill = 0 end if ! check for stopping conditions if ( f <= me % tol ) then call me % set_status ( istat = 1 , string = 'Required accuracy achieved' ) exit elseif ( maxval ( abs ( x - xold )) <= me % tolx ) then call me % set_status ( istat = 2 , string = 'Solution cannot be improved' ) exit elseif ( iter == me % max_iter ) then call me % set_status ( istat = 3 , string = 'Maximum number of iterations reached' ) exit elseif ( n_uphill > me % n_uphill_max ) then call me % set_status ( istat = 5 , string = 'Too many steps in the uphill direction' ) exit elseif ( me % use_broyden ) then ! If delxmag2 is too small when using broyden, just ! call the user-supplied jacobian function to avoid ! a divide by zero on the next step. This should ! normally only happen when the solution is almost converged. if ( norm2 ( x - xold ) ** 2 <= eps ) then recompute_jac = . true . else if ( me % broyden_update_n > 0 ) then ! Note that we also recompute if we have taken an uphill step if ( broyden_counter == me % broyden_update_n . or . n_uphill > 0 ) then ! time to recompute the full jacobian recompute_jac = . true . end if end if end if endif end if end do !end of iterations loop end if !Export the last iteration: iter = iter + 1 if ( associated ( me % export_iteration )) call me % export_iteration ( x , fvec , iter ) end subroutine nlesolver_solver","tags":"","loc":"proc/nlesolver_solver.html"},{"title":"destroy_nlesolver_variables – AoC-2023","text":"private  subroutine destroy_nlesolver_variables(me) Destructor Type Bound nlesolver_type Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(out) :: me Source Code subroutine destroy_nlesolver_variables ( me ) implicit none class ( nlesolver_type ), intent ( out ) :: me me % message = 'Error: class has not been initialized' me % istat = - 999 end subroutine destroy_nlesolver_variables","tags":"","loc":"proc/destroy_nlesolver_variables.html"},{"title":"linear_solver – AoC-2023","text":"private  subroutine linear_solver(m, n, a, b, x, info) Solve the linear system: , using a dense, direct method. if n=m : use LAPACK dgesv (LU decomposition) if n/=m : use LAPACK dgels (if m>n uses QR factorization,\n  if m<n uses LQ factorization) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m number of rows in a integer, intent(in) :: n number of columns in a real(kind=wp), intent(in), dimension(m,n) :: a A matrix of the linear system real(kind=wp), intent(in), dimension(m) :: b RHS of the linear system real(kind=wp), intent(out), dimension(n) :: x the solution of the linear system. integer, intent(out) :: info output status flag ( =0 if success) Called by proc~~linear_solver~~CalledByGraph proc~linear_solver nlesolver_module::linear_solver proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver proc~nlesolver_solver->proc~linear_solver program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->proc~nlesolver_solver program~sparse_test sparse_test program~sparse_test->proc~nlesolver_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine linear_solver ( m , n , a , b , x , info ) implicit none integer , intent ( in ) :: n !! number of columns in `a` integer , intent ( in ) :: m !! number of rows in `a` real ( wp ), dimension ( m , n ), intent ( in ) :: a !! `A` matrix of the linear system real ( wp ), dimension ( m ), intent ( in ) :: b !! RHS of the linear system real ( wp ), dimension ( n ), intent ( out ) :: x !! the solution of the linear system. integer , intent ( out ) :: info !! output status flag (`=0` if success) ! LAPACK routine interfaces: interface subroutine dgesv ( n , nrhs , a , lda , ipiv , b , ldb , info ) !! See: [?gesv](https://www.intel.com/content/www/us/en/develop/documentation/onemkl-developer-reference-fortran/top/lapack-routines/lapack-linear-equation-routines/lapack-linear-equation-driver-routines/gesv.html) import :: wp implicit none integer :: info integer :: lda integer :: ldb integer :: n integer :: nrhs integer :: ipiv ( * ) real ( wp ) :: a ( lda , * ) real ( wp ) :: b ( ldb , * ) end subroutine dgesv subroutine dgels ( trans , m , n , nrhs , a , lda , b , ldb , work , lwork , info ) !! See: [?gels](https://www.intel.com/content/www/us/en/develop/documentation/onemkl-developer-reference-fortran/top/lapack-routines/lapack-least-squares-and-eigenvalue-problem/lapack-least-squares-eigenvalue-problem-driver/linear-least-squares-lls-problems-lapack-driver/gels.html) import :: wp implicit none character :: trans integer :: info integer :: lda integer :: ldb integer :: lwork integer :: m integer :: n integer :: nrhs real ( wp ) :: a ( lda , * ) real ( wp ) :: b ( ldb , * ) real ( wp ) :: work ( * ) end subroutine dgels end interface integer , dimension (:), allocatable :: ipiv !! pivot indices array real ( wp ), dimension (:,:), allocatable :: bmat !! copy of `b` so it won't be overwritten real ( wp ), dimension (:), allocatable :: work !! work array for `dgels` real ( wp ), dimension (:,:), allocatable :: amat !! copy of `a` so it won't be overwritten integer :: lwork !! size of `work` allocate ( amat ( m , n )) allocate ( bmat ( max ( 1 , m , n ), 1 )) if ( n == m ) then !normal inverse allocate ( ipiv ( n )) amat = a bmat ( 1 : n , 1 ) = b call dgesv ( n , 1 , amat , n , ipiv , bmat , n , info ) x = bmat ( 1 : n , 1 ) else amat = a bmat = zero bmat ( 1 : m , 1 ) = b lwork = min ( m , n ) + max ( 1 , m , n ) allocate ( work ( lwork )) call dgels ( 'N' , m , n , 1 , amat , m , bmat , max ( 1 , m , n ), work , lwork , info ) x = bmat ( 1 : n , 1 ) end if end subroutine linear_solver","tags":"","loc":"proc/linear_solver.html"},{"title":"simple_step – AoC-2023","text":"private  subroutine simple_step(me, xold, p, x, f, fvec, fjac, fjac_sparse) Take a simple step in the search direction of p * alpha . Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: xold previous value of x real(kind=wp), intent(in), dimension(me%n) :: p search direction real(kind=wp), intent(out), dimension(me%n) :: x new x real(kind=wp), intent(inout) :: f magnitude of fvec real(kind=wp), intent(inout), dimension(me%m) :: fvec function vector real(kind=wp), intent(in), optional, dimension(:,:) :: fjac jacobian matrix [dense] real(kind=wp), intent(in), optional, dimension(:) :: fjac_sparse jacobian matrix [sparse] Source Code subroutine simple_step ( me , xold , p , x , f , fvec , fjac , fjac_sparse ) implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: xold !! previous value of `x` real ( wp ), dimension ( me % n ), intent ( in ) :: p !! search direction real ( wp ), dimension ( me % n ), intent ( out ) :: x !! new `x` real ( wp ), intent ( inout ) :: f !! magnitude of `fvec` real ( wp ), dimension ( me % m ), intent ( inout ) :: fvec !! function vector real ( wp ), dimension (:,:), intent ( in ), optional :: fjac !! jacobian matrix [dense] real ( wp ), dimension (:), intent ( in ), optional :: fjac_sparse !! jacobian matrix [sparse] x = xold + p * me % alpha !evaluate the function at the new point: call me % func ( x , fvec ) f = norm2 ( fvec ) end subroutine simple_step","tags":"","loc":"proc/simple_step.html"},{"title":"backtracking_linesearch – AoC-2023","text":"private  subroutine backtracking_linesearch(me, xold, p, x, f, fvec, fjac, fjac_sparse) Backtracking line search. See also [Backtracking line search](https: Note Either fjac or fjac_sparse should be present. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: xold previous value of x real(kind=wp), intent(in), dimension(me%n) :: p search direction real(kind=wp), intent(out), dimension(me%n) :: x new x real(kind=wp), intent(inout) :: f magnitude of fvec real(kind=wp), intent(inout), dimension(me%m) :: fvec function vector real(kind=wp), intent(in), optional, dimension(:,:) :: fjac jacobian matrix [dense] real(kind=wp), intent(in), optional, dimension(:) :: fjac_sparse jacobian matrix [sparse] Source Code subroutine backtracking_linesearch ( me , xold , p , x , f , fvec , fjac , fjac_sparse ) implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: xold !! previous value of `x` real ( wp ), dimension ( me % n ), intent ( in ) :: p !! search direction real ( wp ), dimension ( me % n ), intent ( out ) :: x !! new `x` real ( wp ), intent ( inout ) :: f !! magnitude of `fvec` real ( wp ), dimension ( me % m ), intent ( inout ) :: fvec !! function vector real ( wp ), dimension (:,:), intent ( in ), optional :: fjac !! jacobian matrix [dense] real ( wp ), dimension (:), intent ( in ), optional :: fjac_sparse !! jacobian matrix [sparse] integer :: i !! counter real ( wp ) :: slope !! local slope of the function of `alpha` along the search direction used for line search logical :: min_alpha_reached !! if the minimum step size is reached during the line search real ( wp ) :: alpha !! `alpha` for the line search real ( wp ) :: ftmp !! `f` value for linesearch real ( wp ) :: t !! used for line search real ( wp ), dimension (:), allocatable :: gradf !! line search objective function gradient vector real ( wp ), dimension (:), allocatable :: xtmp !! `x` value for linesearch real ( wp ), dimension (:), allocatable :: fvectmp !! `fvec` value for linesearch ! allocate arrays: allocate ( gradf ( me % n )) allocate ( xtmp ( me % n )) allocate ( fvectmp ( me % m )) ! compute the gradient of the function to be minimized ! (which in this case is 1/2 the norm of fvec). Use the chain ! rule and the Jacobian matrix already computed. if ( present ( fjac )) then ! dense do i = 1 , me % n gradf ( i ) = dot_product ( fvec , fjac (:, i )) end do else ! sparse do i = 1 , me % n gradf ( i ) = dot_product ( fvec , pack ( fjac_sparse , mask = me % icol == i )) end do end if slope = dot_product ( p , gradf ) t = - me % c * slope if ( me % verbose ) then write ( me % iunit , '(1P,*(A,1X,E16.6))' ) '        slope    = ' , slope write ( me % iunit , '(1P,*(A,1X,E16.6))' ) '        t        = ' , t end if ! perform the line search: min_alpha_reached = . false . alpha = me % alpha_max ! start with the largest step do xtmp = xold + p * alpha call me % func ( xtmp , fvectmp ) ftmp = norm2 ( fvectmp ) if ( me % verbose ) then write ( me % iunit , '(1P,*(A,1X,E16.6))' ) '        alpha    = ' , alpha , ' f       = ' , ftmp if ( f - ftmp >= alpha * t ) then write ( me % iunit , '(1P,2(A,1X,E16.6),1X,A)' ) '        f - ftmp = ' , f - ftmp , ' alpha*t = ' , alpha * t , ' [ACCEPTED]' else write ( me % iunit , '(1P,*(A,1X,E16.6))' ) '        f - ftmp = ' , f - ftmp , ' alpha*t = ' , alpha * t end if end if if ((( f - ftmp ) / 2.0_wp >= alpha * t ) . or . min_alpha_reached ) then if ( min_alpha_reached ) then write ( me % iunit , '(A)' ) '        Minimum alpha reached' end if ! Armijo-Goldstein condition is satisfied ! (or the min step has been reached) x = xtmp fvec = fvectmp f = ftmp exit end if alpha = alpha * me % tau ! reduce step size if ( alpha <= me % alpha_min ) then alpha = me % alpha_min min_alpha_reached = . true . ! will stop on the next step end if end do end subroutine backtracking_linesearch","tags":"","loc":"proc/backtracking_linesearch.html"},{"title":"exact_linesearch – AoC-2023","text":"private  subroutine exact_linesearch(me, xold, p, x, f, fvec, fjac, fjac_sparse) An exact linesearch that uses a derivative-free minimizer to\nfind the minimum value of f(x) between x = xold + p * alpha_min and x = xold + p * alpha_max . Usually this is overkill and not necessary, but is here as an option for testing. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: xold previous value of x real(kind=wp), intent(in), dimension(me%n) :: p search direction real(kind=wp), intent(out), dimension(me%n) :: x new x real(kind=wp), intent(inout) :: f magnitude of fvec real(kind=wp), intent(inout), dimension(me%m) :: fvec function vector real(kind=wp), intent(in), optional, dimension(:,:) :: fjac jacobian matrix [dense] real(kind=wp), intent(in), optional, dimension(:) :: fjac_sparse jacobian matrix [sparse] Calls proc~~exact_linesearch~~CallsGraph proc~exact_linesearch nlesolver_module::exact_linesearch proc~fmin fmin_module::fmin proc~exact_linesearch->proc~fmin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine exact_linesearch ( me , xold , p , x , f , fvec , fjac , fjac_sparse ) implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: xold !! previous value of `x` real ( wp ), dimension ( me % n ), intent ( in ) :: p !! search direction real ( wp ), dimension ( me % n ), intent ( out ) :: x !! new `x` real ( wp ), intent ( inout ) :: f !! magnitude of `fvec` real ( wp ), dimension ( me % m ), intent ( inout ) :: fvec !! function vector real ( wp ), dimension (:,:), intent ( in ), optional :: fjac !! jacobian matrix [dense] real ( wp ), dimension (:), intent ( in ), optional :: fjac_sparse !! jacobian matrix [sparse] real ( wp ), dimension (:), allocatable :: xnew !! used in [[func_for_fmin]] real ( wp ) :: alpha_min allocate ( xnew ( me % n )) ! find the minimum value of f in the range of alphas: alpha_min = fmin ( func_for_fmin , me % alpha_min , me % alpha_max , me % fmin_tol ) if ( me % verbose ) write ( me % iunit , '(1P,*(A,1X,E16.6))' ) '        alpha_min = ' , alpha_min x = xold + p * alpha_min if ( all ( x == xnew )) then ! already computed in the func else call me % func ( x , fvec ) f = norm2 ( fvec ) end if contains real ( wp ) function func_for_fmin ( alpha ) !! function for [[fmin]] implicit none real ( wp ), intent ( in ) :: alpha !! indep variable xnew = xold + p * alpha call me % func ( xnew , fvec ) func_for_fmin = norm2 ( fvec ) ! return result f = func_for_fmin ! just in case this is the solution end function func_for_fmin end subroutine exact_linesearch","tags":"","loc":"proc/exact_linesearch.html"},{"title":"fixed_point_linesearch – AoC-2023","text":"private  subroutine fixed_point_linesearch(me, xold, p, x, f, fvec, fjac, fjac_sparse) A simple search that just evaluates the function at a specified\nnumber of points and picks the one with the minimum function value. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: xold previous value of x real(kind=wp), intent(in), dimension(me%n) :: p search direction real(kind=wp), intent(out), dimension(me%n) :: x new x real(kind=wp), intent(inout) :: f magnitude of fvec real(kind=wp), intent(inout), dimension(me%m) :: fvec function vector real(kind=wp), intent(in), optional, dimension(:,:) :: fjac jacobian matrix [dense] real(kind=wp), intent(in), optional, dimension(:) :: fjac_sparse jacobian matrix [sparse] Source Code subroutine fixed_point_linesearch ( me , xold , p , x , f , fvec , fjac , fjac_sparse ) implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: xold !! previous value of `x` real ( wp ), dimension ( me % n ), intent ( in ) :: p !! search direction real ( wp ), dimension ( me % n ), intent ( out ) :: x !! new `x` real ( wp ), intent ( inout ) :: f !! magnitude of `fvec` real ( wp ), dimension ( me % m ), intent ( inout ) :: fvec !! function vector real ( wp ), dimension (:,:), intent ( in ), optional :: fjac !! jacobian matrix [dense] real ( wp ), dimension (:), intent ( in ), optional :: fjac_sparse !! jacobian matrix [sparse] integer :: i !! counter integer :: n_points !! number of points to compute real ( wp ), dimension (:), allocatable :: alphas_to_try !! set of `alpha` values to try real ( wp ), dimension (:), allocatable :: x_tmp !! temp `x` real ( wp ), dimension (:), allocatable :: fvec_tmp !! temp `fvec` real ( wp ) :: f_tmp !! temp `f` real ( wp ) :: step_size !! step size for `alpha` integer :: n !! number of steps to divide the interval ! 1 o-----------o ! 2 o-----o-----o ! 3 o---o---o---o n = me % n_intervals n_points = n + 1 allocate ( alphas_to_try ( n_points )) allocate ( x_tmp ( me % n )) allocate ( fvec_tmp ( me % m )) step_size = ( me % alpha_max - me % alpha_min ) / real ( n , wp ) ! compute the alphas: alphas_to_try ( 1 ) = me % alpha_min do i = 2 , n alphas_to_try ( i ) = alphas_to_try ( i - 1 ) + step_size end do alphas_to_try ( n_points ) = me % alpha_max ! now compute the functions at these alphas: f = big do i = 1 , n_points x_tmp = xold + p * alphas_to_try ( i ) ! evaluate the function at tthis point: call me % func ( x_tmp , fvec_tmp ) f_tmp = norm2 ( fvec_tmp ) if ( f_tmp <= f ) then ! new best point x = x_tmp f = f_tmp fvec = fvec_tmp end if end do end subroutine fixed_point_linesearch","tags":"","loc":"proc/fixed_point_linesearch.html"},{"title":"match – AoC-2023","text":"function match(ipattern, ints) returns true if the pattern is valid for the int list. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: ipattern integer, intent(in), dimension(:) :: ints Return Value logical Called by proc~~match~~CalledByGraph proc~match problem_12::match proc~test problem_12::test proc~test->proc~match proc~test->proc~test proc~go~6 problem_12::go proc~go~6->proc~test program~problem_12 problem_12 program~problem_12->proc~go~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function match ( ipattern , ints ) !! returns true if the pattern is valid for the int list. integer , dimension (:), intent ( in ) :: ipattern integer , dimension (:), intent ( in ) :: ints integer :: i , iacc , int_checked integer , dimension ( 1 ) :: ifirst , iend logical :: accumulating ! .##..###... -> 2,3 ! start and end indices (ignoring leading and trailing spaces) ifirst = findloc ( ipattern , 1 ) iend = findloc ( ipattern , 1 , back = . true .) if ( ifirst ( 1 ) == 0 . or . iend ( 1 ) == 0 ) then ! all blank match = . false .; return end if ! step through the pattern and stop once we find it invalid accumulating = . true . iacc = 0 int_checked = 0 ! the count of ints that have been checked match = . true . ! initialize do i = ifirst ( 1 ), iend ( 1 ) select case ( ipattern ( i )) case ( POINT ) if ( accumulating ) then int_checked = int_checked + 1 ! check the next one if ( int_checked > size ( ints )) then ! too many ints match = . false . return else if ( ints ( int_checked ) /= iacc ) then ! doesn't match match = . false . return end if accumulating = . false . iacc = 0 end if case ( NUMBER ) if ( accumulating ) then iacc = iacc + 1 else ! start of a new number accumulating = . true . iacc = 1 end if if ( i == iend ( 1 )) then ! last number int_checked = int_checked + 1 ! check the next one if ( int_checked /= size ( ints )) then ! not enough ints match = . false . return else if ( ints ( int_checked ) /= iacc ) then ! doesn't match match = . false . return end if end if end select end do end function match","tags":"","loc":"proc/match.html"},{"title":"go – AoC-2023","text":"subroutine go(expand, isum) Arguments Type Intent Optional Attributes Name logical, intent(in) :: expand integer(kind=ip), intent(out) :: isum Calls proc~~go~6~~CallsGraph proc~go~6 problem_12::go interface~split aoc_utilities::split proc~go~6->interface~split proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~go~6->proc~number_of_lines_in_file proc~parse_ints aoc_utilities::parse_ints proc~go~6->proc~parse_ints proc~read_line aoc_utilities::read_line proc~go~6->proc~read_line proc~str_to_int_array_with_mapping aoc_utilities::str_to_int_array_with_mapping proc~go~6->proc~str_to_int_array_with_mapping proc~test problem_12::test proc~go~6->proc~test proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~test->proc~test proc~match problem_12::match proc~test->proc~match proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~go~6~~CalledByGraph proc~go~6 problem_12::go program~problem_12 problem_12 program~problem_12->proc~go~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine go ( expand , isum ) logical , intent ( in ) :: expand integer ( ip ), intent ( out ) :: isum integer :: iunit , n_lines , n_unknowns integer ( ip ) :: n_perms character ( len = :), allocatable :: line , pattern type ( string ), dimension (:), allocatable :: vals ! open(newunit=iunit, file='inputs/day12_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day12.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ints = parse_ints ( vals ( 2 )% str ) ! integer list  1,1,3 pattern = vals ( 1 )% str ! the pattern   #.#.### ! will convert the pattern to an array of numbers: ipattern = str_to_int_array_with_mapping ( pattern ,[ '.' , '#' , '?' ],& [ POINT , NUMBER , QUESTION ]) ! 1010111 if ( expand ) then ! brute force it ipattern = [ ipattern , QUESTION , ipattern , QUESTION , & ipattern , QUESTION , ipattern , QUESTION , & ipattern ] ints = [ ints , ints , ints , ints , ints ] end if n_unknowns = count ( ipattern == 2 ) n_valid = 0 ! number of valid permutations n_perms = 2 ** n_unknowns ! number of permutations ipattern_tmp = ipattern ! recursively test all the permutations if ( allocated ( a )) deallocate ( a ) allocate ( a ( n_unknowns )) call test ( 1 , n_unknowns ) isum = isum + n_valid ! write(*,*) iline, 'n_valid = ', n_valid end do end subroutine go","tags":"","loc":"proc/go~6.html"},{"title":"test – AoC-2023","text":"recursive subroutine test(i, n) each ? can be either a . or a #\ncheck pattern to match the int list Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: n Calls proc~~test~~CallsGraph proc~test problem_12::test proc~test->proc~test proc~match problem_12::match proc~test->proc~match Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~test~~CalledByGraph proc~test problem_12::test proc~test->proc~test proc~go~6 problem_12::go proc~go~6->proc~test program~problem_12 problem_12 program~problem_12->proc~go~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine test ( i , n ) !! each ? can be either a . or a # !! check pattern to match the int list integer , intent ( in ) :: i , n integer :: ix integer , dimension ( * ), parameter :: icoeffs = [ POINT , NUMBER ] !! set of coefficients ['.', '#'] ! what we are not doing here is accounting for permutations ! that we know do not match, because the begin with a sequence ! that doesn't match. those need to be skipped... if ( i > n ) then ! so we have an array of 0s and 1s -> replace the 2s in the ipattern with these !     ipattern: 2220111  -> ???.### !            a: 011      -> .## !       result: 0110111  -> .##.### !write(*,'(a,1x,i5,1x, *(I1))') 'test:', iline, ipattern_tmp ipattern_tmp = unpack ( a , mask = ipattern == QUESTION , field = ipattern ) if ( match ( ipattern_tmp , ints )) n_valid = n_valid + 1 else do ix = 1 , 2 a ( i ) = icoeffs ( ix ) call test ( i + 1 , n ) end do end if end subroutine test","tags":"","loc":"proc/test.html"},{"title":"index_in_queue – AoC-2023","text":"function index_in_queue(state) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state Return Value integer(kind=ip) index in the queue. -1 if not present Calls proc~~index_in_queue~~CallsGraph proc~index_in_queue problem_17::index_in_queue proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~index_in_queue->proc~get_from_cache~2 proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~index_in_queue->proc~put_in_cache~2 proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~index_in_queue~~CalledByGraph proc~index_in_queue problem_17::index_in_queue proc~check problem_17::check proc~check->proc~index_in_queue program~problem_17 problem_17 program~problem_17->proc~check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function index_in_queue ( state ) result ( idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ) :: idx !! index in the queue. -1 if not present integer ( ip ) :: i logical :: found integer ( ip ) :: cache_idx integer ( ip ), dimension (:), allocatable :: cache_ival call cache % get ( state , cache_idx , cache_ival , found ) if ( found ) then idx = cache_ival ( 1 ) else idx = - 1 if (. not . allocated ( queue )) error stop 'error: queue not allocated' do i = 1 , queue_size if ( all ( state == queue ( i )% state )) then idx = i exit end if end do if ( idx /= - 1 ) call cache % put ( cache_idx , state ,[ idx ]) end if end function index_in_queue","tags":"","loc":"proc/index_in_queue.html"},{"title":"check – AoC-2023","text":"subroutine check(idx, idirection) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: idx integer(kind=ip), intent(in) :: idirection direction to move from current Calls proc~~check~~CallsGraph proc~check problem_17::check proc~add_to_queue problem_17::add_to_queue proc~check->proc~add_to_queue proc~index_in_queue problem_17::index_in_queue proc~check->proc~index_in_queue proc~expand_queue problem_17::expand_queue proc~add_to_queue->proc~expand_queue proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~index_in_queue->proc~get_from_cache~2 proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~index_in_queue->proc~put_in_cache~2 proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check~~CalledByGraph proc~check problem_17::check program~problem_17 problem_17 program~problem_17->proc~check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine check ( idx , idirection ) implicit none integer ( ip ), intent ( in ) :: idx ! current item in the queue to process integer ( ip ), intent ( in ) :: idirection !! direction to move from current integer ( ip ) :: alt integer ( ip ), dimension ( 2 ) :: v ! neighbor to move to integer ( ip ) :: imovesv , idxv , distv integer ( ip ), dimension ( NSTATE ) :: istate logical :: in_queue associate ( i => queue ( idx )% state ( 1 ), & j => queue ( idx )% state ( 2 ), & direction => queue ( idx )% state ( 3 ), & n_moves => queue ( idx )% state ( 4 )) if ( direction ==- idirection ) return ! can't reverse ! the one to go to: if ( direction == idirection ) then if ( n_moves == MAX_MOVES_IN_DIR ) return ! can't move in this direction anymore imovesv = n_moves + 1 else if ( n_moves /= 0 . and . n_moves < 4 ) return ! must move at last 4 before a turn! imovesv = 1 ! reset on change of direction end if select case ( idirection ) case ( UP ); v = [ i - 1 , j ] case ( DOWN ); v = [ i + 1 , j ] case ( LEFT ); v = [ i , j - 1 ] case ( RIGHT ); v = [ i , j + 1 ] end select if ( v ( 1 ) < 1 . or . v ( 2 ) < 1 . or . v ( 1 ) > n_rows . or . v ( 2 ) > n_cols ) return ! can't go off the board if ( v ( 1 ) == n_rows . and . v ( 2 ) == n_cols . and . imovesv < 4 ) return ! require at least 4 to end istate = [ v ( 1 ), v ( 2 ), idirection , imovesv ] ! new state idxv = index_in_queue ( istate ) ! is it already in the queue in_queue = idxv > 0 ! if this one is already part of another path if ( in_queue ) then if ( queue ( idxv )% visited ) return ! already visited this one distv = queue ( idxv )% dist ! distance in the queue else !call add_to_queue(istate, idxv) ! add this to the queue for processing ! always add it ?? distv = huge ( 1_ip ) ! not processed yet, so huge number end if !alt = queue(idx)%dist + map(queue(idxv)%state(1), queue(idxv)%state(2)) alt = queue ( idx )% dist + map ( v ( 1 ), v ( 2 )) ! new distance if ( alt < distv ) then ! the new one is better, so replace values in the queue if (. not . in_queue ) call add_to_queue ( istate , idxv ) ! only add it if we accept it ???? ! accept this step queue ( idxv )% dist = alt ! new best dist queue ( idxv )% iprev = idx ! previous end if end associate end subroutine check","tags":"","loc":"proc/check.html"},{"title":"add_to_queue – AoC-2023","text":"subroutine add_to_queue(state, idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state integer(kind=ip), intent(out) :: idx index of the element in the queue Calls proc~~add_to_queue~~CallsGraph proc~add_to_queue problem_17::add_to_queue proc~expand_queue problem_17::expand_queue proc~add_to_queue->proc~expand_queue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~add_to_queue~~CalledByGraph proc~add_to_queue problem_17::add_to_queue proc~check problem_17::check proc~check->proc~add_to_queue program~problem_17 problem_17 program~problem_17->proc~add_to_queue program~problem_17->proc~check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine add_to_queue ( state , idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ), intent ( out ) :: idx !! index of the element in the queue if ( allocated ( queue )) then call expand_queue ( queue , queue_size , item ( state = state )) idx = queue_size else queue = [ item ( state = state )] queue_size = 1 idx = 1 end if end subroutine add_to_queue","tags":"","loc":"proc/add_to_queue.html"},{"title":"expand_queue – AoC-2023","text":"pure subroutine expand_queue(vec, n, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name type( item ), intent(inout), dimension(:), allocatable :: vec integer(kind=ip), intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call type( item ), intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) Called by proc~~expand_queue~~CalledByGraph proc~expand_queue problem_17::expand_queue proc~add_to_queue problem_17::add_to_queue proc~add_to_queue->proc~expand_queue proc~check problem_17::check proc~check->proc~add_to_queue program~problem_17 problem_17 program~problem_17->proc~add_to_queue program~problem_17->proc~check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine expand_queue ( vec , n , val , finished ) integer ( ip ), parameter :: chunk_size = 1000 type ( item ), dimension (:), allocatable , intent ( inout ) :: vec integer ( ip ), intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call type ( item ), intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) type ( item ), dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_queue","tags":"","loc":"proc/expand_queue.html"},{"title":"go – AoC-2023","text":"function go(expansion_factor) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: expansion_factor Return Value integer(kind=ip) Calls proc~~go~7~~CallsGraph proc~go~7 problem_11::go interface~manhatten_distance aoc_utilities::manhatten_distance proc~go~7->interface~manhatten_distance proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~go~7->proc~read_file_to_char_array proc~manhatten_distance_64 aoc_utilities::manhatten_distance_64 interface~manhatten_distance->proc~manhatten_distance_64 proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~go~7~~CalledByGraph proc~go~7 problem_11::go program~problem_11 problem_11 program~problem_11->proc~go~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code integer ( ip ) function go ( expansion_factor ) integer ( ip ), intent ( in ) :: expansion_factor integer :: i , j , nrows , ncols , n_galaxies , n , k character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:,:), allocatable :: idists integer ( ip ), dimension (:), allocatable :: igal , jgal integer ( ip ), dimension (:,:), allocatable :: ix , iy ! array = read_file_to_char_array('inputs/day11_test.txt') array = read_file_to_char_array ( 'inputs/day11.txt' ) nrows = size ( array , 1 ); ncols = size ( array , 2 ) n_galaxies = count ( array == '#' ) ! track the real indices after expansion ix = transpose ( spread ([( i , i = 1 , ncols )], 1 , nrows )) ! row indices iy = spread ([( i , i = 1 , nrows )], 1 , ncols ) ! col indices igal = pack ( ix , array == '#' ) ! indices of galaxies jgal = pack ( iy , array == '#' ) ! expand the array, keeping track of the new row indices do i = 1 , nrows ! add rows if necessary if ( all ( array ( i ,:) == '.' )) ix ( i :,:) = ix ( i :,:) + expansion_factor - 1 ! new row end do do j = 1 , ncols ! add cols if necessary if ( all ( array (:, j ) == '.' )) iy (:, j :) = iy (:, j :) + expansion_factor - 1 ! new column end do ! now compute all the distances: allocate ( idists ( n_galaxies , n_galaxies )); idists = 0 do i = 1 , n_galaxies do j = 1 , n_galaxies if ( j <= i ) cycle ! only need the lower diagonal idists ( i , j ) = manhatten_distance ( ix ( igal ( i ), jgal ( i )), iy ( igal ( i ), jgal ( i )),& ix ( igal ( j ), jgal ( j )), iy ( igal ( j ), jgal ( j ))) end do end do go = sum ( idists ) end function go","tags":"","loc":"proc/go~7.html"},{"title":"unique_int – AoC-2023","text":"private  function unique_int(vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value integer, dimension(:), allocatable unique elements of ivec Calls proc~~unique_int~~CallsGraph proc~unique_int numdiff_utilities_module::unique_int interface~expand_vector numdiff_utilities_module::expand_vector proc~unique_int->interface~expand_vector interface~sort_ascending numdiff_utilities_module::sort_ascending proc~unique_int->interface~sort_ascending proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector->proc~expand_vector_real proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap~2 numdiff_utilities_module::swap proc~sort_ascending_int->interface~swap~2 proc~sort_ascending_real->interface~swap~2 proc~swap_int numdiff_utilities_module::swap_int interface~swap~2->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap~2->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~unique_int~~CalledByGraph proc~unique_int numdiff_utilities_module::unique_int interface~unique~2 numdiff_utilities_module::unique interface~unique~2->proc~unique_int proc~divide_interval numdiff_utilities_module::divide_interval proc~divide_interval->interface~unique~2 proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique~2 proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function unique_int ( vec , chunk_size ) result ( ivec_unique ) implicit none integer , dimension (:), intent ( in ) :: vec !! a vector of integers integer , intent ( in ) :: chunk_size !! chunk size for adding to arrays integer , dimension (:), allocatable :: ivec_unique !! unique elements of `ivec` integer , dimension ( size ( vec )) :: ivec !! temp copy of vec integer :: i !! counter integer :: n !! number of unique elements ! first we sort it: ivec = vec ! make a copy call sort_ascending ( ivec ) ! add the first element: n = 1 ivec_unique = [ ivec ( 1 )] ! walk through array and get the unique ones: if ( size ( ivec ) > 1 ) then do i = 2 , size ( ivec ) if ( ivec ( i ) /= ivec ( i - 1 )) then call expand_vector ( ivec_unique , n , chunk_size , val = ivec ( i )) end if end do call expand_vector ( ivec_unique , n , chunk_size , finished = . true .) end if end function unique_int","tags":"","loc":"proc/unique_int.html"},{"title":"unique_real – AoC-2023","text":"private  function unique_real(vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value real(kind=wp), dimension(:), allocatable unique elements of ivec Calls proc~~unique_real~~CallsGraph proc~unique_real numdiff_utilities_module::unique_real interface~expand_vector numdiff_utilities_module::expand_vector proc~unique_real->interface~expand_vector interface~sort_ascending numdiff_utilities_module::sort_ascending proc~unique_real->interface~sort_ascending proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector->proc~expand_vector_real proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap~2 numdiff_utilities_module::swap proc~sort_ascending_int->interface~swap~2 proc~sort_ascending_real->interface~swap~2 proc~swap_int numdiff_utilities_module::swap_int interface~swap~2->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap~2->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~unique_real~~CalledByGraph proc~unique_real numdiff_utilities_module::unique_real interface~unique~2 numdiff_utilities_module::unique interface~unique~2->proc~unique_real proc~divide_interval numdiff_utilities_module::divide_interval proc~divide_interval->interface~unique~2 proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique~2 proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function unique_real ( vec , chunk_size ) result ( ivec_unique ) implicit none real ( wp ), dimension (:), intent ( in ) :: vec !! a vector of integers integer , intent ( in ) :: chunk_size !! chunk size for adding to arrays real ( wp ), dimension (:), allocatable :: ivec_unique !! unique elements of `ivec` real ( wp ), dimension ( size ( vec )) :: ivec !! temp copy of vec integer :: i !! counter integer :: n !! number of unique elements ! first we sort it: ivec = vec ! make a copy call sort_ascending ( ivec ) ! add the first element: n = 1 ivec_unique = [ ivec ( 1 )] ! walk through array and get the unique ones: if ( size ( ivec ) > 1 ) then do i = 2 , size ( ivec ) if ( ivec ( i ) /= ivec ( i - 1 )) then call expand_vector ( ivec_unique , n , chunk_size , val = ivec ( i )) end if end do call expand_vector ( ivec_unique , n , chunk_size , finished = . true .) end if end function unique_real","tags":"","loc":"proc/unique_real.html"},{"title":"equal_within_tol – AoC-2023","text":"public pure function equal_within_tol(vals, tol) result(equal) Returns true if the values in the array are the same\n(to within the specified absolute tolerance). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: vals a set of values real(kind=wp), intent(in) :: tol a positive tolerance value Return Value logical true if they are equal\nwithin the tolerance Called by proc~~equal_within_tol~~CalledByGraph proc~equal_within_tol numdiff_utilities_module::equal_within_tol proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~equal_within_tol proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~equal_within_tol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function equal_within_tol ( vals , tol ) result ( equal ) implicit none real ( wp ), dimension (:), intent ( in ) :: vals !! a set of values real ( wp ), intent ( in ) :: tol !! a positive tolerance value logical :: equal !! true if they are equal !! within the tolerance equal = all ( abs ( vals - vals ( 1 )) <= abs ( tol ) ) end function equal_within_tol","tags":"","loc":"proc/equal_within_tol.html"},{"title":"divide_interval – AoC-2023","text":"public  function divide_interval(num_points) result(points) Returns a set of slightly randomized equally-spaced\n  points that divide an interval. Example: for num_points = 3: o---|---|---|---o\n         1   2   3 returns: [0.25308641972530865, 0.5061728394506173, 0.759259259175926] . Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_points the number of points in the interval Return Value real(kind=wp), dimension(:), allocatable the resultant vector Calls proc~~divide_interval~~CallsGraph proc~divide_interval numdiff_utilities_module::divide_interval interface~unique~2 numdiff_utilities_module::unique proc~divide_interval->interface~unique~2 proc~unique_int numdiff_utilities_module::unique_int interface~unique~2->proc~unique_int proc~unique_real numdiff_utilities_module::unique_real interface~unique~2->proc~unique_real interface~expand_vector numdiff_utilities_module::expand_vector proc~unique_int->interface~expand_vector interface~sort_ascending numdiff_utilities_module::sort_ascending proc~unique_int->interface~sort_ascending proc~unique_real->interface~expand_vector proc~unique_real->interface~sort_ascending proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector->proc~expand_vector_real proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap~2 numdiff_utilities_module::swap proc~sort_ascending_int->interface~swap~2 proc~sort_ascending_real->interface~swap~2 proc~swap_int numdiff_utilities_module::swap_int interface~swap~2->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap~2->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~divide_interval~~CalledByGraph proc~divide_interval numdiff_utilities_module::divide_interval proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function divide_interval ( num_points ) result ( points ) implicit none integer , intent ( in ) :: num_points !! the number of points in the interval real ( wp ), dimension (:), allocatable :: points !! the resultant vector real ( wp ), parameter :: noise = 1.012345678901234567_wp !! a noise value. Not a round number !! so as to avoid freak zeros in the !! jacobian real ( wp ), parameter :: min_val = 1 0.0_wp * epsilon ( 1.0_wp ) !! the minimize distance from the lower bound real ( wp ), parameter :: max_val = 1.0_wp - min_val !! the minimize distance from the upper bound integer :: i !! counter real ( wp ) :: delta !! step size real ( wp ), dimension (:), allocatable :: tmp !! a temp array to hold the values delta = 1.0_wp / ( num_points + 1 ) allocate ( tmp ( num_points )) do i = 1 , num_points tmp ( i ) = min ( max ( min_val , delta * i * noise ), max_val ) end do ! this is to protect for the min/max case if there ! are enough points so that some are duplicated near ! the bounds: points = unique ( tmp , chunk_size = 10 ) end function divide_interval","tags":"","loc":"proc/divide_interval.html"},{"title":"expand_vector_int – AoC-2023","text":"private pure subroutine expand_vector_int(vec, n, chunk_size, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) Called by proc~~expand_vector_int~~CalledByGraph proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector numdiff_utilities_module::expand_vector interface~expand_vector->proc~expand_vector_int proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->interface~expand_vector proc~resize_sparsity_vectors numerical_differentiation_module::numdiff_type%resize_sparsity_vectors proc~compute_sparsity_random->proc~resize_sparsity_vectors proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->interface~expand_vector proc~compute_sparsity_random_2->proc~resize_sparsity_vectors proc~divide_interval numdiff_utilities_module::divide_interval proc~compute_sparsity_random_2->proc~divide_interval proc~resize_sparsity_vectors->interface~expand_vector proc~unique_int numdiff_utilities_module::unique_int proc~unique_int->interface~expand_vector proc~unique_real numdiff_utilities_module::unique_real proc~unique_real->interface~expand_vector interface~unique~2 numdiff_utilities_module::unique interface~unique~2->proc~unique_int interface~unique~2->proc~unique_real proc~divide_interval->interface~unique~2 proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique~2 proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine expand_vector_int ( vec , n , chunk_size , val , finished ) implicit none integer , dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ) :: chunk_size !! allocate `vec` in blocks of this size (>0) integer , intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) integer , dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector_int","tags":"","loc":"proc/expand_vector_int.html"},{"title":"expand_vector_real – AoC-2023","text":"private pure subroutine expand_vector_real(vec, n, chunk_size, val, finished) Add elements to the real vector in chunks. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) real(kind=wp), intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) Called by proc~~expand_vector_real~~CalledByGraph proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector numdiff_utilities_module::expand_vector interface~expand_vector->proc~expand_vector_real proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->interface~expand_vector proc~resize_sparsity_vectors numerical_differentiation_module::numdiff_type%resize_sparsity_vectors proc~compute_sparsity_random->proc~resize_sparsity_vectors proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->interface~expand_vector proc~compute_sparsity_random_2->proc~resize_sparsity_vectors proc~divide_interval numdiff_utilities_module::divide_interval proc~compute_sparsity_random_2->proc~divide_interval proc~resize_sparsity_vectors->interface~expand_vector proc~unique_int numdiff_utilities_module::unique_int proc~unique_int->interface~expand_vector proc~unique_real numdiff_utilities_module::unique_real proc~unique_real->interface~expand_vector interface~unique~2 numdiff_utilities_module::unique interface~unique~2->proc~unique_int interface~unique~2->proc~unique_real proc~divide_interval->interface~unique~2 proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique~2 proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine expand_vector_real ( vec , n , chunk_size , val , finished ) implicit none real ( wp ), dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ) :: chunk_size !! allocate `vec` in blocks of this size (>0) real ( wp ), intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) real ( wp ), dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector_real","tags":"","loc":"proc/expand_vector_real.html"},{"title":"sort_ascending_int – AoC-2023","text":"private  subroutine sort_ascending_int(ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec Calls proc~~sort_ascending_int~~CallsGraph proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int interface~swap~2 numdiff_utilities_module::swap proc~sort_ascending_int->interface~swap~2 proc~swap_int numdiff_utilities_module::swap_int interface~swap~2->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap~2->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sort_ascending_int~~CalledByGraph proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int interface~sort_ascending numdiff_utilities_module::sort_ascending interface~sort_ascending->proc~sort_ascending_int proc~unique_int numdiff_utilities_module::unique_int proc~unique_int->interface~sort_ascending proc~unique_real numdiff_utilities_module::unique_real proc~unique_real->interface~sort_ascending interface~unique~2 numdiff_utilities_module::unique interface~unique~2->proc~unique_int interface~unique~2->proc~unique_real proc~divide_interval numdiff_utilities_module::divide_interval proc~divide_interval->interface~unique~2 proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique~2 proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine sort_ascending_int ( ivec ) implicit none integer , dimension (:), intent ( inout ) :: ivec call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending_int","tags":"","loc":"proc/sort_ascending_int.html"},{"title":"sort_ascending_real – AoC-2023","text":"private  subroutine sort_ascending_real(ivec) Sorts a real array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: ivec Calls proc~~sort_ascending_real~~CallsGraph proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real interface~swap~2 numdiff_utilities_module::swap proc~sort_ascending_real->interface~swap~2 proc~swap_int numdiff_utilities_module::swap_int interface~swap~2->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap~2->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sort_ascending_real~~CalledByGraph proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real interface~sort_ascending numdiff_utilities_module::sort_ascending interface~sort_ascending->proc~sort_ascending_real proc~unique_int numdiff_utilities_module::unique_int proc~unique_int->interface~sort_ascending proc~unique_real numdiff_utilities_module::unique_real proc~unique_real->interface~sort_ascending interface~unique~2 numdiff_utilities_module::unique interface~unique~2->proc~unique_int interface~unique~2->proc~unique_real proc~divide_interval numdiff_utilities_module::divide_interval proc~divide_interval->interface~unique~2 proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique~2 proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine sort_ascending_real ( ivec ) implicit none real ( wp ), dimension (:), intent ( inout ) :: ivec call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending_real","tags":"","loc":"proc/sort_ascending_real.html"},{"title":"swap_int – AoC-2023","text":"private pure elemental subroutine swap_int(i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 Called by proc~~swap_int~~CalledByGraph proc~swap_int numdiff_utilities_module::swap_int interface~swap~2 numdiff_utilities_module::swap interface~swap~2->proc~swap_int proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int proc~sort_ascending_int->interface~swap~2 proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real proc~sort_ascending_real->interface~swap~2 interface~sort_ascending numdiff_utilities_module::sort_ascending interface~sort_ascending->proc~sort_ascending_int interface~sort_ascending->proc~sort_ascending_real proc~unique_int numdiff_utilities_module::unique_int proc~unique_int->interface~sort_ascending proc~unique_real numdiff_utilities_module::unique_real proc~unique_real->interface~sort_ascending interface~unique~2 numdiff_utilities_module::unique interface~unique~2->proc~unique_int interface~unique~2->proc~unique_real proc~divide_interval numdiff_utilities_module::divide_interval proc~divide_interval->interface~unique~2 proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique~2 proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap_int ( i1 , i2 ) implicit none integer , intent ( inout ) :: i1 integer , intent ( inout ) :: i2 integer :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_int","tags":"","loc":"proc/swap_int.html"},{"title":"swap_real – AoC-2023","text":"private pure elemental subroutine swap_real(i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: i1 real(kind=wp), intent(inout) :: i2 Called by proc~~swap_real~~CalledByGraph proc~swap_real numdiff_utilities_module::swap_real interface~swap~2 numdiff_utilities_module::swap interface~swap~2->proc~swap_real proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int proc~sort_ascending_int->interface~swap~2 proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real proc~sort_ascending_real->interface~swap~2 interface~sort_ascending numdiff_utilities_module::sort_ascending interface~sort_ascending->proc~sort_ascending_int interface~sort_ascending->proc~sort_ascending_real proc~unique_int numdiff_utilities_module::unique_int proc~unique_int->interface~sort_ascending proc~unique_real numdiff_utilities_module::unique_real proc~unique_real->interface~sort_ascending interface~unique~2 numdiff_utilities_module::unique interface~unique~2->proc~unique_int interface~unique~2->proc~unique_real proc~divide_interval numdiff_utilities_module::divide_interval proc~divide_interval->interface~unique~2 proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique~2 proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap_real ( i1 , i2 ) implicit none real ( wp ), intent ( inout ) :: i1 real ( wp ), intent ( inout ) :: i2 real ( wp ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_real","tags":"","loc":"proc/swap_real.html"},{"title":"expand_vector – AoC-2023","text":"public interface expand_vector Calls interface~~expand_vector~~CallsGraph interface~expand_vector numdiff_utilities_module::expand_vector proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector->proc~expand_vector_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~expand_vector~~CalledByGraph interface~expand_vector numdiff_utilities_module::expand_vector proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->interface~expand_vector proc~resize_sparsity_vectors numerical_differentiation_module::numdiff_type%resize_sparsity_vectors proc~compute_sparsity_random->proc~resize_sparsity_vectors proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->interface~expand_vector proc~compute_sparsity_random_2->proc~resize_sparsity_vectors proc~divide_interval numdiff_utilities_module::divide_interval proc~compute_sparsity_random_2->proc~divide_interval proc~resize_sparsity_vectors->interface~expand_vector proc~unique_int numdiff_utilities_module::unique_int proc~unique_int->interface~expand_vector proc~unique_real numdiff_utilities_module::unique_real proc~unique_real->interface~expand_vector interface~unique~2 numdiff_utilities_module::unique interface~unique~2->proc~unique_int interface~unique~2->proc~unique_real proc~divide_interval->interface~unique~2 proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique~2 proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure subroutine expand_vector_int (vec, n, chunk_size, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) private pure subroutine expand_vector_real (vec, n, chunk_size, val, finished) Add elements to the real vector in chunks. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) real(kind=wp), intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n )","tags":"","loc":"interface/expand_vector.html"},{"title":"unique – AoC-2023","text":"public interface unique Calls interface~~unique~2~~CallsGraph interface~unique~2 numdiff_utilities_module::unique proc~unique_int numdiff_utilities_module::unique_int interface~unique~2->proc~unique_int proc~unique_real numdiff_utilities_module::unique_real interface~unique~2->proc~unique_real interface~expand_vector numdiff_utilities_module::expand_vector proc~unique_int->interface~expand_vector interface~sort_ascending numdiff_utilities_module::sort_ascending proc~unique_int->interface~sort_ascending proc~unique_real->interface~expand_vector proc~unique_real->interface~sort_ascending proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector->proc~expand_vector_real proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap~2 numdiff_utilities_module::swap proc~sort_ascending_int->interface~swap~2 proc~sort_ascending_real->interface~swap~2 proc~swap_int numdiff_utilities_module::swap_int interface~swap~2->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap~2->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~unique~2~~CalledByGraph interface~unique~2 numdiff_utilities_module::unique proc~divide_interval numdiff_utilities_module::divide_interval proc~divide_interval->interface~unique~2 proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique~2 proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function unique_int (vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value integer, dimension(:), allocatable unique elements of ivec private  function unique_real (vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value real(kind=wp), dimension(:), allocatable unique elements of ivec","tags":"","loc":"interface/unique~2.html"},{"title":"sort_ascending – AoC-2023","text":"public interface sort_ascending Calls interface~~sort_ascending~~CallsGraph interface~sort_ascending numdiff_utilities_module::sort_ascending proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap~2 numdiff_utilities_module::swap proc~sort_ascending_int->interface~swap~2 proc~sort_ascending_real->interface~swap~2 proc~swap_int numdiff_utilities_module::swap_int interface~swap~2->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap~2->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~sort_ascending~~CalledByGraph interface~sort_ascending numdiff_utilities_module::sort_ascending proc~unique_int numdiff_utilities_module::unique_int proc~unique_int->interface~sort_ascending proc~unique_real numdiff_utilities_module::unique_real proc~unique_real->interface~sort_ascending interface~unique~2 numdiff_utilities_module::unique interface~unique~2->proc~unique_int interface~unique~2->proc~unique_real proc~divide_interval numdiff_utilities_module::divide_interval proc~divide_interval->interface~unique~2 proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique~2 proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine sort_ascending_int (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_real (ivec) Sorts a real array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: ivec","tags":"","loc":"interface/sort_ascending.html"},{"title":"swap – AoC-2023","text":"private interface swap Calls interface~~swap~2~~CallsGraph interface~swap~2 numdiff_utilities_module::swap proc~swap_int numdiff_utilities_module::swap_int interface~swap~2->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap~2->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~swap~2~~CalledByGraph interface~swap~2 numdiff_utilities_module::swap proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int proc~sort_ascending_int->interface~swap~2 proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real proc~sort_ascending_real->interface~swap~2 interface~sort_ascending numdiff_utilities_module::sort_ascending interface~sort_ascending->proc~sort_ascending_int interface~sort_ascending->proc~sort_ascending_real proc~unique_int numdiff_utilities_module::unique_int proc~unique_int->interface~sort_ascending proc~unique_real numdiff_utilities_module::unique_real proc~unique_real->interface~sort_ascending interface~unique~2 numdiff_utilities_module::unique interface~unique~2->proc~unique_int interface~unique~2->proc~unique_real proc~divide_interval numdiff_utilities_module::divide_interval proc~divide_interval->interface~unique~2 proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~put_in_cache->interface~unique~2 proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~compute_function_with_cache->proc~put_in_cache proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~divide_interval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure elemental subroutine swap_int (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap_real (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: i1 real(kind=wp), intent(inout) :: i2","tags":"","loc":"interface/swap~2.html"},{"title":"dsm – AoC-2023","text":"public  subroutine dsm(m, n, npairs, indrow, indcol, ngrp, maxgrp, mingrp, info, ipntr, jpntr) The purpose of dsm is to determine an optimal or near-\noptimal consistent partition of the columns of a sparse m by n matrix a . the sparsity pattern of the matrix a is specified by\nthe arrays indrow and indcol . on input the indices\nfor the non-zero elements of a are indrow(k),indcol(k), k = 1,2,...,npairs . the ( indrow , indcol ) pairs may be specified in any order.\nduplicate input pairs are permitted, but the subroutine\neliminates them. the subroutine partitions the columns of a into groups\nsuch that columns in the same group do not have a\nnon-zero in the same row position. a partition of the\ncolumns of a with this property is consistent with the\ndirect determination of a . Arguments Type Intent Optional Attributes Name integer, intent(in) :: m number of rows of a (>0) integer, intent(in) :: n number of columns of a (>0) integer, intent(in) :: npairs number of ( indrow , indcol ) pairs used\nto describe the sparsity pattern of a (>0) integer, intent(inout), dimension(npairs) :: indrow an integer array of length npairs . on input indrow must contain the row indices of the non-zero elements of a .\non output indrow is permuted so that the corresponding\ncolumn indices are in non-decreasing order. the column\nindices can be recovered from the array jpntr . integer, intent(inout), dimension(npairs) :: indcol an integer array of length npairs . on input indcol must contain the column indices of the non-zero elements of a . on output indcol is permuted so that the corresponding\nrow indices are in non-decreasing order. the row indices\ncan be recovered from the array ipntr . integer, intent(out), dimension(n) :: ngrp specifies the partition of the columns of a .\ncolumn jcol belongs to group ngrp(jcol) . integer, intent(out) :: maxgrp the number of groups in the partition\nof the columns of a . integer, intent(out) :: mingrp a lower bound for the number of groups\nin any consistent partition of the\ncolumns of a . integer, intent(out) :: info for normal termination info = 1 .\nif m , n , or npairs is not positive,\nthen info = 0 . if the k-th element of indrow is not an integer between\n1 and m or the k-th element of indcol is not an integer between 1 and n,\nthen info = -k . integer, intent(out), dimension(m+1) :: ipntr an integer output array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 .\nnote that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(out), dimension(n+1) :: jpntr jpntr is an integer output array of length n + 1 which\nspecifies the locations of the row indices in indrow.\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 .\nnote that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . Calls proc~~dsm~~CallsGraph proc~dsm dsm_module::dsm proc~degr dsm_module::degr proc~dsm->proc~degr proc~ido dsm_module::ido proc~dsm->proc~ido proc~numsrt dsm_module::numsrt proc~dsm->proc~numsrt proc~seq dsm_module::seq proc~dsm->proc~seq proc~setr dsm_module::setr proc~dsm->proc~setr proc~slo dsm_module::slo proc~dsm->proc~slo proc~srtdat dsm_module::srtdat proc~dsm->proc~srtdat proc~ido->proc~numsrt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dsm~~CalledByGraph proc~dsm dsm_module::dsm proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm program~dsm_test dsm_test program~dsm_test->proc~dsm proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dsm ( m , n , Npairs , Indrow , Indcol , Ngrp , Maxgrp , Mingrp , Info , Ipntr , Jpntr ) implicit none integer , intent ( in ) :: m !! number of rows of `a` (>0) integer , intent ( in ) :: n !! number of columns of `a` (>0) integer , intent ( in ) :: npairs !! number of (`indrow`,`indcol`) pairs used !! to describe the sparsity pattern of `a` (>0) integer , intent ( out ) :: maxgrp !! the number of groups in the partition !! of the columns of `a`. integer , intent ( out ) :: mingrp !! a lower bound for the number of groups !! in any consistent partition of the !! columns of `a`. integer , intent ( out ) :: info !! for normal termination `info = 1`. !! if `m`, `n`, or `npairs` is not positive, !! then `info = 0`. if the k-th element of !! `indrow` is not an integer between !! 1 and m or the k-th element of `indcol` !! is not an integer between 1 and n, !! then `info = -k`. integer , dimension ( npairs ), intent ( inout ) :: indrow !! an integer array of length `npairs`. on input `indrow` !! must contain the row indices of the non-zero elements of `a`. !! on output `indrow` is permuted so that the corresponding !! column indices are in non-decreasing order. the column !! indices can be recovered from the array `jpntr`. integer , dimension ( npairs ), intent ( inout ) :: indcol !! an integer array of length `npairs`. on input `indcol` !! must contain the column indices of the non-zero elements of !! `a`. on output `indcol` is permuted so that the corresponding !! row indices are in non-decreasing order. the row indices !! can be recovered from the array `ipntr`. integer , dimension ( n ), intent ( out ) :: ngrp !! specifies the partition of the columns of `a`. !! column `jcol` belongs to group `ngrp(jcol)`. integer , dimension ( m + 1 ), intent ( out ) :: ipntr !! an integer output array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! note that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n + 1 ), intent ( out ) :: jpntr !! jpntr is an integer output array of length n + 1 which !! specifies the locations of the row indices in indrow. !! the row indices for column j are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! note that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( max ( m , 6 * n )) :: iwa !! an integer work array integer :: i , ir , j , jp , k , maxclq , nnz , numgrp !  check the input data. Info = 0 if ( m < 1 . or . n < 1 . or . Npairs < 1 ) return do k = 1 , Npairs Info = - k if ( Indrow ( k ) < 1 . or . Indrow ( k ) > m . or . Indcol ( k ) < 1 . or . Indcol ( k ) > n ) return enddo Info = 1 !  sort the data structure by columns. call srtdat ( n , Npairs , Indrow , Indcol , Jpntr , Iwa ) !  compress the data and determine the number of !  non-zero elements of a. do i = 1 , m Iwa ( i ) = 0 enddo nnz = 1 do j = 1 , n k = nnz do jp = Jpntr ( j ) , Jpntr ( j + 1 ) - 1 ir = Indrow ( jp ) if ( Iwa ( ir ) /= j ) then Indrow ( nnz ) = ir nnz = nnz + 1 Iwa ( ir ) = j endif enddo Jpntr ( j ) = k enddo Jpntr ( n + 1 ) = nnz !  extend the data structure to rows. call setr ( m , n , Indrow , Jpntr , Indcol , Ipntr , Iwa ) !  determine a lower bound for the number of groups. Mingrp = 0 do i = 1 , m Mingrp = max ( Mingrp , Ipntr ( i + 1 ) - Ipntr ( i )) enddo !  determine the degree sequence for the intersection !  graph of the columns of a. call degr ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 5 * n + 1 ), Iwa ( n + 1 )) !  color the intersection graph of the columns of a !  with the smallest-last (sl) ordering. call slo ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 5 * n + 1 ), Iwa ( 4 * n + 1 ), maxclq ,& Iwa ( 1 ), Iwa ( n + 1 ), Iwa ( 2 * n + 1 ), Iwa ( 3 * n + 1 )) call seq ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 4 * n + 1 ), Ngrp , Maxgrp , & Iwa ( n + 1 )) Mingrp = max ( Mingrp , maxclq ) !  exit if the smallest-last ordering is optimal. if ( Maxgrp == Mingrp ) return !  color the intersection graph of the columns of a !  with the incidence-degree (id) ordering. call ido ( m , n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 5 * n + 1 ), Iwa ( 4 * n + 1 ), & maxclq , Iwa ( 1 ), Iwa ( n + 1 ), Iwa ( 2 * n + 1 ), Iwa ( 3 * n + 1 )) call seq ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 4 * n + 1 ), Iwa ( 1 ), numgrp , & Iwa ( n + 1 )) Mingrp = max ( Mingrp , maxclq ) !  retain the better of the two orderings so far. if ( numgrp < Maxgrp ) then Maxgrp = numgrp do j = 1 , n Ngrp ( j ) = Iwa ( j ) enddo !  exit if the incidence-degree ordering is optimal. if ( Maxgrp == Mingrp ) return endif !  color the intersection graph of the columns of a !  with the largest-first (lf) ordering. call numsrt ( n , n - 1 , Iwa ( 5 * n + 1 ), - 1 , Iwa ( 4 * n + 1 ), Iwa ( 2 * n + 1 ), Iwa ( n + 1 )) call seq ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 4 * n + 1 ), Iwa ( 1 ), numgrp , & Iwa ( n + 1 )) !  retain the best of the three orderings and exit. if ( numgrp < Maxgrp ) then Maxgrp = numgrp do j = 1 , n Ngrp ( j ) = Iwa ( j ) enddo endif end subroutine dsm","tags":"","loc":"proc/dsm.html"},{"title":"degr – AoC-2023","text":"private  subroutine degr(n, indrow, jpntr, indcol, ipntr, ndeg, iwa) Given the sparsity pattern of an m by n matrix a ,\n  this subroutine determines the degree sequence for\n  the intersection graph of the columns of a . In graph-theory terminology, the intersection graph of\n  the columns of a is the loopless graph g with vertices a(j), j = 1,2,...,n where a(j) is the j -th column of a and with edge (a(i),a(j)) if and only if columns i and j have a non-zero in the same row position. Note The value of m is not needed by degr and is\n      therefore not present in the subroutine statement. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a . integer, intent(in), dimension(*) :: indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, intent(in), dimension(n+1) :: jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(in), dimension(*) :: indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, intent(in), dimension(*) :: ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(out), dimension(n) :: ndeg an integer output array of length n which\nspecifies the degree sequence. the degree of the j -th column of a is ndeg(j) . integer, dimension(n) :: iwa an integer work array of length n Called by proc~~degr~~CalledByGraph proc~degr dsm_module::degr proc~dsm dsm_module::dsm proc~dsm->proc~degr proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm program~dsm_test dsm_test program~dsm_test->proc~dsm proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine degr ( n , Indrow , Jpntr , Indcol , Ipntr , Ndeg , Iwa ) implicit none integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of `a`. integer , dimension ( * ), intent ( in ) :: indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ), intent ( in ) :: jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ), intent ( in ) :: indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( * ), intent ( in ) :: ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ), intent ( out ) :: ndeg !! an integer output array of length `n` which !! specifies the degree sequence. the degree of the !! `j`-th column of `a` is `ndeg(j)`. integer , dimension ( n ) :: iwa !! an integer work array of length `n` integer :: ic , ip , ir , jcol , jp ! initialization block. do jp = 1 , n Ndeg ( jp ) = 0 Iwa ( jp ) = 0 enddo ! compute the degree sequence by determining the contributions ! to the degrees from the current(jcol) column and further ! columns which have not yet been considered. do jcol = 2 , n Iwa ( jcol ) = n ! determine all positions (ir,jcol) which correspond ! to non-zeroes in the matrix. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! for each row ir, determine all positions (ir,ic) ! which correspond to non-zeroes in the matrix. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! array iwa marks columns which have contributed to ! the degree count of column jcol. update the degree ! counts of these columns as well as column jcol. if ( Iwa ( ic ) < jcol ) then Iwa ( ic ) = jcol Ndeg ( ic ) = Ndeg ( ic ) + 1 Ndeg ( jcol ) = Ndeg ( jcol ) + 1 endif enddo enddo enddo end subroutine degr","tags":"","loc":"proc/degr.html"},{"title":"ido – AoC-2023","text":"private  subroutine ido(m, n, Indrow, Jpntr, Indcol, Ipntr, Ndeg, List, Maxclq, Iwa1, Iwa2, Iwa3, Iwa4) given the sparsity pattern of an m by n matrix a , this\nsubroutine determines an incidence-degree ordering of the\ncolumns of a . the incidence-degree ordering is defined for the loopless\ngraph g with vertices a(j), j = 1,2,...,n where a(j) is the j -th column of a and with edge (a(i),a(j)) if and only if\ncolumns i and j have a non-zero in the same row position. the incidence-degree ordering is determined recursively by\nletting list(k), k = 1,...,n be a column with maximal\nincidence to the subgraph spanned by the ordered columns.\namong all the columns of maximal incidence, ido chooses a\ncolumn of maximal degree. Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of a . integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a . integer, intent(in), dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, intent(in), dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(in), dimension(*) :: Indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, intent(in), dimension(m+1) :: Ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(in), dimension(n) :: Ndeg an integer input array of length n which specifies\nthe degree sequence. the degree of the j -th column\nof a is ndeg(j) . integer, intent(out), dimension(n) :: List an integer output array of length n which specifies\nthe incidence-degree ordering of the columns of a . the j -th\ncolumn in this order is list(j) . integer, intent(out) :: Maxclq an integer output variable set to the size\nof the largest clique found during the ordering. integer, dimension(0:n-1) :: Iwa1 integer work array of length n . integer, dimension(n) :: Iwa2 integer work array of length n . integer, dimension(n) :: Iwa3 integer work array of length n . integer, dimension(n) :: Iwa4 integer work array of length n . Calls proc~~ido~~CallsGraph proc~ido dsm_module::ido proc~numsrt dsm_module::numsrt proc~ido->proc~numsrt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ido~~CalledByGraph proc~ido dsm_module::ido proc~dsm dsm_module::dsm proc~dsm->proc~ido proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm program~dsm_test dsm_test program~dsm_test->proc~dsm proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine ido ( m , n , Indrow , Jpntr , Indcol , Ipntr , Ndeg , List , Maxclq , & Iwa1 , Iwa2 , Iwa3 , Iwa4 ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of `a`. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of `a`. integer , intent ( out ) :: Maxclq !! an integer output variable set to the size !! of the largest clique found during the ordering. integer , dimension ( * ), intent ( in ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ), intent ( in ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ), intent ( in ) :: Indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( m + 1 ), intent ( in ) :: Ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ), intent ( in ) :: Ndeg !! an integer input array of length `n` which specifies !! the degree sequence. the degree of the `j`-th column !! of `a` is `ndeg(j)`. integer , dimension ( n ), intent ( out ) :: List !! an integer output array of length `n` which specifies !! the incidence-degree ordering of the columns of `a`. the `j`-th !! column in this order is `list(j)`. integer , dimension ( 0 : n - 1 ) :: Iwa1 !! integer work array of length `n`. integer , dimension ( n ) :: Iwa2 !! integer work array of length `n`. integer , dimension ( n ) :: Iwa3 !! integer work array of length `n`. integer , dimension ( n ) :: Iwa4 !! integer work array of length `n`. integer :: ic , ip , ir , jcol , jp , maxinc , maxlst , ncomp , & numinc , numlst , numord , numwgt ! sort the degree sequence. call numsrt ( n , n - 1 , Ndeg , - 1 , Iwa4 , Iwa2 , Iwa3 ) ! initialization block. ! ! create a doubly-linked list to access the incidences of the ! columns. the pointers for the linked list are as follows. ! ! each un-ordered column ic is in a list (the incidence list) ! of columns with the same incidence. ! ! iwa1(numinc) is the first column in the numinc list ! unless iwa1(numinc) = 0. in this case there are ! no columns in the numinc list. ! ! iwa2(ic) is the column before ic in the incidence list ! unless iwa2(ic) = 0. in this case ic is the first ! column in this incidence list. ! ! iwa3(ic) is the column after ic in the incidence list ! unless iwa3(ic) = 0. in this case ic is the last ! column in this incidence list. ! ! if ic is an un-ordered column, then list(ic) is the ! incidence of ic to the graph induced by the ordered ! columns. if jcol is an ordered column, then list(jcol) ! is the incidence-degree order of column jcol. maxinc = 0 do jp = n , 1 , - 1 ic = Iwa4 ( jp ) Iwa1 ( n - jp ) = 0 Iwa2 ( ic ) = 0 Iwa3 ( ic ) = Iwa1 ( 0 ) if ( Iwa1 ( 0 ) > 0 ) Iwa2 ( Iwa1 ( 0 )) = ic Iwa1 ( 0 ) = ic Iwa4 ( jp ) = 0 List ( jp ) = 0 enddo ! DETERMINE THE MAXIMAL SEARCH LENGTH FOR THE LIST ! OF COLUMNS OF MAXIMAL INCIDENCE. maxlst = 0 do ir = 1 , m maxlst = maxlst + ( Ipntr ( ir + 1 ) - Ipntr ( ir )) ** 2 enddo maxlst = maxlst / n Maxclq = 0 numord = 1 ! BEGINNING OF ITERATION LOOP. ! UPDATE THE SIZE OF THE LARGEST CLIQUE ! FOUND DURING THE ORDERING. 100 if ( maxinc == 0 ) ncomp = 0 ncomp = ncomp + 1 if ( maxinc + 1 == ncomp ) Maxclq = max ( Maxclq , ncomp ) ! CHOOSE A COLUMN JCOL OF MAXIMAL DEGREE AMONG THE ! COLUMNS OF MAXIMAL INCIDENCE MAXINC. 200 jp = Iwa1 ( maxinc ) if ( jp > 0 ) then numwgt = - 1 do numlst = 1 , maxlst if ( Ndeg ( jp ) > numwgt ) then numwgt = Ndeg ( jp ) jcol = jp endif jp = Iwa3 ( jp ) if ( jp <= 0 ) exit enddo List ( jcol ) = numord numord = numord + 1 ! TERMINATION TEST. if ( numord > n ) then ! INVERT THE ARRAY LIST. do jcol = 1 , n Iwa2 ( List ( jcol )) = jcol enddo do jp = 1 , n List ( jp ) = Iwa2 ( jp ) enddo else ! DELETE COLUMN JCOL FROM THE MAXINC LIST. if ( Iwa2 ( jcol ) == 0 ) then Iwa1 ( maxinc ) = Iwa3 ( jcol ) else Iwa3 ( Iwa2 ( jcol )) = Iwa3 ( jcol ) endif if ( Iwa3 ( jcol ) > 0 ) Iwa2 ( Iwa3 ( jcol )) = Iwa2 ( jcol ) ! FIND ALL COLUMNS ADJACENT TO COLUMN JCOL. Iwa4 ( jcol ) = n ! DETERMINE ALL POSITIONS (IR,JCOL) WHICH CORRESPOND ! TO NON-ZEROES IN THE MATRIX. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! FOR EACH ROW IR, DETERMINE ALL POSITIONS (IR,IC) ! WHICH CORRESPOND TO NON-ZEROES IN THE MATRIX. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! ARRAY IWA4 MARKS COLUMNS WHICH ARE ADJACENT TO ! COLUMN JCOL. if ( Iwa4 ( ic ) < numord ) then Iwa4 ( ic ) = numord ! UPDATE THE POINTERS TO THE CURRENT INCIDENCE LISTS. numinc = List ( ic ) List ( ic ) = List ( ic ) + 1 maxinc = max ( maxinc , List ( ic )) ! DELETE COLUMN IC FROM THE NUMINC LIST. if ( Iwa2 ( ic ) == 0 ) then Iwa1 ( numinc ) = Iwa3 ( ic ) else Iwa3 ( Iwa2 ( ic )) = Iwa3 ( ic ) endif if ( Iwa3 ( ic ) > 0 ) Iwa2 ( Iwa3 ( ic )) = Iwa2 ( ic ) ! ADD COLUMN IC TO THE NUMINC+1 LIST. Iwa2 ( ic ) = 0 Iwa3 ( ic ) = Iwa1 ( numinc + 1 ) if ( Iwa1 ( numinc + 1 ) > 0 ) Iwa2 ( Iwa1 ( numinc + 1 )) = ic Iwa1 ( numinc + 1 ) = ic endif enddo enddo ! END OF ITERATION LOOP. goto 100 endif else maxinc = maxinc - 1 goto 200 endif end subroutine ido","tags":"","loc":"proc/ido.html"},{"title":"numsrt – AoC-2023","text":"private  subroutine numsrt(n, Nmax, Num, Mode, Index, Last, Next) Given a sequence of integers, this subroutine groups\n  together those indices with the same sequence value\n  and, optionally, sorts the sequence into either\n  ascending or descending order. The sequence of integers is defined by the array num ,\n  and it is assumed that the integers are each from the set 0,1,...,nmax . on output the indices k such that num(k) = l for any l = 0,1,...,nmax can be obtained from the arrays\n  last and next as follows. k = last ( l ) while ( k /= 0 ) k = next ( k ) Optionally, the subroutine produces an array index so that\n  the sequence num(index(i)), i = 1,2,...,n is sorted. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable. integer :: Nmax a positive integer input variable. integer, dimension(n) :: Num an input array of length n which contains the\nsequence of integers to be grouped and sorted. it\nis assumed that the integers are each from the set 0,1,...,nmax . integer :: Mode an integer input variable. the sequence num is\nsorted in ascending order if mode is positive and in\ndescending order if mode is negative. if mode is 0,\nno sorting is done. integer, dimension(n) :: Index an integer output array of length n set so\nthat the sequence num(index(i)), i = 1,2,...,n is sorted according to the setting of mode.\nif mode is 0, index is not referenced. integer, dimension(0:Nmax) :: Last an integer output array of length nmax + 1 . the\nindex of num for the last occurrence of l is last(l) for any l = 0,1,...,nmax unless last(l) = 0 . in\nthis case l does not appear in num . integer, dimension(n) :: Next an integer output array of length n . if num(k) = l , then the index of num for the previous\noccurrence of l is next(k) for any l = 0,1,...,nmax unless next(k) = 0 . in this case there is no previous\noccurrence of l in num . Called by proc~~numsrt~~CalledByGraph proc~numsrt dsm_module::numsrt proc~dsm dsm_module::dsm proc~dsm->proc~numsrt proc~ido dsm_module::ido proc~dsm->proc~ido proc~ido->proc~numsrt proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm program~dsm_test dsm_test program~dsm_test->proc~dsm proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine numsrt ( n , Nmax , Num , Mode , Index , Last , Next ) implicit none integer , intent ( in ) :: n !! a positive integer input variable. integer :: Nmax !! a positive integer input variable. integer :: Mode !! an integer input variable. the sequence `num` is !! sorted in ascending order if `mode` is positive and in !! descending order if `mode` is negative. if `mode` is 0, !! no sorting is done. integer , dimension ( n ) :: Num !! an input array of length `n` which contains the !! sequence of integers to be grouped and sorted. it !! is assumed that the integers are each from the set !! `0,1,...,nmax`. integer , dimension ( n ) :: Index !! an integer output array of length `n` set so !! that the sequence !! `num(index(i)), i = 1,2,...,n` !! is sorted according to the setting of mode. !! if `mode` is 0, `index` is not referenced. integer , dimension ( 0 : Nmax ) :: Last !! an integer output array of length `nmax + 1`. the !! index of `num` for the last occurrence of `l` is `last(l)` !! for any `l = 0,1,...,nmax` unless `last(l) = 0`. in !! this case `l` does not appear in `num`. integer , dimension ( n ) :: Next !! an integer output array of length `n`. if !! `num(k) = l`, then the index of `num` for the previous !! occurrence of `l` is `next(k)` for any `l = 0,1,...,nmax` !! unless `next(k) = 0`. in this case there is no previous !! occurrence of `l` in `num`. integer :: i , j , jinc , jl , ju , k , l ! determine the arrays next and last. do i = 0 , Nmax Last ( i ) = 0 enddo do k = 1 , n l = Num ( k ) Next ( k ) = Last ( l ) Last ( l ) = k enddo if ( Mode /= 0 ) then ! store the pointers to the sorted array in index. i = 1 if ( Mode > 0 ) then jl = 0 ju = Nmax jinc = 1 else jl = Nmax ju = 0 jinc = - 1 endif do j = jl , ju , jinc k = Last ( j ) do if ( k == 0 ) exit Index ( i ) = k i = i + 1 k = Next ( k ) enddo enddo end if end subroutine numsrt","tags":"","loc":"proc/numsrt.html"},{"title":"seq – AoC-2023","text":"private  subroutine seq(n, Indrow, Jpntr, Indcol, Ipntr, List, Ngrp, Maxgrp, Iwa) given the sparsity pattern of an m by n matrix a , this\nsubroutine determines a consistent partition of the\ncolumns of a by a sequential algorithm. a consistent partition is defined in terms of the loopless\ngraph g with vertices a(j), j = 1,2,...,n where a(j) is the j -th column of a and with edge (a(i),a(j)) if and only if\ncolumns i and j have a non-zero in the same row position. a partition of the columns of a into groups is consistent\nif the columns in any group are not adjacent in the graph g .\nin graph-theory terminology, a consistent partition of the\ncolumns of a corresponds to a coloring of the graph g . the subroutine examines the columns in the order specified\nby the array list, and assigns the current column to the\ngroup with the smallest possible number. note that the value of m is not needed by seq and is\ntherefore not present in the subroutine statement. Arguments Type Intent Optional Attributes Name integer :: n a positive integer input variable set to the number\nof columns of a . integer, dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(*) :: Indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, dimension(*) :: Ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(n) :: List an integer input array of length n which specifies\nthe order to be used by the sequential algorithm.\nthe j -th column in this order is list(j) . integer, dimension(n) :: Ngrp an integer output array of length n which specifies\nthe partition of the columns of a . column jcol belongs\nto group ngrp(jcol) . integer :: Maxgrp an integer output variable which specifies the\nnumber of groups in the partition of the columns of a . integer, dimension(n) :: Iwa an integer work array of length n Called by proc~~seq~~CalledByGraph proc~seq dsm_module::seq proc~dsm dsm_module::dsm proc~dsm->proc~seq proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm program~dsm_test dsm_test program~dsm_test->proc~dsm proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine seq ( n , Indrow , Jpntr , Indcol , Ipntr , List , Ngrp , Maxgrp , Iwa ) implicit none integer :: n !! a positive integer input variable set to the number !! of columns of `a`. integer :: Maxgrp !! an integer output variable which specifies the !! number of groups in the partition of the columns of `a`. integer , dimension ( * ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ) :: Indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( * ) :: Ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ) :: List !! an integer input array of length `n` which specifies !! the order to be used by the sequential algorithm. !! the `j`-th column in this order is `list(j)`. integer , dimension ( n ) :: Ngrp !! an integer output array of length `n` which specifies !! the partition of the columns of `a`. column `jcol` belongs !! to group `ngrp(jcol)`. integer , dimension ( n ) :: Iwa !! an integer work array of length `n` integer :: ic , ip , ir , j , jcol , jp ! initialization block. Maxgrp = 0 do jp = 1 , n Ngrp ( jp ) = n Iwa ( jp ) = 0 enddo ! beginning of iteration loop. do j = 1 , n jcol = List ( j ) ! find all columns adjacent to column jcol. ! ! determine all positions (ir,jcol) which correspond ! to non-zeroes in the matrix. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! for each row ir, determine all positions (ir,ic) ! which correspond to non-zeroes in the matrix. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! array iwa marks the group numbers of the ! columns which are adjacent to column jcol. Iwa ( Ngrp ( ic )) = j enddo enddo ! assign the smallest un-marked group number to jcol. do jp = 1 , Maxgrp if ( Iwa ( jp ) /= j ) then Maxgrp = Maxgrp - 1 exit end if enddo Maxgrp = Maxgrp + 1 Ngrp ( jcol ) = jp enddo ! end of iteration loop. end subroutine seq","tags":"","loc":"proc/seq.html"},{"title":"setr – AoC-2023","text":"private  subroutine setr(m, n, Indrow, Jpntr, Indcol, Ipntr, Iwa) given a column-oriented definition of the sparsity pattern\nof an m by n matrix a , this subroutine determines a\nrow-oriented definition of the sparsity pattern of a . on input the column-oriented definition is specified by\nthe arrays indrow and jpntr . on output the row-oriented\ndefinition is specified by the arrays indcol and ipntr . Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of a . integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a . integer, dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(*) :: Indcol an integer output array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, dimension(m+1) :: Ipntr an integer output array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(1) is set to 1 and that ipntr(m+1)-1 is\nthen the number of non-zero elements of the matrix a . integer, dimension(m) :: Iwa an integer work array of length m . Called by proc~~setr~~CalledByGraph proc~setr dsm_module::setr proc~dsm dsm_module::dsm proc~dsm->proc~setr proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm program~dsm_test dsm_test program~dsm_test->proc~dsm proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine setr ( m , n , Indrow , Jpntr , Indcol , Ipntr , Iwa ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of `a`. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of `a`. integer , dimension ( * ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ) :: Indcol !! an integer output array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( m + 1 ) :: Ipntr !! an integer output array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(1)` is set to 1 and that `ipntr(m+1)-1` is !! then the number of non-zero elements of the matrix `a`. integer , dimension ( m ) :: Iwa !! an integer work array of length `m`. integer :: ir , jcol , jp ! store in array iwa the counts of non-zeroes in the rows. do ir = 1 , m Iwa ( ir ) = 0 enddo do jp = 1 , Jpntr ( n + 1 ) - 1 Iwa ( Indrow ( jp )) = Iwa ( Indrow ( jp )) + 1 enddo ! set pointers to the start of the rows in indcol. Ipntr ( 1 ) = 1 do ir = 1 , m Ipntr ( ir + 1 ) = Ipntr ( ir ) + Iwa ( ir ) Iwa ( ir ) = Ipntr ( ir ) enddo ! fill indcol. do jcol = 1 , n do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) Indcol ( Iwa ( ir )) = jcol Iwa ( ir ) = Iwa ( ir ) + 1 enddo enddo end subroutine setr","tags":"","loc":"proc/setr.html"},{"title":"slo – AoC-2023","text":"private  subroutine slo(n, Indrow, Jpntr, Indcol, Ipntr, Ndeg, List, Maxclq, Iwa1, Iwa2, Iwa3, Iwa4) given the sparsity pattern of an m by n matrix a , this\nsubroutine determines the smallest-last ordering of the\ncolumns of a . the smallest-last ordering is defined for the loopless\ngraph g with vertices a(j), j = 1,2,...,n where a(j) is the j -th column of a and with edge (a(i),a(j)) if and only if\ncolumns i and j have a non-zero in the same row position. the smallest-last ordering is determined recursively by\nletting list(k), k = n,...,1 be a column with least degree\nin the subgraph spanned by the un-ordered columns. note that the value of m is not needed by slo and is\ntherefore not present in the subroutine statement. Arguments Type Intent Optional Attributes Name integer :: n a positive integer input variable set to the number\nof columns of a . integer, dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(*) :: Indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, dimension(*) :: Ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(n) :: Ndeg an integer input array of length n which specifies\nthe degree sequence. the degree of the j -th column\nof a is ndeg(j) . integer, dimension(n) :: List an integer output array of length n which specifies\nthe smallest-last ordering of the columns of a . the j -th\ncolumn in this order is list(j) . integer :: Maxclq an integer output variable set to the size\nof the largest clique found during the ordering. integer, dimension(0:n-1) :: Iwa1 integer work array of length n integer, dimension(n) :: Iwa2 integer work array of length n integer, dimension(n) :: Iwa3 integer work array of length n integer, dimension(n) :: Iwa4 integer work array of length n Called by proc~~slo~~CalledByGraph proc~slo dsm_module::slo proc~dsm dsm_module::dsm proc~dsm->proc~slo proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm program~dsm_test dsm_test program~dsm_test->proc~dsm proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine slo ( n , Indrow , Jpntr , Indcol , Ipntr , Ndeg , List , Maxclq , Iwa1 , & Iwa2 , Iwa3 , Iwa4 ) implicit none integer :: n !! a positive integer input variable set to the number !! of columns of `a`. integer :: Maxclq !! an integer output variable set to the size !! of the largest clique found during the ordering. integer , dimension ( * ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ) :: Indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( * ) :: Ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ) :: Ndeg !! an integer input array of length `n` which specifies !! the degree sequence. the degree of the `j`-th column !! of `a` is `ndeg(j)`. integer , dimension ( n ) :: List !! an integer output array of length `n` which specifies !! the smallest-last ordering of the columns of `a`. the `j`-th !! column in this order is `list(j)`. integer , dimension ( 0 : n - 1 ) :: Iwa1 !! integer work array of length `n` integer , dimension ( n ) :: Iwa2 !! integer work array of length `n` integer , dimension ( n ) :: Iwa3 !! integer work array of length `n` integer , dimension ( n ) :: Iwa4 !! integer work array of length `n` integer :: ic , ip , ir , jcol , jp , mindeg , numdeg , numord ! INITIALIZATION BLOCK. mindeg = n do jp = 1 , n Iwa1 ( jp - 1 ) = 0 Iwa4 ( jp ) = n List ( jp ) = Ndeg ( jp ) mindeg = min ( mindeg , Ndeg ( jp )) enddo ! CREATE A DOUBLY-LINKED LIST TO ACCESS THE DEGREES OF THE ! COLUMNS. THE POINTERS FOR THE LINKED LIST ARE AS FOLLOWS. ! ! EACH UN-ORDERED COLUMN IC IS IN A LIST (THE DEGREE LIST) ! OF COLUMNS WITH THE SAME DEGREE. ! ! IWA1(NUMDEG) IS THE FIRST COLUMN IN THE NUMDEG LIST ! UNLESS IWA1(NUMDEG) = 0. IN THIS CASE THERE ARE ! NO COLUMNS IN THE NUMDEG LIST. ! ! IWA2(IC) IS THE COLUMN BEFORE IC IN THE DEGREE LIST ! UNLESS IWA2(IC) = 0. IN THIS CASE IC IS THE FIRST ! COLUMN IN THIS DEGREE LIST. ! ! IWA3(IC) IS THE COLUMN AFTER IC IN THE DEGREE LIST ! UNLESS IWA3(IC) = 0. IN THIS CASE IC IS THE LAST ! COLUMN IN THIS DEGREE LIST. ! ! IF IC IS AN UN-ORDERED COLUMN, THEN LIST(IC) IS THE ! DEGREE OF IC IN THE GRAPH INDUCED BY THE UN-ORDERED ! COLUMNS. IF JCOL IS AN ORDERED COLUMN, THEN LIST(JCOL) ! IS THE SMALLEST-LAST ORDER OF COLUMN JCOL. do jp = 1 , n numdeg = Ndeg ( jp ) Iwa2 ( jp ) = 0 Iwa3 ( jp ) = Iwa1 ( numdeg ) if ( Iwa1 ( numdeg ) > 0 ) Iwa2 ( Iwa1 ( numdeg )) = jp Iwa1 ( numdeg ) = jp enddo Maxclq = 0 numord = n !  BEGINNING OF ITERATION LOOP. ! ! ! MARK THE SIZE OF THE LARGEST CLIQUE ! FOUND DURING THE ORDERING. 100 if ( mindeg + 1 == numord . and . Maxclq == 0 ) Maxclq = numord ! CHOOSE A COLUMN JCOL OF MINIMAL DEGREE MINDEG. 200 jcol = Iwa1 ( mindeg ) if ( jcol > 0 ) then List ( jcol ) = numord numord = numord - 1 ! TERMINATION TEST. if ( numord == 0 ) then ! INVERT THE ARRAY LIST. do jcol = 1 , n Iwa2 ( List ( jcol )) = jcol enddo do jp = 1 , n List ( jp ) = Iwa2 ( jp ) enddo else ! DELETE COLUMN JCOL FROM THE MINDEG LIST. Iwa1 ( mindeg ) = Iwa3 ( jcol ) if ( Iwa3 ( jcol ) > 0 ) Iwa2 ( Iwa3 ( jcol )) = 0 ! FIND ALL COLUMNS ADJACENT TO COLUMN JCOL. Iwa4 ( jcol ) = 0 ! DETERMINE ALL POSITIONS (IR,JCOL) WHICH CORRESPOND ! TO NON-ZEROES IN THE MATRIX. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! FOR EACH ROW IR, DETERMINE ALL POSITIONS (IR,IC) ! WHICH CORRESPOND TO NON-ZEROES IN THE MATRIX. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! ARRAY IWA4 MARKS COLUMNS WHICH ARE ADJACENT TO ! COLUMN JCOL. if ( Iwa4 ( ic ) > numord ) then Iwa4 ( ic ) = numord ! UPDATE THE POINTERS TO THE CURRENT DEGREE LISTS. numdeg = List ( ic ) List ( ic ) = List ( ic ) - 1 mindeg = min ( mindeg , List ( ic )) ! DELETE COLUMN IC FROM THE NUMDEG LIST. if ( Iwa2 ( ic ) == 0 ) then Iwa1 ( numdeg ) = Iwa3 ( ic ) else Iwa3 ( Iwa2 ( ic )) = Iwa3 ( ic ) endif if ( Iwa3 ( ic ) > 0 ) Iwa2 ( Iwa3 ( ic )) = Iwa2 ( ic ) ! ADD COLUMN IC TO THE NUMDEG-1 LIST. Iwa2 ( ic ) = 0 Iwa3 ( ic ) = Iwa1 ( numdeg - 1 ) if ( Iwa1 ( numdeg - 1 ) > 0 ) Iwa2 ( Iwa1 ( numdeg - 1 )) = ic Iwa1 ( numdeg - 1 ) = ic endif enddo enddo ! END OF ITERATION LOOP. goto 100 endif else mindeg = mindeg + 1 goto 200 endif end subroutine slo","tags":"","loc":"proc/slo.html"},{"title":"srtdat – AoC-2023","text":"private  subroutine srtdat(n, Nnz, Indrow, Indcol, Jpntr, Iwa) given the non-zero elements of an m by n matrix a in\narbitrary order as specified by their row and column\nindices, this subroutine permutes these elements so\nthat their column indices are in non-decreasing order. on input it is assumed that the elements are specified in indrow(k),indcol(k), k = 1,...,nnz . on output the elements are permuted so that indcol is\nin non-decreasing order. in addition, the array jpntr is set so that the row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that the value of m is not needed by srtdat and is\ntherefore not present in the subroutine statement. Arguments Type Intent Optional Attributes Name integer :: n a positive integer input variable set to the number\nof columns of a . integer :: Nnz a positive integer input variable set to the number\nof non-zero elements of a . integer, dimension(Nnz) :: Indrow an integer array of length nnz . on input indrow must contain the row indices of the non-zero elements of a .\non output indrow is permuted so that the corresponding\ncolumn indices of indcol are in non-decreasing order. integer, dimension(Nnz) :: Indcol an integer array of length nnz . on input indcol must contain the column indices of the non-zero elements\nof a . on output indcol is permuted so that these indices\nare in non-decreasing order. integer, dimension(n+1) :: Jpntr an integer output array of length n + 1 which\nspecifies the locations of the row indices in the output indrow . the row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(1) is set to 1 and that jpntr(n+1)-1 is then nnz . integer, dimension(n) :: Iwa an integer work array of length n . Called by proc~~srtdat~~CalledByGraph proc~srtdat dsm_module::srtdat proc~dsm dsm_module::dsm proc~dsm->proc~srtdat proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~dsm_wrapper->proc~dsm program~dsm_test dsm_test program~dsm_test->proc~dsm proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine srtdat ( n , Nnz , Indrow , Indcol , Jpntr , Iwa ) implicit none integer :: n !! a positive integer input variable set to the number !! of columns of `a`. integer :: Nnz !! a positive integer input variable set to the number !! of non-zero elements of `a`. integer , dimension ( Nnz ) :: Indrow !! an integer array of length `nnz`. on input `indrow` !! must contain the row indices of the non-zero elements of `a`. !! on output `indrow` is permuted so that the corresponding !! column indices of `indcol` are in non-decreasing order. integer , dimension ( Nnz ) :: Indcol !! an integer array of length `nnz`. on input `indcol` !! must contain the column indices of the non-zero elements !! of `a`. on output `indcol` is permuted so that these indices !! are in non-decreasing order. integer , dimension ( n + 1 ) :: Jpntr !! an integer output array of length `n + 1` which !! specifies the locations of the row indices in the output !! `indrow`. the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(1)` is set to 1 and that `jpntr(n+1)-1` !! is then `nnz`. integer , dimension ( n ) :: Iwa !! an integer work array of length `n`. integer :: i , j , k , l ! store in array iwa the counts of non-zeroes in the columns. do j = 1 , n Iwa ( j ) = 0 enddo do k = 1 , Nnz Iwa ( Indcol ( k )) = Iwa ( Indcol ( k )) + 1 enddo ! set pointers to the start of the columns in indrow. Jpntr ( 1 ) = 1 do j = 1 , n Jpntr ( j + 1 ) = Jpntr ( j ) + Iwa ( j ) Iwa ( j ) = Jpntr ( j ) enddo k = 1 ! begin in-place sort. do j = Indcol ( k ) if ( k >= Jpntr ( j ) ) then ! current element is in position. now examine the ! next element or the first un-sorted element in ! the j-th group. k = max ( k + 1 , Iwa ( j )) else ! current element is not in position. place element ! in position and make the displaced element the ! current element. l = Iwa ( j ) Iwa ( j ) = Iwa ( j ) + 1 i = Indrow ( k ) Indrow ( k ) = Indrow ( l ) Indcol ( k ) = Indcol ( l ) Indrow ( l ) = i Indcol ( l ) = j endif if ( k > Nnz ) exit end do end subroutine srtdat","tags":"","loc":"proc/srtdat.html"},{"title":"fdjs – AoC-2023","text":"public  subroutine fdjs(m, n, Col, Ind, Npntr, Ngrp, Numgrp, d, Fjacd, Fjac) Given a consistent partition of the columns of an m by n jacobian matrix into groups, this subroutine computes\n  approximations to those columns in a given group.  the\n  approximations are stored into either a column-oriented\n  or a row-oriented pattern. a partition is consistent if the columns in any group\n  do not have a non-zero in the same row position. approximations to the columns of the jacobian matrix in a\n  given group can be obtained by specifying a difference\n  parameter array d with d(jcol) non-zero if and only if jcol is a column in the group, and an approximation to jac*d where jac denotes the jacobian matrix of a mapping f. d can be defined with the following segment of code. do jcol = 1 , n d ( jcol ) = 0.0 if ( ngrp ( jcol ) == numgrp ) d ( jcol ) = eta ( jcol ) end do in the above code numgrp is the given group number, ngrp(jcol) is the group number of column jcol , and eta(jcol) is the difference parameter used to\n  approximate column jcol of the jacobian matrix.\n  suitable values for the array eta must be provided. as mentioned above, an approximation to jac*d must\n  also be provided. for example, the approximation f ( x + d ) - f ( x ) corresponds to the forward difference formula at x . Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of the jacobian matrix. integer, intent(in) :: n a positive integer input variable set to the number\nof columns of the jacobian matrix. logical, intent(in) :: Col a logical input variable. if col is set true, then the\njacobian approximations are stored into a column-oriented\npattern. if col is set false, then the jacobian\napproximations are stored into a row-oriented pattern. integer, dimension(*) :: Ind an integer input array which contains the row\nindices for the non-zeroes in the jacobian matrix\nif col is true, and contains the column indices for\nthe non-zeroes in the jacobian matrix if col is false. integer, dimension(*) :: Npntr an integer input array which specifies the\nlocations of the row indices in ind if col is true, and\nspecifies the locations of the column indices in ind if col is false. if col is true, the indices for column j are ind(k), k = npntr(j),...,npntr(j+1)-1 .\nif col is false, the indices for row i are ind(k), k = npntr(i),...,npntr(i+1)-1 . Note that npntr(n+1)-1 if col is true, or npntr(m+1)-1 if col is false, is then the number of non-zero elements\nof the jacobian matrix. integer, dimension(n) :: Ngrp an integer input array of length n which specifies\nthe partition of the columns of the jacobian matrix.\ncolumn jcol belongs to group ngrp(jcol) . integer :: Numgrp a positive integer input variable set to a group\nnumber in the partition. the columns of the jacobian\nmatrix in this group are to be estimated on this call. real(kind=wp), dimension(n) :: d an input array of length n which contains the\ndifference parameter vector for the estimate of\nthe jacobian matrix columns in group numgrp . real(kind=wp), dimension(m) :: Fjacd an input array of length m which contains\nan approximation to the difference vector jac*d ,\nwhere jac denotes the jacobian matrix. real(kind=wp), dimension(*) :: Fjac an output array of length nnz , where nnz is the\nnumber of its non-zero elements. at each call of fdjs , fjac is updated to include the non-zero elements of the\njacobian matrix for those columns in group numgrp . fjac should not be altered between successive calls to fdjs . Called by proc~~fdjs~~CalledByGraph proc~fdjs dsm_module::fdjs program~dsm_test dsm_test program~dsm_test->proc~fdjs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fdjs ( m , n , Col , Ind , Npntr , Ngrp , Numgrp , d , Fjacd , Fjac ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of the jacobian matrix. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of the jacobian matrix. integer :: Numgrp !! a positive integer input variable set to a group !! number in the partition. the columns of the jacobian !! matrix in this group are to be estimated on this call. integer , dimension ( * ) :: Ind !! an integer input array which contains the row !! indices for the non-zeroes in the jacobian matrix !! if `col` is true, and contains the column indices for !! the non-zeroes in the jacobian matrix if `col` is false. integer , dimension ( * ) :: Npntr !! an integer input array which specifies the !! locations of the row indices in `ind` if `col` is true, and !! specifies the locations of the column indices in `ind` if !! `col` is false. if `col` is true, the indices for column `j` are !!       `ind(k), k = npntr(j),...,npntr(j+1)-1`. !! if `col` is false, the indices for row `i` are !!       `ind(k), k = npntr(i),...,npntr(i+1)-1`. !! ***Note*** that `npntr(n+1)-1` if `col` is true, or `npntr(m+1)-1` !! if `col` is false, is then the number of non-zero elements !! of the jacobian matrix. integer , dimension ( n ) :: Ngrp !! an integer input array of length `n` which specifies !! the partition of the columns of the jacobian matrix. !! column `jcol` belongs to group `ngrp(jcol)`. real ( wp ), dimension ( n ) :: d !! an input array of length `n` which contains the !! difference parameter vector for the estimate of !! the jacobian matrix columns in group `numgrp`. real ( wp ), dimension ( m ) :: Fjacd !! an input array of length `m` which contains !! an approximation to the difference vector `jac*d`, !! where `jac` denotes the jacobian matrix. real ( wp ), dimension ( * ) :: Fjac !! an output array of length `nnz`, where `nnz` is the !! number of its non-zero elements. at each call of `fdjs`, !! `fjac` is updated to include the non-zero elements of the !! jacobian matrix for those columns in group `numgrp`. `fjac` !! should not be altered between successive calls to `fdjs`. logical , intent ( in ) :: Col !! a logical input variable. if `col` is set true, then the !! jacobian approximations are stored into a column-oriented !! pattern. if `col` is set false, then the jacobian !! approximations are stored into a row-oriented pattern. integer :: ip , irow , jcol , jp ! compute estimates of jacobian matrix columns in group ! numgrp. the array fjacd must contain an approximation ! to jac*d, where jac denotes the jacobian matrix and d ! is a difference parameter vector with d(jcol) non-zero ! if and only if jcol is a column in group numgrp. if ( Col ) then ! column orientation. do jcol = 1 , n if ( Ngrp ( jcol ) == Numgrp ) then do jp = Npntr ( jcol ) , Npntr ( jcol + 1 ) - 1 irow = Ind ( jp ) Fjac ( jp ) = Fjacd ( irow ) / d ( jcol ) enddo endif enddo else ! row orientation. do irow = 1 , m do ip = Npntr ( irow ) , Npntr ( irow + 1 ) - 1 jcol = Ind ( ip ) if ( Ngrp ( jcol ) == Numgrp ) then Fjac ( ip ) = Fjacd ( irow ) / d ( jcol ) exit endif enddo enddo endif end subroutine fdjs","tags":"","loc":"proc/fdjs.html"},{"title":"check – AoC-2023","text":"function check(i, j) if the char is part of a number, then get it and append to ivals Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Return Value logical Calls proc~~check~2~~CallsGraph proc~check~2 problem_3::check proc~get_number problem_3::get_number proc~check~2->proc~get_number proc~is_number aoc_utilities::is_number proc~check~2->proc~is_number proc~is_symbol problem_3::is_symbol proc~get_number->proc~is_symbol proc~is_not_number aoc_utilities::is_not_number proc~is_symbol->proc~is_not_number proc~is_not_number->proc~is_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check~2~~CalledByGraph proc~check~2 problem_3::check program~problem_3 problem_3 program~problem_3->proc~check~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function check ( i , j ) !! if the char is part of a number, then get it and append to ivals integer , intent ( in ) :: i , j check = is_number ( array ( i , j )) if ( check ) ivals = [ ivals , get_number ( i , j )] end function check","tags":"","loc":"proc/check~2.html"},{"title":"is_symbol – AoC-2023","text":"function is_symbol(c) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical Calls proc~~is_symbol~~CallsGraph proc~is_symbol problem_3::is_symbol proc~is_not_number aoc_utilities::is_not_number proc~is_symbol->proc~is_not_number proc~is_number aoc_utilities::is_number proc~is_not_number->proc~is_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~is_symbol~~CalledByGraph proc~is_symbol problem_3::is_symbol proc~get_number problem_3::get_number proc~get_number->proc~is_symbol program~problem_3 problem_3 program~problem_3->proc~is_symbol program~problem_3->proc~get_number proc~check~2 problem_3::check program~problem_3->proc~check~2 proc~check~2->proc~get_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function is_symbol ( c ) character ( len = 1 ), intent ( in ) :: c is_symbol = is_not_number ( c ) . and . c /= '.' end function is_symbol","tags":"","loc":"proc/is_symbol.html"},{"title":"get_number – AoC-2023","text":"function get_number(i, j) get the full number contining the character at i,j Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Return Value integer(kind=ip) Calls proc~~get_number~~CallsGraph proc~get_number problem_3::get_number proc~is_symbol problem_3::is_symbol proc~get_number->proc~is_symbol proc~is_not_number aoc_utilities::is_not_number proc~is_symbol->proc~is_not_number proc~is_number aoc_utilities::is_number proc~is_not_number->proc~is_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_number~~CalledByGraph proc~get_number problem_3::get_number proc~check~2 problem_3::check proc~check~2->proc~get_number program~problem_3 problem_3 program~problem_3->proc~get_number program~problem_3->proc~check~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code integer ( ip ) function get_number ( i , j ) !! get the full number contining the character at i,j integer , intent ( in ) :: i , j jstart = j jend = j do if ( array ( i , jstart - 1 ) == '.' . or . is_symbol ( array ( i , jstart - 1 ))) exit jstart = jstart - 1 end do do if ( array ( i , jend + 1 ) == '.' . or . is_symbol ( array ( i , jend + 1 ))) exit jend = jend + 1 end do get_number = int ( array ( i , jstart : jend )) end function get_number","tags":"","loc":"proc/get_number.html"},{"title":"ddot – AoC-2023","text":"public  function ddot(n, dx, incx, dy, incy) dot product of two vectors Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: dx (*) integer :: incx real(kind=wp) :: dy (*) integer :: incy Return Value real(kind=wp) Called by proc~~ddot~~CalledByGraph proc~ddot lsqpblas_module::ddot proc~acheck lsqr_module::lsqr_solver%acheck proc~acheck->proc~ddot proc~test~2 lsqrtest_module::test_solver%test proc~test~2->proc~acheck proc~lsqr_test lsqrtest_module::lsqr_test proc~lsqr_test->proc~test~2 program~main~2 main program~main~2->proc~lsqr_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code real ( wp ) function ddot ( n , dx , incx , dy , incy ) integer incx , incy , n real ( wp ) dx ( * ), dy ( * ) real ( wp ) dtemp integer i , ix , iy , m , mp1 ddot = zero dtemp = zero if ( n <= 0 ) return if ( incx == 1 . and . incy == 1 ) then ! code for both increments equal to 1 ! clean-up loop m = mod ( n , 5 ) if ( m /= 0 ) then do i = 1 , m dtemp = dtemp + dx ( i ) * dy ( i ) end do if ( n < 5 ) then ddot = dtemp return end if end if mp1 = m + 1 do i = mp1 , n , 5 dtemp = dtemp + dx ( i ) * dy ( i ) + dx ( i + 1 ) * dy ( i + 1 ) + dx ( i + 2 ) * dy ( i + 2 ) + dx ( i + 3 ) * dy ( i + 3 ) + dx ( i + 4 ) * dy ( i + 4 ) end do else ! code for unequal increments or equal increments not equal to 1 ix = 1 iy = 1 if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dtemp = dtemp + dx ( ix ) * dy ( iy ) ix = ix + incx iy = iy + incy end do end if ddot = dtemp end function ddot","tags":"","loc":"proc/ddot.html"},{"title":"dnrm2 – AoC-2023","text":"public  function dnrm2(n, x, incx) euclidean norm of a vector. Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: x (*) integer :: incx Return Value real(kind=wp) Called by proc~~dnrm2~~CalledByGraph proc~dnrm2 lsqpblas_module::dnrm2 proc~acheck lsqr_module::lsqr_solver%acheck proc~acheck->proc~dnrm2 proc~lsqr lsqr_module::lsqr_solver%LSQR proc~lsqr->proc~dnrm2 proc~lstp lsqrtest_module::test_solver%lstp proc~lstp->proc~dnrm2 proc~test~2 lsqrtest_module::test_solver%test proc~test~2->proc~dnrm2 proc~test~2->proc~acheck proc~test~2->proc~lsqr proc~test~2->proc~lstp proc~xcheck lsqr_module::lsqr_solver%xcheck proc~test~2->proc~xcheck proc~xcheck->proc~dnrm2 proc~lsqr_test lsqrtest_module::lsqr_test proc~lsqr_test->proc~test~2 proc~solve_ez lsqr_module::lsqr_solver_ez%solve_ez proc~solve_ez->proc~lsqr proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver proc~nlesolver_solver->proc~solve_ez program~main~2 main program~main~2->proc~lsqr_test program~main~3 main program~main~3->proc~solve_ez program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->proc~nlesolver_solver program~sparse_test sparse_test program~sparse_test->proc~nlesolver_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code real ( wp ) function dnrm2 ( n , x , incx ) integer incx , n real ( wp ) x ( * ) real ( wp ) absxi , norm , scale , ssq integer ix if ( n < 1 . or . incx < 1 ) then norm = zero else if ( n == 1 ) then norm = abs ( x ( 1 )) else scale = zero ssq = one ! the following loop is equivalent to this call to the lapack ! auxiliary routine: ! call dlassq( n, x, incx, scale, ssq ) do ix = 1 , 1 + ( n - 1 ) * incx , incx if ( x ( ix ) /= zero ) then absxi = abs ( x ( ix )) if ( scale < absxi ) then ssq = one + ssq * ( scale / absxi ) ** 2 scale = absxi else ssq = ssq + ( absxi / scale ) ** 2 end if end if end do norm = scale * sqrt ( ssq ) end if dnrm2 = norm end function dnrm2","tags":"","loc":"proc/dnrm2.html"},{"title":"dcopy – AoC-2023","text":"public  subroutine dcopy(n, dx, incx, dy, incy) copies a vector, x , to a vector, y . Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: dx (*) integer :: incx real(kind=wp) :: dy (*) integer :: incy Called by proc~~dcopy~~CalledByGraph proc~dcopy lsqpblas_module::dcopy proc~acheck lsqr_module::lsqr_solver%acheck proc~acheck->proc~dcopy proc~lsqr lsqr_module::lsqr_solver%LSQR proc~lsqr->proc~dcopy proc~lstp lsqrtest_module::test_solver%lstp proc~lstp->proc~dcopy proc~test~2 lsqrtest_module::test_solver%test proc~test~2->proc~dcopy proc~test~2->proc~acheck proc~test~2->proc~lsqr proc~test~2->proc~lstp proc~xcheck lsqr_module::lsqr_solver%xcheck proc~test~2->proc~xcheck proc~xcheck->proc~dcopy proc~lsqr_test lsqrtest_module::lsqr_test proc~lsqr_test->proc~test~2 proc~solve_ez lsqr_module::lsqr_solver_ez%solve_ez proc~solve_ez->proc~lsqr proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver proc~nlesolver_solver->proc~solve_ez program~main~2 main program~main~2->proc~lsqr_test program~main~3 main program~main~3->proc~solve_ez program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->proc~nlesolver_solver program~sparse_test sparse_test program~sparse_test->proc~nlesolver_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dcopy ( n , dx , incx , dy , incy ) integer incx , incy , n real ( wp ) dx ( * ), dy ( * ) integer i , ix , iy , m , mp1 if ( n <= 0 ) return if ( incx == 1 . and . incy == 1 ) then ! code for both increments equal to 1 ! clean-up loop m = mod ( n , 7 ) if ( m /= 0 ) then do i = 1 , m dy ( i ) = dx ( i ) end do if ( n < 7 ) return end if mp1 = m + 1 do i = mp1 , n , 7 dy ( i ) = dx ( i ) dy ( i + 1 ) = dx ( i + 1 ) dy ( i + 2 ) = dx ( i + 2 ) dy ( i + 3 ) = dx ( i + 3 ) dy ( i + 4 ) = dx ( i + 4 ) dy ( i + 5 ) = dx ( i + 5 ) dy ( i + 6 ) = dx ( i + 6 ) end do else ! code for unequal increments or equal increments ! not equal to 1 ix = 1 iy = 1 if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dy ( iy ) = dx ( ix ) ix = ix + incx iy = iy + incy end do end if end subroutine dcopy","tags":"","loc":"proc/dcopy.html"},{"title":"dscal – AoC-2023","text":"public  subroutine dscal(n, da, dx, incx) scales a vector by a constant. Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: da real(kind=wp) :: dx (*) integer :: incx Called by proc~~dscal~~CalledByGraph proc~dscal lsqpblas_module::dscal proc~acheck lsqr_module::lsqr_solver%acheck proc~acheck->proc~dscal proc~lsqr lsqr_module::lsqr_solver%LSQR proc~lsqr->proc~dscal proc~lstp lsqrtest_module::test_solver%lstp proc~lstp->proc~dscal proc~xcheck lsqr_module::lsqr_solver%xcheck proc~xcheck->proc~dscal proc~solve_ez lsqr_module::lsqr_solver_ez%solve_ez proc~solve_ez->proc~lsqr proc~test~2 lsqrtest_module::test_solver%test proc~test~2->proc~acheck proc~test~2->proc~lsqr proc~test~2->proc~lstp proc~test~2->proc~xcheck proc~lsqr_test lsqrtest_module::lsqr_test proc~lsqr_test->proc~test~2 proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver proc~nlesolver_solver->proc~solve_ez program~main~3 main program~main~3->proc~solve_ez program~main~2 main program~main~2->proc~lsqr_test program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->proc~nlesolver_solver program~sparse_test sparse_test program~sparse_test->proc~nlesolver_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dscal ( n , da , dx , incx ) real ( wp ) da integer incx , n real ( wp ) dx ( * ) integer i , m , mp1 , nincx if ( n <= 0 . or . incx <= 0 ) return if ( incx == 1 ) then ! code for increment equal to 1 ! clean-up loop m = mod ( n , 5 ) if ( m /= 0 ) then do i = 1 , m dx ( i ) = da * dx ( i ) end do if ( n < 5 ) return end if mp1 = m + 1 do i = mp1 , n , 5 dx ( i ) = da * dx ( i ) dx ( i + 1 ) = da * dx ( i + 1 ) dx ( i + 2 ) = da * dx ( i + 2 ) dx ( i + 3 ) = da * dx ( i + 3 ) dx ( i + 4 ) = da * dx ( i + 4 ) end do else ! code for increment not equal to 1 nincx = n * incx do i = 1 , nincx , incx dx ( i ) = da * dx ( i ) end do end if end subroutine dscal","tags":"","loc":"proc/dscal.html"},{"title":"index_in_queue – AoC-2023","text":"function index_in_queue(state) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state Return Value integer(kind=ip) index in the queue. -1 if not present Called by proc~~index_in_queue~2~~CalledByGraph proc~index_in_queue~2 problem_17::index_in_queue proc~check~3 problem_17::check proc~check~3->proc~index_in_queue~2 program~problem_17~2 problem_17 program~problem_17~2->proc~check~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function index_in_queue ( state ) result ( idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ) :: idx !! index in the queue. -1 if not present integer :: i idx = - 1 if (. not . allocated ( queue )) error stop 'error: queue not allocated' do i = 1 , size ( queue ) if ( all ( state == queue ( i )% state )) then idx = i return end if end do end function index_in_queue","tags":"","loc":"proc/index_in_queue~2.html"},{"title":"check – AoC-2023","text":"subroutine check(idx, idirection) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: idx integer(kind=ip), intent(in) :: idirection direction to move from current Calls proc~~check~3~~CallsGraph proc~check~3 problem_17::check proc~add_to_queue~2 problem_17::add_to_queue proc~check~3->proc~add_to_queue~2 proc~index_in_queue~2 problem_17::index_in_queue proc~check~3->proc~index_in_queue~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check~3~~CalledByGraph proc~check~3 problem_17::check program~problem_17~2 problem_17 program~problem_17~2->proc~check~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine check ( idx , idirection ) implicit none integer ( ip ), intent ( in ) :: idx ! current item in the queue to process integer ( ip ), intent ( in ) :: idirection !! direction to move from current integer ( ip ) :: alt integer ( ip ), dimension ( 2 ) :: v ! neighbor to move to integer ( ip ) :: imovesv , idxv , distv integer ( ip ), dimension ( NSTATE ) :: istate logical :: in_queue associate ( i => queue ( idx )% state ( 1 ), & j => queue ( idx )% state ( 2 ), & direction => queue ( idx )% state ( 3 ), & n_moves => queue ( idx )% state ( 4 )) if ( direction ==- idirection ) return ! can't reverse ! the one to go to: if ( direction == idirection ) then if ( n_moves == MAX_MOVES_IN_DIR ) return ! can't move in this direction anymore imovesv = n_moves + 1 else imovesv = 1 ! reset on change of direction end if select case ( idirection ) case ( UP ); v = [ i - 1 , j ] case ( DOWN ); v = [ i + 1 , j ] case ( LEFT ); v = [ i , j - 1 ] case ( RIGHT ); v = [ i , j + 1 ] end select if ( v ( 1 ) < 1 . or . v ( 2 ) < 1 . or . v ( 1 ) > n_rows . or . v ( 2 ) > n_cols ) return ! can't go off the board istate = [ v ( 1 ), v ( 2 ), idirection , imovesv ] ! new state idxv = index_in_queue ( istate ) ! is it already in the queue in_queue = idxv > 0 ! if this one is already part of another path if ( in_queue ) then if ( queue ( idxv )% visited ) return ! already visited this one distv = queue ( idxv )% dist ! distance in the queue else !call add_to_queue(istate, idxv) ! add this to the queue for processing ! always add it ?? distv = huge ( 1_ip ) ! not processed yet, so huge number end if !alt = queue(idx)%dist + map(queue(idxv)%state(1), queue(idxv)%state(2)) alt = queue ( idx )% dist + map ( v ( 1 ), v ( 2 )) ! new distance if ( alt < distv ) then ! the new one is better, so replace values in the queue if (. not . in_queue ) call add_to_queue ( istate , idxv ) ! only add it if we accept it ???? ! accept this step queue ( idxv )% dist = alt ! new best dist queue ( idxv )% iprev = idx ! previous end if end associate end subroutine check","tags":"","loc":"proc/check~3.html"},{"title":"add_to_queue – AoC-2023","text":"subroutine add_to_queue(state, idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state integer(kind=ip), intent(out) :: idx index of the element in the queue Called by proc~~add_to_queue~2~~CalledByGraph proc~add_to_queue~2 problem_17::add_to_queue proc~check~3 problem_17::check proc~check~3->proc~add_to_queue~2 program~problem_17~2 problem_17 program~problem_17~2->proc~add_to_queue~2 program~problem_17~2->proc~check~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine add_to_queue ( state , idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ), intent ( out ) :: idx !! index of the element in the queue if ( allocated ( queue )) then queue = [ queue , item ( state = state )] idx = size ( queue ) else queue = [ item ( state = state )] idx = 1 end if end subroutine add_to_queue","tags":"","loc":"proc/add_to_queue~2.html"},{"title":"node_index – AoC-2023","text":"pure function node_index(node) find the node number for this name Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: node Return Value integer Called by proc~~node_index~~CalledByGraph proc~node_index problem_25::node_index program~problem_25 problem_25 program~problem_25->proc~node_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer function node_index ( node ) !! find the node number for this name character ( len =* ), intent ( in ) :: node integer , dimension ( 1 ) :: idx idx = findloc ( nodes , node ) node_index = idx ( 1 ) end function node_index","tags":"","loc":"proc/node_index.html"},{"title":"traverse – AoC-2023","text":"recursive subroutine traverse(i) travere the graph and visit all the connected nodes Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Called by proc~~traverse~~CalledByGraph proc~traverse problem_25::traverse proc~traverse->proc~traverse program~problem_25 problem_25 program~problem_25->proc~traverse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine traverse ( i ) !! travere the graph and visit all the connected nodes integer , intent ( in ) :: i integer :: j if ( visited ( i )) return visited ( i ) = . true . do j = 1 , size ( graph ( i )% connections ) call traverse ( graph ( i )% connections ( j )) end do end subroutine traverse","tags":"","loc":"proc/traverse.html"},{"title":"go – AoC-2023","text":"recursive subroutine go(i, j, direction_from) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i grid coordinate integer, intent(in) :: j grid coordinate integer, intent(in) :: direction_from direction coming from (TOP,BOTTOM,LEFT,RIGHT Called by proc~~go~2~~CalledByGraph proc~go~2 problem_16::go proc~go~2->proc~go~2 program~problem_16 problem_16 program~problem_16->proc~go~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine go ( i , j , direction_from ) integer , intent ( in ) :: i , j !! grid coordinate integer , intent ( in ) :: direction_from !! direction coming from (TOP,BOTTOM,LEFT,RIGHT integer :: k if ( i > nrows . or . i < 1 . or . j > ncols . or . j < 1 ) return ! off the board if ( visited ( direction_from , i , j )) return ! this case has already been done visited ( direction_from , i , j ) = . true . ! mark this one as visited in this direction associate ( c => array ( i , j )) select case ( c ) case ( '.' ) ! continue in same direction k = 1 do ! loop until we hit something else ! (to avoid unnecessary recursion) select case ( direction_from ) case ( TOP ) ! V if (( i + k ) > nrows ) return if ( array ( i + k , j ) /= '.' ) then call go ( i + k , j , direction_from ) return end if visited ( direction_from , i + k , j ) = . true . case ( BOTTOM ) ! &#94; if (( i - k ) < 1 ) return if ( array ( i - k , j ) /= '.' ) then call go ( i - k , j , direction_from ) return end if visited ( direction_from , i - k , j ) = . true . case ( LEFT ) ! --> if (( j + k ) > ncols ) return if ( array ( i , j + k ) /= '.' ) then call go ( i , j + k , direction_from ) return end if visited ( direction_from , i , j + k ) = . true . case ( RIGHT ) ! <-- if (( j - k ) < 1 ) return if ( array ( i , j - k ) /= '.' ) then call go ( i , j - k , direction_from ) return end if visited ( direction_from , i , j - k ) = . true . end select k = k + 1 end do case ( '-' ) select case ( direction_from ) case ( TOP , BOTTOM ) ! V, &#94; call go ( i , j + 1 , LEFT ) ! split call go ( i , j - 1 , RIGHT ) case ( LEFT ) ! --> call go ( i , j + 1 , LEFT ) case ( RIGHT ) ! <-- call go ( i , j - 1 , RIGHT ) end select case ( '|' ) select case ( direction_from ) case ( TOP ) ! V call go ( i + 1 , j , TOP ) case ( BOTTOM ) ! &#94; call go ( i - 1 , j , BOTTOM ) case ( LEFT , RIGHT ) ! -->, <-- call go ( i + 1 , j , TOP ) call go ( i - 1 , j , BOTTOM ) end select case ( '/' ) select case ( direction_from ) case ( TOP ) ! V call go ( i , j - 1 , RIGHT ) case ( BOTTOM ) ! &#94; call go ( i , j + 1 , LEFT ) case ( LEFT ) ! --> call go ( i - 1 , j , BOTTOM ) case ( RIGHT ) ! <-- call go ( i + 1 , j , TOP ) end select case ( '\\' ) select case ( direction_from ) case ( TOP ) ! V call go ( i , j + 1 , LEFT ) case ( BOTTOM ) ! &#94; call go ( i , j - 1 , RIGHT ) case ( LEFT ) ! --> call go ( i + 1 , j , TOP ) case ( RIGHT ) ! <-- call go ( i - 1 , j , BOTTOM ) end select end select end associate end subroutine go","tags":"","loc":"proc/go~2.html"},{"title":"process – AoC-2023","text":"recursive function process(iworkflow, irule, p) result(iaccepted) process this part range starting with irule Arguments Type Intent Optional Attributes Name integer, intent(in) :: iworkflow integer, intent(in) :: irule type( part ), intent(in) :: p Return Value integer(kind=ip) Calls proc~~process~~CallsGraph proc~process problem_19b::process proc~process->proc~process proc~get_accepted problem_19b::get_accepted proc~process->proc~get_accepted proc~workflow_name_to_index problem_19b::workflow_name_to_index proc~process->proc~workflow_name_to_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~process~~CalledByGraph proc~process problem_19b::process proc~process->proc~process program~problem_19b problem_19b program~problem_19b->proc~process Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive function process ( iworkflow , irule , p ) result ( iaccepted ) !! process this part range starting with irule integer , intent ( in ) :: iworkflow integer , intent ( in ) :: irule type ( part ), intent ( in ) :: p integer ( ip ) :: iaccepted integer ( ip ), dimension (:), allocatable :: itmp , itmp_t , itmp_f integer ( ip ) :: i type ( part ) :: pt , pf iaccepted = 0 associate ( r => workflows ( iworkflow )% rules ( irule ) ) ! check if we are done if ( r % accept ) then iaccepted = get_accepted ( p ) return else if ( r % reject ) then iaccepted = 0 return end if ! process recursively, by splitting up the intervals when necessary if ( r % operator > 0 ) then ! process the operator select case ( r % operator ) case ( 1 ) ! < ! always create the two sets and process the two cases below ! [note that some sets maybe empty] ! ! example: ![1,200]   < 10   ==> [1,9]    TRUE !                     [10,200] FALSE itmp = [( i , i = p % xmas ( r % operator_arg )% v ( 1 ), p % xmas ( r % operator_arg )% v ( 2 ))] itmp_t = pack ( itmp , mask = itmp < r % operator_val ) !true itmp_f = pack ( itmp , mask = itmp >= r % operator_val ) !false if ( size ( itmp_t ) > 0 ) then ! some are true pt = p pt % xmas ( r % operator_arg )% v = [ itmp_t ( 1 ), itmp_t ( size ( itmp_t ))] if ( r % goto == 'A' ) then iaccepted = iaccepted + get_accepted ( pt ) else if ( r % goto /= 'R' ) then ! go to next workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , pt ) end if end if if ( size ( itmp_f ) > 0 ) then ! some are false pf = p pf % xmas ( r % operator_arg )% v = [ itmp_f ( 1 ), itmp_f ( size ( itmp_f ))] iaccepted = iaccepted + process ( iworkflow , irule + 1 , pf ) ! next rule end if case ( 2 ) ! > itmp = [( i , i = p % xmas ( r % operator_arg )% v ( 1 ), p % xmas ( r % operator_arg )% v ( 2 ))] itmp_t = pack ( itmp , mask = itmp > r % operator_val ) !true itmp_f = pack ( itmp , mask = itmp <= r % operator_val ) !false if ( size ( itmp_t ) > 0 ) then ! some are true pt = p pt % xmas ( r % operator_arg )% v = [ itmp_t ( 1 ), itmp_t ( size ( itmp_t ))] if ( r % goto == 'A' ) then iaccepted = iaccepted + get_accepted ( pt ) else if ( r % goto /= 'R' ) then ! go to next workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , pt ) end if end if if ( size ( itmp_f ) > 0 ) then ! some are false pf = p pf % xmas ( r % operator_arg )% v = [ itmp_f ( 1 ), itmp_f ( size ( itmp_f ))] iaccepted = iaccepted + process ( iworkflow , irule + 1 , pf ) ! next rule end if end select else ! goto another workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , p ) end if end associate !end do end function process","tags":"","loc":"proc/process.html"},{"title":"get_accepted – AoC-2023","text":"function get_accepted(p) count of all the parts in the set Arguments Type Intent Optional Attributes Name type( part ), intent(in) :: p Return Value integer(kind=ip) Called by proc~~get_accepted~~CalledByGraph proc~get_accepted problem_19b::get_accepted proc~process problem_19b::process proc~process->proc~get_accepted proc~process->proc~process program~problem_19b problem_19b program~problem_19b->proc~process Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code integer ( ip ) function get_accepted ( p ) !! count of all the parts in the set type ( part ), intent ( in ) :: p get_accepted = ( 1 + ( p % xmas ( 1 )% v ( 2 ) - p % xmas ( 1 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 2 )% v ( 2 ) - p % xmas ( 2 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 3 )% v ( 2 ) - p % xmas ( 3 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 4 )% v ( 2 ) - p % xmas ( 4 )% v ( 1 ))) end function get_accepted","tags":"","loc":"proc/get_accepted.html"},{"title":"workflow_name_to_index – AoC-2023","text":"function workflow_name_to_index(name) result(idx) get the index of this workflow in the array Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value integer Called by proc~~workflow_name_to_index~~CalledByGraph proc~workflow_name_to_index problem_19b::workflow_name_to_index proc~process problem_19b::process proc~process->proc~workflow_name_to_index proc~process->proc~process program~problem_19b problem_19b program~problem_19b->proc~workflow_name_to_index program~problem_19b->proc~process Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function workflow_name_to_index ( name ) result ( idx ) !! get the index of this workflow in the array character ( len =* ), intent ( in ) :: name integer :: idx do idx = 1 , size ( workflows ) if ( name == workflows ( idx )% name ) return ! found it end do if ( idx > size ( workflows )) error stop 'workflow not found: ' // name end function workflow_name_to_index","tags":"","loc":"proc/workflow_name_to_index.html"},{"title":"parse_rule – AoC-2023","text":"function parse_rule(s) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value type( rule ) Calls proc~~parse_rule~~CallsGraph proc~parse_rule problem_19b::parse_rule interface~split aoc_utilities::split proc~parse_rule->interface~split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~parse_rule~~CalledByGraph proc~parse_rule problem_19b::parse_rule program~problem_19b problem_19b program~problem_19b->proc~parse_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function parse_rule ( s ) result ( r ) character ( len =* ), intent ( in ) :: s type ( rule ) :: r type ( string ), dimension (:), allocatable :: v character ( len =* ), parameter :: xmas = 'xmas' ! 1,2,3,4 if ( s == 'A' ) then r % accept = . true . else if ( s == 'R' ) then r % reject = . true . else if ( index ( s , '>' ) > 0 ) then v = split ( s ( 3 :), ':' ) ! example: a<2006:qkq r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 2 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else if ( index ( s , '<' ) > 0 ) then v = split ( s ( 3 :), ':' ) r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 1 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else r % goto = s ! it's a workflow name end if end if end function parse_rule","tags":"","loc":"proc/parse_rule.html"},{"title":"my_func – AoC-2023","text":"subroutine my_func(me, x, f, funcs_to_compute) Problem function Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: f integer, intent(in), dimension(:) :: funcs_to_compute Source Code subroutine my_func ( me , x , f , funcs_to_compute ) !! Problem function implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f integer , dimension (:), intent ( in ) :: funcs_to_compute if ( any ( funcs_to_compute == 1 )) f ( 1 ) = x ( 1 ) * x ( 2 ) - x ( 3 ) ** 3 if ( any ( funcs_to_compute == 2 )) f ( 2 ) = x ( 3 ) - 1.0_wp if ( any ( funcs_to_compute == 3 )) f ( 3 ) = x ( 4 ) * x ( 5 ) if ( any ( funcs_to_compute == 4 )) f ( 4 ) = 2.0_wp * x ( 6 ) + sin ( x ( 7 )) if ( any ( funcs_to_compute == 5 )) f ( 5 ) = cos ( x ( 8 )) + sqrt ( abs ( x ( 9 ))) if ( any ( funcs_to_compute == 6 )) f ( 6 ) = 1.0_wp / ( 1.0_wp + exp ( x ( 10 ))) func_evals = func_evals + 1 end subroutine my_func","tags":"","loc":"proc/my_func~2.html"},{"title":"set_function – AoC-2023","text":"private  subroutine set_function(me, f) Set the function in a diff_func .\nMust be called before diff . Type Bound diff_func Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me procedure( func ) :: f Called by proc~~set_function~~CalledByGraph proc~set_function diff_module::diff_func%set_function proc~compute_jacobian_with_diff numerical_differentiation_module::compute_jacobian_with_diff proc~compute_jacobian_with_diff->proc~set_function Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_function ( me , f ) implicit none class ( diff_func ), intent ( inout ) :: me procedure ( func ) :: f me % f => f end subroutine set_function","tags":"","loc":"proc/set_function.html"},{"title":"terminate – AoC-2023","text":"private  subroutine terminate(me) Can be called by the user in the function to terminate the computation.\nThis will set ifail=-1 . Type Bound diff_func Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me Source Code subroutine terminate ( me ) implicit none class ( diff_func ), intent ( inout ) :: me me % stop = . true . end subroutine terminate","tags":"","loc":"proc/terminate.html"},{"title":"diff – AoC-2023","text":"private  subroutine diff(me, iord, x0, xmin, xmax, eps, accr, deriv, error, ifail) the procedure diff calculates the first, second or\nthird order derivative of a function by using neville's process to\nextrapolate from a sequence of simple polynomial approximations based on\ninterpolating points distributed symmetrically about x0 (or lying only on\none side of x0 should this be necessary).  if the specified tolerance is\nnon-zero then the procedure attempts to satisfy this absolute or relative\naccuracy requirement, while if it is unsuccessful or if the tolerance is\nset to zero then the result having the minimum achievable estimated error\nis returned instead. Type Bound diff_func Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me integer, intent(in) :: iord 1, 2 or 3 specifies that the first, second or third order\nderivative,respectively, is required. real(kind=wp), intent(in) :: x0 the point at which the derivative of the function is to be calculated. real(kind=wp), intent(in) :: xmin xmin , xmax restrict the interpolating points to lie in [ xmin , xmax ], which\nshould be the largest interval including x0 in which the function is\ncalculable and continuous. real(kind=wp), intent(in) :: xmax xmin , xmax restrict the interpolating points to lie in [ xmin , xmax ], which\nshould be the largest interval including x0 in which the function is\ncalculable and continuous. real(kind=wp), intent(in) :: eps denotes the tolerance, either absolute or relative. eps=0 specifies that\nthe error is to be minimised, while eps>0 or eps<0 specifies that the\nabsolute or relative error, respectively, must not exceed abs(eps) if\npossible.  the accuracy requirement should not be made stricter than\nnecessary, since the amount of computation tends to increase as\nthe magnitude of eps decreases, and is particularly high when eps=0 . real(kind=wp), intent(in) :: accr denotes that the absolute ( accr>0 ) or relative ( accr<0 ) errors in the\ncomputed values of the function are most unlikely to exceed abs(accr) , which\nshould be as small as possible.  if the user cannot estimate accr with\ncomplete confidence, then it should be set to zero. real(kind=wp), intent(out) :: deriv the calculated value of the derivative real(kind=wp), intent(out) :: error an estimated upper bound on the magnitude of the absolute error in\nthe calculated result.  it should always be examined, since in extreme case\nmay indicate that there are no correct significant digits in the value\nreturned for derivative. integer, intent(out) :: ifail will have one of the following values on exit: 0 the procedure was successful. 1 the estimated error in the result exceeds the (non-zero) requested\n     error, but the most accurate result possible has been returned. 2 input data incorrect (derivative and error will be undefined). 3 the interval [ xmin , xmax ] is too small (derivative and error will be\n     undefined). -1 stopped by the user. Calls proc~~diff~2~~CallsGraph proc~diff~2 diff_module::diff_func%diff proc~faccur diff_module::diff_func%faccur proc~diff~2->proc~faccur Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~diff~2~~CalledByGraph proc~diff~2 diff_module::diff_func%diff proc~compute_jacobian_with_diff numerical_differentiation_module::compute_jacobian_with_diff proc~compute_jacobian_with_diff->proc~diff~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine diff ( me , iord , x0 , xmin , xmax , eps , accr , deriv , error , ifail ) implicit none class ( diff_func ), intent ( inout ) :: me integer , intent ( in ) :: iord !! 1, 2 or 3 specifies that the first, second or third order !! derivative,respectively, is required. real ( wp ), intent ( in ) :: x0 !! the point at which the derivative of the function is to be calculated. real ( wp ), intent ( in ) :: xmin !! `xmin`, `xmax` restrict the interpolating points to lie in [`xmin`, `xmax`], which !! should be the largest interval including `x0` in which the function is !! calculable and continuous. real ( wp ), intent ( in ) :: xmax !! `xmin`, `xmax` restrict the interpolating points to lie in [`xmin`, `xmax`], which !! should be the largest interval including `x0` in which the function is !! calculable and continuous. real ( wp ), intent ( in ) :: eps !! denotes the tolerance, either absolute or relative. `eps=0` specifies that !! the error is to be minimised, while `eps>0` or `eps<0` specifies that the !! absolute or relative error, respectively, must not exceed `abs(eps)` if !! possible.  the accuracy requirement should not be made stricter than !! necessary, since the amount of computation tends to increase as !! the magnitude of `eps` decreases, and is particularly high when `eps=0`. real ( wp ), intent ( in ) :: accr !! denotes that the absolute (`accr>0`) or relative (`accr<0`) errors in the !! computed values of the function are most unlikely to exceed `abs(accr)`, which !! should be as small as possible.  if the user cannot estimate `accr` with !! complete confidence, then it should be set to zero. real ( wp ), intent ( out ) :: deriv !! the calculated value of the derivative real ( wp ), intent ( out ) :: error !! an estimated upper bound on the magnitude of the absolute error in !! the calculated result.  it should always be examined, since in extreme case !! may indicate that there are no correct significant digits in the value !! returned for derivative. integer , intent ( out ) :: ifail !! will have one of the following values on exit: !!  *0* the procedure was successful. !!  *1* the estimated error in the result exceeds the (non-zero) requested !!      error, but the most accurate result possible has been returned. !!  *2* input data incorrect (derivative and error will be undefined). !!  *3* the interval [`xmin`, `xmax`] is too small (derivative and error will be !!      undefined). !!  *-1* stopped by the user. real ( wp ) :: acc , beta , beta4 , h , h0 , h1 , h2 , & newh1 , newh2 , heval , hprev , baseh , hacc1 , hacc2 , nhacc1 , & nhacc2 , minh , maxh , maxh1 , maxh2 , tderiv , f0 , twof0 , f1 , f2 , f3 , f4 , fmax , & maxfun , pmaxf , df1 , deltaf , pdelta , z , zpower , c0f0 , c1 , c2 , c3 , dnew , dprev , & re , te , newerr , temerr , newacc , pacc1 , pacc2 , facc1 , facc2 , acc0 , & acc1 , acc2 , relacc , twoinf , twosup , s , & d ( 10 ), denom ( 10 ), e ( 10 ), minerr ( 10 ), maxf ( 0 : 10 ), save ( 0 : 13 ), storef ( - 45 : 45 ), factor integer :: i , j , k , n , nmax , method , signh , fcount , init logical :: ignore ( 10 ), contin , saved real ( wp ) :: dummy1 , dummy2 integer , parameter :: eta = digits ( 1.0_wp ) - 1 !! minimum number of significant binary digits (apart from the !! sign digit) used to represent the mantissa of real(wp) numbers. it should !! be decreased by one if the computer truncates rather than rounds. integer , parameter :: inf = - minexponent ( 1.0_wp ) - 2 !! the largest possible positive integers subject to !! 2**(-inf) and -2**(-inf) being representable real(wp) numbers. integer , parameter :: sup = maxexponent ( 1.0_wp ) - 1 !! the largest possible positive integers subject to !! 2**sup and -2**sup being representable real(wp) numbers. real ( wp ), parameter :: sqrt2 = sqrt ( 2.0_wp ) !!  \\sqrt(2)  real ( wp ), parameter :: sqrt3 = sqrt ( 3.0_wp ) !!  \\sqrt(3)  me % stop = . false . ! execution commences with examination of input parameters if ( iord < 1 . or . iord > 3 . or . xmax <= xmin . or . & x0 > xmax . or . x0 < xmin . or . . not . associated ( me % f )) then ifail = 2 else acc = accr twoinf = 2.0_wp ** ( - inf ) twosup = 2.0_wp ** sup factor = 2.0_wp ** ( real (( inf + sup ), wp ) / 3 0.0_wp ) if ( factor < 25 6.0_wp ) factor = 25 6.0_wp maxh1 = xmax - x0 signh = 1 if ( x0 - xmin <= maxh1 ) then maxh2 = x0 - xmin else maxh2 = maxh1 maxh1 = x0 - xmin signh = - 1 end if relacc = 2.0_wp ** ( 1.0_wp - eta ) maxh1 = ( 1.0_wp - relacc ) * maxh1 maxh2 = ( 1.0_wp - relacc ) * maxh2 s = 12 8.0_wp * twoinf if ( abs ( x0 ) > 12 8.0_wp * twoinf * 2.0_wp ** eta ) s = abs ( x0 ) * 2.0_wp ** ( - eta ) if ( maxh1 < s ) then ! interval too small ifail = 3 return end if if ( acc < 0.0_wp ) then if ( - acc > relacc ) relacc = - acc acc = 0.0_wp end if ! determine the smallest spacing at which the calculated ! function values are unequal near x0. f0 = me % f ( x0 ) if ( me % stop ) then ifail = - 1 return end if twof0 = f0 + f0 if ( abs ( x0 ) > twoinf * 2.0_wp ** eta ) then h = abs ( x0 ) * 2.0_wp ** ( - eta ) z = 2.0_wp else h = twoinf z = 6 4.0_wp end if df1 = me % f ( x0 + signh * h ) - f0 if ( me % stop ) then ifail = - 1 return end if do if ( df1 /= 0.0_wp . or . z * h > maxh1 ) exit h = z * h df1 = me % f ( x0 + signh * h ) - f0 if ( me % stop ) then ifail = - 1 return end if if ( z /= 2.0_wp ) then if ( df1 /= 0.0_wp ) then h = h / z z = 2.0_wp df1 = 0.0_wp else if ( z * h > maxh1 ) z = 2.0_wp end if end if end do if ( df1 == 0.0_wp ) then ! constant function deriv = 0.0_wp error = 0.0_wp ifail = 0 return end if if ( h > maxh1 / 12 8.0_wp ) then ! minimum h too large ifail = 3 return end if h = 8.0_wp * h h1 = signh * h h0 = h1 h2 = - h1 minh = 2.0_wp ** ( - min ( inf , sup ) / iord ) if ( minh < h ) minh = h select case ( iord ) case ( 1 ) s = 8.0_wp case ( 2 ) s = 9.0_wp * sqrt3 case ( 3 ) s = 2 7.0_wp end select if ( minh > maxh1 / s ) then ifail = 3 return end if if ( minh > maxh2 / s . or . maxh2 < 12 8.0_wp * twoinf ) then method = 1 else method = 2 end if ! method 1 uses 1-sided formulae, and method 2 symmetric. ! now estimate accuracy of calculated function values. if ( method /= 2 . or . iord == 2 ) then if ( x0 /= 0.0_wp ) then dummy1 = 0.0_wp dummy2 = - h1 call me % faccur ( dummy1 , dummy2 , acc0 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return else acc0 = 0.0_wp end if end if if ( abs ( h1 ) > twosup / 12 8.0_wp ) then hacc1 = twosup else hacc1 = 12 8.0_wp * h1 end if if ( abs ( hacc1 ) / 4.0_wp < minh ) then hacc1 = 4.0_wp * signh * minh else if ( abs ( hacc1 ) > maxh1 ) then hacc1 = signh * maxh1 end if f1 = me % f ( x0 + hacc1 ) if ( me % stop ) then ifail = - 1 return end if call me % faccur ( hacc1 , h1 , acc1 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return if ( method == 2 ) then hacc2 = - hacc1 if ( abs ( hacc2 ) > maxh2 ) hacc2 = - signh * maxh2 f1 = me % f ( x0 + hacc2 ) if ( me % stop ) then ifail = - 1 return end if call me % faccur ( hacc2 , h2 , acc2 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return end if nmax = 8 if ( eta > 36 ) nmax = 10 n = - 1 fcount = 0 deriv = 0.0_wp error = twosup init = 3 contin = . true . do n = n + 1 if (. not . contin ) exit if ( init == 3 ) then ! calculate coefficients for differentiation ! formulae and neville extrapolation algorithm if ( iord == 1 ) then beta = 2.0_wp else if ( method == 2 ) then beta = sqrt2 else beta = sqrt3 end if beta4 = beta ** 4 z = beta if ( method == 2 ) z = z ** 2 zpower = 1.0_wp do k = 1 , nmax zpower = z * zpower denom ( k ) = zpower - 1 end do if ( method == 2 . and . iord == 1 ) then e ( 1 ) = 5.0_wp e ( 2 ) = 6.3_wp do i = 3 , nmax e ( i ) = 6.81_wp end do else if (( method /= 2 . and . iord == 1 ) . or . & ( method == 2 . and . iord == 2 )) then e ( 1 ) = 1 0.0_wp e ( 2 ) = 1 6.0_wp e ( 3 ) = 2 0.36_wp e ( 4 ) = 2 3.0_wp e ( 5 ) = 2 4.46_wp do i = 6 , nmax e ( i ) = 2 6.0_wp end do if ( method == 2 . and . iord == 2 ) then do i = 1 , nmax e ( i ) = 2.0_wp * e ( i ) end do end if else if ( method /= 2 . and . iord == 2 ) then e ( 1 ) = 1 7.78_wp e ( 2 ) = 3 0.06_wp e ( 3 ) = 3 9.66_wp e ( 4 ) = 4 6.16_wp e ( 5 ) = 5 0.26_wp do i = 6 , nmax e ( i ) = 5 5.0_wp end do else if ( method == 2 . and . iord == 3 ) then e ( 1 ) = 2 5.97_wp e ( 2 ) = 4 1.22_wp e ( 3 ) = 5 0.95_wp e ( 4 ) = 5 6.4_wp e ( 5 ) = 5 9.3_wp do i = 6 , nmax e ( i ) = 6 2.0_wp end do else e ( 1 ) = 2 4.5_wp e ( 2 ) = 4 0.4_wp e ( 3 ) = 5 2.78_wp e ( 4 ) = 6 1.2_wp e ( 5 ) = 6 6.55_wp do i = 6 , nmax e ( i ) = 7 3.0_wp end do c0f0 = - twof0 / ( 3.0_wp * beta ) c1 = 3.0_wp / ( 3.0_wp * beta - 1.0_wp ) c2 = - 1.0_wp / ( 3.0_wp * ( beta - 1.0_wp )) c3 = 1.0_wp / ( 3.0_wp * beta * ( 5.0_wp - 2.0_wp * beta )) end if end if if ( init >= 2 ) then ! initialization of steplengths, accuracy and other parameters heval = signh * minh h = heval baseh = heval maxh = maxh2 if ( method == 1 ) maxh = maxh1 do k = 1 , nmax minerr ( k ) = twosup ignore ( k ) = . false . end do if ( method == 1 ) newacc = acc1 if ( method == - 1 ) newacc = acc2 if ( method == 2 ) newacc = ( acc1 + acc2 ) / 2.0_wp if ( newacc < acc ) newacc = acc if (( method /= 2 . or . iord == 2 ) . and . newacc < acc0 ) newacc = acc0 if ( method /= - 1 ) then facc1 = acc1 nhacc1 = hacc1 newh1 = h1 end if if ( method /= 1 ) then facc2 = acc2 nhacc2 = hacc2 newh2 = h2 else facc2 = 0.0_wp nhacc2 = 0.0_wp end if init = 1 j = 0 saved = . false . end if ! calculate new or initial function values if ( init == 1 . and . ( n == 0 . or . iord == 1 ) . and . & . not .( method == 2 . and . fcount >= 45 )) then if ( method == 2 ) then fcount = fcount + 1 f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if storef ( fcount ) = f1 f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if storef ( - fcount ) = f2 else j = j + 1 if ( j <= fcount ) then f1 = storef ( j * method ) else f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if end if end if else f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if if ( method == 2 ) then f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if end if end if if ( n == 0 ) then if ( method == 2 . and . iord == 3 ) then pdelta = f1 - f2 pmaxf = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp heval = beta * heval f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if deltaf = f1 - f2 maxfun = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp heval = beta * heval f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if else if ( method /= 2 . and . iord >= 2 ) then if ( iord == 2 ) then f3 = f1 else f4 = f1 heval = beta * heval f3 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if end if heval = beta * heval f2 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if heval = beta * heval f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if end if end if ! evaluate a new approximation dnew to the derivative if ( n > nmax ) then n = nmax do i = 1 , n maxf ( i - 1 ) = maxf ( i ) end do end if if ( method == 2 ) then maxf ( n ) = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp if ( iord == 1 ) then dnew = ( f1 - f2 ) / 2.0_wp else if ( iord == 2 ) then dnew = f1 + f2 - twof0 else dnew = - pdelta pdelta = deltaf deltaf = f1 - f2 dnew = dnew + 0.5_wp * deltaf if ( maxf ( n ) < pmaxf ) maxf ( n ) = pmaxf pmaxf = maxfun maxfun = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp end if else maxf ( n ) = abs ( f1 ) if ( iord == 1 ) then dnew = f1 - f0 else if ( iord == 2 ) then dnew = ( twof0 - 3.0_wp * f3 + f1 ) / 3.0_wp if ( maxf ( n ) < abs ( f3 )) maxf ( n ) = abs ( f3 ) f3 = f2 f2 = f1 else dnew = c3 * f1 + c2 * f2 + c1 * f4 + c0f0 if ( maxf ( n ) < abs ( f2 )) maxf ( n ) = abs ( f2 ) if ( maxf ( n ) < abs ( f4 )) maxf ( n ) = abs ( f4 ) f4 = f3 f3 = f2 f2 = f1 end if end if if ( abs ( h ) > 1 ) then dnew = dnew / h ** iord else if ( 12 8.0_wp * abs ( dnew ) > twosup * abs ( h ) ** iord ) then dnew = twosup / 12 8.0_wp else dnew = dnew / h ** iord end if end if if ( init == 0 ) then ! update estimated accuracy of function values newacc = acc if (( method /= 2 . or . iord == 2 ) . and . newacc < acc0 ) newacc = acc0 if ( method /= - 1 . and . abs ( nhacc1 ) <= 1.125_wp * abs ( heval ) / beta4 ) then nhacc1 = heval pacc1 = facc1 call me % faccur ( nhacc1 , newh1 , facc1 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return if ( facc1 < pacc1 ) facc1 = ( 3.0_wp * facc1 + pacc1 ) / 4.0_wp end if if ( method /= 1 . and . abs ( nhacc2 ) <= 1.125_wp * abs ( heval ) / beta4 ) then if ( method == 2 ) then f1 = f2 nhacc2 = - heval else nhacc2 = heval end if pacc2 = facc2 call me % faccur ( nhacc2 , newh2 , facc2 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return if ( facc2 < pacc2 ) facc2 = ( 3.0_wp * facc2 + pacc2 ) / 4.0_wp end if if ( method == 1 . and . newacc < facc1 ) newacc = facc1 if ( method == - 1 . and . newacc < facc2 ) newacc = facc2 if ( method == 2 . and . newacc < ( facc1 + facc2 ) / 2.0_wp ) & newacc = ( facc1 + facc2 ) / 2.0_wp end if ! evaluate successive elements of the current row in the neville ! array, estimating and examining the truncation and rounding ! errors in each contin = n < nmax hprev = abs ( h ) fmax = maxf ( n ) if (( method /= 2 . or . iord == 2 ) . and . fmax < abs ( f0 )) fmax = abs ( f0 ) do k = 1 , n dprev = d ( k ) d ( k ) = dnew dnew = dprev + ( dprev - dnew ) / denom ( k ) te = abs ( dnew - d ( k )) if ( fmax < maxf ( n - k )) fmax = maxf ( n - k ) hprev = hprev / beta if ( newacc >= relacc * fmax ) then re = newacc * e ( k ) else re = relacc * fmax * e ( k ) end if if ( re /= 0.0_wp ) then if ( hprev > 1 ) then re = re / hprev ** iord else if ( 2.0_wp * re > twosup * hprev ** iord ) then re = twosup / 2.0_wp else re = re / hprev ** iord end if end if newerr = te + re if ( te > re ) newerr = 1.25_wp * newerr if (. not . ignore ( k )) then if (( init == 0 . or . ( k == 2 . and . . not . ignore ( 1 ))) & . and . newerr < error ) then deriv = d ( k ) error = newerr end if if ( init == 1 . and . n == 1 ) then tderiv = d ( 1 ) temerr = newerr end if if ( minerr ( k ) < twosup / 4.0_wp ) then s = 4.0_wp * minerr ( k ) else s = twosup end if if ( te > re . or . newerr > s ) then ignore ( k ) = . true . else contin = . true . end if if ( newerr < minerr ( k )) minerr ( k ) = newerr if ( init == 1 . and . n == 2 . and . k == 1 . and . . not . ignore ( 1 )) then if ( newerr < temerr ) then tderiv = d ( 1 ) temerr = newerr end if if ( temerr < error ) then deriv = tderiv error = temerr end if end if end if end do if ( n < nmax ) d ( n + 1 ) = dnew if ( eps < 0.0_wp ) then s = abs ( eps * deriv ) else s = eps end if if ( error <= s ) then contin = . false . else if ( init == 1 . and . ( n == 2 . or . ignore ( 1 ))) then if (( ignore ( 1 ) . or . ignore ( 2 )) . and . saved ) then saved = . false . n = 2 h = beta * save ( 0 ) heval = beta * save ( 1 ) maxf ( 0 ) = save ( 2 ) maxf ( 1 ) = save ( 3 ) maxf ( 2 ) = save ( 4 ) d ( 1 ) = save ( 5 ) d ( 2 ) = save ( 6 ) d ( 3 ) = save ( 7 ) minerr ( 1 ) = save ( 8 ) minerr ( 2 ) = save ( 9 ) if ( method == 2 . and . iord == 3 ) then pdelta = save ( 10 ) deltaf = save ( 11 ) pmaxf = save ( 12 ) maxfun = save ( 13 ) else if ( method /= 2 . and . iord >= 2 ) then f2 = save ( 10 ) f3 = save ( 11 ) if ( iord == 3 ) f4 = save ( 12 ) end if init = 0 ignore ( 1 ) = . false . ignore ( 2 ) = . false . else if (. not . ( ignore ( 1 ) . or . ignore ( 2 )) . and . n == 2 & . and . beta4 * factor * abs ( heval ) <= maxh ) then ! save all current values in case of return to current point saved = . true . save ( 0 ) = h save ( 1 ) = heval save ( 2 ) = maxf ( 0 ) save ( 3 ) = maxf ( 1 ) save ( 4 ) = maxf ( 2 ) save ( 5 ) = d ( 1 ) save ( 6 ) = d ( 2 ) save ( 7 ) = d ( 3 ) save ( 8 ) = minerr ( 1 ) save ( 9 ) = minerr ( 2 ) if ( method == 2 . and . iord == 3 ) then save ( 10 ) = pdelta save ( 11 ) = deltaf save ( 12 ) = pmaxf save ( 13 ) = maxfun else if ( method /= 2 . and . iord >= 2 ) then save ( 10 ) = f2 save ( 11 ) = f3 if ( iord == 3 ) save ( 12 ) = f4 end if h = factor * baseh heval = h baseh = h n = - 1 else init = 0 h = beta * h heval = beta * heval end if else if ( contin . and . beta * abs ( heval ) <= maxh ) then h = beta * h heval = beta * heval else if ( method /= 1 ) then contin = . true . if ( method == 2 ) then init = 3 method = - 1 if ( iord /= 2 ) then if ( x0 /= 0.0_wp ) then dummy1 = 0.0_wp dummy2 = - h0 call me % faccur ( dummy1 , dummy2 , acc0 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return else acc0 = 0.0_wp end if end if else init = 2 method = 1 end if n = - 1 signh = - signh else contin = . false . end if end do if ( eps < 0.0_wp ) then s = abs ( eps * deriv ) else s = eps end if ifail = 0 if ( eps /= 0.0_wp . and . error > s ) ifail = 1 end if end subroutine diff","tags":"","loc":"proc/diff~2.html"},{"title":"faccur – AoC-2023","text":"private  subroutine faccur(me, h0, h1, facc, x0, twoinf, f0, f1, ifail) This procedure attempts to estimate the level of rounding errors in\nthe calculated function values near the point x0+h0 by fitting a\nleast-squares straight-line approximation to the function at the\nsix points x0+h0-j*h1 , ( j = 0,1,3,5,7,9 ), and then setting facc to\ntwice the largest deviation of the function values from this line. hi is adjusted if necessary so that it is approximately 8 times the\nsmallest spacing at which the function values are unequal near x0+h0 . Type Bound diff_func Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me real(kind=wp), intent(inout) :: h0 real(kind=wp), intent(inout) :: h1 real(kind=wp), intent(out) :: facc real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: twoinf real(kind=wp), intent(in) :: f0 real(kind=wp), intent(in) :: f1 integer, intent(out) :: ifail 0 if no error, -1 if user termination. Called by proc~~faccur~~CalledByGraph proc~faccur diff_module::diff_func%faccur proc~diff~2 diff_module::diff_func%diff proc~diff~2->proc~faccur proc~compute_jacobian_with_diff numerical_differentiation_module::compute_jacobian_with_diff proc~compute_jacobian_with_diff->proc~diff~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine faccur ( me , h0 , h1 , facc , x0 , twoinf , f0 , f1 , ifail ) implicit none class ( diff_func ), intent ( inout ) :: me real ( wp ), intent ( inout ) :: h0 real ( wp ), intent ( inout ) :: h1 real ( wp ), intent ( out ) :: facc real ( wp ), intent ( in ) :: x0 real ( wp ), intent ( in ) :: twoinf real ( wp ), intent ( in ) :: f0 real ( wp ), intent ( in ) :: f1 integer , intent ( out ) :: ifail !! 0 if no error, -1 if user termination. real ( wp ) :: a0 , a1 , f00 , f001 , f2 , deltaf , t0 , t1 , df ( 5 ) integer :: j ifail = 0 t0 = 0.0_wp t1 = 0.0_wp if ( h0 /= 0.0_wp ) then if ( x0 + h0 /= 0.0_wp ) then f00 = f1 else h0 = 0.875_wp * h0 f00 = me % f ( x0 + h0 ) if ( me % stop ) then ifail = - 1 return end if end if if ( abs ( h1 ) >= 3 2.0_wp * twoinf ) h1 = h1 / 8.0_wp if ( 1 6.0_wp * abs ( h1 ) > abs ( h0 )) h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp f001 = me % f ( x0 + h0 - h1 ) if ( me % stop ) then ifail = - 1 return end if if ( f001 == f00 ) then if ( 25 6.0_wp * abs ( h1 ) <= abs ( h0 )) then h1 = 2.0_wp * h1 do f001 = me % f ( x0 + h0 - h1 ) if ( me % stop ) then ifail = - 1 return end if if ( f001 /= f00 . or . 25 6.0_wp * abs ( h1 ) > abs ( h0 )) exit h1 = 2.0_wp * h1 end do h1 = 8.0_wp * h1 else h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp end if else if ( 25 6.0_wp * twoinf <= abs ( h0 )) then do f001 = me % f ( x0 + h0 - h1 / 2.0_wp ) if ( me % stop ) then ifail = - 1 return end if if ( f001 == f00 . or . abs ( h1 ) < 4.0_wp * twoinf ) exit h1 = h1 / 2.0_wp end do h1 = 8.0_wp * h1 if ( 1 6.0_wp * abs ( h1 ) > abs ( h0 )) h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp else h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp end if end if else f00 = f0 end if do j = 1 , 5 f2 = me % f ( x0 + h0 - real ( 2 * j - 1 , wp ) * h1 ) if ( me % stop ) then ifail = - 1 return end if df ( j ) = f2 - f00 t0 = t0 + df ( j ) t1 = t1 + real ( 2 * j - 1 , wp ) * df ( j ) end do a0 = ( 3 3.0_wp * t0 - 5.0_wp * t1 ) / 7 3.0_wp a1 = ( - 5.0_wp * t0 + 1.2_wp * t1 ) / 7 3.0_wp facc = abs ( a0 ) do j = 1 , 5 deltaf = abs ( df ( j ) - ( a0 + real ( 2 * j - 1 , wp ) * a1 )) if ( facc < deltaf ) facc = deltaf end do facc = 2.0_wp * facc end subroutine faccur","tags":"","loc":"proc/faccur.html"},{"title":"vector_djb_hash – AoC-2023","text":"private pure function vector_djb_hash(r) result(hash) DJB hash algorithm for a integer(ip) vector. See also J. Shahbazian, Fortran hashing algorithm, July 6, 2013 Fortran Dev Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: r the vector Return Value integer(kind=ip) the hash value Called by proc~~vector_djb_hash~2~~CalledByGraph proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~get_from_cache~2->proc~vector_djb_hash~2 proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->proc~get_from_cache~2 proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->proc~get_from_cache~2 proc~get_all_pieces_below->proc~get_all_pieces_below proc~go~5 problem_12b::go proc~go~5->proc~get_from_cache~2 proc~ipoint problem_12b::ipoint proc~go~5->proc~ipoint proc~ipound problem_12b::ipound proc~go~5->proc~ipound proc~index_in_queue problem_17::index_in_queue proc~index_in_queue->proc~get_from_cache~2 proc~check problem_17::check proc~check->proc~index_in_queue proc~ipoint->proc~go~5 proc~ipound->proc~go~5 program~problem_12b problem_12b program~problem_12b->proc~go~5 program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_17 problem_17 program~problem_17->proc~check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function vector_djb_hash ( r ) result ( hash ) integer ( ip ), dimension (:), intent ( in ) :: r !! the vector integer ( ip ) :: hash !! the hash value integer :: i !! counter hash = 5381_ip do i = 1 , size ( r ) hash = ishft ( hash , 5_ip ) + hash + r ( i ) end do end function vector_djb_hash","tags":"","loc":"proc/vector_djb_hash~2.html"},{"title":"initialize_cache – AoC-2023","text":"private  subroutine initialize_cache(me, isize, chunk_size) Initialize the cache. Must be called first before use. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: isize the size of the hash table integer, intent(in), optional :: chunk_size chunk size to speed up reallocation\nof arrays. A good value is a guess for\nthe actual number of elements of f that\nwill be saved per value of x [default is 100] Calls proc~~initialize_cache~2~~CallsGraph proc~initialize_cache~2 aoc_cache_module::function_cache%initialize_cache proc~destroy_cache~2 aoc_cache_module::function_cache%destroy_cache proc~initialize_cache~2->proc~destroy_cache~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~initialize_cache~2~~CalledByGraph proc~initialize_cache~2 aoc_cache_module::function_cache%initialize_cache program~problem_12b problem_12b program~problem_12b->proc~initialize_cache~2 program~problem_17 problem_17 program~problem_17->proc~initialize_cache~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize_cache ( me , isize , chunk_size ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: isize !! the size of the hash table integer , intent ( in ), optional :: chunk_size !! chunk size to speed up reallocation !! of arrays. A good value is a guess for !! the actual number of elements of `f` that !! will be saved per value of `x` [default is 100] call me % destroy () allocate ( me % c ( 0 : isize - 1 )) if ( present ( chunk_size )) then me % chunk_size = chunk_size else me % chunk_size = 100 end if end subroutine initialize_cache","tags":"","loc":"proc/initialize_cache~2.html"},{"title":"get_from_cache – AoC-2023","text":"private  subroutine get_from_cache(me, x, i, f, found) Check if the x vector is in the cache, if so return f .\nNote that only some of the elements may be present, so it will return\nthe ones there are there, and indicate which ones were found. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer(kind=ip), intent(in), dimension(:) :: x independant variable vector integer(kind=ip), intent(out) :: i index in the hash table integer(kind=ip), intent(out), dimension(:), allocatable :: f f(x) from the cache (if it was found) logical, intent(out) :: found if x was found in the cache Calls proc~~get_from_cache~2~~CallsGraph proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_from_cache~2~~CalledByGraph proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->proc~get_from_cache~2 proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->proc~get_from_cache~2 proc~get_all_pieces_below->proc~get_all_pieces_below proc~go~5 problem_12b::go proc~go~5->proc~get_from_cache~2 proc~ipoint problem_12b::ipoint proc~go~5->proc~ipoint proc~ipound problem_12b::ipound proc~go~5->proc~ipound proc~index_in_queue problem_17::index_in_queue proc~index_in_queue->proc~get_from_cache~2 proc~check problem_17::check proc~check->proc~index_in_queue proc~ipoint->proc~go~5 proc~ipound->proc~go~5 program~problem_12b problem_12b program~problem_12b->proc~go~5 program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_17 problem_17 program~problem_17->proc~check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_from_cache ( me , x , i , f , found ) implicit none class ( function_cache ), intent ( inout ) :: me integer ( ip ), dimension (:), intent ( in ) :: x !! independant variable vector integer ( ip ), intent ( out ) :: i !! index in the hash table integer ( ip ), dimension (:), allocatable , intent ( out ) :: f !! `f(x)` from the cache (if it was found) logical , intent ( out ) :: found !! if `x` was found in the cache integer :: j !! counter ! initialize: found = . false . if ( allocated ( me % c )) then ! get index in the hash table: i = mod ( abs ( vector_djb_hash ( x )), int ( size ( me % c ), ip ) ) ! check the table: if ( allocated ( me % c ( i )% x )) then if ( size ( me % c ( i )% x ) == size ( x )) then if ( all ( me % c ( i )% x == x )) then found = . true . f = me % c ( i )% f end if end if end if else error stop 'Error: the cache has not been initialized.' end if end subroutine get_from_cache","tags":"","loc":"proc/get_from_cache~2.html"},{"title":"put_in_cache – AoC-2023","text":"private  subroutine put_in_cache(me, i, x, f) Put a value into the cache. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer(kind=ip), intent(in) :: i index in the hash table integer(kind=ip), intent(in), dimension(:) :: x independant variable vector integer(kind=ip), intent(in), dimension(:) :: f function Called by proc~~put_in_cache~2~~CalledByGraph proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->proc~put_in_cache~2 proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->proc~put_in_cache~2 proc~get_all_pieces_below->proc~get_all_pieces_below proc~go~5 problem_12b::go proc~go~5->proc~put_in_cache~2 proc~ipoint problem_12b::ipoint proc~go~5->proc~ipoint proc~ipound problem_12b::ipound proc~go~5->proc~ipound proc~index_in_queue problem_17::index_in_queue proc~index_in_queue->proc~put_in_cache~2 proc~check problem_17::check proc~check->proc~index_in_queue proc~ipoint->proc~go~5 proc~ipound->proc~go~5 program~problem_12b problem_12b program~problem_12b->proc~go~5 program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above program~problem_22->proc~get_all_pieces_below program~problem_17 problem_17 program~problem_17->proc~check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine put_in_cache ( me , i , x , f ) implicit none class ( function_cache ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: i !! index in the hash table integer ( ip ), dimension (:), intent ( in ) :: x !! independant variable vector integer ( ip ), dimension (:), intent ( in ) :: f !! function integer ( ip ), parameter :: null = huge ( 1 ) !! an unusual value to initialize arrays if ( allocated ( me % c )) then if ( i <= size ( me % c )) then ! add to the cache me % c ( i )% x = x me % c ( i )% f = f else error stop 'Error: invalid index in hash table.' end if else error stop 'Error: the cache has not been initialized.' end if end subroutine put_in_cache","tags":"","loc":"proc/put_in_cache~2.html"},{"title":"destroy_cache – AoC-2023","text":"private  subroutine destroy_cache(me) Destroy a cache. Type Bound function_cache Arguments Type Intent Optional Attributes Name class( function_cache ), intent(out) :: me Called by proc~~destroy_cache~2~~CalledByGraph proc~destroy_cache~2 aoc_cache_module::function_cache%destroy_cache proc~initialize_cache~2 aoc_cache_module::function_cache%initialize_cache proc~initialize_cache~2->proc~destroy_cache~2 program~problem_12b problem_12b program~problem_12b->proc~initialize_cache~2 program~problem_17 problem_17 program~problem_17->proc~initialize_cache~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy_cache ( me ) implicit none class ( function_cache ), intent ( out ) :: me end subroutine destroy_cache","tags":"","loc":"proc/destroy_cache~2.html"},{"title":"extrapolate – AoC-2023","text":"pure function extrapolate(ivals) result(iextrap) extrapolate the next value in the sequence using\na difference table. Straightfoward implemention:\ncreate the full table, and then evaluate it. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals Return Value integer(kind=ip) Calls proc~~extrapolate~~CallsGraph proc~extrapolate problem_9::extrapolate proc~diff aoc_utilities::diff proc~extrapolate->proc~diff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~extrapolate~~CalledByGraph proc~extrapolate problem_9::extrapolate program~problem_9 problem_9 program~problem_9->proc~extrapolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function extrapolate ( ivals ) result ( iextrap ) !! extrapolate the next value in the sequence using !! a difference table. Straightfoward implemention: !! create the full table, and then evaluate it. integer ( ip ), dimension (:), intent ( in ) :: ivals integer ( ip ) :: iextrap integer :: i , n type ( int64_vec ), dimension (:), allocatable :: diff_table !! difference table (vector of vectors) ! create the difference table: diff_table = [ int64_vec ( ivals )]; n = 1 do n = n + 1 diff_table = [ diff_table , int64_vec ( diff ( diff_table ( n - 1 )% vals ))] ! next line is diff of previous line if ( all ( diff_table ( n )% vals == 0 )) exit end do ! extrapolate iextrap = 0 do i = n - 1 , 1 , - 1 associate ( ilast => diff_table ( i )% vals ( size ( diff_table ( i )% vals )) ) iextrap = iextrap + ilast end associate end do end function extrapolate","tags":"","loc":"proc/extrapolate.html"},{"title":"fcn – AoC-2023","text":"subroutine fcn(n, x, Indcol, Ipntr, Fvec) Function subroutine for testing fdjs . Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: x (n) integer :: Indcol (*) integer :: Ipntr (n+1) real(kind=wp) :: Fvec (n) Called by proc~~fcn~~CalledByGraph proc~fcn dsm_test::fcn program~dsm_test dsm_test program~dsm_test->proc~fcn Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fcn ( n , x , Indcol , Ipntr , Fvec ) !! Function subroutine for testing [[fdjs]]. implicit none integer n integer Indcol ( * ) , Ipntr ( n + 1 ) real ( wp ) :: x ( n ) , Fvec ( n ) integer i , ip real ( wp ) :: sum do i = 1 , n sum = 0.0_wp do ip = Ipntr ( i ) , Ipntr ( i + 1 ) - 1 sum = sum + x ( Indcol ( ip )) enddo sum = sum + x ( i ) Fvec ( i ) = sum * ( 1.0_wp + sum ) + 1.0_wp enddo end subroutine fcn","tags":"","loc":"proc/fcn.html"},{"title":"add_lens – AoC-2023","text":"public  subroutine add_lens(me, l) Type Bound box Arguments Type Intent Optional Attributes Name class( box ), intent(inout) :: me type( lens ), intent(in) :: l lense to add Called by proc~~add_lens~~CalledByGraph proc~add_lens problem_15_module::box%add_lens program~problem_15 problem_15 program~problem_15->proc~add_lens Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine add_lens ( me , l ) ! = class ( box ), intent ( inout ) :: me type ( lens ), intent ( in ) :: l !! lense to add integer :: i !! counter if ( allocated ( me % lenses )) then do i = 1 , size ( me % lenses ) if ( me % lenses ( i )% label == l % label ) then me % lenses ( i ) = l ! replace with this one return end if end do me % lenses = [ me % lenses , l ] ! if not found, add to end else me % lenses = [ l ] ! first one in the box end if end subroutine add_lens","tags":"","loc":"proc/add_lens.html"},{"title":"remove_lens – AoC-2023","text":"public  subroutine remove_lens(me, label) remove the lens with the label (if present) Type Bound box Arguments Type Intent Optional Attributes Name class( box ), intent(inout) :: me character(len=*), intent(in) :: label Called by proc~~remove_lens~~CalledByGraph proc~remove_lens problem_15_module::box%remove_lens program~problem_15 problem_15 program~problem_15->proc~remove_lens Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine remove_lens ( me , label ) ! - !! remove the lens with the label (if present) class ( box ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: label integer :: i type ( lens ), dimension (:), allocatable :: tmp if ( allocated ( me % lenses )) then allocate ( tmp ( 0 )) do i = 1 , size ( me % lenses ) if ( me % lenses ( i )% label /= label ) tmp = [ tmp , me % lenses ( i )] end do call move_alloc ( tmp , me % lenses ) end if end subroutine remove_lens","tags":"","loc":"proc/remove_lens.html"},{"title":"hash – AoC-2023","text":"pure elemental function hash(s) Determine the ASCII code for the current character of the string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value integer(kind=ip) Called by proc~~hash~~CalledByGraph proc~hash problem_15::hash program~problem_15 problem_15 program~problem_15->proc~hash Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental integer ( ip ) function hash ( s ) !! Determine the ASCII code for the current character of the string. character ( len =* ), intent ( in ) :: s integer :: i hash = 0 do i = 1 , len ( s ) hash = modulo ( 17_ip * ( hash + iachar ( s ( i : i ))), 256_ip ) end do end function hash","tags":"","loc":"proc/hash.html"},{"title":"lsqr_test – AoC-2023","text":"public  subroutine lsqr_test() Unit test. Arguments None Calls proc~~lsqr_test~~CallsGraph proc~lsqr_test lsqrtest_module::lsqr_test proc~test~2 lsqrtest_module::test_solver%test proc~lsqr_test->proc~test~2 4 4 proc~test~2->4 proc~acheck lsqr_module::lsqr_solver%acheck proc~test~2->proc~acheck proc~dcopy lsqpblas_module::dcopy proc~test~2->proc~dcopy proc~dnrm2 lsqpblas_module::dnrm2 proc~test~2->proc~dnrm2 proc~lsqr lsqr_module::lsqr_solver%LSQR proc~test~2->proc~lsqr proc~lstp lsqrtest_module::test_solver%lstp proc~test~2->proc~lstp proc~xcheck lsqr_module::lsqr_solver%xcheck proc~test~2->proc~xcheck proc~acheck->proc~dcopy proc~acheck->proc~dnrm2 aprod aprod proc~acheck->aprod proc~ddot lsqpblas_module::ddot proc~acheck->proc~ddot proc~dscal lsqpblas_module::dscal proc~acheck->proc~dscal proc~lsqr->proc~dcopy proc~lsqr->proc~dnrm2 proc~lsqr->aprod proc~d2norm lsqr_module::d2norm proc~lsqr->proc~d2norm proc~lsqr->proc~dscal proc~lstp->proc~dcopy proc~lstp->proc~dnrm2 proc~aprod1 lsqrtest_module::test_solver%aprod1 proc~lstp->proc~aprod1 proc~lstp->proc~dscal proc~hprod lsqrtest_module::hprod proc~lstp->proc~hprod proc~xcheck->proc~dcopy proc~xcheck->proc~dnrm2 proc~xcheck->aprod proc~xcheck->proc~dscal proc~aprod1->proc~hprod Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~lsqr_test~~CalledByGraph proc~lsqr_test lsqrtest_module::lsqr_test program~main~2 main program~main~2->proc~lsqr_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lsqr_test () integer :: iunit , nbar , nduplc , n , m , ndamp , npower real ( wp ) :: damp type ( test_solver ) :: solver open ( newunit = iunit , file = 'LSQR.LIS' , status = 'REPLACE' ) solver % nout = iunit nbar = 1000 nduplc = 40 m = 2 * nbar n = nbar do ndamp = 2 , 7 npower = ndamp damp = 1 0.0_wp ** ( - ndamp - 6 ) call solver % test ( m , n , nduplc , npower , damp ) end do m = nbar n = nbar do ndamp = 2 , 7 npower = ndamp damp = 1 0.0_wp ** ( - ndamp - 6 ) call solver % test ( m , n , nduplc , npower , damp ) end do m = nbar n = 2 * nbar do ndamp = 2 , 7 npower = ndamp damp = 1 0.0_wp ** ( - ndamp - 6 ) call solver % test ( m , n , nduplc , npower , damp ) end do close ( iunit ) end subroutine lsqr_test","tags":"","loc":"proc/lsqr_test.html"},{"title":"test – AoC-2023","text":"private  subroutine test(me, m, n, nduplc, npower, damp) This is an example driver routine for running LSQR.\n  It generates a test problem, solves it, and examines the results.\n  Note that subroutine aprod must be declared external\n  if it is used only in the call to LSQR (and acheck). History 1982---1991:  Various versions implemented. 04 Sep 1991:  \"wantse\" added to argument list of LSQR,\n    making standard errors optional. 10 Feb 1992:  Revised for use with lsqrchk fortran. 31 Mar 2005: changed atol = eps* 0.666667 to eps 0.99\n    to increase accuracy of the solution.  LSQR appears to be\n    successful on all 18 test problems except 5 and 6\n    (which are over-determined and too ill-conditioned to\n    permit any correct digits).\n    The output from an Intel Xeon system with g77 is in LSQR.LIS.\n    The two \"appears to have failed\" messages are no cause for alarm.\n  Michael Saunders, Dept of Operations Research, Stanford University. Type Bound test_solver Arguments Type Intent Optional Attributes Name class( test_solver ), intent(inout) :: me integer :: m integer :: n integer :: nduplc integer :: npower real(kind=wp) :: damp Calls proc~~test~2~~CallsGraph proc~test~2 lsqrtest_module::test_solver%test 4 4 proc~test~2->4 proc~acheck lsqr_module::lsqr_solver%acheck proc~test~2->proc~acheck proc~dcopy lsqpblas_module::dcopy proc~test~2->proc~dcopy proc~dnrm2 lsqpblas_module::dnrm2 proc~test~2->proc~dnrm2 proc~lsqr lsqr_module::lsqr_solver%LSQR proc~test~2->proc~lsqr proc~lstp lsqrtest_module::test_solver%lstp proc~test~2->proc~lstp proc~xcheck lsqr_module::lsqr_solver%xcheck proc~test~2->proc~xcheck proc~acheck->proc~dcopy proc~acheck->proc~dnrm2 aprod aprod proc~acheck->aprod proc~ddot lsqpblas_module::ddot proc~acheck->proc~ddot proc~dscal lsqpblas_module::dscal proc~acheck->proc~dscal proc~lsqr->proc~dcopy proc~lsqr->proc~dnrm2 proc~lsqr->aprod proc~d2norm lsqr_module::d2norm proc~lsqr->proc~d2norm proc~lsqr->proc~dscal proc~lstp->proc~dcopy proc~lstp->proc~dnrm2 proc~aprod1 lsqrtest_module::test_solver%aprod1 proc~lstp->proc~aprod1 proc~lstp->proc~dscal proc~hprod lsqrtest_module::hprod proc~lstp->proc~hprod proc~xcheck->proc~dcopy proc~xcheck->proc~dnrm2 proc~xcheck->aprod proc~xcheck->proc~dscal proc~aprod1->proc~hprod Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~test~2~~CalledByGraph proc~test~2 lsqrtest_module::test_solver%test proc~lsqr_test lsqrtest_module::lsqr_test proc~lsqr_test->proc~test~2 program~main~2 main program~main~2->proc~lsqr_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine test ( me , m , n , nduplc , npower , damp ) class ( test_solver ), intent ( inout ) :: me integer :: m , n , nduplc , npower real ( wp ) :: damp integer , parameter :: maxm = 2000 integer , parameter :: maxn = 2000 integer , parameter :: mxmn = 2000 real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) !! machine precision character ( len = 34 ), parameter :: line = '----------------------------------' integer :: inform , istop , itnlim , j , itn , maxmn , minmn , nprint integer :: locd , lochy , lochz , locw , ltotal logical :: wantse real ( wp ) :: b ( maxm ), u ( maxm ), & v ( maxn ), w ( mxmn ), x ( maxn ), & se ( maxn ), xtrue ( maxn ), y ( mxmn ) real ( wp ) :: atol , btol , conlim , & anorm , acond , rnorm , arnorm , & enorm , etol , xnorm , test1 , test2 , test3 , wnorm if ( m > maxm . or . n > maxn ) then ! m or n too large. write ( me % nout , 8000 ) return end if ! Set the desired solution xtrue. ! For least-squares problems, this is it. ! For underdetermined systems, lstp may alter it. do j = 1 , n ! xtrue(j) = one xtrue ( j ) = j * 0.1_wp end do ! Generate the specified test problem. ! The workspace array  rw  is used for the following vectors: !    d(minmn), hy(m), hz(n), w(maxmn). ! The vectors  d, hy, hz  will define the test matrix A. ! w is needed for workspace in aprod1 and aprod2. maxmn = max ( m , n ) minmn = min ( m , n ) locd = 1 lochy = locd + minmn lochz = lochy + m locw = lochz + n ltotal = locw + maxmn - 1 if ( ltotal > lenrw ) then ! Not enough workspace. write ( me % nout , 9000 ) ltotal end if call me % lstp ( m , n , maxmn , minmn , nduplc , npower , damp , xtrue , & b , me % rw ( locd ), me % rw ( lochy ), me % rw ( lochz ), me % rw ( locw ), & acond , rnorm ) write ( me % nout , 1000 ) line , line , & m , n , nduplc , npower , damp , acond , rnorm , & line , line ! Check that aprod generates y + Ax and x + A'y consistently. call me % acheck ( m , n , me % nout , eps , v , w , x , y , inform ) if ( inform > 0 ) then write ( me % nout , '(a)' ) ' Check eps and power in subroutine acheck' stop end if ! Solve the problem defined by aprod, damp and b. ! Copy the rhs vector b into u  (LSQR will overwrite u) ! and set the other input parameters for LSQR. ! We ask for standard errors only if they are well-defined. call dcopy ( m , b , 1 , u , 1 ) !---  wantse = m > n  .or.  damp > zero wantse = . false . atol = eps ** 0.99_wp btol = atol conlim = 100 0.0_wp * acond itnlim = 4 * ( m + n + 50 ) call me % lsqr ( m , n , damp , wantse , & u , v , w , x , se , & atol , btol , conlim , itnlim , me % nout , & istop , itn , anorm , acond , rnorm , arnorm , xnorm ) ! Examine the results. !-  if (damp == zero) then !-     write(nout, 2000)       xnorm, rnorm, arnorm !-  else !-     write(nout, 2100) damp, xnorm, rnorm, arnorm !-  end if call me % xcheck ( m , n , me % nout , anorm , damp , eps , & b , u , v , w , x , & inform , test1 , test2 , test3 ) ! Print the solution and standard error estimates from  LSQR. nprint = min ( m , n , 8 ) write ( me % nout , 2500 ) ( j , x ( j ) , j = 1 , nprint ) if ( wantse ) then write ( me % nout , 2600 ) ( j , se ( j ), j = 1 , nprint ) end if ! Print a clue about whether the solution looks OK. do j = 1 , n w ( j ) = x ( j ) - xtrue ( j ) end do wnorm = dnrm2 ( n , w , 1 ) xnorm = dnrm2 ( n , xtrue , 1 ) enorm = wnorm / ( one + xnorm ) etol = 0.001_wp if ( enorm <= etol ) then write ( me % nout , 3000 ) enorm else write ( me % nout , 3100 ) enorm end if return 1000 format ( 1 p & // 1 x , 2 a & / ' Least-Squares Test Problem      P(' , 4 i5 , e12 . 2 , ' )' & // ' Condition no. =' , e12 . 4 , '     Residual function =' , e17 . 9 & / 1 x , 2 a ) 2000 format ( 1 p & // ' We are solving    min norm(Ax - b)    with no damping.' & // ' Estimates from LSQR:' & / '    norm(x)         =' , e10 . 3 , ' = xnorm' & / '    norm(r)         =' , e10 . 3 , ' = rnorm' & / '    norm(A''r)       =' , e10 . 3 , ' = arnorm' ) 2100 format ( 1 p & // ' We are solving    min norm(Ax - b)    with damp =' , e10 . 3 & / '                           (damp*x)' & // ' Estimates from LSQR:' & / '    norm(x)         =' , e10 . 3 , ' = xnorm' & / '    norm(rbar)      =' , e10 . 3 , ' = rnorm' & / '    norm(Abar''rbar) =' , e10 . 3 , ' = arnorm' ) 2500 format ( // ' Solution  x:' / 4 ( i6 , g14 . 6 )) 2600 format ( / ' Standard errors  se:' / 4 ( i6 , g14 . 6 )) 3000 format ( 1 p / ' LSQR  appears to be successful.' , & '     Relative error in  x  =' , e10 . 2 ) 3100 format ( 1 p / ' LSQR  appears to have failed.  ' , & '     Relative error in  x  =' , e10 . 2 ) 8000 format ( / ' XXX  m or n is too large.' ) 9000 format ( / ' XXX  Insufficient workspace.' , & '  The length of  rw  should be at least' , i6 ) end subroutine test","tags":"","loc":"proc/test~2.html"},{"title":"aprod_test_solver – AoC-2023","text":"private  subroutine aprod_test_solver(me, mode, m, n, x, y) This is the matrix-vector product routine required by subroutines\nLSQR and CRAIG for a test matrix of the form  A = HY D HZ.\nThe quantities defining D, HY, HZ are in the work array rw,\nfollowed by a work array w.  These are passed to aprod1 and aprod2\nin order to make the code readable. Type Bound test_solver Arguments Type Intent Optional Attributes Name class( test_solver ), intent(inout) :: me integer, intent(in) :: mode integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout), dimension(:) :: x dimension n real(kind=wp), intent(inout), dimension(:) :: y dimension m Calls proc~~aprod_test_solver~~CallsGraph proc~aprod_test_solver lsqrtest_module::test_solver%aprod_test_solver proc~aprod1 lsqrtest_module::test_solver%aprod1 proc~aprod_test_solver->proc~aprod1 proc~aprod2 lsqrtest_module::test_solver%aprod2 proc~aprod_test_solver->proc~aprod2 proc~hprod lsqrtest_module::hprod proc~aprod1->proc~hprod proc~aprod2->proc~hprod Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aprod_test_solver ( me , mode , m , n , x , y ) class ( test_solver ), intent ( inout ) :: me integer , intent ( in ) :: mode integer , intent ( in ) :: m integer , intent ( in ) :: n real ( wp ), dimension (:), intent ( inout ) :: x !! dimension n real ( wp ), dimension (:), intent ( inout ) :: y !! dimension m integer :: locd , lochy , lochz , locw , maxmn , minmn maxmn = max ( m , n ) minmn = min ( m , n ) locd = 1 lochy = locd + minmn lochz = lochy + m locw = lochz + n if ( mode == 1 ) then call me % aprod1 ( m , n , maxmn , minmn , x , y , & me % rw ( locd ), me % rw ( lochy ), me % rw ( lochz ), me % rw ( locw ) ) else call me % aprod2 ( m , n , maxmn , minmn , x , y , & me % rw ( locd ), me % rw ( lochy ), me % rw ( lochz ), me % rw ( locw ) ) end if end subroutine aprod_test_solver","tags":"","loc":"proc/aprod_test_solver.html"},{"title":"aprod1 – AoC-2023","text":"private  subroutine aprod1(me, m, n, maxmn, minmn, x, y, d, hy, hz, w) aprod1  computes  y = y + A x  for subroutine aprod,\nwhere A is a test matrix of the form  A = HY D*HZ,\nand the latter matrices HY, D, HZ are represented by\ninput vectors with the same name. Type Bound test_solver Arguments Type Intent Optional Attributes Name class( test_solver ), intent(inout) :: me integer :: m integer :: n integer :: maxmn integer :: minmn real(kind=wp) :: x (n) real(kind=wp) :: y (m) real(kind=wp) :: d (minmn) real(kind=wp) :: hy (m) real(kind=wp) :: hz (n) real(kind=wp) :: w (maxmn) Calls proc~~aprod1~~CallsGraph proc~aprod1 lsqrtest_module::test_solver%aprod1 proc~hprod lsqrtest_module::hprod proc~aprod1->proc~hprod Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aprod1~~CalledByGraph proc~aprod1 lsqrtest_module::test_solver%aprod1 proc~aprod_test_solver lsqrtest_module::test_solver%aprod_test_solver proc~aprod_test_solver->proc~aprod1 proc~lstp lsqrtest_module::test_solver%lstp proc~lstp->proc~aprod1 proc~test~2 lsqrtest_module::test_solver%test proc~test~2->proc~lstp proc~lsqr_test lsqrtest_module::lsqr_test proc~lsqr_test->proc~test~2 program~main~2 main program~main~2->proc~lsqr_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aprod1 ( me , m , n , maxmn , minmn , x , y , d , hy , hz , w ) class ( test_solver ), intent ( inout ) :: me integer :: m , n , maxmn , minmn real ( wp ) :: x ( n ), y ( m ), d ( minmn ), hy ( m ), hz ( n ), w ( maxmn ) integer :: i call hprod ( n , hz , x , w ) do i = 1 , minmn w ( i ) = d ( i ) * w ( i ) end do do i = n + 1 , m w ( i ) = zero end do call hprod ( m , hy , w , w ) do i = 1 , m y ( i ) = y ( i ) + w ( i ) end do end subroutine aprod1","tags":"","loc":"proc/aprod1.html"},{"title":"aprod2 – AoC-2023","text":"private  subroutine aprod2(me, m, n, maxmn, minmn, x, y, d, hy, hz, w) aprod2  computes  x = x + A(t) y  for subroutine aprod,\nwhere  A  is a test matrix of the form  A = HY D*HZ,\nand the latter matrices  HY, D, HZ  are represented by\ninput vectors with the same name. Type Bound test_solver Arguments Type Intent Optional Attributes Name class( test_solver ), intent(inout) :: me integer :: m integer :: n integer :: maxmn integer :: minmn real(kind=wp) :: x (n) real(kind=wp) :: y (m) real(kind=wp) :: d (minmn) real(kind=wp) :: hy (m) real(kind=wp) :: hz (n) real(kind=wp) :: w (maxmn) Calls proc~~aprod2~~CallsGraph proc~aprod2 lsqrtest_module::test_solver%aprod2 proc~hprod lsqrtest_module::hprod proc~aprod2->proc~hprod Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aprod2~~CalledByGraph proc~aprod2 lsqrtest_module::test_solver%aprod2 proc~aprod_test_solver lsqrtest_module::test_solver%aprod_test_solver proc~aprod_test_solver->proc~aprod2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aprod2 ( me , m , n , maxmn , minmn , x , y , d , hy , hz , w ) class ( test_solver ), intent ( inout ) :: me integer :: m , n , maxmn , minmn real ( wp ) :: x ( n ), y ( m ), d ( minmn ), hy ( m ), hz ( n ), w ( maxmn ) integer :: i call hprod ( m , hy , y , w ) do i = 1 , minmn w ( i ) = d ( i ) * w ( i ) end do do i = m + 1 , n w ( i ) = zero end do call hprod ( n , hz , w , w ) do i = 1 , n x ( i ) = x ( i ) + w ( i ) end do end subroutine aprod2","tags":"","loc":"proc/aprod2.html"},{"title":"hprod – AoC-2023","text":"private  subroutine hprod(n, hz, x, y) hprod  applies a Householder transformation stored in  hz\nto get  y = ( I - 2 hz hz(transpose) ) * x. Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: hz (n) real(kind=wp) :: x (n) real(kind=wp) :: y (n) Called by proc~~hprod~~CalledByGraph proc~hprod lsqrtest_module::hprod proc~aprod1 lsqrtest_module::test_solver%aprod1 proc~aprod1->proc~hprod proc~aprod2 lsqrtest_module::test_solver%aprod2 proc~aprod2->proc~hprod proc~lstp lsqrtest_module::test_solver%lstp proc~lstp->proc~hprod proc~lstp->proc~aprod1 proc~aprod_test_solver lsqrtest_module::test_solver%aprod_test_solver proc~aprod_test_solver->proc~aprod1 proc~aprod_test_solver->proc~aprod2 proc~test~2 lsqrtest_module::test_solver%test proc~test~2->proc~lstp proc~lsqr_test lsqrtest_module::lsqr_test proc~lsqr_test->proc~test~2 program~main~2 main program~main~2->proc~lsqr_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine hprod ( n , hz , x , y ) integer :: n real ( wp ) :: hz ( n ), x ( n ), y ( n ) integer :: i real ( wp ) :: s s = zero do i = 1 , n s = hz ( i ) * x ( i ) + s end do s = s + s do i = 1 , n y ( i ) = x ( i ) - s * hz ( i ) end do end subroutine hprod","tags":"","loc":"proc/hprod.html"},{"title":"lstp – AoC-2023","text":"private  subroutine lstp(me, m, n, maxmn, minmn, nduplc, npower, damp, x, b, d, hy, hz, w, acond, rnorm) lstp  generate a sparse least-squares test problem of the form\n           (   A    ) x = ( b )\n           ( damp I )     ( 0 )\nfor solution by LSQR, or a sparse underdetermined system\n              Ax + damp s = b\nfor solution by CRAIG.  The matrix A is m by n and is\nconstructed in the form  A = HY D*HZ,  where D is an m by n\ndiagonal matrix, and HY and HZ are Householder transformations. m and n may contain any positive values.\nThe first 8 parameters are input to lstp.  The last 8 are output.\nIf m >= n  or  damp = 0, the true solution is x as given.\nOtherwise, x is modified to contain the true solution. Type Bound test_solver Arguments Type Intent Optional Attributes Name class( test_solver ), intent(inout) :: me integer :: m integer :: n integer :: maxmn integer :: minmn integer :: nduplc integer :: npower real(kind=wp) :: damp real(kind=wp) :: x (n) real(kind=wp) :: b (m) real(kind=wp) :: d (minmn) real(kind=wp) :: hy (m) real(kind=wp) :: hz (n) real(kind=wp) :: w (maxmn) real(kind=wp) :: acond real(kind=wp) :: rnorm Calls proc~~lstp~~CallsGraph proc~lstp lsqrtest_module::test_solver%lstp proc~aprod1 lsqrtest_module::test_solver%aprod1 proc~lstp->proc~aprod1 proc~dcopy lsqpblas_module::dcopy proc~lstp->proc~dcopy proc~dnrm2 lsqpblas_module::dnrm2 proc~lstp->proc~dnrm2 proc~dscal lsqpblas_module::dscal proc~lstp->proc~dscal proc~hprod lsqrtest_module::hprod proc~lstp->proc~hprod proc~aprod1->proc~hprod Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~lstp~~CalledByGraph proc~lstp lsqrtest_module::test_solver%lstp proc~test~2 lsqrtest_module::test_solver%test proc~test~2->proc~lstp proc~lsqr_test lsqrtest_module::lsqr_test proc~lsqr_test->proc~test~2 program~main~2 main program~main~2->proc~lsqr_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lstp ( me , m , n , maxmn , minmn , nduplc , npower , damp , x , & b , d , hy , hz , w , acond , rnorm ) class ( test_solver ), intent ( inout ) :: me integer :: m , n , maxmn , minmn , nduplc , npower real ( wp ) :: damp , acond , rnorm real ( wp ) :: b ( m ), x ( n ), d ( minmn ), hy ( m ), hz ( n ), w ( maxmn ) integer :: i , j real ( wp ) alfa , beta , dampsq , t real ( wp ), parameter :: fourpi = 4.0_wp * acos ( - 1.0_wp ) !4.0*3.141592 ! ------------------------------------------------------------------ ! Make two vectors of norm 1.0 for the Householder transformations. ! fourpi  need not be exact. ! ------------------------------------------------------------------ minmn = min ( m , n ) dampsq = damp ** 2 alfa = fourpi / m beta = fourpi / n do i = 1 , m hy ( i ) = sin ( i * alfa ) end do do i = 1 , n hz ( i ) = cos ( i * beta ) end do alfa = dnrm2 ( m , hy , 1 ) beta = dnrm2 ( n , hz , 1 ) call dscal ( m , ( - one / alfa ), hy , 1 ) call dscal ( n , ( - one / beta ), hz , 1 ) ! ------------------------------------------------------------------ ! Set the diagonal matrix  D.  These are the singular values of  A. ! ------------------------------------------------------------------ do i = 1 , minmn j = ( i - 1 + nduplc ) / nduplc t = j * nduplc t = t / minmn d ( i ) = t ** npower end do acond = ( d ( minmn ) ** 2 + dampsq ) / ( d ( 1 ) ** 2 + dampsq ) acond = sqrt ( acond ) ! ------------------------------------------------------------------ ! Set the true solution   x. ! It must be of the form  x = Z ( w )  for some  w. !                               ( 0 ) ! ------------------------------------------------------------------ call hprod ( n , hz , x , w ) do i = m + 1 , n w ( i ) = zero end do call hprod ( n , hz , w , x ) ! Solve D r1bar = dampsq x1bar ! where r1bar and x1bar are both in w. do i = 1 , minmn w ( i ) = dampsq * w ( i ) / d ( i ) end do ! Set r2bar to be anything.  (It is empty if m <= n) ! Then form r = Y rbar (again in w). do i = minmn + 1 , m w ( i ) = one end do call Hprod ( m , hy , w , w ) ! Compute the rhs    b = r  +  Ax. rnorm = dnrm2 ( m , w , 1 ) call dcopy ( m , w , 1 , b , 1 ) call me % aprod1 ( m , n , maxmn , minmn , x , b , d , hy , hz , w ) end subroutine lstp","tags":"","loc":"proc/lstp.html"},{"title":"moves – AoC-2023","text":"pure function moves(istart, iend) result(imoves) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: istart indices for start and end nodes integer(kind=ip), intent(in) :: iend indices for start and end nodes Return Value integer(kind=ip) Called by proc~~moves~~CalledByGraph proc~moves problem_8::moves program~problem_8 problem_8 program~problem_8->proc~moves Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function moves ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart , iend !! indices for start and end nodes integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( idx == iend ) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves","tags":"","loc":"proc/moves.html"},{"title":"moves_any_z – AoC-2023","text":"pure function moves_any_z(istart, iend) result(imoves) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: istart indices for start and end nodes integer(kind=ip), intent(in), dimension(:) :: iend Return Value integer(kind=ip) Called by proc~~moves_any_z~~CalledByGraph proc~moves_any_z problem_8::moves_any_z program~problem_8 problem_8 program~problem_8->proc~moves_any_z Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function moves_any_z ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart !! indices for start and end nodes integer ( ip ), dimension (:), intent ( in ) :: iend integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( any ( idx == iend )) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves_any_z","tags":"","loc":"proc/moves_any_z.html"},{"title":"all_in_set – AoC-2023","text":"pure function all_in_set(ivals, iset) returns true if all the elements of ivals are in the set iset Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals integer(kind=ip), intent(in), dimension(:) :: iset Return Value logical Source Code pure logical function all_in_set ( ivals , iset ) !! returns true if all the elements of ivals are in the set iset integer ( ip ), dimension (:), intent ( in ) :: ivals , iset integer :: i all_in_set = . true . do i = 1 , size ( ivals ) if (. not . any ( ivals ( i ) == iset )) then all_in_set = . false . exit end if end do end function all_in_set","tags":"","loc":"proc/all_in_set.html"},{"title":"find_node – AoC-2023","text":"pure function find_node(name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value integer(kind=ip) Called by proc~~find_node~~CalledByGraph proc~find_node problem_8::find_node program~problem_8 problem_8 program~problem_8->proc~find_node Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer ( ip ) function find_node ( name ) character ( len =* ), intent ( in ) :: name integer ( ip ) :: i do i = 1 , size ( nodes ) if ( name == nodes ( i )% name ) then find_node = i return end if end do error stop 'could not find node' end function find_node","tags":"","loc":"proc/find_node.html"},{"title":"initialize_finite_difference_method – AoC-2023","text":"private  function initialize_finite_difference_method(id, name, class, dx_factors, df_factors, df_den_factor) result(me) Constructor for a finite_diff_method . Note factors are input as integers for convenience, but are converted\n      to reals for the actual computations. (note: this means we can't\n      currently define methods that have non-integer factors). Arguments Type Intent Optional Attributes Name integer, intent(in) :: id unique ID for the method character(len=*), intent(in) :: name the name of the method integer, intent(in) :: class 2=backward diffs, 3=central diffs, etc... integer, intent(in), dimension(:) :: dx_factors multiplicative factors for dx perturbation integer, intent(in), dimension(:) :: df_factors multiplicative factors for accumulating function evaluations integer, intent(in) :: df_den_factor denominator factor for finite difference equation (times dx) Return Value type( finite_diff_method ) Called by proc~~initialize_finite_difference_method~~CalledByGraph proc~initialize_finite_difference_method numerical_differentiation_module::initialize_finite_difference_method interface~finite_diff_method numerical_differentiation_module::finite_diff_method interface~finite_diff_method->proc~initialize_finite_difference_method Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function initialize_finite_difference_method ( id , name , class , dx_factors ,& df_factors , df_den_factor ) result ( me ) implicit none type ( finite_diff_method ) :: me integer , intent ( in ) :: id !! unique ID for the method character ( len =* ), intent ( in ) :: name !! the name of the method integer , intent ( in ) :: class !! 2=backward diffs, 3=central diffs, etc... integer , dimension (:), intent ( in ) :: dx_factors !! multiplicative factors for dx perturbation integer , dimension (:), intent ( in ) :: df_factors !! multiplicative factors for accumulating function evaluations integer , intent ( in ) :: df_den_factor !! denominator factor for finite difference equation (times dx) if ( size ( dx_factors ) /= size ( df_factors )) then error stop 'Error in initialize_finite_difference_method: ' // & 'dx_factors and df_factors arrays must be the same size.' else me % id = id me % name = trim ( name ) me % class = class ! the following is not strictly necessary if the ! compiler fully supports auto-LHS allocation: allocate ( me % dx_factors ( size ( dx_factors ))) allocate ( me % df_factors ( size ( df_factors ))) me % dx_factors = real ( dx_factors , wp ) me % df_factors = real ( df_factors , wp ) me % df_den_factor = real ( df_den_factor , wp ) end if end function initialize_finite_difference_method","tags":"","loc":"proc/initialize_finite_difference_method.html"},{"title":"get_all_methods_in_class – AoC-2023","text":"public  function get_all_methods_in_class(class) result(list_of_methods) Returns all the methods with the given class (i.e., number of points in the formula). Arguments Type Intent Optional Attributes Name integer, intent(in) :: class the class is the number of points in the\nfinite different computation Return Value type( meth_array ) all the methods with the specified class Calls proc~~get_all_methods_in_class~~CallsGraph proc~get_all_methods_in_class numerical_differentiation_module::get_all_methods_in_class proc~get_finite_difference_method numerical_differentiation_module::get_finite_difference_method proc~get_all_methods_in_class->proc~get_finite_difference_method Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_all_methods_in_class~~CalledByGraph proc~get_all_methods_in_class numerical_differentiation_module::get_all_methods_in_class proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~get_all_methods_in_class proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~get_all_methods_in_class program~test1 test1 program~test1->proc~get_all_methods_in_class program~test1->proc~initialize_numdiff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function get_all_methods_in_class ( class ) result ( list_of_methods ) implicit none integer , intent ( in ) :: class !! the `class` is the number of points in the !! finite different computation type ( meth_array ) :: list_of_methods !! all the methods with the specified `class` type ( finite_diff_method ) :: fd !! temp variable for getting a !! method from [[get_finite_difference_method]] integer :: id !! method id counter logical :: found !! status flag integer :: n !! temp size variable type ( finite_diff_method ), dimension (:), allocatable :: tmp !! for resizing `meth` array ! currently, the only way to do this is to call the ! get_finite_difference_method routine and see if there ! is one available. id = 0 do id = id + 1 call get_finite_difference_method ( id , fd , found ) if ( found ) then if ( fd % class == class ) then if ( allocated ( list_of_methods % meth )) then ! add to the list n = size ( list_of_methods % meth ) allocate ( tmp ( n + 1 )) tmp ( 1 : n ) = list_of_methods % meth tmp ( n + 1 ) = fd call move_alloc ( tmp , list_of_methods % meth ) ! ... this doesn't appear to work on Intel compiler ... !list_of_methods%meth = [list_of_methods%meth,fd]  ! add to the list else ! first element: allocate ( list_of_methods % meth ( 1 )) list_of_methods % meth = fd end if elseif ( fd % class > class ) then ! we assume they are in increasing order exit end if else exit ! done end if end do end function get_all_methods_in_class","tags":"","loc":"proc/get_all_methods_in_class.html"},{"title":"failed – AoC-2023","text":"private pure function failed(me) Returns True if an exception has been raised. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(in) :: me Return Value logical Called by proc~~failed~~CalledByGraph proc~failed numerical_differentiation_module::numdiff_type%failed program~test1 test1 program~test1->proc~failed program~test2 test2 program~test2->proc~failed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function failed ( me ) implicit none class ( numdiff_type ), intent ( in ) :: me failed = me % exception_raised end function failed","tags":"","loc":"proc/failed.html"},{"title":"integer_to_string – AoC-2023","text":"private  function integer_to_string(i, with_sign) result(str) Convert an integer to a string. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i the integer logical, intent(in), optional :: with_sign also include the sign (default is False) Return Value character(len=:), allocatable integer converted to a string Called by proc~~integer_to_string~2~~CalledByGraph proc~integer_to_string~2 numerical_differentiation_module::integer_to_string proc~get_formula numerical_differentiation_module::finite_diff_method%get_formula proc~get_formula->proc~integer_to_string~2 proc~set_numdiff_bounds numerical_differentiation_module::numdiff_type%set_numdiff_bounds proc~set_numdiff_bounds->proc~integer_to_string~2 proc~get_finite_diff_formula numerical_differentiation_module::get_finite_diff_formula proc~get_finite_diff_formula->proc~get_formula proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~set_numdiff_bounds proc~initialize_numdiff_for_diff numerical_differentiation_module::numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~set_numdiff_bounds program~test1 test1 program~test1->proc~get_formula program~test1->proc~get_finite_diff_formula program~test1->proc~initialize_numdiff program~test1->proc~initialize_numdiff_for_diff program~test2 test2 program~test2->proc~get_finite_diff_formula Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function integer_to_string ( i , with_sign ) result ( str ) implicit none integer , intent ( in ) :: i !! the integer logical , intent ( in ), optional :: with_sign !! also include the sign (default is False) character ( len = :), allocatable :: str !! integer converted to a string integer :: istat !! `iostat` code for write statement character ( len = 100 ) :: tmp !! logical :: sgn !! local copy of `with_sign` if ( present ( with_sign )) then sgn = with_sign else sgn = . false . end if if ( sgn ) then write ( tmp , '(SP,I100)' , iostat = istat ) i else write ( tmp , '(I100)' , iostat = istat ) i end if if ( istat == 0 ) then str = trim ( adjustl ( tmp )) else str = '****' end if end function integer_to_string","tags":"","loc":"proc/integer_to_string~2.html"},{"title":"print_finite_difference_method – AoC-2023","text":"private  subroutine print_finite_difference_method(me, iunit) Print the contents of a finite_diff_method . Used for debugging. Type Bound finite_diff_method Arguments Type Intent Optional Attributes Name class( finite_diff_method ), intent(in) :: me integer, intent(in) :: iunit file unit for printing\n(assumed to be opened) Source Code subroutine print_finite_difference_method ( me , iunit ) implicit none class ( finite_diff_method ), intent ( in ) :: me integer , intent ( in ) :: iunit !! file unit for printing !! (assumed to be opened) write ( iunit , '(A,1X,I5)' ) 'id            :' , me % id write ( iunit , '(A,1X,A)' ) 'name          :' , me % name write ( iunit , '(A,1X,I5)' ) 'class         :' , me % class write ( iunit , '(A,1X,*(I5,\",\"))' ) 'dx_factors    :' , int ( me % dx_factors ) write ( iunit , '(A,1X,*(I5,\",\"))' ) 'df_factors    :' , int ( me % df_factors ) write ( iunit , '(A,1X,I5)' ) 'df_den_factor :' , int ( me % df_den_factor ) end subroutine print_finite_difference_method","tags":"","loc":"proc/print_finite_difference_method.html"},{"title":"compute_function_with_cache – AoC-2023","text":"private  subroutine compute_function_with_cache(me, x, f, funcs_to_compute) Wrapper for computing the function, using the cache. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x array of variables (size n ) real(kind=wp), intent(out), dimension(:) :: f array of functions (size m ) integer, intent(in), dimension(:) :: funcs_to_compute the elements of the\nfunction vector that need\nto be computed (the other\nare ignored) Calls proc~~compute_function_with_cache~~CallsGraph proc~compute_function_with_cache numerical_differentiation_module::compute_function_with_cache proc~get_from_cache numdiff_cache_module::function_cache%get_from_cache proc~compute_function_with_cache->proc~get_from_cache proc~put_in_cache numdiff_cache_module::function_cache%put_in_cache proc~compute_function_with_cache->proc~put_in_cache proc~vector_djb_hash numdiff_cache_module::vector_djb_hash proc~get_from_cache->proc~vector_djb_hash interface~unique~2 numdiff_utilities_module::unique proc~put_in_cache->interface~unique~2 proc~unique_int numdiff_utilities_module::unique_int interface~unique~2->proc~unique_int proc~unique_real numdiff_utilities_module::unique_real interface~unique~2->proc~unique_real interface~expand_vector numdiff_utilities_module::expand_vector proc~unique_int->interface~expand_vector interface~sort_ascending numdiff_utilities_module::sort_ascending proc~unique_int->interface~sort_ascending proc~unique_real->interface~expand_vector proc~unique_real->interface~sort_ascending proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector->proc~expand_vector_real proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap~2 numdiff_utilities_module::swap proc~sort_ascending_int->interface~swap~2 proc~sort_ascending_real->interface~swap~2 proc~swap_int numdiff_utilities_module::swap_int interface~swap~2->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap~2->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_function_with_cache ( me , x , f , funcs_to_compute ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! array of variables (size `n`) real ( wp ), dimension (:), intent ( out ) :: f !! array of functions (size `m`) integer , dimension (:), intent ( in ) :: funcs_to_compute !! the elements of the !! function vector that need !! to be computed (the other !! are ignored) integer :: i !! index in the cache logical , dimension ( size ( funcs_to_compute )) :: ffound !! functions found in the cache logical :: xfound !! if `x` was found in the cache if ( me % exception_raised ) return ! check for exceptions call me % cache % get ( x , funcs_to_compute , i , f , xfound , ffound ) if ( xfound . and . any ( ffound )) then ! at least one of the functions was found if ( all ( ffound )) return ! all were found ! compute the ones that weren't found, ! and add them to the cache: call me % problem_func ( x , f , pack ( funcs_to_compute , mask = (. not . ffound ))) call me % cache % put ( i , x , f , pack ( funcs_to_compute , mask = (. not . ffound ))) else ! compute the function and add it to the cache: call me % problem_func ( x , f , funcs_to_compute ) call me % cache % put ( i , x , f , funcs_to_compute ) end if end subroutine compute_function_with_cache","tags":"","loc":"proc/compute_function_with_cache.html"},{"title":"get_formula – AoC-2023","text":"private  subroutine get_formula(me, formula) Return a string with the finite difference formula. Example For 3-point backward: dfdx = (f(x-2h)-4f(x-h)+3f(x)) / (2h) Type Bound finite_diff_method Arguments Type Intent Optional Attributes Name class( finite_diff_method ), intent(in) :: me character(len=:), intent(out), allocatable :: formula Calls proc~~get_formula~~CallsGraph proc~get_formula numerical_differentiation_module::finite_diff_method%get_formula proc~integer_to_string~2 numerical_differentiation_module::integer_to_string proc~get_formula->proc~integer_to_string~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_formula~~CalledByGraph proc~get_formula numerical_differentiation_module::finite_diff_method%get_formula proc~get_finite_diff_formula numerical_differentiation_module::get_finite_diff_formula proc~get_finite_diff_formula->proc~get_formula program~test1 test1 program~test1->proc~get_formula program~test1->proc~get_finite_diff_formula program~test2 test2 program~test2->proc~get_finite_diff_formula Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_formula ( me , formula ) class ( finite_diff_method ), intent ( in ) :: me character ( len = :), allocatable , intent ( out ) :: formula integer :: i !! counter character ( len = :), allocatable :: x !! temp variable for integer to string conversion character ( len = :), allocatable :: f !! temp variable for integer to string conversion if ( allocated ( me % dx_factors ) . and . allocated ( me % df_factors )) then formula = 'dfdx = (' do i = 1 , size ( me % dx_factors ) if ( int ( me % df_factors ( i )) == 1 ) then if ( i == 1 ) then formula = formula // 'f(' else formula = formula // '+f(' end if elseif ( int ( me % df_factors ( i )) ==- 1 ) then formula = formula // '-f(' else if ( i == 1 ) then f = integer_to_string ( int ( me % df_factors ( i ))) else f = integer_to_string ( int ( me % df_factors ( i )), with_sign = . true .) end if formula = formula // trim ( adjustl ( f )) // 'f(' end if if ( int ( me % dx_factors ( i )) == 0 ) then formula = formula // 'x' elseif ( int ( me % dx_factors ( i )) == 1 ) then formula = formula // 'x+h' elseif ( int ( me % dx_factors ( i )) ==- 1 ) then formula = formula // 'x-h' else x = integer_to_string ( int ( me % dx_factors ( i )), with_sign = . true .) formula = formula // 'x' // trim ( adjustl ( x )) // 'h' end if formula = formula // ')' end do f = integer_to_string ( int ( me % df_den_factor )) if ( int ( me % df_den_factor ) == 1 ) then formula = formula // ') / h' else formula = formula // ') / (' // trim ( adjustl ( f )) // 'h)' end if else formula = '' end if end subroutine get_formula","tags":"","loc":"proc/get_formula.html"},{"title":"get_finite_diff_formula – AoC-2023","text":"public  subroutine get_finite_diff_formula(id, formula, name) Return a string with the finite difference formula.\n  Input is the method id code. See also: get_formula Arguments Type Intent Optional Attributes Name integer, intent(in) :: id the id code for the method character(len=:), intent(out), allocatable :: formula the formula string character(len=:), intent(out), optional, allocatable :: name Calls proc~~get_finite_diff_formula~~CallsGraph proc~get_finite_diff_formula numerical_differentiation_module::get_finite_diff_formula proc~get_finite_difference_method numerical_differentiation_module::get_finite_difference_method proc~get_finite_diff_formula->proc~get_finite_difference_method proc~get_formula numerical_differentiation_module::finite_diff_method%get_formula proc~get_finite_diff_formula->proc~get_formula proc~integer_to_string~2 numerical_differentiation_module::integer_to_string proc~get_formula->proc~integer_to_string~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_finite_diff_formula~~CalledByGraph proc~get_finite_diff_formula numerical_differentiation_module::get_finite_diff_formula program~test1 test1 program~test1->proc~get_finite_diff_formula program~test2 test2 program~test2->proc~get_finite_diff_formula Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_finite_diff_formula ( id , formula , name ) implicit none integer , intent ( in ) :: id !! the id code for the method character ( len = :), allocatable , intent ( out ) :: formula !! the formula string character ( len = :), allocatable , intent ( out ), optional :: name type ( finite_diff_method ) :: fd logical :: found call get_finite_difference_method ( id , fd , found ) if ( found . and . fd % id /= 0 ) then call get_formula ( fd , formula ) if ( present ( name )) name = fd % name else formula = '' if ( present ( name )) name = '' end if end subroutine get_finite_diff_formula","tags":"","loc":"proc/get_finite_diff_formula.html"},{"title":"get_finite_difference_method – AoC-2023","text":"private  subroutine get_finite_difference_method(id, fd, found) Return a finite_diff_method given the id code.\n  (the id codes begin at 1, are sequential, and uniquely define the method). Available methods Where is the user-defined function of and is a \"small\" perturbation. References G. E. Mullges, F. Uhlig, \"Numerical Algorithms with Fortran\", Springer, 1996. G. W. Griffiths, \"Numerical Analysis Using R\", Cambridge University Press, 2016. Note This is the only routine that has to be changed if a new\n      finite difference method is added. Note The order within a class is assumed to be the order that we would prefer\n      to use them (e.g., central diffs are first, etc.) This is used in\n      the select_finite_diff_method routine. Arguments Type Intent Optional Attributes Name integer, intent(in) :: id the id code for the method type( finite_diff_method ), intent(out) :: fd this method (can be used\nin compute_jacobian ) logical, intent(out) :: found true if it was found Called by proc~~get_finite_difference_method~~CalledByGraph proc~get_finite_difference_method numerical_differentiation_module::get_finite_difference_method proc~get_all_methods_in_class numerical_differentiation_module::get_all_methods_in_class proc~get_all_methods_in_class->proc~get_finite_difference_method proc~get_finite_diff_formula numerical_differentiation_module::get_finite_diff_formula proc~get_finite_diff_formula->proc~get_finite_difference_method proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~get_finite_difference_method proc~initialize_numdiff->proc~get_all_methods_in_class proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~get_all_methods_in_class program~test1 test1 program~test1->proc~get_all_methods_in_class program~test1->proc~get_finite_diff_formula program~test1->proc~initialize_numdiff program~test2 test2 program~test2->proc~get_finite_diff_formula Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_finite_difference_method ( id , fd , found ) implicit none integer , intent ( in ) :: id !! the id code for the method type ( finite_diff_method ), intent ( out ) :: fd !! this method (can be used !! in [[compute_jacobian]]) logical , intent ( out ) :: found !! true if it was found found = . true . select case ( id ) ! 2 point methods case ( 1 ) ! (f(x+h)-f(x)) / h fd = finite_diff_method ( id , '2-point forward 1' , 2 ,[ 1 , 0 ],[ 1 , - 1 ], 1 ) case ( 2 ) ! (f(x)-f(x-h)) / h fd = finite_diff_method ( id , '2-point backward 1' , 2 ,[ 0 , - 1 ],[ 1 , - 1 ], 1 ) ! 3 point methods case ( 3 ) ! (f(x+h)-f(x-h)) / (2h) fd = finite_diff_method ( id , '3-point central' , 3 ,[ 1 , - 1 ],[ 1 , - 1 ], 2 ) case ( 4 ) ! (-3f(x)+4f(x+h)-f(x+2h)) / (2h) fd = finite_diff_method ( id , '3-point forward 2' , 3 ,[ 0 , 1 , 2 ],[ - 3 , 4 , - 1 ], 2 ) case ( 5 ) ! (f(x-2h)-4f(x-h)+3f(x)) / (2h) fd = finite_diff_method ( id , '3-point backward 2' , 3 ,[ - 2 , - 1 , 0 ],[ 1 , - 4 , 3 ], 2 ) ! 4 point methods case ( 6 ) ! (-2f(x-h)-3f(x)+6f(x+h)-f(x+2h)) / (6h) fd = finite_diff_method ( id , '4-point forward 2' , 4 ,[ - 1 , 0 , 1 , 2 ],[ - 2 , - 3 , 6 , - 1 ], 6 ) case ( 7 ) ! (f(x-2h)-6f(x-h)+3f(x)+2f(x+h)) / (6h) fd = finite_diff_method ( id , '4-point backward 2' , 4 ,[ - 2 , - 1 , 0 , 1 ],[ 1 , - 6 , 3 , 2 ], 6 ) case ( 8 ) ! (-11f(x)+18f(x+h)-9f(x+2h)+2f(x+3h)) / (6h) fd = finite_diff_method ( id , '4-point forward 3' , 4 ,[ 0 , 1 , 2 , 3 ],[ - 11 , 18 , - 9 , 2 ], 6 ) case ( 9 ) ! (-2f(x-3h)+9f(x-2h)-18f(x-h)+11f(x)) / (6h) fd = finite_diff_method ( id , '4-point backward 3' , 4 ,[ - 3 , - 2 , - 1 , 0 ],[ - 2 , 9 , - 18 , 11 ], 6 ) ! 5 point methods case ( 10 ) ! (f(x-2h)-8f(x-h)+8f(x+h)-f(x+2h)) / (12h) fd = finite_diff_method ( id , '5-point central' , 5 ,[ - 2 , - 1 , 1 , 2 ],[ 1 , - 8 , 8 , - 1 ], 12 ) case ( 11 ) ! (-3f(x-h)-10f(x)+18f(x+h)-6f(x+2h)+f(x+3h)) / (12h) fd = finite_diff_method ( id , '5-point forward 3' , 5 ,[ - 1 , 0 , 1 , 2 , 3 ],[ - 3 , - 10 , 18 , - 6 , 1 ], 12 ) case ( 12 ) ! (-f(x-3h)+6f(x-2h)-18f(x-h)+10f(x)+3f(x+h)) / (12h) fd = finite_diff_method ( id , '5-point backward 3' , 5 ,[ - 3 , - 2 , - 1 , 0 , 1 ],[ - 1 , 6 , - 18 , 10 , 3 ], 12 ) case ( 13 ) ! (-25f(x)+48f(x+h)-36f(x+2h)+16f(x+3h)-3f(x+4h)) / (12h) fd = finite_diff_method ( id , '5-point forward 4' , 5 ,[ 0 , 1 , 2 , 3 , 4 ],[ - 25 , 48 , - 36 , 16 , - 3 ], 12 ) case ( 14 ) ! (3f(x-4h)-16f(x-3h)+36f(x-2h)-48f(x-h)+25f(x)) / (12h) fd = finite_diff_method ( id , '5-point backward 4' , 5 ,[ - 4 , - 3 , - 2 , - 1 , 0 ],[ 3 , - 16 , 36 , - 48 , 25 ], 12 ) ! 6 point methods case ( 15 ) ! (3f(x-2h)-30f(x-h)-20f(x)+60f(x+h)-15f(x+2h)+2f(x+3h)) / (60h) fd = finite_diff_method ( id , '6-point forward 3' , 6 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 ],[ 3 , - 30 , - 20 , 60 , - 15 , 2 ], 60 ) case ( 16 ) ! (-2f(x-3h)+15f(x-2h)-60f(x-h)+20f(x)+30f(x+h)-3f(x+2h)) / (60h) fd = finite_diff_method ( id , '6-point backward 3' , 6 ,[ - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ - 2 , 15 , - 60 , 20 , 30 , - 3 ], 60 ) case ( 17 ) ! (-12f(x-h)-65f(x)+120f(x+h)-60f(x+2h)+20f(x+3h)-3f(x+4h)) / (60h) fd = finite_diff_method ( id , '6-point forward 4' , 6 ,[ - 1 , 0 , 1 , 2 , 3 , 4 ],[ - 12 , - 65 , 120 , - 60 , 20 , - 3 ], 60 ) case ( 18 ) ! (3f(x-4h)-20f(x-3h)+60f(x-2h)-120f(x-h)+65f(x)+12f(x+h)) / (60h) fd = finite_diff_method ( id , '6-point backward 4' , 6 ,[ - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ 3 , - 20 , 60 , - 120 , 65 , 12 ], 60 ) case ( 19 ) ! (-137f(x)+300f(x+h)-300f(x+2h)+200f(x+3h)-75f(x+4h)+12f(x+5h)) / (60h) fd = finite_diff_method ( id , '6-point forward 5' , 6 ,[ 0 , 1 , 2 , 3 , 4 , 5 ],[ - 137 , 300 , - 300 , 200 , - 75 , 12 ], 60 ) case ( 20 ) ! (-12f(x-5h)+75f(x-4h)-200f(x-3h)+300f(x-2h)-300f(x-h)+137f(x)) / (60h) fd = finite_diff_method ( id , '6-point backward 5' , 6 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ - 12 , 75 , - 200 , 300 , - 300 , 137 ], 60 ) ! 7 point methods case ( 21 ) ! (-f(x-3h)+9f(x-2h)-45f(x-h)+45f(x+h)-9f(x+2h)+f(x+3h)) / (60h) fd = finite_diff_method ( id , '7-point central' , 7 ,[ - 3 , - 2 , - 1 , 1 , 2 , 3 ],[ - 1 , 9 , - 45 , 45 , - 9 , 1 ], 60 ) case ( 22 ) ! (2f(x-2h)-24f(x-h)-35f(x)+80f(x+h)-30f(x+2h)+8f(x+3h)-f(x+4h)) / (60h) fd = finite_diff_method ( id , '7-point forward 4' , 7 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 , 4 ],[ 2 , - 24 , - 35 , 80 , - 30 , 8 , - 1 ], 60 ) case ( 23 ) ! (f(x-4h)-8f(x-3h)+30f(x-2h)-80f(x-h)+35f(x)+24f(x+h)-2f(x+2h)) / (60h) fd = finite_diff_method ( id , '7-point backward 4' , 7 ,[ - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ 1 , - 8 , 30 , - 80 , 35 , 24 , - 2 ], 60 ) case ( 24 ) ! (-10f(x-h)-77f(x)+150f(x+h)-100f(x+2h)+50f(x+3h)-15f(x+4h)+2f(x+5h)) / (60h) fd = finite_diff_method ( id , '7-point forward 5' , 7 ,[ - 1 , 0 , 1 , 2 , 3 , 4 , 5 ],[ - 10 , - 77 , 150 , - 100 , 50 , - 15 , 2 ], 60 ) case ( 25 ) ! (-2f(x-5h)+15f(x-4h)-50f(x-3h)+100f(x-2h)-150f(x-h)+77f(x)+10f(x+h)) / (60h) fd = finite_diff_method ( id , '7-point backward 5' , 7 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ - 2 , 15 , - 50 , 100 , - 150 , 77 , 10 ], 60 ) case ( 26 ) ! (-147f(x)+360f(x+h)-450f(x+2h)+400f(x+3h)-225f(x+4h)+72f(x+5h)-10f(x+6h)) / (60h) fd = finite_diff_method ( id , '7-point forward 6' , 7 ,[ 0 , 1 , 2 , 3 , 4 , 5 , 6 ],[ - 147 , 360 , - 450 , 400 , - 225 , 72 , - 10 ], 60 ) case ( 27 ) ! (10f(x-6h)-72f(x-5h)+225f(x-4h)-400f(x-3h)+450f(x-2h)-360f(x-h)+147f(x)) / (60h) fd = finite_diff_method ( id , '7-point backward 6' , 7 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ 10 , - 72 , 225 , - 400 , 450 , - 360 , 147 ], 60 ) ! 8 point methods case ( 28 ) ! (-4f(x-3h)+42f(x-2h)-252f(x-h)-105f(x)+420f(x+h)-126f(x+2h)+28f(x+3h)-3f(x+4h)) / (420h) fd = finite_diff_method ( id , '8-point forward 4' , 8 ,[ - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 , 4 ],[ - 4 , 42 , - 252 , - 105 , 420 , - 126 , 28 , - 3 ], 420 ) case ( 29 ) ! (3f(x-4h)-28f(x-3h)+126f(x-2h)-420f(x-h)+105f(x)+252f(x+h)-42f(x+2h)+4f(x+3h)) / (420h) fd = finite_diff_method ( id , '8-point backward 4' , 8 ,[ - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 ],[ 3 , - 28 , 126 , - 420 , 105 , 252 , - 42 , 4 ], 420 ) case ( 30 ) ! (10f(x-2h)-140f(x-h)-329f(x)+700f(x+h)-350f(x+2h)+140f(x+3h)-35f(x+4h)+4f(x+5h)) / (420h) fd = finite_diff_method ( id , '8-point forward 5' , 8 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 ],[ 10 , - 140 , - 329 , 700 , - 350 , 140 , - 35 , 4 ], 420 ) case ( 31 ) ! (-4f(x-5h)+35f(x-4h)-140f(x-3h)+350f(x-2h)-700f(x-h)+329f(x)+140f(x+h)-10f(x+2h)) / (420h) fd = finite_diff_method ( id , '8-point backward 5' , 8 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ - 4 , 35 , - 140 , 350 , - 700 , 329 , 140 , - 10 ], 420 ) case ( 32 ) ! (-60f(x-h)-609f(x)+1260f(x+h)-1050f(x+2h)+700f(x+3h)-315f(x+4h)+84f(x+5h)-10f(x+6h)) / (420h) fd = finite_diff_method ( id , '8-point forward 6' , 8 ,[ - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 ],[ - 60 , - 609 , 1260 , - 1050 , 700 , - 315 , 84 , - 10 ], 420 ) case ( 33 ) ! (10f(x-6h)-84f(x-5h)+315f(x-4h)-700f(x-3h)+1050f(x-2h)-1260f(x-h)+609f(x)+60f(x+h)) / (420h) fd = finite_diff_method ( id , '8-point backward 6' , 8 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ 10 , - 84 , 315 , - 700 , 1050 , - 1260 , 609 , 60 ], 420 ) case ( 34 ) ! (-1089f(x)+2940f(x+h)-4410f(x+2h)+4900f(x+3h)-3675f(x+4h)+1764f(x+5h)-490f(x+6h)+60f(x+7h)) / (420h) fd = finite_diff_method ( id , '8-point forward 7' , 8 ,[ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ],[ - 1089 , 2940 , - 4410 , 4900 , - 3675 , 1764 , - 490 , 60 ], 420 ) case ( 35 ) ! (-60f(x-7h)+490f(x-6h)-1764f(x-5h)+3675f(x-4h)-4900f(x-3h)+4410f(x-2h)-2940f(x-h)+1089f(x)) / (420h) fd = finite_diff_method ( id , '8-point backward 7' , 8 ,[ - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ - 60 , 490 , - 1764 , 3675 , - 4900 , 4410 , - 2940 , 1089 ], 420 ) ! 9 point methods case ( 36 ) ! (3f(x-4h)-32f(x-3h)+168f(x-2h)-672f(x-h)+672f(x+h)-168f(x+2h)+32f(x+3h)-3f(x+4h)) / (840h) fd = finite_diff_method ( id , '9-point central' , & 9 ,[ - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 ],[ 3 , - 32 , 168 , - 672 , 672 , - 168 , 32 , - 3 ], 840 ) case ( 37 ) ! (-5f(x-3h)+60f(x-2h)-420f(x-h)-378f(x)+1050f(x+h)-420f(x+2h)+140f(x+3h)-30f(x+4h)+3f(x+5h)) / (840h) fd = finite_diff_method ( id , '9-point forward 5' , & 9 ,[ - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 ],[ - 5 , 60 , - 420 , - 378 , 1050 , - 420 , 140 , - 30 , 3 ], 840 ) case ( 38 ) ! (-3f(x-5h)+30f(x-4h)-140f(x-3h)+420f(x-2h)-1050f(x-h)+378f(x)+420f(x+h)-60f(x+2h)+5f(x+3h)) / (840h) fd = finite_diff_method ( id , '9-point backward 5' , & 9 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 ],[ - 3 , 30 , - 140 , 420 , - 1050 , 378 , 420 , - 60 , 5 ], 840 ) case ( 39 ) ! (15f(x-2h)-240f(x-h)-798f(x)+1680f(x+h)-1050f(x+2h)+560f(x+3h)-210f(x+4h)+48f(x+5h)-5f(x+6h)) / (840h) fd = finite_diff_method ( id , '9-point forward 6' , & 9 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 ],[ 15 , - 240 , - 798 , 1680 , - 1050 , 560 , - 210 , 48 , - 5 ], 840 ) case ( 40 ) ! (5f(x-6h)-48f(x-5h)+210f(x-4h)-560f(x-3h)+1050f(x-2h)-1680f(x-h)+798f(x)+240f(x+h)-15f(x+2h)) / (840h) fd = finite_diff_method ( id , '9-point backward 6' , & 9 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ 5 , - 48 , 210 , - 560 , 1050 , - 1680 , 798 , 240 , - 15 ], 840 ) case ( 41 ) ! (-105f(x-h)-1338f(x)+2940f(x+h)-2940f(x+2h)+2450f(x+3h)-1470f(x+4h)+588f(x+5h)-140f(x+6h)+15f(x+7h)) / (840h) fd = finite_diff_method ( id , '9-point forward 7' , & 9 ,[ - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ],[ - 105 , - 1338 , 2940 , - 2940 , 2450 , - 1470 , 588 , - 140 , 15 ], 840 ) case ( 42 ) ! (-15f(x-7h)+140f(x-6h)-588f(x-5h)+1470f(x-4h)-2450f(x-3h)+2940f(x-2h)-2940f(x-h)+1338f(x)+105f(x+h)) / (840h) fd = finite_diff_method ( id , '9-point backward 7' , & 9 ,[ - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ - 15 , 140 , - 588 , 1470 , - 2450 , 2940 , - 2940 , 1338 , 105 ], 840 ) case ( 43 ) ! (-2283f(x)+6720f(x+h)-11760f(x+2h)+15680f(x+3h)-14700f(x+4h)+9408f(x+5h)-3920f(x+6h)+960f(x+7h)-105f(x+8h)) / (840h) fd = finite_diff_method ( id , '9-point forward 8' , & 9 ,[ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ],[ - 2283 , 6720 , - 11760 , 15680 , - 14700 , 9408 , - 3920 , 960 , - 105 ], 840 ) case ( 44 ) ! (105f(x-8h)-960f(x-7h)+3920f(x-6h)-9408f(x-5h)+14700f(x-4h)-15680f(x-3h)+11760f(x-2h)-6720f(x-h)+2283f(x)) / (840h) fd = finite_diff_method ( id , '9-point backward 8' , & 9 ,[ - 8 , - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ 105 , - 960 , 3920 , - 9408 , 14700 , - 15680 , 11760 , - 6720 , 2283 ], 840 ) ! 11 point methods case ( 500 ) ! (-2f(x-5h)+25f(x-4h)-150f(x-3h)+600f(x-2h)-2100f(x-h)+2100f(x+h)-600f(x+2h)+150f(x+3h)-25f(x+4h)+2f(x+5h)) / (2520h) fd = finite_diff_method ( id , '11-point central' , & 11 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 ],[ - 2 , 25 , - 150 , 600 , - 2100 , 2100 , - 600 , 150 , - 25 , 2 ], 2520 ) ! 13 point methods case ( 600 ) ! (5f(x-6h)-72f(x-5h)+495f(x-4h)-2200f(x-3h)+7425f(x-2h)-23760f(x-h)+23760f(x+h)-7425f(x+2h)+2200f(x+3h)-495f(x+4h)+72f(x+5h)-5f(x+6h)) / (27720h) fd = finite_diff_method ( id , '13-point central' , & 13 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 , 6 ],& [ 5 , - 72 , 495 , - 2200 , 7425 , - 23760 , 23760 , - 7425 , 2200 , - 495 , 72 , - 5 ], 27720 ) ! 15 point methods case ( 700 ) ! (-15f(x-7h)+245f(x-6h)-1911f(x-5h)+9555f(x-4h)-35035f(x-3h)+105105f(x-2h)-315315f(x-h)+315315f(x+h)-105105f(x+2h)+35035f(x+3h)-9555f(x+4h)+1911f(x+5h)-245f(x+6h)+15f(x+7h)) / (360360h) fd = finite_diff_method ( id , '15-point central' , & 15 ,[ - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ],& [ - 15 , 245 , - 1911 , 9555 , - 35035 , 105105 , - 315315 , 315315 , - 105105 , 35035 , - 9555 , 1911 , - 245 , 15 ], 360360 ) ! 17 point methods case ( 800 ) ! (7f(x-8h)-128f(x-7h)+1120f(x-6h)-6272f(x-5h)+25480f(x-4h)-81536f(x-3h)+224224f(x-2h)-640640f(x-h)+640640f(x+h)-224224f(x+2h)+81536f(x+3h)-25480f(x+4h)+6272f(x+5h)-1120f(x+6h)+128f(x+7h)-7f(x+8h)) / (720720h) fd = finite_diff_method ( id , '17-point central' , & 17 ,[ - 8 , - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ],& [ 7 , - 128 , 1120 , - 6272 , 25480 , - 81536 , 224224 , - 640640 , 640640 , - 224224 , 81536 , - 25480 , 6272 , - 1120 , 128 , - 7 ], 720720 ) case default found = . false . end select end subroutine get_finite_difference_method","tags":"","loc":"proc/get_finite_difference_method.html"},{"title":"select_finite_diff_method – AoC-2023","text":"private  subroutine select_finite_diff_method(me, x, xlow, xhigh, dx, list_of_methods, fd, status_ok) Select a finite diff method of a given class so that the perturbations\nof x will not violate the variable bounds. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in) :: x the variable value real(kind=wp), intent(in) :: xlow the variable lower bound real(kind=wp), intent(in) :: xhigh the variable upper bound real(kind=wp), intent(in) :: dx the perturbation value (>0) type( meth_array ), intent(in) :: list_of_methods list of available methods to choose from type( finite_diff_method ), intent(out) :: fd this method can be used logical, intent(out) :: status_ok true if it really doesn't violate the bounds\n(say, the bounds are very close to each other)\nif status_ok=False , then the first method in\nthe given class is returned in fd . Called by proc~~select_finite_diff_method~~CalledByGraph proc~select_finite_diff_method numerical_differentiation_module::numdiff_type%select_finite_diff_method proc~compute_jacobian_for_sparsity numerical_differentiation_module::numdiff_type%compute_jacobian_for_sparsity proc~compute_jacobian_for_sparsity->proc~select_finite_diff_method proc~compute_jacobian_standard numerical_differentiation_module::compute_jacobian_standard proc~compute_jacobian_standard->proc~select_finite_diff_method program~test1 test1 program~test1->proc~select_finite_diff_method proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine select_finite_diff_method ( me , x , xlow , xhigh , dx , list_of_methods , fd , status_ok ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x !! the variable value real ( wp ), intent ( in ) :: xlow !! the variable lower bound real ( wp ), intent ( in ) :: xhigh !! the variable upper bound real ( wp ), intent ( in ) :: dx !! the perturbation value (>0) type ( meth_array ), intent ( in ) :: list_of_methods !! list of available methods to choose from type ( finite_diff_method ), intent ( out ) :: fd !! this method can be used logical , intent ( out ) :: status_ok !! true if it really doesn't violate the bounds !! (say, the bounds are very close to each other) !! if `status_ok=False`, then the first method in !! the given class is returned in `fd`. integer :: i !! counter integer :: j !! counter real ( wp ) :: xs !! if `x` is outside the bounds, this is the value !! on the nearest bound. otherwise equal to `x`. real ( wp ) :: xp !! perturbed `x` value ! initialize: status_ok = . false . if ( me % exception_raised ) return ! check for exceptions ! make sure it is within the bounds xs = min ( xhigh , max ( xlow , x )) ! try all the methods in the class: do i = 1 , size ( list_of_methods % meth ) status_ok = . true . ! will be set to false if any ! perturbation violates the bounds ! check each of the perturbations: do j = 1 , size ( list_of_methods % meth ( i )% dx_factors ) xp = xs + list_of_methods % meth ( i )% dx_factors ( j ) * dx if ( xp < xlow . or . xp > xhigh ) then status_ok = . false . exit end if end do if ( status_ok ) then ! this one is OK to use fd = list_of_methods % meth ( i ) exit end if end do if (. not . status_ok ) then ! no method was found that doesn't violate the bounds, ! so just return the first one in the list. fd = list_of_methods % meth ( 1 ) end if end subroutine select_finite_diff_method","tags":"","loc":"proc/select_finite_diff_method.html"},{"title":"select_finite_diff_method_for_partition_group – AoC-2023","text":"private  subroutine select_finite_diff_method_for_partition_group(me, x, xlow, xhigh, dx, list_of_methods, fd, status_ok) Select a finite diff method of a given class so that the perturbations\nof x will not violate the variable bounds for any variable in the group. The x vector are only the variables in a group (not the full variable vector) Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x the variable values real(kind=wp), intent(in), dimension(:) :: xlow the variable lower bounds real(kind=wp), intent(in), dimension(:) :: xhigh the variable upper bounds real(kind=wp), intent(in), dimension(:) :: dx the perturbation values (>0) type( meth_array ), intent(in) :: list_of_methods list of available methods to choose from type( finite_diff_method ), intent(out) :: fd this method can be used logical, intent(out) :: status_ok true if it really doesn't violate the bounds\n(say, the bounds are very close to each other)\nif status_ok=False , then the first method in\nthe given class is returned in fd . Called by proc~~select_finite_diff_method_for_partition_group~~CalledByGraph proc~select_finite_diff_method_for_partition_group numerical_differentiation_module::numdiff_type%select_finite_diff_method_for_partition_group proc~compute_jacobian_partitioned numerical_differentiation_module::compute_jacobian_partitioned proc~compute_jacobian_partitioned->proc~select_finite_diff_method_for_partition_group Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine select_finite_diff_method_for_partition_group ( me , x , xlow , xhigh , dx ,& list_of_methods , fd , status_ok ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! the variable values real ( wp ), dimension (:), intent ( in ) :: xlow !! the variable lower bounds real ( wp ), dimension (:), intent ( in ) :: xhigh !! the variable upper bounds real ( wp ), dimension (:), intent ( in ) :: dx !! the perturbation values (>0) type ( meth_array ), intent ( in ) :: list_of_methods !! list of available methods to choose from type ( finite_diff_method ), intent ( out ) :: fd !! this method can be used logical , intent ( out ) :: status_ok !! true if it really doesn't violate the bounds !! (say, the bounds are very close to each other) !! if `status_ok=False`, then the first method in !! the given class is returned in `fd`. integer :: i !! counter integer :: j !! counter real ( wp ), dimension ( size ( x )) :: xp !! perturbed `x` values real ( wp ), dimension ( size ( x )) :: xs !! if `x` is outside the bounds, this is the value !! on the nearest bound. otherwise equal to `x`. ! initialize: status_ok = . false . if ( me % exception_raised ) return ! check for exceptions ! make sure they are within the bounds xs = min ( xhigh , max ( xlow , x )) ! try all the methods in the class: do i = 1 , size ( list_of_methods % meth ) status_ok = . true . ! will be set to false if any ! perturbation violates the bounds ! check each of the perturbations: do j = 1 , size ( list_of_methods % meth ( i )% dx_factors ) xp = xs + list_of_methods % meth ( i )% dx_factors ( j ) * dx if ( any ( xp < xlow ) . or . any ( xp > xhigh )) then status_ok = . false . exit end if end do if ( status_ok ) then ! this one is OK to use fd = list_of_methods % meth ( i ) exit end if end do if (. not . status_ok ) then ! no method was found that doesn't violate the bounds, ! so just return the first one in the list. fd = list_of_methods % meth ( 1 ) end if end subroutine select_finite_diff_method_for_partition_group","tags":"","loc":"proc/select_finite_diff_method_for_partition_group.html"},{"title":"initialize_numdiff_for_diff – AoC-2023","text":"private  subroutine initialize_numdiff_for_diff(me, n, m, xlow, xhigh, problem_func, sparsity_mode, info, chunk_size, eps, acc, cache_size, xlow_for_sparsity, xhigh_for_sparsity, dpert_for_sparsity, sparsity_perturb_mode, linear_sparsity_tol, function_precision_tol, num_sparsity_points, print_messages) Alternate version of initialize_numdiff routine when\nusing diff to compute the Jacobian. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: n number of x variables integer, intent(in) :: m number of f functions real(kind=wp), intent(in), dimension(n) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(n) :: xhigh upper bounds on x procedure( func ) :: problem_func the user function that defines the problem\n(returns m functions) integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. procedure( info_f ), optional :: info a function the user can define\nwhich is called when each column\nof the jacobian is computed.\nIt can be used to perform any\nsetup operations. integer, intent(in), optional :: chunk_size chunk size for allocating the arrays\n(must be >0) [default is 100] real(kind=wp), intent(in), optional :: eps tolerance parameter for diff if not present, default is 1.0e-9_wp real(kind=wp), intent(in), optional :: acc tolerance parameter for diff if not present, default is 0.0_wp integer, intent(in), optional :: cache_size if present, this is the cache size\nfor the function cache\n(default is not to enable cache) real(kind=wp), intent(in), optional, dimension(n) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(n) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. real(kind=wp), intent(in), optional, dimension(n) :: dpert_for_sparsity required if sparsity_mode=4 integer, intent(in), optional :: sparsity_perturb_mode perturbation mode (required if sparsity_mode=4 ): 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), optional :: linear_sparsity_tol the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), intent(in), optional :: function_precision_tol the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, intent(in), optional :: num_sparsity_points for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern. logical, intent(in), optional :: print_messages if true, print error messages to error_unit .\ndefault is True. Calls proc~~initialize_numdiff_for_diff~~CallsGraph proc~initialize_numdiff_for_diff numerical_differentiation_module::numdiff_type%initialize_numdiff_for_diff proc~destroy_cache numdiff_cache_module::function_cache%destroy_cache proc~initialize_numdiff_for_diff->proc~destroy_cache proc~initialize_cache numdiff_cache_module::function_cache%initialize_cache proc~initialize_numdiff_for_diff->proc~initialize_cache proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~initialize_numdiff_for_diff->proc~raise_exception proc~set_numdiff_bounds numerical_differentiation_module::numdiff_type%set_numdiff_bounds proc~initialize_numdiff_for_diff->proc~set_numdiff_bounds proc~set_sparsity_mode numerical_differentiation_module::numdiff_type%set_sparsity_mode proc~initialize_numdiff_for_diff->proc~set_sparsity_mode proc~initialize_cache->proc~destroy_cache proc~set_numdiff_bounds->proc~raise_exception proc~integer_to_string~2 numerical_differentiation_module::integer_to_string proc~set_numdiff_bounds->proc~integer_to_string~2 proc~set_sparsity_mode->proc~raise_exception proc~set_numdiff_sparsity_bounds numerical_differentiation_module::numdiff_type%set_numdiff_sparsity_bounds proc~set_sparsity_mode->proc~set_numdiff_sparsity_bounds proc~set_numdiff_sparsity_bounds->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~initialize_numdiff_for_diff~~CalledByGraph proc~initialize_numdiff_for_diff numerical_differentiation_module::numdiff_type%initialize_numdiff_for_diff program~test1 test1 program~test1->proc~initialize_numdiff_for_diff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize_numdiff_for_diff ( me , n , m , xlow , xhigh ,& problem_func , sparsity_mode , info ,& chunk_size , eps , acc , cache_size ,& xlow_for_sparsity , xhigh_for_sparsity ,& dpert_for_sparsity , sparsity_perturb_mode ,& linear_sparsity_tol , function_precision_tol ,& num_sparsity_points , print_messages ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of `x` variables integer , intent ( in ) :: m !! number of `f` functions real ( wp ), dimension ( n ), intent ( in ) :: xlow !! lower bounds on `x` real ( wp ), dimension ( n ), intent ( in ) :: xhigh !! upper bounds on `x` procedure ( func ) :: problem_func !! the user function that defines the problem !! (returns `m` functions) integer , intent ( in ) :: sparsity_mode !! the sparsity computation method: !! !! **1** - assume dense, !! **2** - three-point simple method, !! **3** - will be specified by the user in !! a subsequent call to [[set_sparsity_pattern]]. !! **4** - computes a two-point jacobian !! at `num_sparsity_points` points. procedure ( info_f ), optional :: info !! a function the user can define !! which is called when each column !! of the jacobian is computed. !! It can be used to perform any !! setup operations. integer , intent ( in ), optional :: chunk_size !! chunk size for allocating the arrays !! (must be >0) [default is 100] real ( wp ), intent ( in ), optional :: eps !! tolerance parameter for [[diff]] !! if not present, default is `1.0e-9_wp` real ( wp ), intent ( in ), optional :: acc !! tolerance parameter for [[diff]] !! if not present, default is `0.0_wp` integer , intent ( in ), optional :: cache_size !! if present, this is the cache size !! for the function cache !! (default is not to enable cache) real ( wp ), dimension ( n ), intent ( in ), optional :: xlow_for_sparsity !! lower bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xlow` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: xhigh_for_sparsity !! upper bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xhigh` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: dpert_for_sparsity !! required if `sparsity_mode=4` integer , intent ( in ), optional :: sparsity_perturb_mode !! perturbation mode (required if `sparsity_mode=4`): !! !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` integer , intent ( in ), optional :: num_sparsity_points !! for `sparsity_mode=4`, the number of jacobian !! evaluations used to estimate the sparsity pattern. real ( wp ), intent ( in ), optional :: linear_sparsity_tol !! the equality tolerance for derivatives to !! indicate a constant jacobian element (linear sparsity) real ( wp ), intent ( in ), optional :: function_precision_tol !! the function precision. two functions values !! that are the within this tolerance are !! considered the same value. This is used !! when estimating the sparsity pattern when !! `sparsity_mode=2` in [[compute_sparsity_random]] logical , intent ( in ), optional :: print_messages !! if true, print error messages to `error_unit`. !! default is True. logical :: cache !! if the cache is to be used me % use_diff = . true . ! cache: cache = present ( cache_size ) if ( cache ) cache = cache_size > 0 if ( cache ) then me % compute_function => compute_function_with_cache call me % cache % initialize ( cache_size , n , m ) else me % compute_function => problem_func call me % cache % destroy () end if ! functions: me % problem_func => problem_func me % jacobian_function => compute_jacobian_with_diff ! size of the problem: me % n = n me % m = m ! input variable bounds: call me % set_numdiff_bounds ( xlow , xhigh ) ! set the sparsity function call me % set_sparsity_mode ( sparsity_mode , xlow_for_sparsity , xhigh_for_sparsity ) if ( sparsity_mode == 4 ) then ! these must be present, since we don't have a dpert and perturb mode for the gradients: if ( present ( dpert_for_sparsity ) . and . present ( sparsity_perturb_mode )) then me % dpert_for_sparsity = abs ( dpert_for_sparsity ) ! perturbation options: select case ( sparsity_perturb_mode ) case ( 1 : 3 ) me % sparsity_perturb_mode = sparsity_perturb_mode case default call me % raise_exception ( 1 , 'initialize_numdiff_for_diff' ,& 'sparsity_perturb_mode must be 1, 2, or 3.' ) return end select else call me % raise_exception ( 2 , 'initialize_numdiff_for_diff' ,& 'missing required inputs for sparsity mode 4' ) return end if end if ! if these aren't present, they will just keep the defaults: if ( present ( linear_sparsity_tol )) me % linear_sparsity_tol = linear_sparsity_tol if ( present ( function_precision_tol )) me % function_precision_tol = function_precision_tol if ( present ( num_sparsity_points )) me % num_sparsity_points = num_sparsity_points ! optional: if ( present ( chunk_size )) me % chunk_size = abs ( chunk_size ) if ( present ( eps )) me % eps = eps if ( present ( acc )) me % acc = acc if ( present ( info )) me % info_function => info if ( present ( print_messages )) me % print_messages = print_messages end subroutine initialize_numdiff_for_diff","tags":"","loc":"proc/initialize_numdiff_for_diff.html"},{"title":"set_numdiff_bounds – AoC-2023","text":"private  subroutine set_numdiff_bounds(me, xlow, xhigh) Change the variable bounds in a numdiff_type . See also set_numdiff_sparsity_bounds Note The bounds must be set when the class is initialized,\n      but this routine can be used to change them later if required. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(:) :: xhigh upper bounds on x Calls proc~~set_numdiff_bounds~~CallsGraph proc~set_numdiff_bounds numerical_differentiation_module::numdiff_type%set_numdiff_bounds proc~integer_to_string~2 numerical_differentiation_module::integer_to_string proc~set_numdiff_bounds->proc~integer_to_string~2 proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~set_numdiff_bounds->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_numdiff_bounds~~CalledByGraph proc~set_numdiff_bounds numerical_differentiation_module::numdiff_type%set_numdiff_bounds proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~set_numdiff_bounds proc~initialize_numdiff_for_diff numerical_differentiation_module::numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~set_numdiff_bounds program~test1 test1 program~test1->proc~initialize_numdiff program~test1->proc~initialize_numdiff_for_diff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_numdiff_bounds ( me , xlow , xhigh ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: xlow !! lower bounds on `x` real ( wp ), dimension (:), intent ( in ) :: xhigh !! upper bounds on `x` integer :: i !! counter for error print character ( len = :), allocatable :: error_info !! error message info character ( len = :), allocatable :: istr !! for integer to string character ( len = 30 ) :: xlow_str , xhigh_str !! for real to string if ( me % exception_raised ) return ! check for exceptions if ( allocated ( me % xlow )) deallocate ( me % xlow ) if ( allocated ( me % xhigh )) deallocate ( me % xhigh ) if ( size ( xlow ) /= me % n . or . size ( xhigh ) /= me % n ) then call me % raise_exception ( 3 , 'set_numdiff_bounds' ,& 'invalid size of xlow or xhigh' ) return else if ( any ( xlow >= xhigh )) then error_info = 'all xlow must be < xhigh' do i = 1 , size ( xlow ) if ( xlow ( i ) >= xhigh ( i )) then istr = integer_to_string ( i ) write ( xlow_str , '(F30.16)' ) xlow ( i ) write ( xhigh_str , '(F30.16)' ) xhigh ( i ) error_info = error_info // new_line ( '' ) // '  Error for optimization variable ' // trim ( adjustl ( istr )) // & ': xlow=' // trim ( adjustl ( xlow_str )) // & ' >= xhigh=' // trim ( adjustl ( xhigh_str )) end if end do call me % raise_exception ( 4 , 'set_numdiff_bounds' , error_info ) return else allocate ( me % xlow ( me % n )) allocate ( me % xhigh ( me % n )) me % xlow = xlow me % xhigh = xhigh end if end subroutine set_numdiff_bounds","tags":"","loc":"proc/set_numdiff_bounds.html"},{"title":"set_sparsity_mode – AoC-2023","text":"private  subroutine set_sparsity_mode(me, sparsity_mode, xlow_for_sparsity, xhigh_for_sparsity) Set sparsity mode. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. real(kind=wp), intent(in), optional, dimension(:) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(:) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. Calls proc~~set_sparsity_mode~~CallsGraph proc~set_sparsity_mode numerical_differentiation_module::numdiff_type%set_sparsity_mode proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~set_sparsity_mode->proc~raise_exception proc~set_numdiff_sparsity_bounds numerical_differentiation_module::numdiff_type%set_numdiff_sparsity_bounds proc~set_sparsity_mode->proc~set_numdiff_sparsity_bounds proc~set_numdiff_sparsity_bounds->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_sparsity_mode~~CalledByGraph proc~set_sparsity_mode numerical_differentiation_module::numdiff_type%set_sparsity_mode proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~set_sparsity_mode proc~initialize_numdiff_for_diff numerical_differentiation_module::numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~set_sparsity_mode program~test1 test1 program~test1->proc~initialize_numdiff program~test1->proc~initialize_numdiff_for_diff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_sparsity_mode ( me , sparsity_mode , xlow_for_sparsity , xhigh_for_sparsity ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: sparsity_mode !! the sparsity computation method: !! **1** - assume dense, !! **2** - three-point simple method, !! **3** - will be specified by the user in !! a subsequent call to [[set_sparsity_pattern]]. !! **4** - computes a two-point jacobian !! at `num_sparsity_points` points. real ( wp ), dimension (:), intent ( in ), optional :: xlow_for_sparsity !! lower bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xlow` is used. real ( wp ), dimension (:), intent ( in ), optional :: xhigh_for_sparsity !! upper bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xhigh` is used. if ( me % exception_raised ) return ! check for exceptions ! set the sparsity function select case ( sparsity_mode ) case ( 1 ) ! dense me % compute_sparsity => compute_sparsity_dense case ( 3 ) ! user defined me % compute_sparsity => null () case ( 2 ) ! three-point simple method me % compute_sparsity => compute_sparsity_random ! in this case, we have the option of specifying ! separate bounds for computing the sparsity: call me % set_numdiff_sparsity_bounds ( xlow_for_sparsity , xhigh_for_sparsity ) case ( 4 ) ! compute 2-point jacobian in specified number of points me % compute_sparsity => compute_sparsity_random_2 ! in this case, we have the option of specifying ! separate bounds for computing the sparsity: call me % set_numdiff_sparsity_bounds ( xlow_for_sparsity , xhigh_for_sparsity ) case default call me % raise_exception ( 5 , 'set_sparsity_mode' ,& 'sparsity_mode must be 1, 2, 3, or 4.' ) return end select end subroutine set_sparsity_mode","tags":"","loc":"proc/set_sparsity_mode.html"},{"title":"set_numdiff_sparsity_bounds – AoC-2023","text":"private  subroutine set_numdiff_sparsity_bounds(me, xlow, xhigh) Sets the variable bounds for sparsity in a numdiff_type .\n  These are only used for sparsity_mode=2 . See also set_numdiff_bounds Note This routine assumes that xlow and xhigh have already\n      been set in the class. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), optional, dimension(:) :: xlow lower bounds on x to be used for\nsparsity computation. If not present,\nthen then xlow values in the class are used. real(kind=wp), intent(in), optional, dimension(:) :: xhigh upper bounds on x to be used for\nsparsity computation. If not present,\nthen then xhigh values in the class are used. Calls proc~~set_numdiff_sparsity_bounds~~CallsGraph proc~set_numdiff_sparsity_bounds numerical_differentiation_module::numdiff_type%set_numdiff_sparsity_bounds proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~set_numdiff_sparsity_bounds->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_numdiff_sparsity_bounds~~CalledByGraph proc~set_numdiff_sparsity_bounds numerical_differentiation_module::numdiff_type%set_numdiff_sparsity_bounds proc~set_sparsity_mode numerical_differentiation_module::numdiff_type%set_sparsity_mode proc~set_sparsity_mode->proc~set_numdiff_sparsity_bounds proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~set_sparsity_mode proc~initialize_numdiff_for_diff numerical_differentiation_module::numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~set_sparsity_mode program~test1 test1 program~test1->proc~initialize_numdiff program~test1->proc~initialize_numdiff_for_diff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_numdiff_sparsity_bounds ( me , xlow , xhigh ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ), optional :: xlow !! lower bounds on `x` to be used for !! sparsity computation. If not present, !! then then `xlow` values in the class are used. real ( wp ), dimension (:), intent ( in ), optional :: xhigh !! upper bounds on `x` to be used for !! sparsity computation. If not present, !! then then `xhigh` values in the class are used. if ( me % exception_raised ) return ! check for exceptions if ( allocated ( me % xlow_for_sparsity )) deallocate ( me % xlow_for_sparsity ) if ( allocated ( me % xhigh_for_sparsity )) deallocate ( me % xhigh_for_sparsity ) if (. not . present ( xlow )) then allocate ( me % xlow_for_sparsity ( size ( me % xlow ))) me % xlow_for_sparsity = me % xlow else allocate ( me % xlow_for_sparsity ( size ( xlow ))) me % xlow_for_sparsity = xlow end if if (. not . present ( xhigh )) then allocate ( me % xhigh_for_sparsity ( size ( me % xhigh ))) me % xhigh_for_sparsity = me % xhigh else allocate ( me % xhigh_for_sparsity ( size ( xhigh ))) me % xhigh_for_sparsity = xhigh end if ! error checks: if ( size ( me % xlow_for_sparsity ) /= me % n . or . size ( me % xhigh_for_sparsity ) /= me % n ) then call me % raise_exception ( 6 , 'set_numdiff_sparsity_bounds' ,& 'invalid size of xlow or xhigh' ) else if ( any ( me % xlow_for_sparsity >= me % xhigh_for_sparsity )) then call me % raise_exception ( 7 , 'set_numdiff_sparsity_bounds' ,& 'all xlow must be < xhigh' ) end if end subroutine set_numdiff_sparsity_bounds","tags":"","loc":"proc/set_numdiff_sparsity_bounds.html"},{"title":"initialize_numdiff – AoC-2023","text":"private  subroutine initialize_numdiff(me, n, m, xlow, xhigh, perturb_mode, dpert, problem_func, sparsity_mode, jacobian_method, jacobian_methods, class, classes, info, chunk_size, partition_sparsity_pattern, cache_size, xlow_for_sparsity, xhigh_for_sparsity, dpert_for_sparsity, sparsity_perturb_mode, linear_sparsity_tol, function_precision_tol, num_sparsity_points) Initialize a numdiff_type class. This must be called first. Note Only one of the following inputs can be used: jacobian_method , jacobian_methods , class , or classes . Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: n number of x variables integer, intent(in) :: m number of f functions real(kind=wp), intent(in), dimension(n) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(n) :: xhigh upper bounds on x integer, intent(in) :: perturb_mode perturbation mode: 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), dimension(n) :: dpert perturbation vector for x procedure( func ) :: problem_func the user function that defines the problem\n(returns m functions) integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. integer, intent(in), optional :: jacobian_method id code for the finite difference method\nto use for all n variables.\nsee get_finite_difference_method integer, intent(in), optional, dimension(n) :: jacobian_methods id codes for the finite difference method\nto use for each variable.\nsee get_finite_difference_method integer, intent(in), optional :: class method class for the finite difference method\nto use for all n variables.\nsee get_finite_difference_method integer, intent(in), optional, dimension(n) :: classes method class for the finite difference methods\nto use for each variable.\nsee get_finite_difference_method procedure( info_f ), optional :: info a function the user can define\nwhich is called when each column\nof the jacobian is computed.\nIt can be used to perform any\nsetup operations. integer, intent(in), optional :: chunk_size chunk size for allocating the arrays\n(must be >0) [default is 100] logical, intent(in), optional :: partition_sparsity_pattern if the sparisty pattern is to\nbe partitioned using DSM [default is False] integer, intent(in), optional :: cache_size if present, this is the cache size\nfor the function cache\n(default is not to enable cache) real(kind=wp), intent(in), optional, dimension(n) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(n) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. real(kind=wp), intent(in), optional, dimension(n) :: dpert_for_sparsity for sparsity_mode=4 , the perturbation integer, intent(in), optional :: sparsity_perturb_mode perturbation mode (required if sparsity_mode=4 ): 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), optional :: linear_sparsity_tol the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), intent(in), optional :: function_precision_tol the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, intent(in), optional :: num_sparsity_points for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern. Calls proc~~initialize_numdiff~~CallsGraph proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff proc~destroy_cache numdiff_cache_module::function_cache%destroy_cache proc~initialize_numdiff->proc~destroy_cache proc~get_all_methods_in_class numerical_differentiation_module::get_all_methods_in_class proc~initialize_numdiff->proc~get_all_methods_in_class proc~get_finite_difference_method numerical_differentiation_module::get_finite_difference_method proc~initialize_numdiff->proc~get_finite_difference_method proc~initialize_cache numdiff_cache_module::function_cache%initialize_cache proc~initialize_numdiff->proc~initialize_cache proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~initialize_numdiff->proc~raise_exception proc~set_numdiff_bounds numerical_differentiation_module::numdiff_type%set_numdiff_bounds proc~initialize_numdiff->proc~set_numdiff_bounds proc~set_sparsity_mode numerical_differentiation_module::numdiff_type%set_sparsity_mode proc~initialize_numdiff->proc~set_sparsity_mode proc~get_all_methods_in_class->proc~get_finite_difference_method proc~initialize_cache->proc~destroy_cache proc~set_numdiff_bounds->proc~raise_exception proc~integer_to_string~2 numerical_differentiation_module::integer_to_string proc~set_numdiff_bounds->proc~integer_to_string~2 proc~set_sparsity_mode->proc~raise_exception proc~set_numdiff_sparsity_bounds numerical_differentiation_module::numdiff_type%set_numdiff_sparsity_bounds proc~set_sparsity_mode->proc~set_numdiff_sparsity_bounds proc~set_numdiff_sparsity_bounds->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~initialize_numdiff~~CalledByGraph proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff program~test1 test1 program~test1->proc~initialize_numdiff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize_numdiff ( me , n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func , sparsity_mode , jacobian_method , jacobian_methods ,& class , classes , info , chunk_size , partition_sparsity_pattern ,& cache_size , xlow_for_sparsity , xhigh_for_sparsity ,& dpert_for_sparsity , sparsity_perturb_mode ,& linear_sparsity_tol , function_precision_tol ,& num_sparsity_points ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of `x` variables integer , intent ( in ) :: m !! number of `f` functions real ( wp ), dimension ( n ), intent ( in ) :: xlow !! lower bounds on `x` real ( wp ), dimension ( n ), intent ( in ) :: xhigh !! upper bounds on `x` integer , intent ( in ) :: perturb_mode !! perturbation mode: !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` real ( wp ), dimension ( n ), intent ( in ) :: dpert !! perturbation vector for `x` procedure ( func ) :: problem_func !! the user function that defines the problem !! (returns `m` functions) integer , intent ( in ) :: sparsity_mode !! the sparsity computation method: !! **1** - assume dense, !! **2** - three-point simple method, !! **3** - will be specified by the user in !! a subsequent call to [[set_sparsity_pattern]]. !! **4** - computes a two-point jacobian !! at `num_sparsity_points` points. integer , intent ( in ), optional :: jacobian_method !! `id` code for the finite difference method !! to use for all `n` variables. !! see [[get_finite_difference_method]] integer , dimension ( n ), intent ( in ), optional :: jacobian_methods !! `id` codes for the finite difference method !! to use for each variable. !! see [[get_finite_difference_method]] integer , intent ( in ), optional :: class !! method class for the finite difference method !! to use for all `n` variables. !! see [[get_finite_difference_method]] integer , dimension ( n ), intent ( in ), optional :: classes !! method class for the finite difference methods !! to use for each variable. !! see [[get_finite_difference_method]] procedure ( info_f ), optional :: info !! a function the user can define !! which is called when each column !! of the jacobian is computed. !! It can be used to perform any !! setup operations. integer , intent ( in ), optional :: chunk_size !! chunk size for allocating the arrays !! (must be >0) [default is 100] logical , intent ( in ), optional :: partition_sparsity_pattern !! if the sparisty pattern is to !! be partitioned using [[DSM]] !! [default is False] integer , intent ( in ), optional :: cache_size !! if present, this is the cache size !! for the function cache !! (default is not to enable cache) real ( wp ), dimension ( n ), intent ( in ), optional :: xlow_for_sparsity !! lower bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xlow` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: xhigh_for_sparsity !! upper bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xhigh` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: dpert_for_sparsity !! for `sparsity_mode=4`, the perturbation integer , intent ( in ), optional :: sparsity_perturb_mode !! perturbation mode (required if `sparsity_mode=4`): !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` real ( wp ), intent ( in ), optional :: linear_sparsity_tol !! the equality tolerance for derivatives to !! indicate a constant jacobian element (linear sparsity) real ( wp ), intent ( in ), optional :: function_precision_tol !! the function precision. two functions values !! that are the within this tolerance are !! considered the same value. This is used !! when estimating the sparsity pattern when !! `sparsity_mode=2` in [[compute_sparsity_random]] integer , intent ( in ), optional :: num_sparsity_points !! for `sparsity_mode=4`, the number of jacobian !! evaluations used to estimate the sparsity pattern. integer :: i !! counter logical :: found !! flag for [[get_finite_difference_method]] logical :: cache !! if the cache is to be used me % use_diff = . false . ! cache: cache = present ( cache_size ) if ( cache ) cache = cache_size > 0 if ( cache ) then me % compute_function => compute_function_with_cache call me % cache % initialize ( cache_size , n , m ) else me % compute_function => problem_func call me % cache % destroy () end if ! functions: me % problem_func => problem_func if ( present ( partition_sparsity_pattern )) then me % partition_sparsity_pattern = partition_sparsity_pattern else me % partition_sparsity_pattern = . false . end if ! method: if ( allocated ( me % meth )) deallocate ( me % meth ) if ( allocated ( me % class )) deallocate ( me % class ) if ( allocated ( me % class_meths )) deallocate ( me % class_meths ) if ( present ( jacobian_method ) . and . . not . present ( jacobian_methods ) . and . & . not . present ( class ) . and . . not . present ( classes )) then ! use the same for all variable me % mode = 1 allocate ( me % meth ( n )) do i = 1 , n call get_finite_difference_method ( jacobian_method , me % meth ( i ), found ) if (. not . found ) then call me % raise_exception ( 8 , 'initialize_numdiff' ,& 'invalid jacobian_method' ) return end if end do elseif (. not . present ( jacobian_method ) . and . present ( jacobian_methods ) . and . & . not . present ( class ) . and . . not . present ( classes )) then ! specify a separate method for each variable me % mode = 1 allocate ( me % meth ( n )) do i = 1 , n call get_finite_difference_method ( jacobian_methods ( i ), me % meth ( i ), found ) if (. not . found ) then call me % raise_exception ( 9 , 'initialize_numdiff' ,& 'invalid jacobian_methods' ) return end if end do if ( me % partition_sparsity_pattern ) then call me % raise_exception ( 10 , 'initialize_numdiff' ,& 'when using partitioned sparsity pattern, ' // & 'all columns must use the same ' // & 'finite diff method.' ) return end if elseif (. not . present ( jacobian_method ) . and . . not . present ( jacobian_methods ) . and . & present ( class ) . and . . not . present ( classes )) then ! use the class for all variables me % mode = 2 allocate ( me % class ( n )) me % class = class allocate ( me % class_meths ( n )) me % class_meths ( 1 ) = get_all_methods_in_class ( class ) if ( n > 1 ) me % class_meths ( 2 : n ) = me % class_meths ( 1 ) ! just copy them over elseif (. not . present ( jacobian_method ) . and . . not . present ( jacobian_methods ) . and . & . not . present ( class ) . and . present ( classes )) then ! specify a separate class for each variable me % mode = 2 me % class = classes allocate ( me % class_meths ( n )) do i = 1 , n me % class_meths ( i ) = get_all_methods_in_class ( me % class ( i )) end do if ( me % partition_sparsity_pattern ) then call me % raise_exception ( 11 , 'initialize_numdiff' ,& 'when using partitioned sparsity pattern, ' // & 'all columns must use the same ' // & 'finite diff method.' ) end if else call me % raise_exception ( 12 , 'initialize_numdiff' ,& 'must specify one of either ' // & 'jacobian_method, jacobian_methods, class, or classes.' ) end if ! size of the problem: me % n = n me % m = m ! input variable bounds: call me % set_numdiff_bounds ( xlow , xhigh ) ! perturbation options: select case ( perturb_mode ) case ( 1 : 3 ) me % perturb_mode = perturb_mode case default call me % raise_exception ( 13 , 'initialize_numdiff' ,& 'perturb_mode must be 1, 2, or 3.' ) return end select if ( allocated ( me % dpert )) deallocate ( me % dpert ) allocate ( me % dpert ( n )) me % dpert = abs ( dpert ) ! optional: if ( present ( info )) me % info_function => info if ( present ( chunk_size )) me % chunk_size = abs ( chunk_size ) ! set the jacobian function, depending on the options: if ( me % partition_sparsity_pattern ) then me % jacobian_function => compute_jacobian_partitioned else me % jacobian_function => compute_jacobian_standard end if ! set the sparsity function call me % set_sparsity_mode ( sparsity_mode , xlow_for_sparsity , xhigh_for_sparsity ) if ( present ( linear_sparsity_tol )) me % linear_sparsity_tol = linear_sparsity_tol if ( present ( function_precision_tol )) me % function_precision_tol = function_precision_tol if ( present ( num_sparsity_points )) me % num_sparsity_points = num_sparsity_points if ( present ( dpert_for_sparsity )) then me % dpert_for_sparsity = abs ( dpert_for_sparsity ) else me % dpert_for_sparsity = dpert ! use the same dpert as the jacobian end if if ( present ( sparsity_perturb_mode )) then select case ( sparsity_perturb_mode ) case ( 1 : 3 ) me % sparsity_perturb_mode = sparsity_perturb_mode case default call me % raise_exception ( 14 , 'initialize_numdiff' ,& 'sparsity_perturb_mode must be 1, 2, or 3.' ) return end select else me % sparsity_perturb_mode = perturb_mode ! use the same perturb mode as the jacobian end if end subroutine initialize_numdiff","tags":"","loc":"proc/initialize_numdiff.html"},{"title":"destroy_numdiff_type – AoC-2023","text":"private  subroutine destroy_numdiff_type(me) destroy the numdiff_type class. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(out) :: me Called by proc~~destroy_numdiff_type~~CalledByGraph proc~destroy_numdiff_type numerical_differentiation_module::numdiff_type%destroy_numdiff_type program~test1 test1 program~test1->proc~destroy_numdiff_type program~test2 test2 program~test2->proc~destroy_numdiff_type Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy_numdiff_type ( me ) implicit none class ( numdiff_type ), intent ( out ) :: me end subroutine destroy_numdiff_type","tags":"","loc":"proc/destroy_numdiff_type.html"},{"title":"destroy_sparsity – AoC-2023","text":"private  subroutine destroy_sparsity(me) destroy a sparsity_pattern type. Type Bound sparsity_pattern Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(out) :: me Called by proc~~destroy_sparsity~~CalledByGraph proc~destroy_sparsity numerical_differentiation_module::sparsity_pattern%destroy_sparsity proc~destroy_sparsity_pattern numerical_differentiation_module::numdiff_type%destroy_sparsity_pattern proc~destroy_sparsity_pattern->proc~destroy_sparsity proc~compute_sparsity_dense numerical_differentiation_module::compute_sparsity_dense proc~compute_sparsity_dense->proc~destroy_sparsity_pattern proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~destroy_sparsity_pattern proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~destroy_sparsity_pattern proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~destroy_sparsity_pattern Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy_sparsity ( me ) implicit none class ( sparsity_pattern ), intent ( out ) :: me end subroutine destroy_sparsity","tags":"","loc":"proc/destroy_sparsity.html"},{"title":"dsm_wrapper – AoC-2023","text":"private  subroutine dsm_wrapper(me, n, m, info) Wrapper for dsm to compute the sparsity pattern partition. Type Bound sparsity_pattern Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(inout) :: me integer, intent(in) :: n number of columns of jacobian matrix integer, intent(in) :: m number of rows of jacobian matrix integer, intent(out) :: info status output from dsm Calls proc~~dsm_wrapper~~CallsGraph proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~dsm dsm_module::dsm proc~dsm_wrapper->proc~dsm proc~degr dsm_module::degr proc~dsm->proc~degr proc~ido dsm_module::ido proc~dsm->proc~ido proc~numsrt dsm_module::numsrt proc~dsm->proc~numsrt proc~seq dsm_module::seq proc~dsm->proc~seq proc~setr dsm_module::setr proc~dsm->proc~setr proc~slo dsm_module::slo proc~dsm->proc~slo proc~srtdat dsm_module::srtdat proc~dsm->proc~srtdat proc~ido->proc~numsrt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dsm_wrapper~~CalledByGraph proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~dsm_wrapper proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~dsm_wrapper proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~dsm_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dsm_wrapper ( me , n , m , info ) implicit none class ( sparsity_pattern ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of columns of jacobian matrix integer , intent ( in ) :: m !! number of rows of jacobian matrix integer , intent ( out ) :: info !! status output from [[dsm]] integer :: mingrp !! for call to [[dsm]] integer , dimension (:), allocatable :: ipntr !! for call to [[dsm]] integer , dimension (:), allocatable :: jpntr !! for call to [[dsm]] integer , dimension (:), allocatable :: irow !! for call to [[dsm]] !! (temp copy since [[dsm]] !! will modify it) integer , dimension (:), allocatable :: icol !! for call to [[dsm]] !! (temp copy since [[dsm]] !! will modify it) allocate ( ipntr ( m + 1 )) allocate ( jpntr ( n + 1 )) allocate ( me % ngrp ( n )) irow = me % irow icol = me % icol call dsm ( m , n , me % num_nonzero_elements ,& irow , icol ,& me % ngrp , me % maxgrp ,& mingrp , info , ipntr , jpntr ) end subroutine dsm_wrapper","tags":"","loc":"proc/dsm_wrapper.html"},{"title":"columns_in_partition_group – AoC-2023","text":"private  subroutine columns_in_partition_group(me, igroup, n_cols, cols, nonzero_rows, indices, status_ok) Returns the columns in a sparsity partition group. Note This is just a wrapper to get data from ngrp . Type Bound sparsity_pattern Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(in) :: me integer, intent(in) :: igroup group number. Should be >0 and <=me%mxgrp integer, intent(out) :: n_cols number of columns in the igroup group. integer, intent(out), dimension(:), allocatable :: cols the column numbers in the igroup group.\n(if none, then it is not allocated) integer, intent(out), dimension(:), allocatable :: nonzero_rows the row numbers of all the nonzero\nJacobian elements in this group integer, intent(out), dimension(:), allocatable :: indices nonzero indices in jac for a group logical, intent(out) :: status_ok true if the partition is valid Called by proc~~columns_in_partition_group~~CalledByGraph proc~columns_in_partition_group numerical_differentiation_module::sparsity_pattern%columns_in_partition_group proc~compute_jacobian_partitioned numerical_differentiation_module::compute_jacobian_partitioned proc~compute_jacobian_partitioned->proc~columns_in_partition_group Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine columns_in_partition_group ( me , igroup , n_cols , cols , nonzero_rows , indices , status_ok ) implicit none class ( sparsity_pattern ), intent ( in ) :: me integer , intent ( in ) :: igroup !! group number. Should be `>0` and `<=me%mxgrp` integer , intent ( out ) :: n_cols !! number of columns in the `igroup` group. integer , dimension (:), allocatable , intent ( out ) :: cols !! the column numbers in the `igroup` group. !! (if none, then it is not allocated) integer , dimension (:), allocatable , intent ( out ) :: nonzero_rows !! the row numbers of all the nonzero !! Jacobian elements in this group integer , dimension (:), allocatable , intent ( out ) :: indices !! nonzero indices in `jac` for a group logical , intent ( out ) :: status_ok !! true if the partition is valid integer :: i !! counter integer :: num_nonzero_elements_in_col !! number of nonzero elements in a column integer :: num_nonzero_elements_in_group !! number of nonzero elements in a group integer , dimension (:), allocatable :: col_indices !! nonzero indices in `jac` for a column if ( me % maxgrp > 0 . and . allocated ( me % ngrp )) then status_ok = . true . n_cols = count ( me % ngrp == igroup ) if ( n_cols > 0 ) then allocate ( cols ( n_cols )) cols = pack ([( i , i = 1 , size ( me % ngrp ))], mask = me % ngrp == igroup ) end if ! get all the non-zero elements in each column: num_nonzero_elements_in_group = 0 ! initialize do i = 1 , n_cols num_nonzero_elements_in_col = count ( me % icol == cols ( i )) if ( num_nonzero_elements_in_col /= 0 ) then ! there are functions to ! compute in this column num_nonzero_elements_in_group = num_nonzero_elements_in_group + & num_nonzero_elements_in_col if ( allocated ( col_indices )) deallocate ( col_indices ) allocate ( col_indices ( num_nonzero_elements_in_col )) col_indices = pack ( me % indices , mask = me % icol == cols ( i )) if ( allocated ( nonzero_rows )) then nonzero_rows = [ nonzero_rows , me % irow ( col_indices )] indices = [ indices , col_indices ] else nonzero_rows = me % irow ( col_indices ) indices = col_indices end if end if end do else status_ok = . false . end if end subroutine columns_in_partition_group","tags":"","loc":"proc/columns_in_partition_group.html"},{"title":"destroy_sparsity_pattern – AoC-2023","text":"private  subroutine destroy_sparsity_pattern(me) Destroy the sparsity pattern in the class. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me Calls proc~~destroy_sparsity_pattern~~CallsGraph proc~destroy_sparsity_pattern numerical_differentiation_module::numdiff_type%destroy_sparsity_pattern proc~destroy_sparsity numerical_differentiation_module::sparsity_pattern%destroy_sparsity proc~destroy_sparsity_pattern->proc~destroy_sparsity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~destroy_sparsity_pattern~~CalledByGraph proc~destroy_sparsity_pattern numerical_differentiation_module::numdiff_type%destroy_sparsity_pattern proc~compute_sparsity_dense numerical_differentiation_module::compute_sparsity_dense proc~compute_sparsity_dense->proc~destroy_sparsity_pattern proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~destroy_sparsity_pattern proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~destroy_sparsity_pattern proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~destroy_sparsity_pattern Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy_sparsity_pattern ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me call me % sparsity % destroy () end subroutine destroy_sparsity_pattern","tags":"","loc":"proc/destroy_sparsity_pattern.html"},{"title":"compute_indices – AoC-2023","text":"private  subroutine compute_indices(me) Computes the indices vector in the class. Type Bound sparsity_pattern Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(inout) :: me Called by proc~~compute_indices~~CalledByGraph proc~compute_indices numerical_differentiation_module::sparsity_pattern%compute_indices proc~compute_sparsity_dense numerical_differentiation_module::compute_sparsity_dense proc~compute_sparsity_dense->proc~compute_indices proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~compute_indices proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~compute_indices proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~compute_indices Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_indices ( me ) implicit none class ( sparsity_pattern ), intent ( inout ) :: me integer :: i !! counter allocate ( me % indices ( me % num_nonzero_elements )) me % indices = [( i , i = 1 , me % num_nonzero_elements )] end subroutine compute_indices","tags":"","loc":"proc/compute_indices.html"},{"title":"set_sparsity_pattern – AoC-2023","text":"private  subroutine set_sparsity_pattern(me, irow, icol, linear_irow, linear_icol, linear_vals, maxgrp, ngrp) To specify the sparsity pattern directly if it is already known. Note If specifying the linear pattern, all three optional arguments\n      must be present. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in), dimension(:) :: irow sparsity pattern nonzero elements row indices integer, intent(in), dimension(:) :: icol sparsity pattern nonzero elements column indices integer, intent(in), optional, dimension(:) :: linear_irow linear sparsity pattern nonzero elements row indices integer, intent(in), optional, dimension(:) :: linear_icol linear sparsity pattern nonzero elements column indices real(kind=wp), intent(in), optional, dimension(:) :: linear_vals linear sparsity values (constant elements of the Jacobian) integer, intent(in), optional :: maxgrp DSM sparsity partition\n[only used if me%partition_sparsity_pattern=True ] integer, intent(in), optional, dimension(:) :: ngrp DSM sparsity partition (size n )\n[only used if me%partition_sparsity_pattern=True ] Calls proc~~set_sparsity_pattern~~CallsGraph proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~compute_indices numerical_differentiation_module::sparsity_pattern%compute_indices proc~set_sparsity_pattern->proc~compute_indices proc~destroy_sparsity_pattern numerical_differentiation_module::numdiff_type%destroy_sparsity_pattern proc~set_sparsity_pattern->proc~destroy_sparsity_pattern proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~set_sparsity_pattern->proc~dsm_wrapper proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~set_sparsity_pattern->proc~raise_exception proc~destroy_sparsity numerical_differentiation_module::sparsity_pattern%destroy_sparsity proc~destroy_sparsity_pattern->proc~destroy_sparsity proc~dsm dsm_module::dsm proc~dsm_wrapper->proc~dsm proc~degr dsm_module::degr proc~dsm->proc~degr proc~ido dsm_module::ido proc~dsm->proc~ido proc~numsrt dsm_module::numsrt proc~dsm->proc~numsrt proc~seq dsm_module::seq proc~dsm->proc~seq proc~setr dsm_module::setr proc~dsm->proc~setr proc~slo dsm_module::slo proc~dsm->proc~slo proc~srtdat dsm_module::srtdat proc~dsm->proc~srtdat proc~ido->proc~numsrt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_sparsity_pattern ( me , irow , icol , linear_irow , linear_icol , linear_vals , maxgrp , ngrp ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , dimension (:), intent ( in ) :: irow !! sparsity pattern nonzero elements row indices integer , dimension (:), intent ( in ) :: icol !! sparsity pattern nonzero elements column indices integer , dimension (:), intent ( in ), optional :: linear_irow !! linear sparsity pattern nonzero elements row indices integer , dimension (:), intent ( in ), optional :: linear_icol !! linear sparsity pattern nonzero elements column indices real ( wp ), dimension (:), intent ( in ), optional :: linear_vals !! linear sparsity values (constant elements of the Jacobian) integer , intent ( in ), optional :: maxgrp !! DSM sparsity partition !! [only used if `me%partition_sparsity_pattern=True`] integer , dimension (:), intent ( in ), optional :: ngrp !! DSM sparsity partition (size `n`) !! [only used if `me%partition_sparsity_pattern=True`] integer :: info !! status output form [[dsm]] call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions if ( size ( irow ) /= size ( icol ) . or . any ( irow > me % m ) . or . any ( icol > me % n )) then call me % raise_exception ( 15 , 'set_sparsity_pattern' ,& 'invalid inputs' ) return else me % sparsity % sparsity_computed = . true . me % sparsity % num_nonzero_elements = size ( irow ) me % sparsity % irow = irow me % sparsity % icol = icol call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) then if ( present ( maxgrp ) . and . present ( ngrp )) then ! use the user-input partition: if ( maxgrp > 0 . and . all ( ngrp >= 1 . and . ngrp <= maxgrp ) . and . size ( ngrp ) == me % n ) then me % sparsity % maxgrp = maxgrp me % sparsity % ngrp = ngrp else call me % raise_exception ( 28 , 'set_sparsity_pattern' ,& 'invalid sparsity partition inputs.' ) return end if else call me % sparsity % dsm_wrapper ( me % n , me % m , info ) if ( info /= 1 ) then call me % raise_exception ( 16 , 'set_sparsity_pattern' ,& 'error partitioning sparsity pattern.' ) return end if end if end if end if ! linear pattern: if ( present ( linear_irow ) . and . present ( linear_icol ) . and . present ( linear_vals )) then if ( size ( linear_irow ) /= size ( linear_icol ) . or . & size ( linear_vals ) /= size ( linear_icol ) . or . & any ( linear_irow > me % m ) . or . & any ( linear_icol > me % n )) then call me % raise_exception ( 17 , 'set_sparsity_pattern' ,& 'invalid linear sparsity pattern' ) return else me % sparsity % linear_irow = linear_irow me % sparsity % linear_icol = linear_icol me % sparsity % linear_vals = linear_vals me % sparsity % linear_sparsity_computed = . true . me % sparsity % num_nonzero_linear_elements = size ( linear_irow ) end if end if end subroutine set_sparsity_pattern","tags":"","loc":"proc/set_sparsity_pattern.html"},{"title":"compute_sparsity_dense – AoC-2023","text":"private  subroutine compute_sparsity_dense(me, x) assume all elements of Jacobian are non-zero. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) Calls proc~~compute_sparsity_dense~~CallsGraph proc~compute_sparsity_dense numerical_differentiation_module::compute_sparsity_dense proc~compute_indices numerical_differentiation_module::sparsity_pattern%compute_indices proc~compute_sparsity_dense->proc~compute_indices proc~destroy_sparsity_pattern numerical_differentiation_module::numdiff_type%destroy_sparsity_pattern proc~compute_sparsity_dense->proc~destroy_sparsity_pattern proc~generate_dense_sparsity_partition numerical_differentiation_module::numdiff_type%generate_dense_sparsity_partition proc~compute_sparsity_dense->proc~generate_dense_sparsity_partition proc~destroy_sparsity numerical_differentiation_module::sparsity_pattern%destroy_sparsity proc~destroy_sparsity_pattern->proc~destroy_sparsity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_sparsity_dense ( me , x ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) integer :: i !! counter integer :: r !! row counter integer :: c !! column counter call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions me % sparsity % num_nonzero_elements = me % m * me % n allocate ( me % sparsity % irow ( me % sparsity % num_nonzero_elements )) allocate ( me % sparsity % icol ( me % sparsity % num_nonzero_elements )) call me % sparsity % compute_indices () ! create the dense matrix: i = 0 do c = 1 , me % n do r = 1 , me % m i = i + 1 me % sparsity % irow ( i ) = r me % sparsity % icol ( i ) = c end do end do ! No real need for this, since it can't be partitioned (all elements are true) if ( me % partition_sparsity_pattern ) call me % generate_dense_sparsity_partition () me % sparsity % sparsity_computed = . true . end subroutine compute_sparsity_dense","tags":"","loc":"proc/compute_sparsity_dense.html"},{"title":"generate_dense_sparsity_partition – AoC-2023","text":"private  subroutine generate_dense_sparsity_partition(me) Generate a \"dense\" sparsity partition. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me Called by proc~~generate_dense_sparsity_partition~~CalledByGraph proc~generate_dense_sparsity_partition numerical_differentiation_module::numdiff_type%generate_dense_sparsity_partition proc~compute_sparsity_dense numerical_differentiation_module::compute_sparsity_dense proc~compute_sparsity_dense->proc~generate_dense_sparsity_partition proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~generate_dense_sparsity_partition Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine generate_dense_sparsity_partition ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer :: i !! counter if ( me % exception_raised ) return ! check for exceptions me % sparsity % maxgrp = me % n allocate ( me % sparsity % ngrp ( me % n )) me % sparsity % ngrp = [( i , i = 1 , me % n )] end subroutine generate_dense_sparsity_partition","tags":"","loc":"proc/generate_dense_sparsity_partition.html"},{"title":"compute_sparsity_random – AoC-2023","text":"private  subroutine compute_sparsity_random(me, x) Compute the sparsity pattern by computing the function at three\n\"random\" points in the [ xlow_for_sparsity , xhigh_for_sparsity ] interval\nand checking if the function values are the same. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n )\n(not used here) Calls proc~~compute_sparsity_random~~CallsGraph proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random interface~expand_vector numdiff_utilities_module::expand_vector proc~compute_sparsity_random->interface~expand_vector proc~compute_indices numerical_differentiation_module::sparsity_pattern%compute_indices proc~compute_sparsity_random->proc~compute_indices proc~destroy_sparsity_pattern numerical_differentiation_module::numdiff_type%destroy_sparsity_pattern proc~compute_sparsity_random->proc~destroy_sparsity_pattern proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~compute_sparsity_random->proc~dsm_wrapper proc~equal_within_tol numdiff_utilities_module::equal_within_tol proc~compute_sparsity_random->proc~equal_within_tol proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_sparsity_random->proc~raise_exception proc~resize_sparsity_vectors numerical_differentiation_module::numdiff_type%resize_sparsity_vectors proc~compute_sparsity_random->proc~resize_sparsity_vectors proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector->proc~expand_vector_real proc~destroy_sparsity numerical_differentiation_module::sparsity_pattern%destroy_sparsity proc~destroy_sparsity_pattern->proc~destroy_sparsity proc~dsm dsm_module::dsm proc~dsm_wrapper->proc~dsm proc~resize_sparsity_vectors->interface~expand_vector proc~degr dsm_module::degr proc~dsm->proc~degr proc~ido dsm_module::ido proc~dsm->proc~ido proc~numsrt dsm_module::numsrt proc~dsm->proc~numsrt proc~seq dsm_module::seq proc~dsm->proc~seq proc~setr dsm_module::setr proc~dsm->proc~setr proc~slo dsm_module::slo proc~dsm->proc~slo proc~srtdat dsm_module::srtdat proc~dsm->proc~srtdat proc~ido->proc~numsrt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_sparsity_random ( me , x ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) !! (not used here) integer :: i !! column counter integer :: j !! row counter integer :: n_icol !! `icol` size counter integer :: n_irow !! `irow` size counter integer :: n_linear_icol !! `linear_icol` size counter integer :: n_linear_irow !! `linear_irow` size counter integer :: n_linear_vals !! `linear_vals` size counter integer , dimension ( me % m ) :: idx !! indices to compute `[1,2,...,m]` real ( wp ), dimension ( me % n ) :: x1 !! perturbed variable vector real ( wp ), dimension ( me % n ) :: x2 !! perturbed variable vector real ( wp ), dimension ( me % n ) :: x3 !! perturbed variable vector real ( wp ), dimension ( me % n ) :: x4 !! perturbed variable vector real ( wp ), dimension ( me % m ) :: f1 !! function evaluation real ( wp ), dimension ( me % m ) :: f2 !! function evaluation real ( wp ), dimension ( me % m ) :: f3 !! function evaluation real ( wp ), dimension ( me % m ) :: f4 !! function evaluation real ( wp ) :: dfdx1 !! for linear sparsity estimation real ( wp ) :: dfdx2 !! for linear sparsity estimation real ( wp ) :: dfdx3 !! for linear sparsity estimation real ( wp ) :: dfdx !! for linear sparsity estimation integer :: info !! status output form [[dsm]] real ( wp ), dimension ( 4 ), parameter :: coeffs = [ 0.20123456787654321_wp ,& 0.40123456787654321_wp ,& 0.60123456787654321_wp ,& 0.80123456787654321_wp ] !! Pick three pseudo-random points roughly equally spaced. !! (add some noise in attempt to avoid freak zeros) !!```` !! xlow---|----|--x--|---xhigh !!        1    2     3 !!```` !! !! Also using an extra point to estimate the !! constant elements of the Jacobian. ! initialize: call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions ! error check: if (. not . allocated ( me % xlow_for_sparsity ) . or . . not . allocated ( me % xhigh_for_sparsity )) then call me % raise_exception ( 18 , 'compute_sparsity_random' ,& 'the x bounds have not been set.' ) return end if associate ( xlow => me % xlow_for_sparsity , xhigh => me % xhigh_for_sparsity ) ! we will compute all the functions: idx = [( i , i = 1 , me % m )] n_icol = 0 ! initialize vector size counters n_irow = 0 n_linear_icol = 0 n_linear_irow = 0 n_linear_vals = 0 ! define a nominal point roughly in the middle: x2 = xlow + ( xhigh - xlow ) * coeffs ( 2 ) call me % compute_function ( x2 , f2 , idx ) if ( me % exception_raised ) return ! check for exceptions if ( me % compute_linear_sparsity_pattern ) then ! we need another point where we perturb all the variables ! to check to make sure it is linear in only one variable. x4 = xlow + ( xhigh - xlow ) * coeffs ( 4 ) call me % compute_function ( x4 , f4 , idx ) if ( me % exception_raised ) return ! check for exceptions end if do i = 1 , me % n ! columns of Jacobian ! restore nominal: x1 = x2 x3 = x2 x1 ( i ) = xlow ( i ) + ( xhigh ( i ) - xlow ( i )) * coeffs ( 1 ) x3 ( i ) = xlow ( i ) + ( xhigh ( i ) - xlow ( i )) * coeffs ( 3 ) call me % compute_function ( x1 , f1 , idx ) if ( me % exception_raised ) return ! check for exceptions call me % compute_function ( x3 , f3 , idx ) if ( me % exception_raised ) return ! check for exceptions do j = 1 , me % m ! each function (rows of Jacobian) if ( equal_within_tol ([ f1 ( j ), f2 ( j ), f3 ( j )], me % function_precision_tol )) then ! no change in the function, so no sparsity element here. cycle else if ( me % compute_linear_sparsity_pattern ) then ! if computing the linear pattern separately. ! do the three points lie on a line? (x1,f1) -> (x2, f2), -> (x3,f3) ! [check that the slopes are equal within a tolerance] dfdx1 = ( f1 ( j ) - f2 ( j )) / ( x1 ( i ) - x2 ( i )) ! slope of line from 1->2 dfdx2 = ( f1 ( j ) - f3 ( j )) / ( x1 ( i ) - x3 ( i )) ! slope of line from 1->3 dfdx3 = ( f1 ( j ) - f4 ( j )) / ( x1 ( i ) - x4 ( i )) ! slope of line from 1->4 if ( equal_within_tol ([ dfdx1 , dfdx2 , dfdx3 ], me % linear_sparsity_tol )) then ! this is a linear element (constant value) dfdx = ( dfdx1 + dfdx2 + dfdx3 ) / 3.0_wp ! just take the average and use that call expand_vector ( me % sparsity % linear_icol , n_linear_icol , me % chunk_size , val = i ) call expand_vector ( me % sparsity % linear_irow , n_linear_irow , me % chunk_size , val = j ) call expand_vector ( me % sparsity % linear_vals , n_linear_vals , me % chunk_size , val = dfdx ) cycle ! this element will not be added to the nonlinear pattern end if end if ! otherwise, add it to the nonlinear pattern: call expand_vector ( me % sparsity % icol , n_icol , me % chunk_size , val = i ) call expand_vector ( me % sparsity % irow , n_irow , me % chunk_size , val = j ) end if end do end do ! resize to correct size: call me % resize_sparsity_vectors ( n_icol , n_irow , n_linear_icol ,& n_linear_irow , n_linear_vals ) end associate call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) then call me % sparsity % dsm_wrapper ( me % n , me % m , info ) if ( info /= 1 ) then call me % raise_exception ( 19 , 'compute_sparsity_random' ,& 'error partitioning sparsity pattern.' ) return end if end if ! finished: me % sparsity % sparsity_computed = . true . end subroutine compute_sparsity_random","tags":"","loc":"proc/compute_sparsity_random.html"},{"title":"resize_sparsity_vectors – AoC-2023","text":"private  subroutine resize_sparsity_vectors(me, n_icol, n_irow, n_linear_icol, n_linear_irow, n_linear_vals) Resize the sparsity arrays after accumulating them. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(inout) :: n_icol integer, intent(inout) :: n_irow integer, intent(inout) :: n_linear_icol integer, intent(inout) :: n_linear_irow integer, intent(inout) :: n_linear_vals Calls proc~~resize_sparsity_vectors~~CallsGraph proc~resize_sparsity_vectors numerical_differentiation_module::numdiff_type%resize_sparsity_vectors interface~expand_vector numdiff_utilities_module::expand_vector proc~resize_sparsity_vectors->interface~expand_vector proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector->proc~expand_vector_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~resize_sparsity_vectors~~CalledByGraph proc~resize_sparsity_vectors numerical_differentiation_module::numdiff_type%resize_sparsity_vectors proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~resize_sparsity_vectors proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~resize_sparsity_vectors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine resize_sparsity_vectors ( me , n_icol , n_irow , n_linear_icol ,& n_linear_irow , n_linear_vals ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( inout ) :: n_icol integer , intent ( inout ) :: n_irow integer , intent ( inout ) :: n_linear_icol integer , intent ( inout ) :: n_linear_irow integer , intent ( inout ) :: n_linear_vals if ( me % exception_raised ) return ! check for exceptions ! resize to correct size: if ( allocated ( me % sparsity % icol )) then call expand_vector ( me % sparsity % icol , n_icol , me % chunk_size , finished = . true .) call expand_vector ( me % sparsity % irow , n_irow , me % chunk_size , finished = . true .) me % sparsity % num_nonzero_elements = size ( me % sparsity % irow ) else me % sparsity % num_nonzero_elements = 0 end if ! linear pattern (note: there may be no linear elements): me % sparsity % linear_sparsity_computed = me % compute_linear_sparsity_pattern . and . & allocated ( me % sparsity % linear_vals ) if ( me % sparsity % linear_sparsity_computed ) then call expand_vector ( me % sparsity % linear_icol , n_linear_icol , me % chunk_size , finished = . true .) call expand_vector ( me % sparsity % linear_irow , n_linear_irow , me % chunk_size , finished = . true .) call expand_vector ( me % sparsity % linear_vals , n_linear_vals , me % chunk_size , finished = . true .) me % sparsity % num_nonzero_linear_elements = n_linear_vals else me % sparsity % num_nonzero_linear_elements = 0 end if end subroutine resize_sparsity_vectors","tags":"","loc":"proc/resize_sparsity_vectors.html"},{"title":"compute_sparsity_random_2 – AoC-2023","text":"private  subroutine compute_sparsity_random_2(me, x) Compute the sparsity pattern by computing a 2-point jacobian at a specified\nnumber of \"random\" points ( num_sparsity_points ) in the\n[ xlow_for_sparsity , xhigh_for_sparsity ] interval and checking if\nthey are the same. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n )\n(not used here) Calls proc~~compute_sparsity_random_2~~CallsGraph proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 interface~expand_vector numdiff_utilities_module::expand_vector proc~compute_sparsity_random_2->interface~expand_vector proc~compute_indices numerical_differentiation_module::sparsity_pattern%compute_indices proc~compute_sparsity_random_2->proc~compute_indices proc~compute_jacobian_for_sparsity numerical_differentiation_module::numdiff_type%compute_jacobian_for_sparsity proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity proc~destroy_sparsity_pattern numerical_differentiation_module::numdiff_type%destroy_sparsity_pattern proc~compute_sparsity_random_2->proc~destroy_sparsity_pattern proc~divide_interval numdiff_utilities_module::divide_interval proc~compute_sparsity_random_2->proc~divide_interval proc~dsm_wrapper numerical_differentiation_module::sparsity_pattern%dsm_wrapper proc~compute_sparsity_random_2->proc~dsm_wrapper proc~equal_within_tol numdiff_utilities_module::equal_within_tol proc~compute_sparsity_random_2->proc~equal_within_tol proc~generate_dense_sparsity_partition numerical_differentiation_module::numdiff_type%generate_dense_sparsity_partition proc~compute_sparsity_random_2->proc~generate_dense_sparsity_partition proc~get_all_methods_in_class numerical_differentiation_module::get_all_methods_in_class proc~compute_sparsity_random_2->proc~get_all_methods_in_class proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_sparsity_random_2->proc~raise_exception proc~resize_sparsity_vectors numerical_differentiation_module::numdiff_type%resize_sparsity_vectors proc~compute_sparsity_random_2->proc~resize_sparsity_vectors proc~expand_vector_int numdiff_utilities_module::expand_vector_int interface~expand_vector->proc~expand_vector_int proc~expand_vector_real numdiff_utilities_module::expand_vector_real interface~expand_vector->proc~expand_vector_real proc~compute_sparsity_perturbation_vector numerical_differentiation_module::numdiff_type%compute_sparsity_perturbation_vector proc~compute_jacobian_for_sparsity->proc~compute_sparsity_perturbation_vector proc~perturb_x_and_compute_f numerical_differentiation_module::numdiff_type%perturb_x_and_compute_f proc~compute_jacobian_for_sparsity->proc~perturb_x_and_compute_f proc~select_finite_diff_method numerical_differentiation_module::numdiff_type%select_finite_diff_method proc~compute_jacobian_for_sparsity->proc~select_finite_diff_method proc~destroy_sparsity numerical_differentiation_module::sparsity_pattern%destroy_sparsity proc~destroy_sparsity_pattern->proc~destroy_sparsity interface~unique~2 numdiff_utilities_module::unique proc~divide_interval->interface~unique~2 proc~dsm dsm_module::dsm proc~dsm_wrapper->proc~dsm proc~get_finite_difference_method numerical_differentiation_module::get_finite_difference_method proc~get_all_methods_in_class->proc~get_finite_difference_method proc~resize_sparsity_vectors->interface~expand_vector proc~unique_int numdiff_utilities_module::unique_int interface~unique~2->proc~unique_int proc~unique_real numdiff_utilities_module::unique_real interface~unique~2->proc~unique_real proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_sparsity_perturbation_vector->proc~compute_perturb_vector proc~degr dsm_module::degr proc~dsm->proc~degr proc~ido dsm_module::ido proc~dsm->proc~ido proc~numsrt dsm_module::numsrt proc~dsm->proc~numsrt proc~seq dsm_module::seq proc~dsm->proc~seq proc~setr dsm_module::setr proc~dsm->proc~setr proc~slo dsm_module::slo proc~dsm->proc~slo proc~srtdat dsm_module::srtdat proc~dsm->proc~srtdat proc~compute_perturb_vector->proc~raise_exception proc~ido->proc~numsrt proc~unique_int->interface~expand_vector interface~sort_ascending numdiff_utilities_module::sort_ascending proc~unique_int->interface~sort_ascending proc~unique_real->interface~expand_vector proc~unique_real->interface~sort_ascending proc~sort_ascending_int numdiff_utilities_module::sort_ascending_int interface~sort_ascending->proc~sort_ascending_int proc~sort_ascending_real numdiff_utilities_module::sort_ascending_real interface~sort_ascending->proc~sort_ascending_real interface~swap~2 numdiff_utilities_module::swap proc~sort_ascending_int->interface~swap~2 proc~sort_ascending_real->interface~swap~2 proc~swap_int numdiff_utilities_module::swap_int interface~swap~2->proc~swap_int proc~swap_real numdiff_utilities_module::swap_real interface~swap~2->proc~swap_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_sparsity_random_2 ( me , x ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) !! (not used here) type :: jac_type !! so we can define an array of jacobian columns real ( wp ), dimension (:), allocatable :: jac !! a column of the jacobian end type jac_type real ( wp ), dimension (:), allocatable :: coeffs !! coefficients for computing `xp` real ( wp ), dimension (:,:), allocatable :: xp !! perturbed `x` array (size `n,num_sparsity_points`) type ( jac_type ), dimension (:), allocatable :: jac_array !! array of jacobian columns type ( sparsity_pattern ) :: tmp_sparsity_pattern !! will accumulate the pattern here !! and copy it into the class when !! finished. integer :: i !! counter for the number of points integer :: j !! counter integer :: icol !! column counter integer :: irow !! row counter real ( wp ) :: dfdx !! value of a jacobian element integer :: n_icol !! `icol` size counter integer :: n_irow !! `irow` size counter integer :: n_linear_icol !! `linear_icol` size counter integer :: n_linear_irow !! `linear_irow` size counter integer :: n_linear_vals !! `linear_vals` size counter type ( meth_array ) :: class_meths !! set of finite diff methods to use real ( wp ), dimension (:), allocatable :: jac !! array of jacobian element values integer :: info !! status output form [[dsm]] ! initialize: call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions ! error check: if (. not . allocated ( me % xlow_for_sparsity ) . or . . not . allocated ( me % xhigh_for_sparsity )) then call me % raise_exception ( 20 , 'compute_sparsity_random_2' ,& 'the x bounds have not been set.' ) return end if ! compute the coefficients: coeffs = divide_interval ( me % num_sparsity_points ) ! save the initial settings: tmp_sparsity_pattern = me % sparsity ! we create a provisional sparsity pattern here, ! to compute one row at a time: me % sparsity % irow = [( irow , irow = 1 , me % m )] me % sparsity % sparsity_computed = . true . me % sparsity % num_nonzero_elements = me % m call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) call me % generate_dense_sparsity_partition () n_icol = 0 n_irow = 0 n_linear_icol = 0 n_linear_irow = 0 n_linear_vals = 0 allocate ( jac ( me % num_sparsity_points )) ! the idea here is to compute the (dense) jacobian ! one column at at time, and keep a running track of ! the ones that have changed. ! first precompute the perturbation arrays for each point: allocate ( xp ( me % n , me % num_sparsity_points )) do i = 1 , me % num_sparsity_points xp (:, i ) = me % xlow_for_sparsity + ( me % xhigh_for_sparsity - me % xlow_for_sparsity ) * coeffs ( i ) end do ! we will use 2-point methods (simple differences): class_meths = get_all_methods_in_class ( 2 ) do icol = 1 , me % n ! column loop ! size the array: if ( allocated ( jac_array )) deallocate ( jac_array ) allocate ( jac_array ( me % num_sparsity_points )) ! compute the ith column of the jacobian: me % sparsity % icol = [( icol , j = 1 , me % m )] do i = 1 , me % num_sparsity_points call me % compute_jacobian_for_sparsity ( icol , class_meths , xp (:, i ), jac_array ( i )% jac ) if ( me % exception_raised ) return ! check for exceptions end do ! check each row: do irow = 1 , me % m ! get the jacobian values for this row,col for all the points: do j = 1 , me % num_sparsity_points jac ( j ) = jac_array ( j )% jac ( irow ) end do ! put the results into the tmp_sparsity_pattern if ( equal_within_tol ([ 0.0_wp , jac ], me % linear_sparsity_tol )) then ! they are all zero cycle else if ( me % compute_linear_sparsity_pattern ) then if ( equal_within_tol ( jac , me % linear_sparsity_tol )) then ! this is a linear element (constant value) dfdx = sum ( jac ) / me % num_sparsity_points ! just take the average and use that call expand_vector ( tmp_sparsity_pattern % linear_icol , n_linear_icol , me % chunk_size , val = icol ) call expand_vector ( tmp_sparsity_pattern % linear_irow , n_linear_irow , me % chunk_size , val = irow ) call expand_vector ( tmp_sparsity_pattern % linear_vals , n_linear_vals , me % chunk_size , val = dfdx ) cycle ! this element will not be added to the nonlinear pattern end if end if ! otherwise, add it to the nonlinear pattern: call expand_vector ( tmp_sparsity_pattern % icol , n_icol , me % chunk_size , val = icol ) call expand_vector ( tmp_sparsity_pattern % irow , n_irow , me % chunk_size , val = irow ) end if end do end do ! copy over the computed pattern: me % sparsity = tmp_sparsity_pattern ! resize to correct size: call me % resize_sparsity_vectors ( n_icol , n_irow , n_linear_icol ,& n_linear_irow , n_linear_vals ) call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) then call me % sparsity % dsm_wrapper ( me % n , me % m , info ) if ( info /= 1 ) then call me % raise_exception ( 21 , 'compute_sparsity_random_2' ,& 'error partitioning sparsity pattern.' ) return end if end if me % sparsity % sparsity_computed = . true . end subroutine compute_sparsity_random_2","tags":"","loc":"proc/compute_sparsity_random_2.html"},{"title":"compute_sparsity_pattern – AoC-2023","text":"private  subroutine compute_sparsity_pattern(me, x, irow, icol, linear_irow, linear_icol, linear_vals) Computes the sparsity pattern and return it.\nUses the settings currently in the class. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) integer, intent(out), dimension(:), allocatable :: irow sparsity pattern nonzero elements row indices integer, intent(out), dimension(:), allocatable :: icol sparsity pattern nonzero elements column indices integer, intent(out), optional, dimension(:), allocatable :: linear_irow linear sparsity pattern\nnonzero elements row indices integer, intent(out), optional, dimension(:), allocatable :: linear_icol linear sparsity pattern nonzero\nelements column indices real(kind=wp), intent(out), optional, dimension(:), allocatable :: linear_vals linear sparsity values (constant\nelements of the Jacobian) Calls proc~~compute_sparsity_pattern~~CallsGraph proc~compute_sparsity_pattern numerical_differentiation_module::numdiff_type%compute_sparsity_pattern proc~get_sparsity_pattern numerical_differentiation_module::numdiff_type%get_sparsity_pattern proc~compute_sparsity_pattern->proc~get_sparsity_pattern Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_sparsity_pattern ( me , x , irow , icol , linear_irow , linear_icol , linear_vals ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) integer , dimension (:), allocatable , intent ( out ) :: irow !! sparsity pattern nonzero elements row indices integer , dimension (:), allocatable , intent ( out ) :: icol !! sparsity pattern nonzero elements column indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_irow !! linear sparsity pattern !! nonzero elements row indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_icol !! linear sparsity pattern nonzero !! elements column indices real ( wp ), dimension (:), allocatable , intent ( out ), optional :: linear_vals !! linear sparsity values (constant !! elements of the Jacobian) if ( me % exception_raised ) return ! check for exceptions if ( associated ( me % compute_sparsity )) then call me % compute_sparsity ( x ) if ( me % exception_raised ) return ! check for exceptions call me % get_sparsity_pattern ( irow , icol , linear_irow , linear_icol , linear_vals ) end if end subroutine compute_sparsity_pattern","tags":"","loc":"proc/compute_sparsity_pattern.html"},{"title":"get_sparsity_pattern – AoC-2023","text":"private  subroutine get_sparsity_pattern(me, irow, icol, linear_irow, linear_icol, linear_vals, maxgrp, ngrp) Returns the sparsity pattern from the class.\nIf it hasn't been computed, the output arrays will not be allocated. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: irow sparsity pattern nonzero elements row indices integer, intent(out), dimension(:), allocatable :: icol sparsity pattern nonzero elements column indices integer, intent(out), optional, dimension(:), allocatable :: linear_irow linear sparsity pattern\nnonzero elements row indices integer, intent(out), optional, dimension(:), allocatable :: linear_icol linear sparsity pattern nonzero\nelements column indices real(kind=wp), intent(out), optional, dimension(:), allocatable :: linear_vals linear sparsity values (constant\nelements of the Jacobian) integer, intent(out), optional :: maxgrp DSM sparsity partition integer, intent(out), optional, dimension(:), allocatable :: ngrp DSM sparsity partition Called by proc~~get_sparsity_pattern~~CalledByGraph proc~get_sparsity_pattern numerical_differentiation_module::numdiff_type%get_sparsity_pattern proc~compute_sparsity_pattern numerical_differentiation_module::numdiff_type%compute_sparsity_pattern proc~compute_sparsity_pattern->proc~get_sparsity_pattern Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_sparsity_pattern ( me , irow , icol ,& linear_irow , linear_icol , linear_vals ,& maxgrp , ngrp ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , dimension (:), allocatable , intent ( out ) :: irow !! sparsity pattern nonzero elements row indices integer , dimension (:), allocatable , intent ( out ) :: icol !! sparsity pattern nonzero elements column indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_irow !! linear sparsity pattern !! nonzero elements row indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_icol !! linear sparsity pattern nonzero !! elements column indices real ( wp ), dimension (:), allocatable , intent ( out ), optional :: linear_vals !! linear sparsity values (constant !! elements of the Jacobian) integer , intent ( out ), optional :: maxgrp !! DSM sparsity partition integer , dimension (:), allocatable , intent ( out ), optional :: ngrp !! DSM sparsity partition if ( me % exception_raised ) return ! check for exceptions if ( allocated ( me % sparsity % irow ) . and . allocated ( me % sparsity % icol )) then irow = me % sparsity % irow icol = me % sparsity % icol end if ! optional linear pattern output: if ( present ( linear_irow )) then if ( allocated ( me % sparsity % linear_irow )) linear_irow = me % sparsity % linear_irow end if if ( present ( linear_icol )) then if ( allocated ( me % sparsity % linear_icol )) linear_icol = me % sparsity % linear_icol end if if ( present ( linear_vals )) then if ( allocated ( me % sparsity % linear_vals )) linear_vals = me % sparsity % linear_vals end if ! optional DSM partition: if ( present ( ngrp ) . and . allocated ( me % sparsity % ngrp )) ngrp = me % sparsity % ngrp if ( present ( maxgrp )) maxgrp = me % sparsity % maxgrp end subroutine get_sparsity_pattern","tags":"","loc":"proc/get_sparsity_pattern.html"},{"title":"compute_jacobian_dense – AoC-2023","text":"private  subroutine compute_jacobian_dense(me, x, jac) just a wrapper for compute_jacobian , that returns a dense ( m x n ) matrix. Note This one will include the constant elements if the linear pattern is available. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:,:), allocatable :: jac the jacobian matrix Calls proc~~compute_jacobian_dense~~CallsGraph proc~compute_jacobian_dense numerical_differentiation_module::numdiff_type%compute_jacobian_dense proc~compute_jacobian numerical_differentiation_module::numdiff_type%compute_jacobian proc~compute_jacobian_dense->proc~compute_jacobian proc~compute_perturbation_vector numerical_differentiation_module::numdiff_type%compute_perturbation_vector proc~compute_jacobian->proc~compute_perturbation_vector proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_jacobian->proc~raise_exception proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_perturbation_vector->proc~compute_perturb_vector proc~compute_perturb_vector->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian_dense ( me , x , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:,:), allocatable , intent ( out ) :: jac !! the jacobian matrix real ( wp ), dimension (:), allocatable :: jac_vec !! sparse jacobian representation integer :: i !! counter if ( me % exception_raised ) return ! check for exceptions ! size output matrix: allocate ( jac ( me % m , me % n )) ! convert to dense form: jac = zero ! compute sparse form of jacobian: call me % compute_jacobian ( x , jac_vec ) if ( me % exception_raised ) return ! check for exceptions if ( allocated ( jac_vec )) then ! add the nonlinear elements: do i = 1 , me % sparsity % num_nonzero_elements jac ( me % sparsity % irow ( i ), me % sparsity % icol ( i )) = jac_vec ( i ) end do deallocate ( jac_vec ) end if ! add the constant elements if necessary: do i = 1 , me % sparsity % num_nonzero_linear_elements jac ( me % sparsity % linear_irow ( i ), me % sparsity % linear_icol ( i )) = me % sparsity % linear_vals ( i ) end do end subroutine compute_jacobian_dense","tags":"","loc":"proc/compute_jacobian_dense.html"},{"title":"perturb_x_and_compute_f – AoC-2023","text":"private  subroutine perturb_x_and_compute_f(me, x, dx_factor, dx, df_factor, column, idx, df) Perturb the specified optimization variable, and compute the function.\nThis routine is designed so that df is accumulated as each function\nevaluation is done, to avoid having to allocate more temporary storage. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x nominal variable vector real(kind=wp), intent(in) :: dx_factor factor to multiply dx real(kind=wp), intent(in), dimension(:) :: dx the perturbation value for this column real(kind=wp), intent(in) :: df_factor factor to multiply function value integer, intent(in) :: column the variable to perturb integer, intent(in), dimension(:) :: idx the elements in this\ncolumn of the Jacobian\nto compute (passed to function) real(kind=wp), intent(inout), dimension(me%m) :: df the accumulated function value\nnote: for the first call, this\nshould be set to zero Called by proc~~perturb_x_and_compute_f~~CalledByGraph proc~perturb_x_and_compute_f numerical_differentiation_module::numdiff_type%perturb_x_and_compute_f proc~compute_jacobian_for_sparsity numerical_differentiation_module::numdiff_type%compute_jacobian_for_sparsity proc~compute_jacobian_for_sparsity->proc~perturb_x_and_compute_f proc~compute_jacobian_standard numerical_differentiation_module::compute_jacobian_standard proc~compute_jacobian_standard->proc~perturb_x_and_compute_f proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine perturb_x_and_compute_f ( me , x , dx_factor , dx ,& df_factor , column , idx , df ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! nominal variable vector real ( wp ), intent ( in ) :: dx_factor !! factor to multiply `dx` real ( wp ), dimension (:), intent ( in ) :: dx !! the perturbation value for this column real ( wp ), intent ( in ) :: df_factor !! factor to multiply function value integer , intent ( in ) :: column !! the variable to perturb integer , dimension (:), intent ( in ) :: idx !! the elements in this !! column of the Jacobian !! to compute (passed to function) real ( wp ), dimension ( me % m ), intent ( inout ) :: df !! the accumulated function value !! note: for the first call, this !! should be set to zero real ( wp ), dimension ( me % n ) :: xp !! the perturbed variable vector real ( wp ), dimension ( me % m ) :: f !! function evaluation if ( me % exception_raised ) return ! check for exceptions xp = x if ( dx_factor /= zero ) xp ( column ) = xp ( column ) + dx_factor * dx ( column ) call me % compute_function ( xp , f , idx ) if ( me % exception_raised ) return ! check for exceptions df ( idx ) = df ( idx ) + df_factor * f ( idx ) end subroutine perturb_x_and_compute_f","tags":"","loc":"proc/perturb_x_and_compute_f.html"},{"title":"compute_jacobian_times_vector – AoC-2023","text":"private  subroutine compute_jacobian_times_vector(me, x, v, z) Returns the product J*v , where J is the m x n Jacobian matrix\n  and v is an n x 1 vector. Note This one will include the constant elements if the linear pattern is available. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(:) :: v vector (size n ) real(kind=wp), intent(out), dimension(:) :: z The product J*v (size m ) Calls proc~~compute_jacobian_times_vector~~CallsGraph proc~compute_jacobian_times_vector numerical_differentiation_module::numdiff_type%compute_jacobian_times_vector proc~compute_jacobian numerical_differentiation_module::numdiff_type%compute_jacobian proc~compute_jacobian_times_vector->proc~compute_jacobian proc~compute_perturbation_vector numerical_differentiation_module::numdiff_type%compute_perturbation_vector proc~compute_jacobian->proc~compute_perturbation_vector proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_jacobian->proc~raise_exception proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_perturbation_vector->proc~compute_perturb_vector proc~compute_perturb_vector->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian_times_vector ( me , x , v , z ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:), intent ( in ) :: v !! vector (size `n`) real ( wp ), dimension (:), intent ( out ) :: z !! The product `J*v` (size `m`) real ( wp ), dimension (:), allocatable :: jac !! sparse jacobian vector integer :: i !! counter integer :: r !! row number in full jacobian integer :: c !! column number in full jacobian if ( me % exception_raised ) return ! check for exceptions ! first compute the jacobian in sparse vector form: call me % compute_jacobian ( x , jac ) if ( me % exception_raised ) return ! check for exceptions ! initialize output vector: z = 0.0_wp if ( allocated ( jac )) then !   J    v   z !  ---   -   - !  X0X   X   X !  0X0 * X = X !  00X   X   X !  00X       X ! multiplication by input v: do i = 1 , me % sparsity % num_nonzero_elements r = me % sparsity % irow ( i ) c = me % sparsity % icol ( i ) z ( r ) = z ( r ) + jac ( i ) * v ( c ) end do deallocate ( jac ) end if ! linear elements if available: do i = 1 , me % sparsity % num_nonzero_linear_elements r = me % sparsity % linear_irow ( i ) c = me % sparsity % linear_icol ( i ) z ( r ) = z ( r ) + me % sparsity % linear_vals ( i ) * v ( c ) end do end subroutine compute_jacobian_times_vector","tags":"","loc":"proc/compute_jacobian_times_vector.html"},{"title":"compute_jacobian – AoC-2023","text":"private  subroutine compute_jacobian(me, x, jac) Compute the Jacobian. Note The output jac only includes the elements of the nonlinear Jacobian.\n      If the constant elements are being handled separately (if the linear\n      pattern is available), then those elements can be obtained by\n      calling get_sparsity_pattern if required. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:), allocatable :: jac sparse jacobian vector Calls proc~~compute_jacobian~~CallsGraph proc~compute_jacobian numerical_differentiation_module::numdiff_type%compute_jacobian proc~compute_perturbation_vector numerical_differentiation_module::numdiff_type%compute_perturbation_vector proc~compute_jacobian->proc~compute_perturbation_vector proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_jacobian->proc~raise_exception proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_perturbation_vector->proc~compute_perturb_vector proc~compute_perturb_vector->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_jacobian~~CalledByGraph proc~compute_jacobian numerical_differentiation_module::numdiff_type%compute_jacobian proc~compute_jacobian_dense numerical_differentiation_module::numdiff_type%compute_jacobian_dense proc~compute_jacobian_dense->proc~compute_jacobian proc~compute_jacobian_times_vector numerical_differentiation_module::numdiff_type%compute_jacobian_times_vector proc~compute_jacobian_times_vector->proc~compute_jacobian program~test1 test1 program~test1->proc~compute_jacobian program~test2 test2 program~test2->proc~compute_jacobian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian ( me , x , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:), allocatable , intent ( out ) :: jac !! sparse jacobian vector real ( wp ), dimension ( me % n ) :: dx !! absolute perturbation (>0) for each variable if ( me % exception_raised ) return ! check for exceptions ! if we don't have a sparsity pattern yet then compute it: ! [also computes the indices vector] if (. not . me % sparsity % sparsity_computed ) call me % compute_sparsity ( x ) if ( me % sparsity % num_nonzero_elements == 0 ) return ! size the jacobian vector: allocate ( jac ( me % sparsity % num_nonzero_elements )) ! compute dx vector: if (. not . me % use_diff ) then ! only need this for the finite difference methods (not diff) call me % compute_perturbation_vector ( x , dx ) if ( me % exception_raised ) return ! check for exceptions end if ! compute the jacobian: if ( associated ( me % jacobian_function )) then call me % jacobian_function ( x , dx , jac ) else call me % raise_exception ( 22 , 'compute_jacobian' ,& 'jacobian_function has not been associated.' ) return end if end subroutine compute_jacobian","tags":"","loc":"proc/compute_jacobian.html"},{"title":"compute_jacobian_for_sparsity – AoC-2023","text":"private  subroutine compute_jacobian_for_sparsity(me, i, class_meths, x, jac) A separate version of compute_jacobian to be used only when\n  computing the sparsity pattern in compute_sparsity_random_2 .\n  It uses class_meths and the sparsity dperts and bounds. Note Based on compute_jacobian . The index manipulation here could be\n      greatly simplified, since we realdy know we are computed all the\n      elements in one column. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: i the column being computed type( meth_array ), intent(in) :: class_meths set of finite diff methods to use real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:), allocatable :: jac sparse jacobian vector Calls proc~~compute_jacobian_for_sparsity~~CallsGraph proc~compute_jacobian_for_sparsity numerical_differentiation_module::numdiff_type%compute_jacobian_for_sparsity proc~compute_sparsity_perturbation_vector numerical_differentiation_module::numdiff_type%compute_sparsity_perturbation_vector proc~compute_jacobian_for_sparsity->proc~compute_sparsity_perturbation_vector proc~perturb_x_and_compute_f numerical_differentiation_module::numdiff_type%perturb_x_and_compute_f proc~compute_jacobian_for_sparsity->proc~perturb_x_and_compute_f proc~select_finite_diff_method numerical_differentiation_module::numdiff_type%select_finite_diff_method proc~compute_jacobian_for_sparsity->proc~select_finite_diff_method proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_sparsity_perturbation_vector->proc~compute_perturb_vector proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_perturb_vector->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_jacobian_for_sparsity~~CalledByGraph proc~compute_jacobian_for_sparsity numerical_differentiation_module::numdiff_type%compute_jacobian_for_sparsity proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian_for_sparsity ( me , i , class_meths , x , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: i !! the column being computed type ( meth_array ), intent ( in ) :: class_meths !! set of finite diff methods to use real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:), allocatable , intent ( out ) :: jac !! sparse jacobian vector real ( wp ), dimension ( me % n ) :: dx !! absolute perturbation (>0) for each variable integer , dimension (:), allocatable :: nonzero_elements_in_col !! the indices of the !! nonzero Jacobian !! elements in a column integer :: j !! function evaluation counter real ( wp ), dimension ( me % m ) :: df !! accumulated function type ( finite_diff_method ) :: fd !! a finite different method (when !! specifying class rather than the method) logical :: status_ok !! error flag integer :: num_nonzero_elements_in_col !! number of nonzero elements in a column if ( me % exception_raised ) return ! check for exceptions ! Note that a sparsity pattern has already been set ! size the jacobian vector: allocate ( jac ( me % sparsity % num_nonzero_elements )) ! compute the perturbation vector (really we only need dx(i)): call me % compute_sparsity_perturbation_vector ( x , dx ) if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero ! determine functions to compute for this column: num_nonzero_elements_in_col = count ( me % sparsity % icol == i ) if ( num_nonzero_elements_in_col /= 0 ) then ! there are functions to compute nonzero_elements_in_col = pack ( me % sparsity % irow , mask = me % sparsity % icol == i ) call me % select_finite_diff_method ( x ( i ), me % xlow_for_sparsity ( i ), me % xhigh_for_sparsity ( i ),& dx ( i ), class_meths , fd , status_ok ) if (. not . status_ok ) then if ( me % print_messages ) then write ( error_unit , '(A,1X,I5)' ) & 'Error in compute_jacobian_for_sparsity: variable bounds violated for column: ' , i end if end if ! compute this column of the Jacobian: df = zero do j = 1 , size ( fd % dx_factors ) if ( associated ( me % info_function )) call me % info_function ([ i ], j , x ) call me % perturb_x_and_compute_f ( x , fd % dx_factors ( j ),& dx , fd % df_factors ( j ),& i , nonzero_elements_in_col , df ) if ( me % exception_raised ) return ! check for exceptions end do df ( nonzero_elements_in_col ) = df ( nonzero_elements_in_col ) / & ( fd % df_den_factor * dx ( i )) ! put result into the output vector: jac ( pack ( me % sparsity % indices , mask = me % sparsity % icol == i )) = & df ( nonzero_elements_in_col ) end if end subroutine compute_jacobian_for_sparsity","tags":"","loc":"proc/compute_jacobian_for_sparsity.html"},{"title":"compute_jacobian_standard – AoC-2023","text":"private  subroutine compute_jacobian_standard(me, x, dx, jac) Compute the Jacobian using finite differences.\n(one column at a time) Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector (size num_nonzero_elements ) Calls proc~~compute_jacobian_standard~~CallsGraph proc~compute_jacobian_standard numerical_differentiation_module::compute_jacobian_standard proc~perturb_x_and_compute_f numerical_differentiation_module::numdiff_type%perturb_x_and_compute_f proc~compute_jacobian_standard->proc~perturb_x_and_compute_f proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_jacobian_standard->proc~raise_exception proc~select_finite_diff_method numerical_differentiation_module::numdiff_type%select_finite_diff_method proc~compute_jacobian_standard->proc~select_finite_diff_method Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian_standard ( me , x , dx , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) !! for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector (size !! `num_nonzero_elements`) integer , dimension (:), allocatable :: nonzero_elements_in_col !! the indices of the !! nonzero Jacobian !! elements in a column integer :: i !! column counter integer :: j !! function evaluation counter real ( wp ), dimension ( me % m ) :: df !! accumulated function type ( finite_diff_method ) :: fd !! a finite different method (when !! specifying class rather than the method) logical :: status_ok !! error flag integer :: num_nonzero_elements_in_col !! number of nonzero elements in a column if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero ! compute Jacobian matrix column-by-column: do i = 1 , me % n ! determine functions to compute for this column: num_nonzero_elements_in_col = count ( me % sparsity % icol == i ) if ( num_nonzero_elements_in_col /= 0 ) then ! there are functions to compute nonzero_elements_in_col = pack ( me % sparsity % irow , mask = me % sparsity % icol == i ) select case ( me % mode ) case ( 1 ) ! use the specified methods ! compute this column of the Jacobian: df = zero do j = 1 , size ( me % meth ( i )% dx_factors ) if ( associated ( me % info_function )) call me % info_function ([ i ], j , x ) call me % perturb_x_and_compute_f ( x , me % meth ( i )% dx_factors ( j ),& dx , me % meth ( i )% df_factors ( j ),& i , nonzero_elements_in_col , df ) if ( me % exception_raised ) return ! check for exceptions end do df ( nonzero_elements_in_col ) = df ( nonzero_elements_in_col ) / & ( me % meth ( i )% df_den_factor * dx ( i )) case ( 2 ) ! select the method from the class so as not to violate the bounds call me % select_finite_diff_method ( x ( i ), me % xlow ( i ), me % xhigh ( i ),& dx ( i ), me % class_meths ( i ), fd , status_ok ) if (. not . status_ok ) then if ( me % print_messages ) then write ( error_unit , '(A,1X,I5)' ) & 'Error in compute_jacobian_standard: variable bounds violated for column: ' , i end if end if ! compute this column of the Jacobian: df = zero do j = 1 , size ( fd % dx_factors ) if ( associated ( me % info_function )) call me % info_function ([ i ], j , x ) call me % perturb_x_and_compute_f ( x , fd % dx_factors ( j ),& dx , fd % df_factors ( j ),& i , nonzero_elements_in_col , df ) if ( me % exception_raised ) return ! check for exceptions end do df ( nonzero_elements_in_col ) = df ( nonzero_elements_in_col ) / & ( fd % df_den_factor * dx ( i )) case default call me % raise_exception ( 23 , 'compute_jacobian_standard' ,& 'invalid mode' ) return end select ! put result into the output vector: jac ( pack ( me % sparsity % indices , mask = me % sparsity % icol == i )) = & df ( nonzero_elements_in_col ) end if end do end subroutine compute_jacobian_standard","tags":"","loc":"proc/compute_jacobian_standard.html"},{"title":"compute_jacobian_with_diff – AoC-2023","text":"private  subroutine compute_jacobian_with_diff(me, x, dx, jac) Compute the Jacobian one element at a time using the Neville's process\nalgorithm diff . This takes a very large number of function evaluations,\nbut should give a very accurate answer. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector (size num_nonzero_elements ) Calls proc~~compute_jacobian_with_diff~~CallsGraph proc~compute_jacobian_with_diff numerical_differentiation_module::compute_jacobian_with_diff proc~diff~2 diff_module::diff_func%diff proc~compute_jacobian_with_diff->proc~diff~2 proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_jacobian_with_diff->proc~raise_exception proc~set_function diff_module::diff_func%set_function proc~compute_jacobian_with_diff->proc~set_function proc~faccur diff_module::diff_func%faccur proc~diff~2->proc~faccur Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian_with_diff ( me , x , dx , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) !! for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector (size !! `num_nonzero_elements`) integer , parameter :: iord = 1 !! tells [[diff]] to compute first derivative integer :: i !! counter for nonzero elements of jacobian type ( diff_func ) :: d !! the [[diff]] class to use real ( wp ) :: x0 !! value of ith variable for [[diff]] real ( wp ) :: xmin !! ith variable lower bound real ( wp ) :: xmax !! ith variable upper bound real ( wp ) :: deriv !! derivative value df/dx from [[diff]] real ( wp ) :: error !! estimated error from [[diff]] integer :: ifail !! [[diff]] error flag real ( wp ), dimension ( me % n ) :: xp !! used by [[dfunc]]. real ( wp ), dimension ( me % m ) :: fvec !! used by [[dfunc]]. integer :: ir !! row index of next non-zero element integer :: ic !! column index of next non-zero element integer :: ic_prev !! previous column perturbed integer :: icount !! count of number of times a column has been perturbed logical :: use_info !! if we are reporting to the user if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero use_info = associated ( me % info_function ) if ( use_info ) ic_prev = - 1 ! set the function for diff: call d % set_function ( dfunc ) ! each element is computed one by one do i = 1 , me % sparsity % num_nonzero_elements ir = me % sparsity % irow ( i ) ic = me % sparsity % icol ( i ) x0 = x ( ic ) xmin = me % xlow ( ic ) xmax = me % xhigh ( ic ) ! if reporting to the user, have to keep track ! of which column is being perturbed, and how ! many times: if ( use_info ) then if ( ic /= ic_prev ) icount = 0 end if call d % compute_derivative ( iord , x0 , xmin , xmax , me % eps , me % acc , deriv , error , ifail ) if ( ifail == 0 . or . ifail == 1 ) then jac ( i ) = deriv else if ( ifail == - 1 ) then ! this indicates an exception was ! already raised, so just return. return else call me % raise_exception ( 24 , 'compute_jacobian_with_diff' ,& 'error computing derivative with DIFF.' ) return end if if ( use_info ) ic_prev = ic end do contains function dfunc ( this , xval ) result ( fx ) !! interface to user function for [[diff]] routine. implicit none class ( diff_func ), intent ( inout ) :: this real ( wp ), intent ( in ) :: xval !! input variable (`ic` variable) real ( wp ) :: fx !! derivative of `ir` function !! w.r.t. `xval` variable if ( use_info ) then icount = icount + 1 call me % info_function ([ ic ], icount , x ) end if xp = x xp ( ic ) = xval call me % compute_function ( xp , fvec , funcs_to_compute = [ ir ]) if ( me % exception_raised ) then ! check for exceptions fx = 0.0_wp call me % terminate () else fx = fvec ( ir ) end if end function dfunc end subroutine compute_jacobian_with_diff","tags":"","loc":"proc/compute_jacobian_with_diff.html"},{"title":"compute_jacobian_partitioned – AoC-2023","text":"private  subroutine compute_jacobian_partitioned(me, x, dx, jac) Compute the Jacobian using finite differences,\n(using the partitioned sparsity pattern to compute multiple columns\nat a time). Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0) for each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector Calls proc~~compute_jacobian_partitioned~~CallsGraph proc~compute_jacobian_partitioned numerical_differentiation_module::compute_jacobian_partitioned proc~columns_in_partition_group numerical_differentiation_module::sparsity_pattern%columns_in_partition_group proc~compute_jacobian_partitioned->proc~columns_in_partition_group proc~perturb_x_and_compute_f_partitioned numerical_differentiation_module::numdiff_type%perturb_x_and_compute_f_partitioned proc~compute_jacobian_partitioned->proc~perturb_x_and_compute_f_partitioned proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_jacobian_partitioned->proc~raise_exception proc~select_finite_diff_method_for_partition_group numerical_differentiation_module::numdiff_type%select_finite_diff_method_for_partition_group proc~compute_jacobian_partitioned->proc~select_finite_diff_method_for_partition_group Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_jacobian_partitioned ( me , x , dx , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector integer :: i !! column counter integer :: j !! function evaluation counter integer :: igroup !! group number counter integer :: n_cols !! number of columns in a group integer , dimension (:), allocatable :: cols !! array of column indices in a group integer , dimension (:), allocatable :: nonzero_rows !! the indices of the nonzero Jacobian !! elementes (row numbers) in a group integer , dimension (:), allocatable :: indices !! nonzero indices in `jac` for a group integer , dimension (:), allocatable :: col_indices !! nonzero indices in `jac` for a column real ( wp ), dimension ( me % m ) :: df !! accumulated function type ( finite_diff_method ) :: fd !! a finite different method (when !! specifying class rather than the method) logical :: status_ok !! error flag integer :: num_nonzero_elements_in_col if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero ! compute by group: do igroup = 1 , me % sparsity % maxgrp ! get the columns in this group: call me % sparsity % columns_in_partition_group ( igroup , n_cols , cols ,& nonzero_rows , indices , status_ok ) if (. not . status_ok ) then call me % raise_exception ( 25 , 'compute_jacobian_partitioned' ,& 'the partition has not been computed.' ) return end if if ( n_cols > 0 ) then if ( allocated ( nonzero_rows )) then select case ( me % mode ) case ( 1 ) ! use the specified methods ! note: all the methods must be the same within a group ! compute the columns of the Jacobian in this group: df = zero do j = 1 , size ( me % meth ( 1 )% dx_factors ) if ( associated ( me % info_function )) call me % info_function ( cols , j , x ) call me % perturb_x_and_compute_f_partitioned ( x , me % meth ( 1 )% dx_factors ( j ),& dx , me % meth ( 1 )% df_factors ( j ),& cols , nonzero_rows , df ) if ( me % exception_raised ) return ! check for exceptions end do ! divide by the denominator, which can be different for each column: do i = 1 , n_cols num_nonzero_elements_in_col = count ( me % sparsity % icol == cols ( i )) if ( allocated ( col_indices )) deallocate ( col_indices ) allocate ( col_indices ( num_nonzero_elements_in_col )) col_indices = pack ( me % sparsity % indices , mask = me % sparsity % icol == cols ( i )) df ( me % sparsity % irow ( col_indices )) = df ( me % sparsity % irow ( col_indices )) / & ( me % meth ( 1 )% df_den_factor * dx ( cols ( i ))) end do case ( 2 ) ! select the method from the class so as not to violate ! the bounds on *any* of the variables in the group ! note: all the classes must be the same within a group call me % select_finite_diff_method_for_partition_group ( & x ( cols ), me % xlow ( cols ), me % xhigh ( cols ),& dx ( cols ), me % class_meths ( 1 ), fd , status_ok ) if (. not . status_ok ) then if ( me % print_messages ) then ! will not consider this a fatal error for now: write ( error_unit , '(A,1X,I5,1X,A,1X,*(I5,1X))' ) & 'Error in compute_jacobian_partitioned: ' // & 'variable bounds violated for group: ' ,& igroup , '. columns: ' , cols end if end if ! compute the columns of the Jacobian in this group: df = zero do j = 1 , size ( fd % dx_factors ) if ( associated ( me % info_function )) call me % info_function ( cols , j , x ) call me % perturb_x_and_compute_f_partitioned ( x , fd % dx_factors ( j ),& dx , fd % df_factors ( j ),& cols , nonzero_rows , df ) if ( me % exception_raised ) return ! check for exceptions end do ! divide by the denominator, which can be different for each column: do i = 1 , n_cols num_nonzero_elements_in_col = count ( me % sparsity % icol == cols ( i )) if ( allocated ( col_indices )) deallocate ( col_indices ) allocate ( col_indices ( num_nonzero_elements_in_col )) col_indices = pack ( me % sparsity % indices , mask = me % sparsity % icol == cols ( i )) df ( me % sparsity % irow ( col_indices )) = df ( me % sparsity % irow ( col_indices )) / & ( fd % df_den_factor * dx ( cols ( i ))) end do case default call me % raise_exception ( 26 , 'compute_jacobian_partitioned' , 'invalid mode' ) return end select ! put result into the output vector: jac ( indices ) = df ( nonzero_rows ) end if end if end do end subroutine compute_jacobian_partitioned","tags":"","loc":"proc/compute_jacobian_partitioned.html"},{"title":"perturb_x_and_compute_f_partitioned – AoC-2023","text":"private  subroutine perturb_x_and_compute_f_partitioned(me, x, dx_factor, dx, df_factor, columns, idx, df) Perturb the specified optimization variable, and compute the function.\nThis routine is designed so that df is accumulated as each function\nevaluation is done, to avoid having to allocate more temporary storage. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x nominal variable vector real(kind=wp), intent(in) :: dx_factor factor to multiply dx real(kind=wp), intent(in), dimension(:) :: dx the perturbation value for this column real(kind=wp), intent(in) :: df_factor factor to multiply function value integer, intent(in), dimension(:) :: columns the variables to perturb integer, intent(in), dimension(:) :: idx the elements in this\ncolumn of the Jacobian\nto compute (passed to function) real(kind=wp), intent(inout), dimension(me%m) :: df the accumulated function value\nnote: for the first call, this\nshould be set to zero Called by proc~~perturb_x_and_compute_f_partitioned~~CalledByGraph proc~perturb_x_and_compute_f_partitioned numerical_differentiation_module::numdiff_type%perturb_x_and_compute_f_partitioned proc~compute_jacobian_partitioned numerical_differentiation_module::compute_jacobian_partitioned proc~compute_jacobian_partitioned->proc~perturb_x_and_compute_f_partitioned Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine perturb_x_and_compute_f_partitioned ( me , x , dx_factor , dx ,& df_factor , columns , idx , df ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! nominal variable vector real ( wp ), intent ( in ) :: dx_factor !! factor to multiply `dx` real ( wp ), dimension (:), intent ( in ) :: dx !! the perturbation value for this column real ( wp ), intent ( in ) :: df_factor !! factor to multiply function value integer , dimension (:), intent ( in ) :: columns !! the variables to perturb integer , dimension (:), intent ( in ) :: idx !! the elements in this !! column of the Jacobian !! to compute (passed to function) real ( wp ), dimension ( me % m ), intent ( inout ) :: df !! the accumulated function value !! note: for the first call, this !! should be set to zero real ( wp ), dimension ( me % n ) :: xp !! the perturbed variable vector real ( wp ), dimension ( me % m ) :: f !! function evaluation if ( me % exception_raised ) return ! check for exceptions xp = x if ( dx_factor /= zero ) xp ( columns ) = xp ( columns ) + dx_factor * dx ( columns ) call me % compute_function ( xp , f , idx ) if ( me % exception_raised ) return ! check for exceptions df ( idx ) = df ( idx ) + df_factor * f ( idx ) end subroutine perturb_x_and_compute_f_partitioned","tags":"","loc":"proc/perturb_x_and_compute_f_partitioned.html"},{"title":"compute_perturb_vector – AoC-2023","text":"private  subroutine compute_perturb_vector(me, x, dpert, perturb_mode, dx) Compute dx , the perturbation vector for x Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dpert integer, intent(in) :: perturb_mode real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable Calls proc~~compute_perturb_vector~~CallsGraph proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_perturb_vector->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_perturb_vector~~CalledByGraph proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_perturbation_vector numerical_differentiation_module::numdiff_type%compute_perturbation_vector proc~compute_perturbation_vector->proc~compute_perturb_vector proc~compute_sparsity_perturbation_vector numerical_differentiation_module::numdiff_type%compute_sparsity_perturbation_vector proc~compute_sparsity_perturbation_vector->proc~compute_perturb_vector proc~compute_jacobian numerical_differentiation_module::numdiff_type%compute_jacobian proc~compute_jacobian->proc~compute_perturbation_vector proc~compute_jacobian_for_sparsity numerical_differentiation_module::numdiff_type%compute_jacobian_for_sparsity proc~compute_jacobian_for_sparsity->proc~compute_sparsity_perturbation_vector proc~compute_jacobian_dense numerical_differentiation_module::numdiff_type%compute_jacobian_dense proc~compute_jacobian_dense->proc~compute_jacobian proc~compute_jacobian_times_vector numerical_differentiation_module::numdiff_type%compute_jacobian_times_vector proc~compute_jacobian_times_vector->proc~compute_jacobian proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity program~test1 test1 program~test1->proc~compute_jacobian program~test2 test2 program~test2->proc~compute_jacobian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_perturb_vector ( me , x , dpert , perturb_mode , dx ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dpert integer , intent ( in ) :: perturb_mode real ( wp ), dimension ( me % n ), intent ( out ) :: dx !! absolute perturbation (>0) !! for each variable real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) !! the smallest allowed absolute step if ( me % exception_raised ) return ! check for exceptions select case ( perturb_mode ) case ( 1 ) dx = abs ( dpert ) case ( 2 ) dx = abs ( dpert * x ) case ( 3 ) dx = abs ( dpert ) * ( 1.0_wp + abs ( x )) case default call me % raise_exception ( 27 , 'compute_perturb_vector' ,& 'invalid value for perturb_mode (must be 1, 2, or 3)' ) return end select ! make sure none are too small: where ( dx < eps ) dx = eps end where end subroutine compute_perturb_vector","tags":"","loc":"proc/compute_perturb_vector.html"},{"title":"compute_perturbation_vector – AoC-2023","text":"private  subroutine compute_perturbation_vector(me, x, dx) Compute dx , the perturbation vector for x used\nwhen computing the gradients. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable Calls proc~~compute_perturbation_vector~~CallsGraph proc~compute_perturbation_vector numerical_differentiation_module::numdiff_type%compute_perturbation_vector proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_perturbation_vector->proc~compute_perturb_vector proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_perturb_vector->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_perturbation_vector~~CalledByGraph proc~compute_perturbation_vector numerical_differentiation_module::numdiff_type%compute_perturbation_vector proc~compute_jacobian numerical_differentiation_module::numdiff_type%compute_jacobian proc~compute_jacobian->proc~compute_perturbation_vector proc~compute_jacobian_dense numerical_differentiation_module::numdiff_type%compute_jacobian_dense proc~compute_jacobian_dense->proc~compute_jacobian proc~compute_jacobian_times_vector numerical_differentiation_module::numdiff_type%compute_jacobian_times_vector proc~compute_jacobian_times_vector->proc~compute_jacobian program~test1 test1 program~test1->proc~compute_jacobian program~test2 test2 program~test2->proc~compute_jacobian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_perturbation_vector ( me , x , dx ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( out ) :: dx !! absolute perturbation (>0) !! for each variable if ( me % exception_raised ) return ! check for exceptions call me % compute_perturb_vector ( x , me % dpert , me % perturb_mode , dx ) end subroutine compute_perturbation_vector","tags":"","loc":"proc/compute_perturbation_vector.html"},{"title":"compute_sparsity_perturbation_vector – AoC-2023","text":"private  subroutine compute_sparsity_perturbation_vector(me, x, dx) Compute dx , the perturbation vector for x used\nwhen computing the sparsity pattern. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable Calls proc~~compute_sparsity_perturbation_vector~~CallsGraph proc~compute_sparsity_perturbation_vector numerical_differentiation_module::numdiff_type%compute_sparsity_perturbation_vector proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_sparsity_perturbation_vector->proc~compute_perturb_vector proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_perturb_vector->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_sparsity_perturbation_vector~~CalledByGraph proc~compute_sparsity_perturbation_vector numerical_differentiation_module::numdiff_type%compute_sparsity_perturbation_vector proc~compute_jacobian_for_sparsity numerical_differentiation_module::numdiff_type%compute_jacobian_for_sparsity proc~compute_jacobian_for_sparsity->proc~compute_sparsity_perturbation_vector proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_sparsity_perturbation_vector ( me , x , dx ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( out ) :: dx !! absolute perturbation (>0) !! for each variable if ( me % exception_raised ) return ! check for exceptions call me % compute_perturb_vector ( x , me % dpert_for_sparsity , me % sparsity_perturb_mode , dx ) end subroutine compute_sparsity_perturbation_vector","tags":"","loc":"proc/compute_sparsity_perturbation_vector.html"},{"title":"print_sparsity – AoC-2023","text":"private  subroutine print_sparsity(me, n, m, iunit, dense) Print the sparsity pattern. Type Bound sparsity_pattern Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(in) :: me integer, intent(in) :: n number of variables (columns of jacobian) integer, intent(in) :: m number of functions (rows of jacobian) integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) logical, intent(in), optional :: dense if present and true, the matrix form\nof the sparsity pattern is printed\n(default is vector form) Source Code subroutine print_sparsity ( me , n , m , iunit , dense ) implicit none class ( sparsity_pattern ), intent ( in ) :: me integer , intent ( in ) :: n !! number of variables (columns of jacobian) integer , intent ( in ) :: m !! number of functions (rows of jacobian) integer , intent ( in ) :: iunit !! file unit to write to. !! (assumed to be already opened) logical , intent ( in ), optional :: dense !! if present and true, the matrix form !! of the sparsity pattern is printed !! (default is vector form) logical :: print_matrix !! if the matrix form is to be printed integer :: r !! row counter character ( len = 1 ), dimension ( n ) :: row !! a row of the sparsity matrix if ( present ( dense )) then print_matrix = dense else print_matrix = . false . ! default end if write ( iunit , '(A)' ) '---Sparsity pattern---' if ( allocated ( me % irow ) . and . allocated ( me % icol )) then if ( print_matrix ) then do r = 1 , m ! print by row row = '0' row ( pack ( me % icol , mask = me % irow == r )) = 'X' write ( iunit , '(*(A1))' ) row end do else write ( iunit , '(A,1X,*(I3,\",\"))' ) 'irow:' , me % irow write ( iunit , '(A,1X,*(I3,\",\"))' ) 'icol:' , me % icol end if if ( allocated ( me % ngrp )) then write ( iunit , '(A)' ) '' write ( iunit , '(A)' ) '---Sparsity partition---' write ( iunit , '(A,1x,I5)' ) 'Number of groups:' , me % maxgrp write ( iunit , '(A,1x,*(I5,1X))' ) 'Group array:     ' , me % ngrp end if end if write ( iunit , '(A)' ) '' ! print linear pattern if available if ( me % linear_sparsity_computed ) then write ( iunit , '(A)' ) '---Linear sparsity pattern---' if ( allocated ( me % linear_icol ) . and . allocated ( me % linear_irow )) then if ( print_matrix ) then do r = 1 , m ! print by row row = '0' row ( pack ( me % linear_icol , mask = me % linear_irow == r )) = 'X' write ( iunit , '(*(A1))' ) row end do else write ( iunit , '(A,1X,*(I3,\",\"))' ) 'irow:' , me % linear_irow write ( iunit , '(A,1X,*(I3,\",\"))' ) 'icol:' , me % linear_icol write ( iunit , '(A,1X,*(E30.16,\",\"))' ) 'vals:' , me % linear_vals end if end if write ( iunit , '(A)' ) '' end if end subroutine print_sparsity","tags":"","loc":"proc/print_sparsity.html"},{"title":"print_sparsity_pattern – AoC-2023","text":"private  subroutine print_sparsity_pattern(me, iunit) Print the sparsity pattern in vector form ( irow , icol ). Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) Called by proc~~print_sparsity_pattern~~CalledByGraph proc~print_sparsity_pattern numerical_differentiation_module::numdiff_type%print_sparsity_pattern program~test1 test1 program~test1->proc~print_sparsity_pattern Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine print_sparsity_pattern ( me , iunit ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: iunit !! file unit to write to. !! (assumed to be already opened) call me % sparsity % print ( me % n , me % m , iunit , dense = . false .) end subroutine print_sparsity_pattern","tags":"","loc":"proc/print_sparsity_pattern.html"},{"title":"print_sparsity_matrix – AoC-2023","text":"private  subroutine print_sparsity_matrix(me, iunit) Print the sparsity pattern in matrix form. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) Called by proc~~print_sparsity_matrix~~CalledByGraph proc~print_sparsity_matrix numerical_differentiation_module::numdiff_type%print_sparsity_matrix program~test1 test1 program~test1->proc~print_sparsity_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine print_sparsity_matrix ( me , iunit ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: iunit !! file unit to write to. !! (assumed to be already opened) call me % sparsity % print ( me % n , me % m , iunit , dense = . true .) end subroutine print_sparsity_matrix","tags":"","loc":"proc/print_sparsity_matrix.html"},{"title":"terminate – AoC-2023","text":"private  subroutine terminate(me) A user-callable routine. When called, it will terminate\nall computations and return. The istat return code will be\nset to -1 . This can be called in the function or the info function. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me Source Code subroutine terminate ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me if ( me % exception_raised ) return ! check for existing exceptions me % istat = - 1 me % error_msg = 'Terminated by the user' me % exception_raised = . true . end subroutine terminate","tags":"","loc":"proc/terminate~2.html"},{"title":"raise_exception – AoC-2023","text":"private  subroutine raise_exception(me, istat, routine, error_msg) Raise an exception. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: istat error code. character(len=*), intent(in) :: routine the routine where the error was raised. character(len=*), intent(in) :: error_msg error message string. Called by proc~~raise_exception~~CalledByGraph proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_jacobian numerical_differentiation_module::numdiff_type%compute_jacobian proc~compute_jacobian->proc~raise_exception proc~compute_perturbation_vector numerical_differentiation_module::numdiff_type%compute_perturbation_vector proc~compute_jacobian->proc~compute_perturbation_vector proc~compute_jacobian_partitioned numerical_differentiation_module::compute_jacobian_partitioned proc~compute_jacobian_partitioned->proc~raise_exception proc~compute_jacobian_standard numerical_differentiation_module::compute_jacobian_standard proc~compute_jacobian_standard->proc~raise_exception proc~compute_jacobian_with_diff numerical_differentiation_module::compute_jacobian_with_diff proc~compute_jacobian_with_diff->proc~raise_exception proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_perturb_vector->proc~raise_exception proc~compute_sparsity_random numerical_differentiation_module::compute_sparsity_random proc~compute_sparsity_random->proc~raise_exception proc~compute_sparsity_random_2 numerical_differentiation_module::compute_sparsity_random_2 proc~compute_sparsity_random_2->proc~raise_exception proc~compute_jacobian_for_sparsity numerical_differentiation_module::numdiff_type%compute_jacobian_for_sparsity proc~compute_sparsity_random_2->proc~compute_jacobian_for_sparsity proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff proc~initialize_numdiff->proc~raise_exception proc~set_numdiff_bounds numerical_differentiation_module::numdiff_type%set_numdiff_bounds proc~initialize_numdiff->proc~set_numdiff_bounds proc~set_sparsity_mode numerical_differentiation_module::numdiff_type%set_sparsity_mode proc~initialize_numdiff->proc~set_sparsity_mode proc~initialize_numdiff_for_diff numerical_differentiation_module::numdiff_type%initialize_numdiff_for_diff proc~initialize_numdiff_for_diff->proc~raise_exception proc~initialize_numdiff_for_diff->proc~set_numdiff_bounds proc~initialize_numdiff_for_diff->proc~set_sparsity_mode proc~set_numdiff_bounds->proc~raise_exception proc~set_numdiff_sparsity_bounds numerical_differentiation_module::numdiff_type%set_numdiff_sparsity_bounds proc~set_numdiff_sparsity_bounds->proc~raise_exception proc~set_sparsity_mode->proc~raise_exception proc~set_sparsity_mode->proc~set_numdiff_sparsity_bounds proc~set_sparsity_pattern numerical_differentiation_module::numdiff_type%set_sparsity_pattern proc~set_sparsity_pattern->proc~raise_exception proc~compute_jacobian_dense numerical_differentiation_module::numdiff_type%compute_jacobian_dense proc~compute_jacobian_dense->proc~compute_jacobian proc~compute_jacobian_times_vector numerical_differentiation_module::numdiff_type%compute_jacobian_times_vector proc~compute_jacobian_times_vector->proc~compute_jacobian proc~compute_perturbation_vector->proc~compute_perturb_vector proc~compute_sparsity_perturbation_vector numerical_differentiation_module::numdiff_type%compute_sparsity_perturbation_vector proc~compute_sparsity_perturbation_vector->proc~compute_perturb_vector program~test1 test1 program~test1->proc~compute_jacobian program~test1->proc~initialize_numdiff program~test1->proc~initialize_numdiff_for_diff program~test2 test2 program~test2->proc~compute_jacobian proc~compute_jacobian_for_sparsity->proc~compute_sparsity_perturbation_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine raise_exception ( me , istat , routine , error_msg ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: istat !! error code. character ( len =* ), intent ( in ) :: routine !! the routine where the error was raised. character ( len =* ), intent ( in ) :: error_msg !! error message string. me % istat = istat me % error_msg = 'Error in ' // trim ( routine ) // ' : ' // trim ( error_msg ) me % exception_raised = . true . end subroutine raise_exception","tags":"","loc":"proc/raise_exception.html"},{"title":"clear_exceptions – AoC-2023","text":"private  subroutine clear_exceptions(me) Clear all exceptions. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me Source Code subroutine clear_exceptions ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me me % istat = 0 if ( allocated ( me % error_msg )) deallocate ( me % error_msg ) me % exception_raised = . false . end subroutine clear_exceptions","tags":"","loc":"proc/clear_exceptions.html"},{"title":"get_error_status – AoC-2023","text":"private  subroutine get_error_status(me, istat, error_msg) Returns the current error code and message. Type Bound numdiff_type Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(in) :: me integer, intent(out), optional :: istat error code ( istat=0 means no errors). character(len=:), intent(out), optional, allocatable :: error_msg error message string. Called by proc~~get_error_status~~CalledByGraph proc~get_error_status numerical_differentiation_module::numdiff_type%get_error_status program~test1 test1 program~test1->proc~get_error_status program~test2 test2 program~test2->proc~get_error_status Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_error_status ( me , istat , error_msg ) implicit none class ( numdiff_type ), intent ( in ) :: me integer , intent ( out ), optional :: istat !! error code (`istat=0` means no errors). character ( len = :), allocatable , intent ( out ), optional :: error_msg !! error message string. if ( present ( istat )) istat = me % istat if ( present ( error_msg )) then if ( allocated ( me % error_msg )) then error_msg = me % error_msg else error_msg = '' end if end if end subroutine get_error_status","tags":"","loc":"proc/get_error_status.html"},{"title":"finite_diff_method – AoC-2023","text":"public interface finite_diff_method constructor Calls interface~~finite_diff_method~~CallsGraph interface~finite_diff_method numerical_differentiation_module::finite_diff_method proc~initialize_finite_difference_method numerical_differentiation_module::initialize_finite_difference_method interface~finite_diff_method->proc~initialize_finite_difference_method Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function initialize_finite_difference_method (id, name, class, dx_factors, df_factors, df_den_factor) result(me) Constructor for a finite_diff_method . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: id unique ID for the method character(len=*), intent(in) :: name the name of the method integer, intent(in) :: class 2=backward diffs, 3=central diffs, etc... integer, intent(in), dimension(:) :: dx_factors multiplicative factors for dx perturbation integer, intent(in), dimension(:) :: df_factors multiplicative factors for accumulating function evaluations integer, intent(in) :: df_den_factor denominator factor for finite difference equation (times dx) Return Value type( finite_diff_method )","tags":"","loc":"interface/finite_diff_method.html"},{"title":"solve – AoC-2023","text":"public  subroutine solve(n_cols, n_rows, n_nonzero, irow, icol, mat, b, x, istat, settings) Wrapper for lu1fac + lu6sol to solve a linear system A*x = b . Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_cols n : number of columns in A. integer, intent(in) :: n_rows m : number of rows in A. integer, intent(in) :: n_nonzero number of nonzero elements of A. integer, intent(in), dimension(n_nonzero) :: irow sparsity pattern (size is n_nonzero ) integer, intent(in), dimension(n_nonzero) :: icol sparsity pattern (size is n_nonzero ) real(kind=rp), intent(in), dimension(n_nonzero) :: mat matrix elements (size is n_nonzero ) real(kind=rp), intent(in), dimension(n_rows) :: b right hand side (size is m ) real(kind=rp), intent(out), dimension(n_cols) :: x solution !size is n integer, intent(out) :: istat status code type( lusol_settings ), intent(in), optional :: settings settings (if not present, defaults are used) Calls proc~~solve~~CallsGraph proc~solve lusol_ez_module::solve proc~lu1fac lusol::lu1fac proc~solve->proc~lu1fac proc~lu6sol lusol::lu6sol proc~solve->proc~lu6sol proc~lu1fad lusol::lu1fad proc~lu1fac->proc~lu1fad proc~lu1or1 lusol::lu1or1 proc~lu1fac->proc~lu1or1 proc~lu1or2 lusol::lu1or2 proc~lu1fac->proc~lu1or2 proc~lu1or3 lusol::lu1or3 proc~lu1fac->proc~lu1or3 proc~lu1or4 lusol::lu1or4 proc~lu1fac->proc~lu1or4 proc~lu1pq1 lusol::lu1pq1 proc~lu1fac->proc~lu1pq1 proc~lu1slk lusol::lu1slk proc~lu1fac->proc~lu1slk proc~lu6chk lusol::lu6chk proc~lu1fac->proc~lu6chk proc~lu6l lusol::lu6L proc~lu6sol->proc~lu6l proc~lu6ld lusol::lu6LD proc~lu6sol->proc~lu6ld proc~lu6lt lusol::lu6Lt proc~lu6sol->proc~lu6lt proc~lu6u lusol::lu6U proc~lu6sol->proc~lu6u proc~lu6ut lusol::lu6Ut proc~lu6sol->proc~lu6ut proc~hbuild lusol::Hbuild proc~lu1fad->proc~hbuild proc~hchange lusol::Hchange proc~lu1fad->proc~hchange proc~hdelete lusol::Hdelete proc~lu1fad->proc~hdelete proc~lu1ful lusol::lu1ful proc~lu1fad->proc~lu1ful proc~lu1gau lusol::lu1gau proc~lu1fad->proc~lu1gau proc~lu1mar lusol::lu1mar proc~lu1fad->proc~lu1mar proc~lu1mrp lusol::lu1mRP proc~lu1fad->proc~lu1mrp proc~lu1msp lusol::lu1mSP proc~lu1fad->proc~lu1msp proc~lu1mxc lusol::lu1mxc proc~lu1fad->proc~lu1mxc proc~lu1mxr lusol::lu1mxr proc~lu1fad->proc~lu1mxr proc~lu1pen lusol::lu1pen proc~lu1fad->proc~lu1pen proc~lu1pq2 lusol::lu1pq2 proc~lu1fad->proc~lu1pq2 proc~lu1pq3 lusol::lu1pq3 proc~lu1fad->proc~lu1pq3 proc~lu1rec lusol::lu1rec proc~lu1fad->proc~lu1rec proc~hinsert lusol::Hinsert proc~hbuild->proc~hinsert proc~hdown lusol::Hdown proc~hchange->proc~hdown proc~hup lusol::Hup proc~hchange->proc~hup proc~hdelete->proc~hchange proc~lu1dcp lusol::lu1DCP proc~lu1ful->proc~lu1dcp proc~lu1dpp lusol::lu1DPP proc~lu1ful->proc~lu1dpp proc~hinsert->proc~hup proc~jdamax lusol::jdamax proc~lu1dcp->proc~jdamax proc~lu1dpp->proc~jdamax Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~solve~~CalledByGraph proc~solve lusol_ez_module::solve proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine solve ( n_cols , n_rows , n_nonzero , irow , icol , mat , b , x , istat , settings ) integer , intent ( in ) :: n_cols !! `n`: number of columns in A. integer , intent ( in ) :: n_rows !! `m`: number of rows in A. integer , intent ( in ) :: n_nonzero !! number of nonzero elements of A. integer , dimension ( n_nonzero ), intent ( in ) :: irow , icol !! sparsity pattern (size is `n_nonzero`) real ( rp ), dimension ( n_nonzero ), intent ( in ) :: mat !! matrix elements (size is `n_nonzero`) real ( rp ), dimension ( n_rows ), intent ( in ) :: b !! right hand side (size is `m`) real ( rp ), dimension ( n_cols ), intent ( out ) :: x !! solution !size is `n` integer , intent ( out ) :: istat !! status code type ( lusol_settings ), intent ( in ), optional :: settings !! settings (if not present, defaults are used) integer ( ip ) :: nelem , n , m integer ( ip ) :: lena real ( rp ), dimension (:), allocatable :: a integer ( ip ), dimension (:), allocatable :: indc integer ( ip ), dimension (:), allocatable :: indr real ( rp ), dimension (:), allocatable :: ww real ( rp ), dimension (:), allocatable :: w real ( rp ), dimension (:), allocatable :: v integer ( ip ) :: inform integer ( ip ) :: luparm ( 30 ) real ( rp ) :: parmlu ( 30 ) integer ( ip ), dimension (:), allocatable :: p , q , & lenc , lenr , & iploc , iqloc , & ipinv , iqinv , & locc , locr type ( lusol_settings ) :: options if ( present ( settings )) options = settings ! use user-supplied settings n = n_cols m = n_rows nelem = n_nonzero lena = 1 + max ( 2 * nelem , 10 * m , 10 * n , 10000 ) allocate ( a ( lena )) allocate ( indc ( lena )) allocate ( indr ( lena )) associate ( n => n_cols , m => n_rows ) allocate ( p ( m ), q ( n ), lenc ( n ), lenr ( m ), & iploc ( n ), iqloc ( m ), ipinv ( m ), & iqinv ( n ), locc ( n ) , locr ( m )) allocate ( ww ( n )) allocate ( w ( n )) ! x allocate ( v ( m )) ! b end associate a = 0 ; indc = 0 ; indr = 0 a ( 1 : nelem ) = mat indc ( 1 : nelem ) = irow indr ( 1 : nelem ) = icol ! settings luparm = 0 luparm ( 1 ) = options % nout luparm ( 2 ) = options % lprint luparm ( 3 ) = options % maxcol luparm ( 6 ) = options % method luparm ( 8 ) = options % keepLU parmlu = 0 parmlu ( 1 ) = options % Ltol1 parmlu ( 2 ) = options % Ltol2 parmlu ( 3 ) = options % small parmlu ( 4 ) = options % Utol1 parmlu ( 5 ) = options % Utol2 parmlu ( 6 ) = options % Uspace parmlu ( 7 ) = options % dens1 parmlu ( 8 ) = options % dens2 call lu1fac ( m , n , nelem , lena , luparm , parmlu , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & iploc , iqloc , ipinv , iqinv , ww , inform ) !write(*,*) 'lu1fac inform = ', inform !  inform = 0 if the LU factors were obtained successfully. !         = 1 if U appears to be singular, as judged by lu6chk. !         = 3 if some index pair indc(l), indr(l) lies outside !             the matrix dimensions 1:m , 1:n. !         = 4 if some index pair indc(l), indr(l) duplicates !             another such pair. !         = 7 if the arrays a, indc, indr were not large enough. !             Their length \"lena\" should be increase to at least !             the value \"minlen\" given in luparm(13). !         = 8 if there was some other fatal error.  (Shouldn't happen!) !         = 9 if no diagonal pivot could be found with TSP or TDP. !             The matrix must not be sufficiently definite !             or quasi-definite. !         =10 if there was some other fatal error. v = b ! right hand side ! solve `A w = v`. call lu6sol ( options % mode , m , n , v , w , & lena , luparm , parmlu , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & inform ) !write(*,*) 'lu6sol inform = ', inform ! On exit, inform = 0 except as follows. ! If mode = 3,4,5,6 and if U (and hence A) is singular, then ! inform = 1 if there is a nonzero residual in solving the system ! involving U.  parmlu(20) returns the norm of the residual. x = w ! solution istat = int ( inform ) end subroutine solve","tags":"","loc":"proc/solve.html"},{"title":"func – AoC-2023","text":"function func(x) result(f) Test function to minimize. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x indep. variable Return Value real(kind=wp) function value f(x) Source Code function func ( x ) result ( f ) implicit none real ( wp ), intent ( in ) :: x !! indep. variable real ( wp ) :: f !! function value `f(x)` f = sin ( x ) end function func","tags":"","loc":"proc/func~4.html"},{"title":"jdamax – AoC-2023","text":"private  function jdamax(n, x, incx) result(iAmax) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: n real(kind=rp), intent(in) :: x (:) integer(kind=ip), intent(in) :: incx Return Value integer(kind=ip) Called by proc~~jdamax~~CalledByGraph proc~jdamax lusol::jdamax proc~lu1dcp lusol::lu1DCP proc~lu1dcp->proc~jdamax proc~lu1dpp lusol::lu1DPP proc~lu1dpp->proc~jdamax proc~lu1ful lusol::lu1ful proc~lu1ful->proc~lu1dcp proc~lu1ful->proc~lu1dpp proc~lu1fad lusol::lu1fad proc~lu1fad->proc~lu1ful proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function jdamax ( n , x , incx ) result ( iAmax ) integer ( ip ), intent ( in ) :: n , incx real ( rp ), intent ( in ) :: x (:) integer ( ip ) :: iAmax !=========================================================================== ! jdamax does the same as idamax in most cases. ! jdamax > 0 if x contains normal values. ! jdamax = 0 if n = 0. ! jdamax < 0 means x(-jdamax) contains the first NaN or Inf. ! ! 29 Jul 2003: First version of jdamax implemented for s5setx. ! 29 Jul 2003: Current version of jdamax ! 15 Mar 2008: First f90 version. !=========================================================================== intrinsic :: huge integer ( ip ) :: i , ix , kmax real ( rp ) :: dmax , xi real ( rp ), parameter :: realmax = huge ( realmax ) if ( n < 1 ) then iAmax = 0 return end if dmax = zero ix = 1 kmax = 1 do i = 1 , n xi = abs ( x ( ix ) ) if ( xi <= realmax ) then ! false if xi = Nan or Inf if ( dmax < xi ) then dmax = xi kmax = ix end if else go to 800 end if ix = ix + incx end do iAmax = kmax return 800 iAmax = - ix end function jdamax","tags":"","loc":"proc/jdamax.html"},{"title":"lu1fac – AoC-2023","text":"public  subroutine lu1fac(m, n, nelem, lena, luparm, parmlu, a, indc, indr, p, q, lenc, lenr, locc, locr, iploc, iqloc, ipinv, iqinv, w, inform) ! nelem  = numnz     !!! Don't change nelem.\n! nelem is now numnz below (it might be less than the input value). Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: nelem integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: indc (lena) integer(kind=ip), intent(inout) :: indr (lena) integer(kind=ip), intent(inout) :: p (m) integer(kind=ip), intent(inout) :: q (n) integer(kind=ip), intent(inout) :: lenc (n) integer(kind=ip), intent(inout) :: lenr (m) integer(kind=ip), intent(inout) :: locc (n) integer(kind=ip), intent(inout) :: locr (m) integer(kind=ip), intent(inout) :: iploc (n) integer(kind=ip), intent(inout) :: iqloc (m) integer(kind=ip), intent(inout) :: ipinv (m) integer(kind=ip), intent(inout) :: iqinv (n) real(kind=rp), intent(inout) :: w (n) integer(kind=ip), intent(out) :: inform Calls proc~~lu1fac~~CallsGraph proc~lu1fac lusol::lu1fac proc~lu1fad lusol::lu1fad proc~lu1fac->proc~lu1fad proc~lu1or1 lusol::lu1or1 proc~lu1fac->proc~lu1or1 proc~lu1or2 lusol::lu1or2 proc~lu1fac->proc~lu1or2 proc~lu1or3 lusol::lu1or3 proc~lu1fac->proc~lu1or3 proc~lu1or4 lusol::lu1or4 proc~lu1fac->proc~lu1or4 proc~lu1pq1 lusol::lu1pq1 proc~lu1fac->proc~lu1pq1 proc~lu1slk lusol::lu1slk proc~lu1fac->proc~lu1slk proc~lu6chk lusol::lu6chk proc~lu1fac->proc~lu6chk proc~hbuild lusol::Hbuild proc~lu1fad->proc~hbuild proc~hchange lusol::Hchange proc~lu1fad->proc~hchange proc~hdelete lusol::Hdelete proc~lu1fad->proc~hdelete proc~lu1ful lusol::lu1ful proc~lu1fad->proc~lu1ful proc~lu1gau lusol::lu1gau proc~lu1fad->proc~lu1gau proc~lu1mar lusol::lu1mar proc~lu1fad->proc~lu1mar proc~lu1mrp lusol::lu1mRP proc~lu1fad->proc~lu1mrp proc~lu1msp lusol::lu1mSP proc~lu1fad->proc~lu1msp proc~lu1mxc lusol::lu1mxc proc~lu1fad->proc~lu1mxc proc~lu1mxr lusol::lu1mxr proc~lu1fad->proc~lu1mxr proc~lu1pen lusol::lu1pen proc~lu1fad->proc~lu1pen proc~lu1pq2 lusol::lu1pq2 proc~lu1fad->proc~lu1pq2 proc~lu1pq3 lusol::lu1pq3 proc~lu1fad->proc~lu1pq3 proc~lu1rec lusol::lu1rec proc~lu1fad->proc~lu1rec proc~hinsert lusol::Hinsert proc~hbuild->proc~hinsert proc~hdown lusol::Hdown proc~hchange->proc~hdown proc~hup lusol::Hup proc~hchange->proc~hup proc~hdelete->proc~hchange proc~lu1dcp lusol::lu1DCP proc~lu1ful->proc~lu1dcp proc~lu1dpp lusol::lu1DPP proc~lu1ful->proc~lu1dpp proc~hinsert->proc~hup proc~jdamax lusol::jdamax proc~lu1dcp->proc~jdamax proc~lu1dpp->proc~jdamax Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~lu1fac~~CalledByGraph proc~lu1fac lusol::lu1fac proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1fac ( m , n , nelem , lena , luparm , parmlu , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & iploc , iqloc , ipinv , iqinv , w , inform ) integer ( ip ), intent ( in ) :: m , n , nelem , lena integer ( ip ), intent ( inout ) :: luparm ( 30 ) integer ( ip ), intent ( inout ) :: indc ( lena ), indr ( lena ), & p ( m ) , q ( n ) , & lenc ( n ) , lenr ( m ) , & iploc ( n ) , iqloc ( m ) , & ipinv ( m ) , iqinv ( n ) , & locc ( n ) , locr ( m ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), a ( lena ), w ( n ) integer ( ip ), intent ( out ) :: inform !------------------------------------------------------------------ ! lu1fac computes a factorization A = L*U, where A is a sparse ! matrix with m rows and n columns, P*L*P' is lower triangular ! and P*U*Q is upper triangular for certain permutations P, Q ! (which are returned in the arrays p, q). ! Stability is ensured by limiting the size of the elements of L. ! ! The nonzeros of A are input via the parallel arrays a, indc, indr, ! which should contain nelem entries of the form    aij,    i,    j ! in any order.  There should be no duplicate pairs         i,    j. ! ! ****************************************************************** ! *        Beware !!!   The row indices i must be in indc,         * ! *              and the column indices j must be in indr.         * ! *              (Not the other way round!)                        * ! ****************************************************************** ! ! It does not matter if some of the entries in a(*) are zero. ! Entries satisfying  abs( a(i) ) .le. parmlu(3)  are ignored. ! Other parameters in luparm and parmlu are described below. ! ! The matrix A may be singular.  On exit, nsing = luparm(11) gives ! the number of apparent singularities.  This is the number of ! \"small\" diagonals of the permuted factor U, as judged by ! the input tolerances Utol1 = parmlu(4) and  Utol2 = parmlu(5). ! The diagonal element diagj associated with column j of A is ! \"small\" if !                 abs( diagj ) .le. Utol1 ! or !                 abs( diagj ) .le. Utol2 * max( uj ), ! ! where max( uj ) is the maximum element in the j-th column of U. ! The position of such elements is returned in w(*).  In general, ! w(j) = + max( uj ),  but if column j is a singularity, ! w(j) = - max( uj ).  Thus, w(j) .le. 0 if column j appears to be ! dependent on the other columns of A. ! ! NOTE: lu1fac (like certain other sparse LU packages) does not ! treat dense columns efficiently.  This means it will be slow ! on \"arrow matrices\" of the form !                  A = (x       a) !                      (  x     b) !                      (    x   c) !                      (      x d) !                      (x x x x e) ! if the numerical values in the dense column allow it to be ! chosen LATE in the pivot order. ! ! With TPP (Threshold Partial Pivoting), the dense column is ! likely to be chosen late. ! ! With TCP (Threshold Complete Pivoting), if any of a,b,c,d ! is significantly larger than other elements of A, it will ! be chosen as the first pivot and the dense column will be ! eliminated, giving reasonably sparse factors. ! However, if element e is so big that TCP chooses it, the factors ! will become dense.  (It's hard to win on these examples!) !================================================================== ! ! ! Notes on the array names ! ------------------------ ! ! During the LU factorization, the sparsity pattern of the matrix ! being factored is stored twice: in a column list and a row list. ! ! The column list is ( a, indc, locc, lenc ) ! where !       a(*)    holds the nonzeros, !       indc(*) holds the indices for the column list, !       locc(j) points to the start of column j in a(*) and indc(*), !       lenc(j) is the number of nonzeros in column j. ! ! The row list is    (    indr, locr, lenr ) ! where !       indr(*) holds the indices for the row list, !       locr(i) points to the start of row i in indr(*), !       lenr(i) is the number of nonzeros in row i. ! ! ! At all stages of the LU factorization, p contains a complete ! row permutation.  At the start of stage k,  p(1), ..., p(k-1) ! are the first k-1 rows of the final row permutation P. ! The remaining rows are stored in an ordered list !                    ( p, iploc, ipinv ) ! where !       iploc(nz) points to the start in p(*) of the set of rows !                 that currently contain nz nonzeros, !       ipinv(i)  points to the position of row i in p(*). ! ! For example, !       iploc(1) = k   (and this is where rows of length 1 begin), !       iploc(2) = k+p  if there are p rows of length 1 !                      (and this is where rows of length 2 begin). ! ! Similarly for q, iqloc, iqinv. !================================================================== ! ! ! 00 Jun 1983  Original version. ! 00 Jul 1987  nrank  saved in luparm(16). ! 12 Apr 1989  ipinv, iqinv added as workspace. ! 26 Apr 1989  maxtie replaced by maxcol in Markowitz search. ! 16 Mar 1992  jumin  saved in luparm(19). ! 10 Jun 1992  lu1fad has to move empty rows and cols to the bottom !              (via lu1pq3) before doing the dense LU. ! 12 Jun 1992  Deleted dense LU (lu1ful, lu1vlu). ! 25 Oct 1993  keepLU implemented. ! 07 Feb 1994  Added new dense LU (lu1ful, lu1den). ! 21 Dec 1994  Bugs fixed in lu1fad (nrank) and lu1ful (ipvt). ! 08 Aug 1995  Use p instead of w as parameter to lu1or3 (for F90). ! 13 Sep 2000  TPP and TCP options implemented. ! 17 Oct 2000  Fixed troubles due to A = empty matrix (Todd Munson). ! 01 Dec 2000  Save Lmax, Umax, etc. after both lu1fad and lu6chk. !              lu1fad sets them when keepLU = false. !              lu6chk sets them otherwise, and includes items !              from the dense LU. ! 11 Mar 2001  lu6chk now looks at diag(U) when keepLU = false. ! 26 Apr 2002  New TCP implementation using heap routines to !              store largest element in each column. !              New workspace arrays Ha, Hj, Hk required. !              For compatibility, borrow space from a, indc, indr !              rather than adding new input parameters. ! 01 May 2002  lu1den changed to lu1DPP (dense partial  pivoting). !              lu1DCP implemented       (dense complete pivoting). !              Both TPP and TCP now switch to dense mode and end. ! ! 10 Jan 2010: First f90 version. !--------------------------------------------------------------------- ! ! !  INPUT PARAMETERS ! !  m      (not altered) is the number of rows in A. !  n      (not altered) is the number of columns in A. !  nelem  (not altered) is the number of matrix entries given in !         the arrays a, indc, indr. !  lena   (not altered) is the dimension of  a, indc, indr. !         This should be significantly larger than nelem. !         Typically one should have !            lena > max( 2*nelem, 10*m, 10*n, 10000 ) !         but some applications may need more. !         On machines with virtual memory it is safe to have !         lena \"far bigger than necessary\", since not all of the !         arrays will be used. !  a      (overwritten) contains entries   Aij  in   a(1:nelem). !  indc   (overwritten) contains the indices i in indc(1:nelem). !  indr   (overwritten) contains the indices j in indr(1:nelem). ! !  luparm input parameters:                                Typical value ! !  luparm( 1) = nout     File number for printed messages.         6 ! !  luparm( 2) = lprint   Print level.                              0 !                   <  0 suppresses output. !                   =  0 gives error messages. !                  >= 10 gives statistics about the LU factors. !                  >= 50 gives debug output from lu1fac !                        (the pivot row and column and the !                        no. of rows and columns involved at !                        each elimination step). ! !  luparm( 3) = maxcol   lu1fac: maximum number of columns         5 !                        searched allowed in a Markowitz-type !                        search for the next pivot element. !                        For some of the factorization, the !                        number of rows searched is !                        maxrow = maxcol - 1. ! !  luparm( 6) = 0    =>  TPP: Threshold Partial   Pivoting.        0 !             = 1    =>  TRP: Threshold Rook      Pivoting. !             = 2    =>  TCP: Threshold Complete  Pivoting. !             = 3    =>  TSP: Threshold Symmetric Pivoting. !             = 4    =>  TDP: Threshold Diagonal  Pivoting. !                             (TDP not yet implemented). !                        TRP and TCP are more expensive than TPP but !                        more stable and better at revealing rank. !                        Take care with setting parmlu(1), especially !                        with TCP. !                        NOTE: TSP and TDP are for symmetric matrices !                        that are either definite or quasi-definite. !                        TSP is effectively TRP for symmetric matrices. !                        TDP is effectively TCP for symmetric matrices. ! !  luparm( 8) = keepLU   lu1fac: keepLU = 1 means the numerical    1 !                        factors will be computed if possible. !                        keepLU = 0 means L and U will be discarded !                        but other information such as the row and !                        column permutations will be returned. !                        The latter option requires less storage. ! !  parmlu input parameters:                                Typical value ! !  parmlu( 1) = Ltol1    Max Lij allowed during Factor. !                                                  TPP     10.0 or 100.0 !                                                  TRP      4.0 or  10.0 !                                                  TCP      5.0 or  10.0 !                                                  TSP      4.0 or  10.0 !                        With TRP and TCP (Rook and Complete Pivoting), !                        values less than 25.0 may be expensive !                        on badly scaled data.  However, !                        values less than 10.0 may be needed !                        to obtain a reliable rank-revealing !                        factorization. !  parmlu( 2) = Ltol2    Max Lij allowed during Updates.            10.0 !                        during updates. !  parmlu( 3) = small    Absolute tolerance for       eps**0.8 = 3.0d-13 !                        treating reals as zero. !  parmlu( 4) = Utol1    Absolute tol for flagging    eps**0.67= 3.7d-11 !                        small diagonals of U. !  parmlu( 5) = Utol2    Relative tol for flagging    eps**0.67= 3.7d-11 !                        small diagonals of U. !                        (eps = machine precision) !  parmlu( 6) = Uspace   Factor limiting waste space in  U.      3.0 !                        In lu1fac, the row or column lists !                        are compressed if their length !                        exceeds Uspace times the length of !                        either file after the last compression. !  parmlu( 7) = dens1    The density at which the Markowitz      0.3 !                        pivot strategy should search maxcol !                        columns and no rows. !                        (Use 0.3 unless you are experimenting !                        with the pivot strategy.) !  parmlu( 8) = dens2    the density at which the Markowitz      0.5 !                        strategy should search only 1 column, !                        or (if storage is available) !                        the density at which all remaining !                        rows and columns will be processed !                        by a dense LU code. !                        For example, if dens2 = 0.1 and lena is !                        large enough, a dense LU will be used !                        once more than 10 per cent of the !                        remaining matrix is nonzero. ! ! !  OUTPUT PARAMETERS ! !  a, indc, indr     contain the nonzero entries in the LU factors of A. !         If keepLU = 1, they are in a form suitable for use !         by other parts of the LUSOL package, such as lu6sol. !         U is stored by rows at the start of a, indr. !         L is stored by cols at the end   of a, indc. !         If keepLU = 0, only the diagonals of U are stored, at the !         end of a. !  p, q   are the row and column permutations defining the !         pivot order.  For example, row p(1) and column q(1) !         defines the first diagonal of U. !  lenc(1:numl0) contains the number of entries in nontrivial !         columns of L (in pivot order). !  lenr(1:m) contains the number of entries in each row of U !         (in original order). !  locc(1:n) = 0 (ready for the LU update routines). !  locr(1:m) points to the beginning of the rows of U in a, indr. !  iploc, iqloc, ipinv, iqinv  are undefined. !  w      indicates singularity as described above. !  inform = 0 if the LU factors were obtained successfully. !         = 1 if U appears to be singular, as judged by lu6chk. !         = 3 if some index pair indc(l), indr(l) lies outside !             the matrix dimensions 1:m , 1:n. !         = 4 if some index pair indc(l), indr(l) duplicates !             another such pair. !         = 7 if the arrays a, indc, indr were not large enough. !             Their length \"lena\" should be increase to at least !             the value \"minlen\" given in luparm(13). !         = 8 if there was some other fatal error.  (Shouldn't happen!) !         = 9 if no diagonal pivot could be found with TSP or TDP. !             The matrix must not be sufficiently definite !             or quasi-definite. !         =10 if there was some other fatal error. ! !  luparm output parameters: ! !  luparm(10) = inform   Return code from last call to any LU routine. !  luparm(11) = nsing    No. of singularities marked in the !                        output array w(*). !  luparm(12) = jsing    Column index of last singularity. !  luparm(13) = minlen   Minimum recommended value for  lena. !  luparm(14) = maxlen   ? !  luparm(15) = nupdat   No. of updates performed by the lu8 routines. !  luparm(16) = nrank    No. of nonempty rows of U. !  luparm(17) = ndens1   No. of columns remaining when the density of !                        the matrix being factorized reached dens1. !  luparm(18) = ndens2   No. of columns remaining when the density of !                        the matrix being factorized reached dens2. !  luparm(19) = jumin    The column index associated with DUmin. !  luparm(20) = numL0    No. of columns in initial  L. !  luparm(21) = lenL0    Size of initial  L  (no. of nonzeros). !  luparm(22) = lenU0    Size of initial  U. !  luparm(23) = lenL     Size of current  L. !  luparm(24) = lenU     Size of current  U. !  luparm(25) = lrow     Length of row file. !  luparm(26) = ncp      No. of compressions of LU data structures. !  luparm(27) = mersum   lu1fac: sum of Markowitz merit counts. !  luparm(28) = nUtri    lu1fac: triangular rows in U. !  luparm(29) = nLtri    lu1fac: triangular rows in L. !  luparm(30) = nslack   lu1fac: no. of unit vectors at start of U. (info only) ! ! ! !  parmlu output parameters: ! !  parmlu(10) = Amax     Maximum element in  A. !  parmlu(11) = Lmax     Maximum multiplier in current  L. !  parmlu(12) = Umax     Maximum element in current  U. !  parmlu(13) = DUmax    Maximum diagonal in  U. !  parmlu(14) = DUmin    Minimum diagonal in  U. !  parmlu(15) = Akmax    Maximum element generated at any stage !                        during TCP factorization. !  parmlu(16) = growth   TPP: Umax/Amax    TRP, TCP, TSP: Akmax/Amax !  parmlu(17) = !  parmlu(18) = !  parmlu(19) = !  parmlu(20) = resid    lu6sol: residual after solve with U or U'. !  ... !  parmlu(30) = !--------------------------------------------------------------------- character ( 1 ) :: mnkey character ( 2 ) :: kPiv ( 0 : 3 ) integer ( ip ) :: i , idummy , j , jsing , jumin , & k , l , l2 , lena2 , lenH , lenL , & lenLk , lenU , lenUk , lerr , & ll , llsave , lm , lmaxr , locH , & lprint , lPiv , lrow , ltopl , & lu , mersum , minlen , nbump , & ncp , ndens1 , ndens2 , & nLtri , nmove , nout , nrank , & nsing , numl0 , numnz , nslack , nUtri logical :: keepLU , TCP , TPP , TRP , TSP real ( rp ) :: Agrwth , Akmax , Amax , avgmer , & condU , delem , densty , dincr , & dm , dn , DUmax , DUmin , growth , & Lmax , Ltol , small , Ugrwth , & Umax ! Grab relevant input parameters. nout = luparm ( 1 ) lprint = luparm ( 2 ) lPiv = luparm ( 6 ) keepLU = luparm ( 8 ) /= 0 Ltol = parmlu ( 1 ) ! Limit on size of Lij small = parmlu ( 3 ) ! Drop tolerance TPP = lPiv == 0 ! Threshold Partial   Pivoting (normal). TRP = lPiv == 1 ! Threshold Rook      Pivoting TCP = lPiv == 2 ! Threshold Complete  Pivoting. TSP = lPiv == 3 ! Threshold Symmetric Pivoting. kPiv ( 0 ) = 'PP' kPiv ( 1 ) = 'RP' kPiv ( 2 ) = 'CP' kPiv ( 3 ) = 'SP' ! Initialize output parameters. inform = 0 minlen = nelem + 2 * ( m + n ) numl0 = 0 lenL = 0 lenU = 0 lrow = 0 mersum = 0 nUtri = m nLtri = 0 ndens1 = 0 ndens2 = 0 nrank = 0 nsing = 0 jsing = 0 jumin = 0 nslack = 0 Amax = zero Lmax = zero Umax = zero DUmax = zero DUmin = zero Akmax = zero if ( m > n ) then mnkey = '>' else if ( m == n ) then mnkey = '=' else mnkey = '<' end if ! Float version of dimensions. dm = m dn = n delem = nelem ! Initialize workspace parameters. luparm ( 26 ) = 0 ! ncp if ( lena < minlen ) go to 970 !------------------------------------------------------------------- ! Organize the  aij's  in  a, indc, indr. ! lu1or1  deletes small entries, tests for illegal  i,j's, !         and counts the nonzeros in each row and column. ! lu1or2  reorders the elements of  A  by columns. ! lu1or3  uses the column list to test for duplicate entries !         (same indices  i,j). ! lu1or4  constructs a row list from the column list. !------------------------------------------------------------------- call lu1or1 ( m , n , nelem , lena , small , & a , indc , indr , lenc , lenr , & Amax , numnz , lerr , inform ) if ( nout > 0 . and . lprint >= 10 ) then densty = 10 0.0_rp * delem / ( dm * dn ) write ( nout , 1000 ) m , mnkey , n , numnz , Amax , densty end if if ( inform /= 0 ) go to 930 !!! nelem  = numnz     !!! Don't change nelem. !!! nelem is now numnz below (it might be less than the input value). call lu1or2 ( n , numnz , lena , a , indc , indr , lenc , locc ) call lu1or3 ( m , n , lena , indc , lenc , locc , p , lerr , inform ) if ( inform /= 0 ) go to 940 call lu1or4 ( m , n , numnz , lena , indc , indr , lenc , lenr , locc , locr ) !------------------------------------------------------------------ ! Set up lists of rows and columns with equal numbers of nonzeros, ! using  indc(*)  as workspace. ! 12 Dec 2015: Always call lu1slk here now. ! This sets nslack and w(j) = 1.0 for slacks, else 0.0. !------------------------------------------------------------------ call lu1pq1 ( m , n , lenr , p , iploc , ipinv , indc ( numnz + 1 ) ) call lu1pq1 ( n , m , lenc , q , iqloc , iqinv , indc ( numnz + 1 ) ) call lu1slk ( m , n , lena , q , iqloc , a , indc , locc , nslack , w ) luparm ( 30 ) = nslack !------------------------------------------------------------------ ! For TCP, allocate Ha, Hj, Hk at the end of a, indc, indr. ! Then compute the factorization  A = L*U. !------------------------------------------------------------------ lenH = 0 ! Keep -Wmaybe-uninitialized happy. lena2 = 0 ! locH = 0 ! lmaxr = 0 ! if ( TPP . or . TSP ) then lenH = 1 lena2 = lena locH = lena lmaxr = 1 else if ( TRP ) then lenH = 1 ! Dummy lena2 = lena - m ! Reduced length of      a locH = lena ! Dummy lmaxr = lena2 + 1 ! Start of Amaxr      in a else if ( TCP ) then lenH = n ! Length of heap lena2 = lena - lenH ! Reduced length of      a, indc, indr locH = lena2 + 1 ! Start of Ha, Hj, Hk in a, indc, indr lmaxr = 1 ! Dummy end if call lu1fad ( m , n , numnz , lena2 , luparm , parmlu , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & iploc , iqloc , ipinv , iqinv , w , & lenH , a ( locH ), indc ( locH ), indr ( locH ), a ( lmaxr ), & inform , lenL , lenU , minlen , mersum , & nUtri , nLtri , ndens1 , ndens2 , nrank , nslack , & Lmax , Umax , DUmax , DUmin , Akmax ) luparm ( 16 ) = nrank luparm ( 23 ) = lenL if ( inform == 7 ) go to 970 if ( inform == 9 ) go to 985 if ( inform == 10 ) go to 981 if ( inform > 0 ) go to 980 if ( keepLU ) then !--------------------------------------------------------------- ! The LU factors are at the top of  a, indc, indr, ! with the columns of  L  and the rows of  U  in the order ! ! ( free )   ... ( u3 ) ( l3 ) ( u2 ) ( l2 ) ( u1 ) ( l1 ). ! ! Starting with ( l1 ) and ( u1 ), move the rows of  U  to the ! left and the columns of  L  to the right, giving ! ! ( u1 ) ( u2 ) ( u3 ) ...   ( free )   ... ( l3 ) ( l2 ) ( l1 ). ! ! Also, set  numl0 = the number of nonempty columns of L. !--------------------------------------------------------------- lu = 0 ll = lena + 1 lm = lena2 + 1 ltopl = ll - lenL - lenU lrow = lenU do k = 1 , nrank i = p ( k ) lenUk = - lenr ( i ) lenr ( i ) = lenUk j = q ( k ) lenLk = - lenc ( j ) - 1 if ( lenLk > 0 ) then numl0 = numl0 + 1 iqloc ( numl0 ) = lenLk end if if ( lu + lenUk < ltopl ) then !========================================================= ! There is room to move ( uk ).  Just right-shift ( lk ). !========================================================= do idummy = 1 , lenLk ll = ll - 1 lm = lm - 1 a ( ll ) = a ( lm ) indc ( ll ) = indc ( lm ) indr ( ll ) = indr ( lm ) end do else !========================================================= ! There is no room for ( uk ) yet.  We have to ! right-shift the whole of the remaining LU file. ! Note that ( lk ) ends up in the correct place. !========================================================= llsave = ll - lenLk nmove = lm - ltopl do idummy = 1 , nmove ll = ll - 1 lm = lm - 1 a ( ll ) = a ( lm ) indc ( ll ) = indc ( lm ) indr ( ll ) = indr ( lm ) end do ltopl = ll ll = llsave lm = ll end if !====================================================== ! Left-shift ( uk ). !====================================================== locr ( i ) = lu + 1 l2 = lm - 1 lm = lm - lenUk do l = lm , l2 lu = lu + 1 a ( lu ) = a ( l ) indr ( lu ) = indr ( l ) end do end do !--------------------------------------------------------------- ! Save the lengths of the nonempty columns of  L, ! and initialize  locc(j)  for the LU update routines. !--------------------------------------------------------------- lenc ( 1 : numl0 ) = iqloc ( 1 : numl0 ) locc ( 1 : n ) = 0 !--------------------------------------------------------------- ! Test for singularity. ! lu6chk  sets  nsing, jsing, jumin, Lmax, Umax, DUmax, DUmin ! (including entries from the dense LU). ! input      i1 = 1 means we're calling lu6chk from LUSOL. ! output inform = 1 if there are singularities (nsing > 0). ! 12 Dec 2015: nslack is now an input. !--------------------------------------------------------------- call lu6chk ( i1 , m , n , nslack , w , lena , luparm , parmlu , & a , indc , indr , p , q , & lenc , lenr , locc , locr , inform ) nsing = luparm ( 11 ) jsing = luparm ( 12 ) jumin = luparm ( 19 ) Lmax = parmlu ( 11 ) Umax = parmlu ( 12 ) DUmax = parmlu ( 13 ) DUmin = parmlu ( 14 ) else !--------------------------------------------------------------- ! keepLU = 0.  L and U were not kept, just the diagonals of U. ! lu1fac will probably be called again soon with keepLU = .true. ! 11 Mar 2001: lu6chk revised.  We can call it with keepLU = 0, !              but we want to keep Lmax, Umax from lu1fad. ! 05 May 2002: Allow for TCP with new lu1DCP.  Diag(U) starts !              below lena2, not lena.  Need lena2 in next line. ! 12 Dec 2015: nslack is now an input. !--------------------------------------------------------------- call lu6chk ( i1 , m , n , nslack , w , lena2 , luparm , parmlu , & a , indc , indr , p , q , & lenc , lenr , locc , locr , inform ) nsing = luparm ( 11 ) jsing = luparm ( 12 ) jumin = luparm ( 19 ) DUmax = parmlu ( 13 ) DUmin = parmlu ( 14 ) end if go to 990 !------------ ! Error exits. !------------ 930 inform = 3 if ( lprint >= 0 ) write ( nout , 1300 ) lerr , indc ( lerr ), indr ( lerr ) go to 990 940 inform = 4 if ( lprint >= 0 ) write ( nout , 1400 ) lerr , indc ( lerr ), indr ( lerr ) go to 990 970 inform = 7 if ( lprint >= 0 ) write ( nout , 1700 ) lena , minlen go to 990 980 inform = 8 if ( lprint >= 0 ) write ( nout , 1800 ) go to 990 981 inform = 10 go to 990 985 inform = 9 if ( lprint >= 0 ) write ( nout , 1900 ) ! Store output parameters. 990 luparm ( 10 ) = inform luparm ( 11 ) = nsing luparm ( 12 ) = jsing luparm ( 13 ) = minlen luparm ( 15 ) = 0 luparm ( 16 ) = nrank luparm ( 17 ) = ndens1 luparm ( 18 ) = ndens2 luparm ( 19 ) = jumin luparm ( 20 ) = numl0 luparm ( 21 ) = lenL luparm ( 22 ) = lenU luparm ( 23 ) = lenL luparm ( 24 ) = lenU luparm ( 25 ) = lrow luparm ( 27 ) = mersum luparm ( 28 ) = nUtri luparm ( 29 ) = nLtri parmlu ( 10 ) = Amax parmlu ( 11 ) = Lmax parmlu ( 12 ) = Umax parmlu ( 13 ) = DUmax parmlu ( 14 ) = DUmin parmlu ( 15 ) = Akmax Agrwth = Akmax / ( Amax + 1.0e-20_rp ) Ugrwth = Umax / ( Amax + 1.0e-20_rp ) if ( TPP ) then growth = Ugrwth else ! TRP or TCP or TSP growth = Agrwth end if parmlu ( 16 ) = growth !------------------------------------------------------------------ ! Print statistics for the LU factors. !------------------------------------------------------------------ ncp = luparm ( 26 ) condU = DUmax / max ( DUmin , 1.0e-20_rp ) dincr = lenL + lenU - nelem dincr = dincr * 10 0.0_rp / max ( delem , one ) avgmer = mersum avgmer = avgmer / dm nbump = m - nUtri - nLtri if ( nout > 0 . and . lprint >= 10 ) then if ( TPP ) then write ( nout , 1100 ) avgmer , lenL , lenL + lenU , ncp , dincr , & nUtri , lenU , Ltol , Umax , Ugrwth , & nLtri , ndens1 , Lmax else write ( nout , 1120 ) kPiv ( lPiv ), avgmer , & lenL , lenL + lenU , ncp , dincr , & nUtri , lenU , Ltol , Umax , Ugrwth , & nLtri , ndens1 , Lmax , Akmax , Agrwth end if write ( nout , 1200 ) nbump , ndens2 , DUmax , DUmin , condU end if return 1000 format ( ' m' , i12 , ' ' , a , 'n' , i12 , '  Elems' , i9 , & '  Amax' , es10 . 1 , '  Density' , f7 . 2 ) 1100 format ( ' Merit' , f8 . 1 , '  lenL' , i9 , '  L+U' , i11 , & '  Cmpressns' , i5 , '  Incres' , f8 . 2 & / ' Utri' , i9 , '  lenU' , i9 , '  Ltol' , es10 . 2 , & '  Umax' , es10 . 1 , '  Ugrwth' , es8 . 1 & / ' Ltri' , i9 , '  dense1' , i7 , '  Lmax' , es10 . 2 ) 1120 format ( ' Mer' , a2 , f8 . 1 , '  lenL' , i9 , '  L+U' , i11 , & '  Cmpressns' , i5 , '  Incres' , f8 . 2 & / ' Utri' , i9 , '  lenU' , i9 , '  Ltol' , es10 . 2 , & '  Umax' , es10 . 1 , '  Ugrwth' , es8 . 1 & / ' Ltri' , i9 , '  dense1' , i7 , '  Lmax' , es10 . 2 , & '  Akmax' , es9 . 1 , '  Agrwth' , es8 . 1 ) 1200 format ( ' bump' , i9 , '  dense2' , i7 , '  DUmax' , es9 . 1 , & '  DUmin' , es9 . 1 , '  condU' , es9 . 1 ) 1300 format ( / ' lu1fac  error...  entry  a(' , i8 , ')  has an illegal' , & ' row or column index' & // ' indc, indr =' , 2 i8 ) 1400 format ( / ' lu1fac  error...  entry  a(' , i8 , ')  has the same' , & ' indices as an earlier entry' & // ' indc, indr =' , 2 i8 ) 1700 format ( / ' lu1fac  error...  insufficient storage' & // ' Increase  lena  from' , i10 , '  to at least' , i10 ) 1800 format ( / ' lu1fac  error...  fatal bug' , & '   (sorry --- this should never happen)' ) 1900 format ( / ' lu1fac  error...  TSP used but' , & ' diagonal pivot could not be found' ) end subroutine lu1fac","tags":"","loc":"proc/lu1fac.html"},{"title":"lu1fad – AoC-2023","text":"private  subroutine lu1fad(m, n, nelem, lena, luparm, parmlu, a, indc, indr, p, q, lenc, lenr, locc, locr, iploc, iqloc, ipinv, iqinv, w, lenH, Ha, Hj, Hk, Amaxr, inform, lenL, lenU, minlen, mersum, nUtri, nLtri, ndens1, ndens2, nrank, nslack, Lmax, Umax, DUmax, DUmin, Akmax) !   a(ldiagU + nrowu) = abest ! This was in pivot order.\n!!! DEBUG Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: nelem integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: indc (lena) integer(kind=ip), intent(inout) :: indr (lena) integer(kind=ip), intent(inout) :: p (m) integer(kind=ip), intent(inout) :: q (n) integer(kind=ip), intent(inout) :: lenc (n) integer(kind=ip), intent(inout) :: lenr (m) integer(kind=ip), intent(inout) :: locc (n) integer(kind=ip), intent(inout) :: locr (m) integer(kind=ip), intent(inout) :: iploc (n) integer(kind=ip), intent(inout) :: iqloc (m) integer(kind=ip), intent(inout) :: ipinv (m) integer(kind=ip), intent(inout) :: iqinv (n) real(kind=rp), intent(inout) :: w (n) integer(kind=ip), intent(in) :: lenH real(kind=rp), intent(inout) :: Ha (lenH) integer(kind=ip), intent(inout) :: Hj (lenH) integer(kind=ip), intent(inout) :: Hk (lenH) real(kind=rp), intent(inout) :: Amaxr (m) integer(kind=ip), intent(out) :: inform integer(kind=ip), intent(out) :: lenL integer(kind=ip), intent(out) :: lenU integer(kind=ip), intent(out) :: minlen integer(kind=ip), intent(out) :: mersum integer(kind=ip), intent(out) :: nUtri integer(kind=ip), intent(out) :: nLtri integer(kind=ip), intent(out) :: ndens1 integer(kind=ip), intent(out) :: ndens2 integer(kind=ip), intent(out) :: nrank integer(kind=ip), intent(in) :: nslack real(kind=rp), intent(out) :: Lmax real(kind=rp), intent(out) :: Umax real(kind=rp), intent(out) :: DUmax real(kind=rp), intent(out) :: DUmin real(kind=rp), intent(out) :: Akmax Calls proc~~lu1fad~~CallsGraph proc~lu1fad lusol::lu1fad proc~hbuild lusol::Hbuild proc~lu1fad->proc~hbuild proc~hchange lusol::Hchange proc~lu1fad->proc~hchange proc~hdelete lusol::Hdelete proc~lu1fad->proc~hdelete proc~lu1ful lusol::lu1ful proc~lu1fad->proc~lu1ful proc~lu1gau lusol::lu1gau proc~lu1fad->proc~lu1gau proc~lu1mar lusol::lu1mar proc~lu1fad->proc~lu1mar proc~lu1mrp lusol::lu1mRP proc~lu1fad->proc~lu1mrp proc~lu1msp lusol::lu1mSP proc~lu1fad->proc~lu1msp proc~lu1mxc lusol::lu1mxc proc~lu1fad->proc~lu1mxc proc~lu1mxr lusol::lu1mxr proc~lu1fad->proc~lu1mxr proc~lu1pen lusol::lu1pen proc~lu1fad->proc~lu1pen proc~lu1pq2 lusol::lu1pq2 proc~lu1fad->proc~lu1pq2 proc~lu1pq3 lusol::lu1pq3 proc~lu1fad->proc~lu1pq3 proc~lu1rec lusol::lu1rec proc~lu1fad->proc~lu1rec proc~hinsert lusol::Hinsert proc~hbuild->proc~hinsert proc~hdown lusol::Hdown proc~hchange->proc~hdown proc~hup lusol::Hup proc~hchange->proc~hup proc~hdelete->proc~hchange proc~lu1dcp lusol::lu1DCP proc~lu1ful->proc~lu1dcp proc~lu1dpp lusol::lu1DPP proc~lu1ful->proc~lu1dpp proc~hinsert->proc~hup proc~jdamax lusol::jdamax proc~lu1dcp->proc~jdamax proc~lu1dpp->proc~jdamax Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~lu1fad~~CalledByGraph proc~lu1fad lusol::lu1fad proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1fad ( m , n , nelem , lena , luparm , parmlu , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & iploc , iqloc , ipinv , iqinv , w , & lenH , Ha , Hj , Hk , Amaxr , & inform , lenL , lenU , minlen , mersum , & nUtri , nLtri , ndens1 , ndens2 , nrank , nslack , & Lmax , Umax , DUmax , DUmin , Akmax ) integer ( ip ), intent ( in ) :: m , n , nelem , lena , lenH , nslack integer ( ip ), intent ( inout ) :: luparm ( 30 ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), a ( lena ), Amaxr ( m ), & w ( n ), Ha ( lenH ) integer ( ip ), intent ( inout ) :: indc ( lena ), indr ( lena ), & p ( m ) , q ( n ) , & lenc ( n ) , lenr ( m ) , & locc ( n ) , locr ( m ) , & iploc ( n ) , iqloc ( m ) , & ipinv ( m ), iqinv ( n ), & Hj ( lenH ) , Hk ( lenH ) integer ( ip ), intent ( out ) :: inform , lenL , lenU , & minlen , mersum , & nUtri , nLtri , ndens1 , ndens2 , nrank real ( rp ), intent ( out ) :: Lmax , Umax , DUmax , DUmin , Akmax !------------------------------------------------------------------ ! lu1fad  is a driver for the numerical phase of lu1fac. ! At each stage it computes a column of  L  and a row of  U, ! using a Markowitz criterion to select the pivot element, ! subject to a stability criterion that bounds the elements of  L. ! ! 00 Jan 1986  Version documented in LUSOL paper: !              Gill, Murray, Saunders and Wright (1987), !              Maintaining LU factors of a general sparse matrix, !              Linear algebra and its applications 88/89, 239-270. ! ! 02 Feb 1989  Following Suhl and Aittoniemi (1987), the largest !              element in each column is now kept at the start of !              the column, i.e. in position locc(j) of a and indc. !              This should speed up the Markowitz searches. !              To save time on highly triangular matrices, we wait !              until there are no further columns of length 1 !              before setting and maintaining that property. ! ! 12 Apr 1989  ipinv and iqinv added (inverses of p and q) !              to save searching p and q for rows and columns !              altered in each elimination step.  (Used in lu1pq2) ! ! 19 Apr 1989  Code segmented to reduce its size. !              lu1gau does most of the Gaussian elimination work. !              lu1mar does just the Markowitz search. !              lu1mxc moves biggest elements to top of columns. !              lu1pen deals with pending fill-in in the row list. !              lu1pq2 updates the row and column permutations. ! ! 26 Apr 1989  maxtie replaced by maxcol, maxrow in the Markowitz !              search.  maxcol, maxrow change as density increases. ! ! 25 Oct 1993  keepLU implemented. ! ! 07 Feb 1994  Exit main loop early to finish off with a dense LU. !              densLU tells lu1fad whether to do it. ! 21 Dec 1994  Bug fixed.  nrank was wrong after the call to lu1ful. ! 12 Nov 1999  A parallel version of dcopy gave trouble in lu1ful !              during left-shift of dense matrix D within a(*). !              Fixed this unexpected problem here in lu1fad !              by making sure the first and second D don't overlap. ! ! 13 Sep 2000  TCP (Threshold Complete Pivoting) implemented. !              lu2max added !              (finds aijmax from biggest elems in each col). !              Utri, Ltri and Spars1 phases apply. !              No switch to Dense CP yet.  (Only TPP switches.) ! 14 Sep 2000  imax needed to remember row containing aijmax. ! 22 Sep 2000  For simplicity, lu1mxc always fixes !              all modified cols. !              (TPP spars2 used to fix just the first maxcol cols.) ! 08 Nov 2000: Speed up search for aijmax. !              Don't need to search all columns if the elimination !              didn't alter the col containing the current aijmax. ! 21 Nov 2000: lu1slk implemented for Utri phase with TCP !              to guard against deceptive triangular matrices. !              (Utri used to have aijtol >= 0.9999 to include !              slacks, but this allows other 1s to be accepted.) !              Utri now accepts slacks, but applies normal aijtol !              test to other pivots. ! 28 Nov 2000: TCP with empty cols must call lu1mxc and lu2max !              with ( lq1, n, ... ), not just ( 1, n, ... ). ! 23 Mar 2001: lu1fad bug with TCP. !              A col of length 1 might not be accepted as a pivot. !              Later it appears in a pivot row and temporarily !              has length 0 (when pivot row is removed !              but before the column is filled in).  If it is the !              last column in storage, the preceding col also thinks !              it is \"last\".  Trouble arises when the preceding col !              needs fill-in -- it overlaps the real \"last\" column. !              (Very rarely, same trouble might have happened if !              the drop tolerance caused columns to have length 0.) ! !              Introduced ilast to record the last row in row file, !                         jlast to record the last col in col file. !              lu1rec returns ilast = indr(lrow + 1) !                          or jlast = indc(lcol + 1). !        ***   (Should be an output parameter, but didn't want to !              alter lu1rec's parameter list.) !              lu1rec also treats empty rows or cols safely. !              (Doesn't eliminate them!) !        ***   20 Dec 2015: Made ilast an output as it should be. ! ! 26 Apr 2002: Heap routines added for TCP. !              lu2max no longer needed. !              imax, jmax used only for printing. ! 01 May 2002: lu1DCP implemented (dense complete pivoting). !              Both TPP and TCP now switch to dense LU !              when density exceeds dens2. ! 06 May 2002: In dense mode, store diag(U) in natural order. ! 09 May 2002: lu1mCP implemented (Markowitz TCP via heap). ! 11 Jun 2002: lu1mRP implemented (Markowitz TRP). ! 28 Jun 2002: Fixed call to lu1mxr. ! 14 Dec 2002: lu1mSP implemented (Markowitz TSP). ! 15 Dec 2002: Both TPP and TSP can grab cols of length 1 !              during Utri. ! 19 Dec 2004: Hdelete(...) has new input argument Hlenin. ! 26 Mar 2006: lu1fad returns nrank  = min( mrank, nrank ) !              and ignores nsing from lu1ful ! ! 10 Jan 2010: First f90 version. ! 03 Apr 2013: lu1mxr recoded to improve efficiency of TRP. ! 12 Dec 2015: nslack is now an input. ! 20 Dec 2015: lu1rec returns ilast as output parameter. !------------------------------------------------------------------ logical :: Utri , Ltri , spars1 , spars2 , dense , & densLU , keepLU , TCP , TPP , TRP , TSP real ( rp ) :: abest , aijmax , aijtol , amax , & dens1 , dens2 , diag , & Lij , Ltol , small , Uspace !------------------------------------------------------------------ ! Local variables !--------------- ! ! lcol   is the length of the column file.  It points to the last !        nonzero in the column list. ! lrow   is the analogous quantity for the row file. ! lfile  is the file length (lcol or lrow) after the most recent !        compression of the column list or row list. ! nrowd  and  ncold  are the number of rows and columns in the !        matrix defined by the pivot column and row.  They are the !        dimensions of the submatrix D being altered at this stage. ! melim  and  nelim  are the number of rows and columns in the !        same matrix D, excluding the pivot column and row. ! mleft  and  nleft  are the number of rows and columns !        still left to be factored. ! nzchng is the increase in nonzeros in the matrix that remains !        to be factored after the current elimination !        (usually negative). ! nzleft is the number of nonzeros still left to be factored. ! nspare is the space we leave at the end of the last row or !        column whenever a row or column is being moved to the end !        of its file.  nspare = 1 or 2 might help reduce the !        number of file compressions when storage is tight. ! ! The row and column ordering permutes A into the form ! !                        ------------------------ !                         \\                     | !                          \\         U1         | !                           \\                   | !                            -------------------- !                            |\\ !                            | \\ !                            |  \\ !            P A Q   =       |   \\ !                            |    \\ !                            |     -------------- !                            |     |            | !                            |     |            | !                            | L1  |     A2     | !                            |     |            | !                            |     |            | !                            -------------------- ! ! where the block A2 is factored as  A2 = L2 U2. ! The phases of the factorization are as follows. ! ! Utri   is true when U1 is being determined. !        Any column of length 1 is accepted immediately (if TPP). ! ! Ltri   is true when L1 is being determined. !        lu1mar exits as soon as an acceptable pivot is found !        in a row of length 1. ! ! spars1 is true while the density of the (modified) A2 is less !        than the parameter dens1 = parmlu(7) = 0.3 say. !        lu1mar searches maxcol columns and maxrow rows, !        where  maxcol = luparm(3),  maxrow = maxcol - 1. !        lu1mxc is used to keep the biggest element at the top !        of all remaining columns. ! ! spars2 is true while the density of the modified A2 is less !        than the parameter dens2 = parmlu(8) = 0.6 say. !        lu1mar searches maxcol columns and no rows. !        lu1mxc could fix up only the first maxcol cols (with TPP). !        22 Sep 2000: For simplicity, lu1mxc fixes all modified cols. ! ! dense  is true once the density of A2 reaches dens2. !        lu1mar searches only 1 column (the shortest). !        lu1mxc could fix up only the first column (with TPP). !        22 Sep 2000: For simplicity, lu1mxc fixes all modified cols. !------------------------------------------------------------------ integer ( ip ) :: Hlen , Hlenin , hops , h , & i , ibest , ilast , imax , & j , jbest , jlast , jmax , lPiv , & k , kbest , kk , kslack , & l , last , lc , lc1 , lcol , & lD , ldiagU , lenD , leni , lenj , & lfile , lfirst , lfree , limit , & ll , ll1 , lpivc , lpivc1 , lpivc2 , & lpivr , lpivr1 , lpivr2 , lprint , & lq , lq1 , lq2 , lr , lr1 , & lrow , ls , lsave , lu , lu1 , & mark , maxcol , maxmn , maxrow , mbest , & melim , minfre , minmn , mleft , & mrank , ncold , nelim , nfill , & nfree , nleft , nout , nrowd , nrowu , & nsing , nspare , nzchng , nzleft integer ( ip ) :: markc ( n ), markr ( m ) real ( rp ) :: v nout = luparm ( 1 ) lprint = luparm ( 2 ) maxcol = luparm ( 3 ) lPiv = luparm ( 6 ) keepLU = luparm ( 8 ) /= 0 TPP = lPiv == 0 ! Threshold Partial   Pivoting (normal). TRP = lPiv == 1 ! Threshold Rook      Pivoting TCP = lPiv == 2 ! Threshold Complete  Pivoting. TSP = lPiv == 3 ! Threshold Symmetric Pivoting. densLU = . false . maxrow = maxcol - 1 ilast = m ! Assume row m is last in the row file. jlast = n ! Assume col n is last in the col file. lfile = nelem lrow = nelem lcol = nelem minmn = min ( m , n ) maxmn = max ( m , n ) nzleft = nelem nspare = 1 ldiagU = 0 ! Keep -Wmaybe-uninitialized happy. if ( keepLU ) then lu1 = lena + 1 else ! Store only the diagonals of U in the top of memory. ldiagU = lena - n lu1 = ldiagU + 1 end if Ltol = parmlu ( 1 ) small = parmlu ( 3 ) Uspace = parmlu ( 6 ) dens1 = parmlu ( 7 ) dens2 = parmlu ( 8 ) Utri = . true . Ltri = . false . spars1 = . false . spars2 = . false . dense = . false . kslack = 0 ! 12 Dec 2015: Count slacks accepted during Utri. ! Check parameters. Ltol = max ( Ltol , 1.0001_rp ) dens1 = min ( dens1 , dens2 ) ! Initialize output parameters. ! lenL, lenU, minlen, mersum, nUtri, nLtri, ndens1, ndens2, nrank, ! nslack, are already initialized by lu1fac. lenL = 0 lenU = 0 minlen = 0 mersum = 0 nLtri = 0 nUtri = 0 ndens1 = 0 ndens2 = 0 nrank = 0 Lmax = zero Umax = zero DUmax = zero DUmin = 1.0e+20_rp if ( nelem == 0 ) Dumin = zero Akmax = zero hops = 0 ! More initialization. if ( TPP . or . TSP ) then ! Don't worry yet about lu1mxc. aijmax = zero aijtol = zero Hlen = 1 else ! TRP or TCP ! Move biggest element to top of each column. ! Set w(*) to mark slack columns (unit vectors). ! 12 Dec 2015: lu1fac (lu1slk) sets w(*) before lu1fad. ! 13 Dec 2015: lu1mxc fixed (empty cols caused trouble). call lu1mxc ( i1 , n , q , a , indc , lenc , locc ) ! call lu1slk( m, n, lena, q, iqloc, a, locc, w ) end if if ( TRP ) then ! Find biggest element in each row. mark = 0 call lu1mxr ( mark , i1 , m , m , n , lena , inform , & a , indc , lenc , locc , indr , lenr , locr , & p , markc , markr , Amaxr ) if ( inform > 0 ) go to 981 end if if ( TCP ) then ! Set Ha(1:Hlen) = biggest element in each column, ! Hj(1:Hlen) = corresponding column indices. ! 17 Dec 2015: Allow for empty columns. Hlen = 0 do kk = 1 , n Hlen = Hlen + 1 j = q ( kk ) if ( lenc ( j ) > 0 ) then lc = locc ( j ) amax = abs ( a ( lc ) ) else amax = zero end if Ha ( Hlen ) = amax Hj ( Hlen ) = j Hk ( j ) = Hlen end do ! Build the heap, creating new Ha, Hj and setting Hk(1:Hlen). call Hbuild ( Ha , Hj , Hk , Hlen , Hlen , hops ) end if !------------------------------------------------------------------ ! Start of main loop. !------------------------------------------------------------------ mleft = m + 1 nleft = n + 1 do 800 nrowu = 1 , minmn ! mktime = (nrowu / ntime) + 4 ! eltime = (nrowu / ntime) + 9 mleft = mleft - 1 nleft = nleft - 1 ! Bail out if there are no nonzero rows left. if ( iploc ( 1 ) > m ) go to 900 ! For TCP, the largest Aij is at the top of the heap. if ( TCP ) then aijmax = Ha ( 1 ) ! Marvelously easy ! Akmax = max ( Akmax , aijmax ) aijtol = aijmax / Ltol end if !=============================================================== ! Find a suitable pivot element. !=============================================================== if ( Utri ) then !------------------------------------------------------------ ! So far all columns have had length 1. ! We are still looking for the (backward) triangular part of A ! that forms the first rows and columns of U. ! 12 Dec 2015: Use nslack and kslack to choose slacks first. !------------------------------------------------------------ lq1 = iqloc ( 1 ) lq2 = n if ( m > 1 ) lq2 = iqloc ( 2 ) - 1 if ( kslack < nslack ) then do lq = lq1 , lq2 j = q ( lq ) if ( w ( j ) > zero ) then ! Accept a slack kslack = kslack + 1 jbest = j lc = locc ( jbest ) ibest = indc ( lc ) abest = a ( lc ) mbest = 0 go to 300 end if end do ! DEBUG ERROR ! write(*,*) 'slack not found' ! write(*,*) 'kslack, nslack =', kslack, nslack ! stop else if ( kslack == nslack ) then ! Maybe print msg if ( lprint >= 50 ) then write ( nout , * ) 'Slacks ended.  nslack =' , nslack end if kslack = nslack + 1 ! So print happens once end if ! All slacks will be grabbed before we get here. if ( lq1 <= lq2 ) then ! There are more cols of length 1. if ( TPP . or . TSP ) then jbest = q ( lq1 ) ! Grab the first one. else ! TRP or TCP    ! Scan all columns of length 1. jbest = 0 do lq = lq1 , lq2 j = q ( lq ) ! 12 Dec 2015: Slacks grabbed earlier. ! if (w(j) > zero) then ! Accept a slack !   jbest  = j !   go to 250 ! end if lc = locc ( j ) amax = abs ( a ( lc ) ) if ( TRP ) then i = indc ( lc ) aijtol = Amaxr ( i ) / Ltol end if if ( amax >= aijtol ) then jbest = j go to 250 end if end do end if 250 if ( jbest > 0 ) then lc = locc ( jbest ) ibest = indc ( lc ) mbest = 0 go to 300 end if end if ! This is the end of the U triangle. ! We will not return to this part of the code. ! TPP and TSP call lu1mxc for the first time ! (to move biggest element to top of each column). if ( lprint >= 50 ) then write ( nout , 1100 ) 'Utri ended.  spars1 = true' end if Utri = . false . Ltri = . true . spars1 = . true . nUtri = nrowu - 1 if ( TPP . or . TSP ) then call lu1mxc ( lq1 , n , q , a , indc , lenc , locc ) end if end if if ( spars1 ) then !------------------------------------------------------------ ! Perform a Markowitz search. ! Search cols of length 1, then rows of length 1, ! then   cols of length 2, then rows of length 2, etc. !------------------------------------------------------------ ! if (TPP) then ! 12 Jun 2002: Next line disables lu1mCP below if ( TPP . or . TCP ) then call lu1mar ( m , n , lena , maxmn , & TCP , aijtol , Ltol , maxcol , maxrow , & ibest , jbest , mbest , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & iploc , iqloc ) else if ( TRP ) then call lu1mRP ( m , n , lena , maxmn , & Ltol , maxcol , maxrow , & ibest , jbest , mbest , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & iploc , iqloc , Amaxr ) ! else if (TCP) then ! Disabled by test above ! call lu1mCP( m    , n     , lena  , aijtol, & !              ibest, jbest , mbest ,         & !              a    , indc  , indr  ,         & !              lenc , lenr  , locc  ,         & !              Hlen , Ha    , Hj    ) else if ( TSP ) then call lu1mSP ( m , n , lena , maxmn , & Ltol , maxcol , & ibest , jbest , mbest , & a , indc , q , locc , iqloc ) if ( ibest == 0 ) go to 990 end if if ( Ltri ) then ! So far all rows have had length 1. ! We are still looking for the (forward) triangle of A ! that forms the first rows and columns of L. if ( mbest > 0 ) then Ltri = . false . nLtri = nrowu - 1 - nUtri if ( lprint >= 50 ) then write ( nout , 1100 ) 'Ltri ended.' end if end if else ! See if what's left is as dense as dens1. if ( nzleft >= ( dens1 * mleft ) * nleft ) then spars1 = . false . spars2 = . true . ndens1 = nleft maxrow = 0 if ( lprint >= 50 ) then write ( nout , 1100 ) 'spars1 ended.  spars2 = true' end if end if end if else if ( spars2 . or . dense ) then !------------------------------------------------------------ ! Perform a restricted Markowitz search, ! looking at only the first maxcol columns.  (maxrow = 0.) !------------------------------------------------------------ ! if (TPP) then ! 12 Jun 2002: Next line disables lu1mCP below if ( TPP . or . TCP ) then call lu1mar ( m , n , lena , maxmn , & TCP , aijtol , Ltol , maxcol , maxrow , & ibest , jbest , mbest , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & iploc , iqloc ) else if ( TRP ) then call lu1mRP ( m , n , lena , maxmn , & Ltol , maxcol , maxrow , & ibest , jbest , mbest , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & iploc , iqloc , Amaxr ) ! else if (TCP) then ! Disabled by test above ! call lu1mCP( m    , n     , lena  , aijtol, & !              ibest, jbest , mbest ,         & !              a    , indc  , indr  ,         & !              lenc , lenr  , locc  ,         & !              Hlen , Ha    , Hj    ) else if ( TSP ) then call lu1mSP ( m , n , lena , maxmn , & Ltol , maxcol , & ibest , jbest , mbest , & a , indc , q , locc , iqloc ) if ( ibest == 0 ) go to 985 end if ! See if what's left is as dense as dens2. if ( spars2 ) then if ( nzleft >= ( dens2 * mleft ) * nleft ) then spars2 = . false . dense = . true . ndens2 = nleft maxcol = 1 if ( lprint >= 50 ) then write ( nout , 1100 ) 'spars2 ended.  dense = true' end if end if end if end if !--------------------------------------------------------------- ! See if we can finish quickly. !--------------------------------------------------------------- if ( dense ) then lenD = mleft * nleft nfree = lu1 - 1 ! 28 Sep 2015: Change 2 to 3 for safety. if ( nfree >= 3 * lenD ) then ! There is room to treat the remaining matrix as ! a dense matrix D. ! We may have to compress the column file first. ! 12 Nov 1999: D used to be put at the !              beginning of free storage (lD = lcol + 1). !              Now put it at the end     (lD = lu1 - lenD) !              so the left-shift in lu1ful will not !              involve overlapping storage !              (fatal with parallel dcopy). densLU = . true . ndens2 = nleft lD = lu1 - lenD if ( lcol >= lD ) then call lu1rec ( n , . true ., luparm , lcol , jlast , & lena , a , indc , lenc , locc ) lfile = lcol end if go to 900 end if end if !=============================================================== ! The best aij has been found. ! The pivot row ibest and the pivot column jbest ! define a dense matrix D of size nrowd x ncold. !=============================================================== 300 ncold = lenr ( ibest ) nrowd = lenc ( jbest ) melim = nrowd - 1 nelim = ncold - 1 mersum = mersum + mbest lenL = lenL + melim lenU = lenU + ncold if ( lprint >= 50 ) then if ( nrowu == 1 ) then write ( nout , 1100 ) 'lu1fad debug:' end if if ( TPP . or . TRP . or . TSP ) then write ( nout , 1200 ) nrowu , ibest , jbest , nrowd , ncold else ! TCP jmax = Hj ( 1 ) imax = indc ( locc ( jmax )) write ( nout , 1200 ) nrowu , ibest , jbest , nrowd , ncold , & imax , jmax , aijmax end if end if !=============================================================== ! Allocate storage for the next column of  L  and next row of  U. ! Initially the top of a, indc, indr are used as follows: ! !            ncold       melim       ncold        melim ! ! a      |...........|...........|ujbest..ujn|li1......lim| ! ! indc   |...........|  lenr(i)  |  lenc(j)  |  markl(i)  | ! ! indr   |...........| iqloc(i)  |  jfill(j) |  ifill(i)  | ! !       &#94;           &#94;             &#94;           &#94;            &#94; !       lfree   lsave             lu1         ll1          oldlu1 ! ! Later the correct indices are inserted: ! ! indc   |           |           |           |i1........im| ! ! indr   |           |           |jbest....jn|ibest..ibest| ! !=============================================================== if ( keepLU ) then ! relax else ! Always point to the top spot. ! Only the current column of L and row of U will ! take up space, overwriting the previous ones. lu1 = ldiagU + 1 end if ll1 = lu1 - melim lu1 = ll1 - ncold lsave = lu1 - nrowd lfree = lsave - ncold ! Make sure the column file has room. ! Also force a compression if its length exceeds a certain limit. limit = int ( Uspace * real ( lfile )) + m + n + 1000 minfre = ncold + melim nfree = lfree - lcol if ( nfree < minfre . or . lcol > limit ) then call lu1rec ( n , . true ., luparm , lcol , jlast , & lena , a , indc , lenc , locc ) lfile = lcol nfree = lfree - lcol if ( nfree < minfre ) go to 970 end if ! Make sure the row file has room. minfre = melim + ncold nfree = lfree - lrow if ( nfree < minfre . or . lrow > limit ) then call lu1rec ( m , . false ., luparm , lrow , ilast , & lena , a , indr , lenr , locr ) lfile = lrow nfree = lfree - lrow if ( nfree < minfre ) go to 970 end if !=============================================================== ! Move the pivot element to the front of its row ! and to the top of its column. !=============================================================== lpivr = locr ( ibest ) lpivr1 = lpivr + 1 lpivr2 = lpivr + nelim do l = lpivr , lpivr2 if ( indr ( l ) == jbest ) exit end do indr ( l ) = indr ( lpivr ) indr ( lpivr ) = jbest lpivc = locc ( jbest ) lpivc1 = lpivc + 1 lpivc2 = lpivc + melim do l = lpivc , lpivc2 if ( indc ( l ) == ibest ) exit end do indc ( l ) = indc ( lpivc ) indc ( lpivc ) = ibest abest = a ( l ) a ( l ) = a ( lpivc ) a ( lpivc ) = abest if ( keepLU ) then ! relax else ! Store just the diagonal of U, in natural order. !!!   a(ldiagU + nrowu) = abest ! This was in pivot order. a ( ldiagU + jbest ) = abest end if !============================================================== ! Delete pivot col from heap. ! Hk tells us where it is in the heap. !============================================================== if ( TCP ) then kbest = Hk ( jbest ) Hlenin = Hlen call Hdelete ( Ha , Hj , Hk , Hlenin , Hlen , n , kbest , h ) hops = hops + h end if !=============================================================== ! Delete the pivot row from the column file ! and store it as the next row of  U. ! Set indr(lu) = 0    to initialize jfill ptrs on columns of D, !     indc(lu) = lenj to save the original column lengths. !=============================================================== a ( lu1 ) = abest indr ( lu1 ) = jbest indc ( lu1 ) = nrowd lu = lu1 diag = abs ( abest ) Umax = max ( Umax , diag ) DUmax = max ( DUmax , diag ) DUmin = min ( DUmin , diag ) do lr = lpivr1 , lpivr2 lu = lu + 1 j = indr ( lr ) lenj = lenc ( j ) lenc ( j ) = lenj - 1 lc1 = locc ( j ) last = lc1 + lenc ( j ) do l = lc1 , last if ( indc ( l ) == ibest ) exit end do a ( lu ) = a ( l ) indr ( lu ) = 0 indc ( lu ) = lenj Umax = max ( Umax , abs ( a ( lu ) ) ) a ( l ) = a ( last ) indc ( l ) = indc ( last ) indc ( last ) = 0 ! Free entry if ( j == jlast ) lcol = lcol - 1 end do !=============================================================== ! Delete the pivot column from the row file ! and store the nonzeros of the next column of  L. ! Set  indc(ll) = 0      to initialize markl(*) markers, ! indr(ll) = 0           to initialize ifill(*) row fill-in cntrs, ! indc(ls) = leni        to save the original row lengths, ! indr(ls) = iqloc(i)    to save parts of  iqloc(*), ! iqloc(i) = lsave - ls  to point to the nonzeros of  L !          = -1, -2, -3, ... in mark(*). !=============================================================== indc ( lsave ) = ncold if ( melim == 0 ) go to 700 ll = ll1 - 1 ls = lsave abest = one / abest do lc = lpivc1 , lpivc2 ll = ll + 1 ls = ls + 1 i = indc ( lc ) leni = lenr ( i ) lenr ( i ) = leni - 1 lr1 = locr ( i ) last = lr1 + lenr ( i ) do l = lr1 , last if ( indr ( l ) == jbest ) exit end do indr ( l ) = indr ( last ) indr ( last ) = 0 ! Free entry if ( i == ilast ) lrow = lrow - 1 a ( ll ) = - a ( lc ) * abest Lij = abs ( a ( ll ) ) Lmax = max ( Lmax , Lij ) !!!!! DEBUG ! if (Lij > Ltol) then ! write( *  ,*) ' Big Lij!!!', nrowu ! write(nout,*) ' Big Lij!!!', nrowu ! end if indc ( ll ) = 0 indr ( ll ) = 0 indc ( ls ) = leni indr ( ls ) = iqloc ( i ) iqloc ( i ) = lsave - ls end do !=============================================================== ! Do the Gaussian elimination. ! This involves adding a multiple of the pivot column ! to all other columns in the pivot row. ! ! Sometimes more than one call to lu1gau is needed to allow ! compression of the column file. ! lfirst  says which column the elimination should start with. ! minfre  is a bound on the storage needed for any one column. ! lu      points to off-diagonals of u. ! nfill   keeps track of pending fill-in in the row file. !=============================================================== if ( nelim == 0 ) go to 700 lfirst = lpivr1 minfre = mleft + nspare lu = 1 nfill = 0 400 call lu1gau ( m , melim , ncold , nspare , small , & lpivc1 , lpivc2 , lfirst , lpivr2 , lfree , minfre , & ilast , jlast , lrow , lcol , lu , nfill , & a , indc , indr , & lenc , lenr , locc , locr , & iqloc , a ( ll1 ), indc ( ll1 ), & a ( lu1 ), indr ( ll1 ), indr ( lu1 ) ) if ( lfirst > 0 ) then ! The elimination was interrupted. ! Compress the column file and try again. ! lfirst, lu and nfill have appropriate new values. call lu1rec ( n , . true ., luparm , lcol , jlast , & lena , a , indc , lenc , locc ) lfile = lcol lpivc = locc ( jbest ) lpivc1 = lpivc + 1 lpivc2 = lpivc + melim nfree = lfree - lcol if ( nfree < minfre ) go to 970 go to 400 end if !=============================================================== ! The column file has been fully updated. ! Deal with any pending fill-in in the row file. !=============================================================== if ( nfill > 0 ) then ! Compress the row file if necessary. ! lu1gau has set nfill to be the number of pending fill-ins ! plus the current length of any rows that need to be moved. minfre = nfill nfree = lfree - lrow if ( nfree < minfre ) then call lu1rec ( m , . false ., luparm , lrow , ilast , & lena , a , indr , lenr , locr ) lfile = lrow lpivr = locr ( ibest ) lpivr1 = lpivr + 1 lpivr2 = lpivr + nelim nfree = lfree - lrow if ( nfree < minfre ) go to 970 end if ! Move rows that have pending fill-in to end of the row file. ! Then insert the fill-in. call lu1pen ( m , melim , ncold , nspare , ilast , & lpivc1 , lpivc2 , lpivr1 , lpivr2 , lrow , & lenc , lenr , locc , locr , & indc , indr , indr ( ll1 ), indr ( lu1 ) ) end if !=============================================================== ! Restore the saved values of iqloc. ! Insert the correct indices for the col of L and the row of U. !=============================================================== 700 lenr ( ibest ) = 0 lenc ( jbest ) = 0 ll = ll1 - 1 ls = lsave do lc = lpivc1 , lpivc2 ll = ll + 1 ls = ls + 1 i = indc ( lc ) iqloc ( i ) = indr ( ls ) indc ( ll ) = i indr ( ll ) = ibest end do lu = lu1 - 1 do lr = lpivr , lpivr2 lu = lu + 1 indr ( lu ) = indr ( lr ) end do !=============================================================== ! Free the space occupied by the pivot row ! and update the column permutation. ! Then free the space occupied by the pivot column ! and update the row permutation. ! ! nzchng is found in both calls to lu1pq2, but we use it only ! after the second. !=============================================================== call lu1pq2 ( ncold , nzchng , & indr ( lpivr ), indc ( lu1 ), lenc , iqloc , q , iqinv ) call lu1pq2 ( nrowd , nzchng , & indc ( lpivc ), indc ( lsave ), lenr , iploc , p , ipinv ) nzleft = nzleft + nzchng !=============================================================== ! lu1mxr resets Amaxr(i) in each modified row i. ! lu1mxc moves the largest aij to the top of each modified col j. ! 28 Jun 2002: Note that cols of L have an implicit diag of 1.0, !              so lu1mxr is called with ll1, not ll1+1, whereas !              lu1mxc is called with             lu1+1. !=============================================================== if ( Utri . and . TPP ) then ! Relax -- we're not keeping big elements at the top yet. else if ( TRP . and . melim > 0 ) then ! Beware: The parts of p that we need are in indc(ll1:ll) ! 28 Sep 2015: inform is now an output. mark = mark + 1 call lu1mxr ( mark , ll1 , ll , m , n , lena , inform , & a , indc , lenc , locc , indr , lenr , locr , & indc , markc , markr , Amaxr ) ! &#94;&#94;&#94;&#94;  Here are the p(k1:k2) needed by lu1mxr. if ( inform > 0 ) go to 981 end if if ( nelim > 0 ) then call lu1mxc ( lu1 + 1 , lu , indr , a , indc , lenc , locc ) if ( TCP ) then ! Update modified columns in heap ! 20 Dec 2015: Allow for empty columns. do kk = lu1 + 1 , lu j = indr ( kk ) k = Hk ( j ) if ( lenc ( j ) > 0 ) then v = abs ( a ( locc ( j )) ) ! Biggest aij in column j else v = zero end if call Hchange ( Ha , Hj , Hk , Hlen , n , k , v , j , h ) hops = hops + h end do end if end if end if !=============================================================== ! Negate lengths of pivot row and column so they will be ! eliminated during compressions. !=============================================================== lenr ( ibest ) = - ncold lenc ( jbest ) = - nrowd ! Test for fatal bug: row or column lists overwriting L and U. if ( lrow > lsave ) go to 980 if ( lcol > lsave ) go to 980 ! Reset the file lengths if pivot row or col was at the end. if ( ibest == ilast ) then lrow = locr ( ibest ) end if if ( jbest == jlast ) then lcol = locc ( jbest ) end if 800 end do !------------------------------------------------------------------ ! End of main loop. !------------------------------------------------------------------ !------------------------------------------------------------------ ! Normal exit. ! Move empty rows and cols to the end of p, q. ! Then finish with a dense LU if necessary. !------------------------------------------------------------------ 900 inform = 0 call lu1pq3 ( m , lenr , p , ipinv , mrank ) call lu1pq3 ( n , lenc , q , iqinv , nrank ) nrank = min ( mrank , nrank ) if ( densLU ) then call lu1ful ( m , n , lena , lenD , lu1 , TPP , & mleft , nleft , nrank , nrowu , & lenL , lenU , nsing , & keepLU , small , & a , a ( lD ), indc , indr , p , q , & lenc , lenr , locc , ipinv , locr ) !***     21 Dec 1994: Bug in next line. !***     nrank  = nrank - nsing.  Changed to next line: !***     nrank  = minmn - nsing !***     26 Mar 2006: Previous line caused bug with m<n and nsing>0. ! Don't mess with nrank any more.  Let end of lu1fac handle it. end if minlen = lenL + lenU + 2 * ( m + n ) go to 990 ! Not enough space free after a compress. ! Set  minlen  to an estimate of the necessary value of  lena. 970 inform = 7 minlen = lena + lfile + 2 * ( m + n ) go to 990 ! Fatal error.  This will never happen! ! (Famous last words.) 980 inform = 8 go to 990 ! Fatal error in lu1mxr.  This will never happen! 981 inform = 10 go to 990 ! Fatal error with TSP.  Diagonal pivot not found. 985 inform = 9 ! Exit. 990 return 1100 format ( / 1 x , a ) 1200 format ( ' nrowu' , i7 , '   i,jbest' , 2 i7 , '   nrowd,ncold' , 2 i6 , & '   i,jmax' , 2 i7 , '   aijmax' , es10 . 2 ) end subroutine lu1fad","tags":"","loc":"proc/lu1fad.html"},{"title":"lu1gau – AoC-2023","text":"private  subroutine lu1gau(m, melim, ncold, nspare, small, lpivc1, lpivc2, lfirst, lpivr2, lfree, minfre, ilast, jlast, lrow, lcol, lu, nfill, a, indc, indr, lenc, lenr, locc, locr, mark, al, markl, au, ifill, jfill) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: melim integer(kind=ip), intent(in) :: ncold integer(kind=ip), intent(in) :: nspare real(kind=rp), intent(in) :: small integer(kind=ip), intent(in) :: lpivc1 integer(kind=ip), intent(in) :: lpivc2 integer(kind=ip), intent(inout) :: lfirst integer(kind=ip), intent(in) :: lpivr2 integer(kind=ip), intent(in) :: lfree integer(kind=ip), intent(in) :: minfre integer(kind=ip), intent(inout) :: ilast integer(kind=ip), intent(inout) :: jlast integer(kind=ip), intent(inout) :: lrow integer(kind=ip), intent(inout) :: lcol integer(kind=ip), intent(inout) :: lu integer(kind=ip), intent(inout) :: nfill real(kind=rp), intent(inout) :: a (*) integer(kind=ip), intent(inout) :: indc (*) integer(kind=ip), intent(inout) :: indr (*) integer(kind=ip), intent(inout) :: lenc (*) integer(kind=ip), intent(inout) :: lenr (*) integer(kind=ip), intent(inout) :: locc (*) integer(kind=ip), intent(in) :: locr (*) integer(kind=ip), intent(in) :: mark (*) real(kind=rp), intent(in) :: al (melim) integer(kind=ip), intent(inout) :: markl (melim) real(kind=rp), intent(in) :: au (ncold) integer(kind=ip), intent(inout) :: ifill (melim) integer(kind=ip), intent(inout) :: jfill (ncold) Called by proc~~lu1gau~~CalledByGraph proc~lu1gau lusol::lu1gau proc~lu1fad lusol::lu1fad proc~lu1fad->proc~lu1gau proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1gau ( m , melim , ncold , nspare , small , & lpivc1 , lpivc2 , lfirst , lpivr2 , lfree , minfre , & ilast , jlast , lrow , lcol , lu , nfill , & a , indc , indr , & lenc , lenr , locc , locr , & mark , al , markl , & au , ifill , jfill ) integer ( ip ), intent ( in ) :: m , melim , ncold , nspare , & lpivc1 , lpivc2 , lpivr2 , lfree , minfre integer ( ip ), intent ( in ) :: locr ( * ), mark ( * ) real ( rp ), intent ( in ) :: small real ( rp ), intent ( in ) :: al ( melim ), au ( ncold ) integer ( ip ), intent ( inout ) :: ilast , jlast , lfirst , lrow , lcol , lu , nfill real ( rp ), intent ( inout ) :: a ( * ) integer ( ip ), intent ( inout ) :: locc ( * ), indc ( * ), indr ( * ), lenc ( * ), lenr ( * ), & markl ( melim ), ifill ( melim ), jfill ( ncold ) !------------------------------------------------------------------ ! lu1gau does most of the work for each step of ! Gaussian elimination. ! A multiple of the pivot column is added to each other column j ! in the pivot row.  The column list is fully updated. ! The row list is updated if there is room, but some fill-ins may ! remain, as indicated by ifill and jfill. ! ! Input: ! ilast    is the row    at the end of the row    list. ! jlast    is the column at the end of the column list. ! lfirst   is the first column to be processed. ! lu + 1   is the corresponding element of U in au(*). ! nfill    keeps track of pending fill-in. ! a(*)     contains the nonzeros for each column j. ! indc(*)  contains the row indices for each column j. ! al(*)    contains the new column of L.  A multiple of it is !          used to modify each column. ! mark(*)  has been set to -1, -2, -3, ... in the rows !          corresponding to nonzero 1, 2, 3, ... of the col of L. ! au(*)    contains the new row of U.  Each nonzero gives the !          required multiple of the column of L. ! ! Workspace: ! markl(*) marks the nonzeros of L actually used. !          (A different mark, namely j, is used for each column.) ! ! Output: ! ilast     New last row    in the row    list. ! jlast     New last column in the column list. ! lfirst    = 0 if all columns were completed, !           > 0 otherwise. ! lu        returns the position of the last nonzero of U !           actually used, in case we come back in again. ! nfill     keeps track of the total extra space needed in the !           row file. ! ifill(ll) counts pending fill-in for rows involved in the new !           column of L. ! jfill(lu) marks the first pending fill-in stored in columns !           involved in the new row of U. ! ! 16 Apr 1989: First version of lu1gau. ! 23 Apr 1989: lfirst, lu, nfill are now input and output !              to allow re-entry if elimination is interrupted. ! 23 Mar 2001: Introduced ilast, jlast. ! 27 Mar 2001: Allow fill-in \"in situ\" if there is already room !              up to but NOT INCLUDING the end of the !              row or column file. !              Seems safe way to avoid overwriting empty rows/cols !              at the end.  (May not be needed though, now that we !              have ilast and jlast.) ! ! 10 Jan 2010: First f90 version. ! 28 Feb 2010: Declare intent and local variables. !------------------------------------------------------------------ logical :: atend integer ( ip ) :: i , j , k , l , l1 , l2 , last , lc , lc1 , lc2 , & leni , lenj , ll , lr , lr1 , lrep , & ndone , ndrop , nfree real ( rp ) :: aij , uj do 600 lr = lfirst , lpivr2 j = indr ( lr ) lenj = lenc ( j ) nfree = lfree - lcol if ( nfree < minfre ) go to 900 !--------------------------------------------------------------- ! Inner loop to modify existing nonzeros in column  j. ! The \"do l = lc1, lc2\" loop performs most of the arithmetic ! involved in the whole LU factorization. ! ndone  counts how many multipliers were used. ! ndrop  counts how many modified nonzeros are negligibly small. !--------------------------------------------------------------- lu = lu + 1 uj = au ( lu ) lc1 = locc ( j ) lc2 = lc1 + lenj - 1 atend = j == jlast ndone = 0 if ( lenj == 0 ) go to 500 ndrop = 0 do l = lc1 , lc2 i = indc ( l ) ll = - mark ( i ) if ( ll > 0 ) then ndone = ndone + 1 markl ( ll ) = j a ( l ) = a ( l ) + al ( ll ) * uj if ( abs ( a ( l ) ) <= small ) then ndrop = ndrop + 1 end if end if end do !--------------------------------------------------------------- ! Remove any negligible modified nonzeros from both ! the column file and the row file. !--------------------------------------------------------------- if ( ndrop == 0 ) go to 500 k = lc1 do l = lc1 , lc2 i = indc ( l ) if ( abs ( a ( l ) ) > small ) then a ( k ) = a ( l ) indc ( k ) = i k = k + 1 cycle end if ! Delete the nonzero from the row file. lenj = lenj - 1 lenr ( i ) = lenr ( i ) - 1 lr1 = locr ( i ) last = lr1 + lenr ( i ) do lrep = lr1 , last if ( indr ( lrep ) == j ) exit end do indr ( lrep ) = indr ( last ) indr ( last ) = 0 if ( i == ilast ) lrow = lrow - 1 end do ! Free the deleted elements from the column file. do l = k , lc2 indc ( l ) = 0 end do if ( atend ) lcol = k - 1 !--------------------------------------------------------------- ! Deal with the fill-in in column j. !--------------------------------------------------------------- 500 if ( ndone == melim ) go to 590 ! See if column j already has room for the fill-in. if ( atend ) go to 540 last = lc1 + lenj - 1 l1 = last + 1 l2 = last + ( melim - ndone ) ! 27 Mar 2001: Be sure it's not at or past end of the col file. if ( l2 >= lcol ) go to 520 do l = l1 , l2 if ( indc ( l ) /= 0 ) go to 520 end do go to 540 ! We must move column j to the end of the column file. ! First, leave some spare room at the end of the ! current last column. ! 14 Jul 2015: (William Gandler) Fix deceptive loop !              do l = lcol + 1, lcol + nspare !                 lcol    = l 520 l1 = lcol + 1 l2 = lcol + nspare do l = l1 , l2 !  lcol    = l indc ( l ) = 0 ! Spare space is free. end do lcol = l2 atend = . true . jlast = j l1 = lc1 lc1 = lcol + 1 locc ( j ) = lc1 do l = l1 , last lcol = lcol + 1 a ( lcol ) = a ( l ) indc ( lcol ) = indc ( l ) indc ( l ) = 0 ! Free space. end do !--------------------------------------------------------------- ! Inner loop for the fill-in in column j. ! This is usually not very expensive. !--------------------------------------------------------------- 540 last = lc1 + lenj - 1 ll = 0 do lc = lpivc1 , lpivc2 ll = ll + 1 if ( markl ( ll ) == j ) cycle aij = al ( ll ) * uj if ( abs ( aij ) <= small ) cycle lenj = lenj + 1 last = last + 1 a ( last ) = aij i = indc ( lc ) indc ( last ) = i leni = lenr ( i ) ! Add 1 fill-in to row i if there is already room. ! 27 Mar 2001: Be sure it's not at or past the end ! of the row file. l = locr ( i ) + leni if ( l < lrow . and . indr ( l ) <= 0 ) then indr ( l ) = j lenr ( i ) = leni + 1 else ! Row i does not have room for the fill-in. ! Increment ifill(ll) to count how often this has ! happened to row i.  Also, add m to the row index ! indc(last) in column j to mark it as a fill-in that is ! still pending. ! If this is the first pending fill-in for row i, ! nfill includes the current length of row i ! (since the whole row has to be moved later). ! If this is the first pending fill-in for column j, ! jfill(lu) records the current length of column j ! (to shorten the search for pending fill-ins later). if ( ifill ( ll ) == 0 ) nfill = nfill + leni + nspare if ( jfill ( lu ) == 0 ) jfill ( lu ) = lenj nfill = nfill + 1 ifill ( ll ) = ifill ( ll ) + 1 indc ( last ) = m + i end if end do if ( atend ) lcol = last ! End loop for column  j.  Store its final length. 590 lenc ( j ) = lenj 600 end do ! Successful completion. lfirst = 0 return ! Interruption.  We have to come back in after the ! column file is compressed.  Give lfirst a new value. ! lu and nfill will retain their current values. 900 lfirst = lr return end subroutine lu1gau","tags":"","loc":"proc/lu1gau.html"},{"title":"lu1mar – AoC-2023","text":"private  subroutine lu1mar(m, n, lena, maxmn, TCP, aijtol, Ltol, maxcol, maxrow, ibest, jbest, mbest, a, indc, indr, p, q, lenc, lenr, locc, locr, iploc, iqloc) ! TPP\n! Absolute test for Complete Pivoting Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(in) :: maxmn logical, intent(in) :: TCP real(kind=rp), intent(in) :: aijtol real(kind=rp), intent(in) :: Ltol integer(kind=ip), intent(in) :: maxcol integer(kind=ip), intent(in) :: maxrow integer(kind=ip), intent(out) :: ibest integer(kind=ip), intent(out) :: jbest integer(kind=ip), intent(out) :: mbest real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: p (m) integer(kind=ip), intent(in) :: q (n) integer(kind=ip), intent(in) :: lenc (n) integer(kind=ip), intent(in) :: lenr (m) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(in) :: locr (m) integer(kind=ip), intent(in) :: iploc (n) integer(kind=ip), intent(in) :: iqloc (m) Called by proc~~lu1mar~~CalledByGraph proc~lu1mar lusol::lu1mar proc~lu1fad lusol::lu1fad proc~lu1fad->proc~lu1mar proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1mar ( m , n , lena , maxmn , & TCP , aijtol , Ltol , maxcol , maxrow , & ibest , jbest , mbest , & a , indc , indr , p , q , & lenc , lenr , locc , locr , iploc , iqloc ) logical , intent ( in ) :: TCP integer ( ip ), intent ( in ) :: m , n , lena , maxmn , maxcol , maxrow real ( rp ), intent ( in ) :: aijtol , Ltol , a ( lena ) integer ( ip ), intent ( in ) :: indc ( lena ), indr ( lena ), p ( m ) , q ( n ) , & lenc ( n ) , lenr ( m ) , iploc ( n ), iqloc ( m ), & locc ( n ) , locr ( m ) integer ( ip ), intent ( out ) :: ibest , jbest , mbest !------------------------------------------------------------------ ! lu1mar  uses a Markowitz criterion to select a pivot element ! for the next stage of a sparse LU factorization, ! subject to a Threshold Partial Pivoting stability criterion (TPP) ! that bounds the elements of L. ! ! 00 Jan 1986: Version documented in LUSOL paper: !              Gill, Murray, Saunders and Wright (1987), !              \"Maintaining LU factors of a general sparse matrix\", !              Linear algebra and its applications 88/89, 239-270. ! ! 02 Feb 1989: Following Suhl and Aittoniemi (1987), the largest !              element in each column is now kept at the start of !              the column, i.e. in position locc(j) of a and indc. !              This should speed up the Markowitz searches. ! ! 26 Apr 1989: Both columns and rows searched during spars1 phase. !              Only columns searched during spars2 phase. !              maxtie replaced by maxcol and maxrow. ! 05 Nov 1993: Initializing  \"mbest = m * n\"  wasn't big enough when !              m = 10, n = 3, and last column had 7 nonzeros. ! 09 Feb 1994: Realised that \"mbest = maxmn * maxmn\" might overflow. !              Changed to    \"mbest = maxmn * 1000\". ! 27 Apr 2000: On large example from Todd Munson, !              that allowed  \"if (mbest .le. nz1**2) go to 900\" !              to exit before any pivot had been found. !              Introduced kbest = mbest / nz1. !              Most pivots can be rejected with no integer(ip) multiply. !              True merit is evaluated only if it's as good as the !              best so far (or better).  There should be no danger !              of integer(ip) overflow unless A is incredibly !              large and dense. ! ! 10 Sep 2000  TCP, aijtol added for Threshold Complete Pivoting. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent. !------------------------------------------------------------------ integer ( ip ) :: i , j , kbest , lc , lc1 , lc2 , len1 , & lp , lp1 , lp2 , lq , lq1 , lq2 , lr , lr1 , lr2 , & merit , ncol , nrow , nz , nz1 real ( rp ) :: abest , aij , amax , cmax , lbest real ( rp ), parameter :: gamma = 2.0 ! gamma  is \"gamma\" in the tie-breaking rule TB4 in the LUSOL paper. !------------------------------------------------------------------ ! Search cols of length nz = 1, then rows of length nz = 1, ! then   cols of length nz = 2, then rows of length nz = 2, etc. !------------------------------------------------------------------ abest = zero lbest = zero ibest = 0 kbest = maxmn + 1 mbest = - 1 ncol = 0 nrow = 0 nz1 = 0 NZS : do nz = 1 , maxmn ! nz1    = nz - 1 ! if (mbest .le. nz1**2) go to 900 if ( kbest <= nz1 ) exit NZS if ( ibest > 0 ) then if ( ncol >= maxcol ) go to 200 end if if ( nz > m ) go to 200 !--------------------------------------------------------------- ! Search the set of columns of length  nz. !--------------------------------------------------------------- lq1 = iqloc ( nz ) lq2 = n if ( nz < m ) lq2 = iqloc ( nz + 1 ) - 1 Cols : do lq = lq1 , lq2 ncol = ncol + 1 j = q ( lq ) lc1 = locc ( j ) lc2 = lc1 + nz1 amax = abs ( a ( lc1 ) ) ! Test all aijs in this column. ! amax is the largest element (the first in the column). ! cmax is the largest multiplier if aij becomes pivot. if ( TCP ) then if ( amax < aijtol ) cycle Cols ! Nothing in whole column end if Colj : do lc = lc1 , lc2 i = indc ( lc ) len1 = lenr ( i ) - 1 ! merit  = nz1 * len1 ! if (merit > mbest) cycle if ( len1 > kbest ) cycle Colj ! aij  has a promising merit. ! Apply the stability test. ! We require  aij  to be sufficiently large compared to ! all other nonzeros in column  j.  This is equivalent ! to requiring cmax to be bounded by Ltol. if ( lc == lc1 ) then ! This is the maximum element, amax. ! Find the biggest element in the rest of the column ! and hence get cmax.  We know cmax .le. 1, but ! we still want it exactly in order to break ties. ! 27 Apr 2002: Settle for cmax = 1. aij = amax cmax = one ! cmax   = zero ! do 140 l = lc1 + 1, lc2 ! cmax  = max( cmax, abs( a(l) ) ) ! 140            continue ! cmax   = cmax / amax else ! aij is not the biggest element, so cmax >= 1. ! Bail out if cmax will be too big. aij = abs ( a ( lc ) ) if ( TCP ) then ! Absolute test for Complete Pivoting if ( aij < aijtol ) cycle Colj else !!! TPP if ( aij * Ltol < amax ) cycle Colj end if cmax = amax / aij end if ! aij  is big enough.  Its maximum multiplier is cmax. merit = nz1 * len1 if ( merit == mbest ) then ! Break ties. ! (Initializing mbest < 0 prevents getting here if ! nothing has been found yet.) ! In this version we minimize cmax ! but if it is already small we maximize the pivot. if ( lbest <= gamma . and . cmax <= gamma ) then if ( abest >= aij ) cycle Colj else if ( lbest <= cmax ) cycle Colj end if end if ! aij  is the best pivot so far. ibest = i jbest = j kbest = len1 mbest = merit abest = aij lbest = cmax if ( nz == 1 ) exit NZS end do Colj ! Finished with that column. if ( ibest > 0 ) then if ( ncol >= maxcol ) exit Cols end if end do Cols !--------------------------------------------------------------- ! Search the set of rows of length  nz. !--------------------------------------------------------------- ! 200  if (mbest .le. nz*nz1) go to 900 200 if ( kbest <= nz ) exit NZS if ( ibest > 0 ) then if ( nrow >= maxrow ) go to 290 end if if ( nz > n ) go to 290 lp1 = iploc ( nz ) lp2 = m if ( nz < n ) lp2 = iploc ( nz + 1 ) - 1 Rows : do lp = lp1 , lp2 nrow = nrow + 1 i = p ( lp ) lr1 = locr ( i ) lr2 = lr1 + nz1 Rowi : do lr = lr1 , lr2 j = indr ( lr ) len1 = lenc ( j ) - 1 ! merit  = nz1 * len1 ! if (merit > mbest) cycle if ( len1 > kbest ) cycle Rowi ! aij  has a promising merit. ! Find where  aij  is in column  j. lc1 = locc ( j ) lc2 = lc1 + len1 amax = abs ( a ( lc1 ) ) do lc = lc1 , lc2 if ( indc ( lc ) == i ) exit end do ! Apply the same stability test as above. aij = abs ( a ( lc ) ) if ( TCP ) then !!! Absolute test for Complete Pivoting if ( aij < aijtol ) cycle Rowi end if if ( lc == lc1 ) then ! This is the maximum element, amax. ! Find the biggest element in the rest of the column ! and hence get cmax.  We know cmax .le. 1, but ! we still want it exactly in order to break ties. ! 27 Apr 2002: Settle for cmax = 1. cmax = one ! cmax   = zero !     do 240 l = lc1 + 1, lc2 !        cmax  = max( cmax, abs( a(l) ) ) ! 240 continue ! cmax   = cmax / amax else ! aij is not the biggest element, so cmax .ge. 1. ! Bail out if cmax will be too big. if ( TCP ) then ! relax else if ( aij * Ltol < amax ) cycle Rowi end if cmax = amax / aij end if ! aij  is big enough.  Its maximum multiplier is cmax. merit = nz1 * len1 if ( merit == mbest ) then ! Break ties as before. ! (Initializing mbest < 0 prevents getting here if ! nothing has been found yet.) if ( lbest <= gamma . and . cmax <= gamma ) then if ( abest >= aij ) cycle Rowi else if ( lbest <= cmax ) cycle Rowi end if end if ! aij  is the best pivot so far. ibest = i jbest = j kbest = len1 mbest = merit abest = aij lbest = cmax if ( nz == 1 ) exit NZS end do Rowi ! Finished with that row. if ( ibest > 0 ) then if ( nrow >= maxrow ) exit Rows end if end do Rows ! See if it's time to quit. 290 if ( ibest > 0 ) then if ( nrow >= maxrow . and . ncol >= maxcol ) exit NZS end if ! Press on with next nz. nz1 = nz if ( ibest > 0 ) kbest = mbest / nz1 end do NZS end subroutine lu1mar","tags":"","loc":"proc/lu1mar.html"},{"title":"lu1mRP – AoC-2023","text":"private  subroutine lu1mRP(m, n, lena, maxmn, Ltol, maxcol, maxrow, ibest, jbest, mbest, a, indc, indr, p, q, lenc, lenr, locc, locr, iploc, iqloc, Amaxr) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(in) :: maxmn real(kind=rp), intent(in) :: Ltol integer(kind=ip), intent(in) :: maxcol integer(kind=ip), intent(in) :: maxrow integer(kind=ip), intent(out) :: ibest integer(kind=ip), intent(out) :: jbest integer(kind=ip), intent(out) :: mbest real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: p (m) integer(kind=ip), intent(in) :: q (n) integer(kind=ip), intent(in) :: lenc (n) integer(kind=ip), intent(in) :: lenr (m) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(in) :: locr (m) integer(kind=ip), intent(in) :: iploc (n) integer(kind=ip), intent(in) :: iqloc (m) real(kind=rp), intent(in) :: Amaxr (m) Called by proc~~lu1mrp~~CalledByGraph proc~lu1mrp lusol::lu1mRP proc~lu1fad lusol::lu1fad proc~lu1fad->proc~lu1mrp proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1mRP ( m , n , lena , maxmn , & Ltol , maxcol , maxrow , & ibest , jbest , mbest , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & iploc , iqloc , Amaxr ) integer ( ip ), intent ( in ) :: m , n , lena , maxmn , maxcol , maxrow real ( rp ), intent ( in ) :: Ltol integer ( ip ), intent ( in ) :: indc ( lena ), indr ( lena ), p ( m ) , q ( n ) , & lenc ( n ) , lenr ( m ) , iploc ( n ), iqloc ( m ), & locc ( n ) , locr ( m ) real ( rp ), intent ( in ) :: a ( lena ) , Amaxr ( m ) integer ( ip ), intent ( out ) :: ibest , jbest , mbest !------------------------------------------------------------------ ! lu1mRP  uses a Markowitz criterion to select a pivot element ! for the next stage of a sparse LU factorization, ! subject to a Threshold Rook Pivoting stability criterion (TRP) ! that bounds the elements of L and U. ! ! 11 Jun 2002: First version of lu1mRP derived from lu1mar. ! 11 Jun 2002: Current version of lu1mRP. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent. !------------------------------------------------------------------ integer ( ip ) :: i , j , kbest , lc , lc1 , lc2 , len1 , & lp , lp1 , lp2 , lq , lq1 , lq2 , lr , lr1 , lr2 , & merit , ncol , nrow , nz , nz1 real ( rp ) :: abest , aij , amax , atoli , atolj !------------------------------------------------------------------ ! Search cols of length nz = 1, then rows of length nz = 1, ! then   cols of length nz = 2, then rows of length nz = 2, etc. !------------------------------------------------------------------ abest = zero ibest = 0 kbest = maxmn + 1 mbest = - 1 ncol = 0 nrow = 0 nz1 = 0 NZS : do nz = 1 , maxmn ! nz1    = nz - 1 ! if (mbest .le. nz1**2) go to 900 if ( kbest <= nz1 ) exit NZS if ( ibest > 0 ) then if ( ncol >= maxcol ) go to 200 end if if ( nz > m ) go to 200 !--------------------------------------------------------------- ! Search the set of columns of length  nz. !--------------------------------------------------------------- lq1 = iqloc ( nz ) lq2 = n if ( nz < m ) lq2 = iqloc ( nz + 1 ) - 1 Cols : do lq = lq1 , lq2 ncol = ncol + 1 j = q ( lq ) lc1 = locc ( j ) lc2 = lc1 + nz1 amax = abs ( a ( lc1 ) ) atolj = amax / Ltol ! Min size of pivots in col j ! Test all aijs in this column. Colj : do lc = lc1 , lc2 i = indc ( lc ) len1 = lenr ( i ) - 1 ! merit  = nz1 * len1 ! if (merit > mbest) cycle Colj if ( len1 > kbest ) cycle Colj ! aij  has a promising merit. ! Apply the Threshold Rook Pivoting stability test. ! First we require aij to be sufficiently large ! compared to other nonzeros in column j. ! Then  we require aij to be sufficiently large ! compared to other nonzeros in row    i. aij = abs ( a ( lc ) ) if ( aij < atolj ) cycle Colj if ( aij * Ltol < Amaxr ( i )) cycle Colj ! aij  is big enough. merit = nz1 * len1 if ( merit == mbest ) then ! Break ties. ! (Initializing mbest < 0 prevents getting here if ! nothing has been found yet.) if ( abest >= aij ) cycle Colj end if ! aij  is the best pivot so far. ibest = i jbest = j kbest = len1 mbest = merit abest = aij if ( nz == 1 ) exit NZS end do Colj ! Finished with that column. if ( ibest > 0 ) then if ( ncol >= maxcol ) exit Cols end if end do Cols !--------------------------------------------------------------- ! Search the set of rows of length  nz. !--------------------------------------------------------------- ! 200  if (mbest .le. nz*nz1) go to 900 200 if ( kbest <= nz ) exit NZS if ( ibest > 0 ) then if ( nrow >= maxrow ) go to 290 end if if ( nz > n ) go to 290 lp1 = iploc ( nz ) lp2 = m if ( nz < n ) lp2 = iploc ( nz + 1 ) - 1 Rows : do lp = lp1 , lp2 nrow = nrow + 1 i = p ( lp ) lr1 = locr ( i ) lr2 = lr1 + nz1 atoli = Amaxr ( i ) / Ltol ! Min size of pivots in row i Rowi : do lr = lr1 , lr2 j = indr ( lr ) len1 = lenc ( j ) - 1 ! merit  = nz1 * len1 ! if (merit > mbest) cycle if ( len1 > kbest ) cycle Rowi ! aij  has a promising merit. ! Find where  aij  is in column j. lc1 = locc ( j ) lc2 = lc1 + len1 amax = abs ( a ( lc1 ) ) do lc = lc1 , lc2 if ( indc ( lc ) == i ) exit end do ! Apply the Threshold Rook Pivoting stability test. ! First we require aij to be sufficiently large ! compared to other nonzeros in row    i. ! Then  we require aij to be sufficiently large ! compared to other nonzeros in column j. aij = abs ( a ( lc ) ) if ( aij < atoli ) cycle Rowi if ( aij * Ltol < amax ) cycle Rowi ! aij  is big enough. merit = nz1 * len1 if ( merit == mbest ) then ! Break ties as before. ! (Initializing mbest < 0 prevents getting here if ! nothing has been found yet.) if ( abest >= aij ) cycle Rowi end if ! aij  is the best pivot so far. ibest = i jbest = j kbest = len1 mbest = merit abest = aij if ( nz == 1 ) exit NZS end do Rowi ! This was loop 260 ! Finished with that row. if ( ibest > 0 ) then if ( nrow >= maxrow ) exit Rows end if end do Rows ! See if it's time to quit. 290 if ( ibest > 0 ) then if ( nrow >= maxrow . and . ncol >= maxcol ) exit NZS end if ! Press on with next nz. nz1 = nz if ( ibest > 0 ) kbest = mbest / nz1 end do NZS end subroutine lu1mRP","tags":"","loc":"proc/lu1mrp.html"},{"title":"lu1mCP – AoC-2023","text":"private  subroutine lu1mCP(m, n, lena, aijtol, ibest, jbest, mbest, a, indc, indr, lenc, lenr, locc, Hlen, Ha, Hj) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: lena real(kind=rp), intent(in) :: aijtol integer(kind=ip), intent(out) :: ibest integer(kind=ip), intent(out) :: jbest integer(kind=ip), intent(out) :: mbest real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: lenc (n) integer(kind=ip), intent(in) :: lenr (m) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(in) :: Hlen real(kind=rp), intent(in) :: Ha (Hlen) integer(kind=ip), intent(in) :: Hj (Hlen) Source Code subroutine lu1mCP ( m , n , lena , aijtol , & ibest , jbest , mbest , & a , indc , indr , & lenc , lenr , locc , & Hlen , Ha , Hj ) integer ( ip ), intent ( in ) :: m , n , lena , Hlen integer ( ip ), intent ( in ) :: indc ( lena ), indr ( lena ), & lenc ( n ) , lenr ( m ) , locc ( n ), Hj ( Hlen ) real ( rp ), intent ( in ) :: aijtol real ( rp ), intent ( in ) :: a ( lena ) , Ha ( Hlen ) integer ( ip ), intent ( out ) :: ibest , jbest , mbest !------------------------------------------------------------------ ! lu1mCP  uses a Markowitz criterion to select a pivot element ! for the next stage of a sparse LU factorization, ! subject to a Threshold Complete Pivoting stability criterion (TCP) ! that bounds the elements of L and U. ! ! 09 May 2002: First version of lu1mCP. !              It searches columns only, using the heap that !              holds the largest element in each column. ! 09 May 2002: Current version of lu1mCP. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent. !------------------------------------------------------------------ integer ( ip ) :: i , j , kheap , lc , lc1 , lc2 , len1 , lenj , & maxcol , merit , ncol , nz1 real ( rp ) :: abest , aij , amax , cmax , lbest real ( rp ), parameter :: gamma = 2.0 ! gamma  is \"gamma\" in the tie-breaking rule TB4 in the LUSOL paper. !------------------------------------------------------------------ ! Search up to maxcol columns stored at the top of the heap. ! The very top column helps initialize mbest. !------------------------------------------------------------------ abest = zero lbest = zero ibest = 0 jbest = Hj ( 1 ) ! Column at the top of the heap lenj = lenc ( jbest ) mbest = lenj * Hlen ! Bigger than any possible merit maxcol = 40 ! ??? Big question ncol = 0 ! No. of columns searched Cols : do kheap = 1 , Hlen amax = Ha ( kheap ) if ( amax < aijtol ) cycle Cols ncol = ncol + 1 j = Hj ( kheap ) !--------------------------------------------------------------- ! This column has at least one entry big enough (the top one). ! Search the column for other possibilities. !--------------------------------------------------------------- lenj = lenc ( j ) nz1 = lenj - 1 lc1 = locc ( j ) lc2 = lc1 + nz1 !--amax   = abs( a(lc1) ) ! Test all aijs in this column. ! amax is the largest element (the first in the column). ! cmax is the largest multiplier if aij becomes pivot. Colj : do lc = lc1 , lc2 i = indc ( lc ) len1 = lenr ( i ) - 1 merit = nz1 * len1 if ( merit > mbest ) cycle Colj ! aij  has a promising merit. if ( lc == lc1 ) then ! This is the maximum element, amax. ! Find the biggest element in the rest of the column ! and hence get cmax.  We know cmax .le. 1, but ! we still want it exactly in order to break ties. ! 27 Apr 2002: Settle for cmax = 1. aij = amax cmax = one ! cmax   = zero !     do 140 l = lc1 + 1, lc2 !        cmax  = max( cmax, abs( a(l) ) ) ! 140 continue ! cmax   = cmax / amax else ! aij is not the biggest element, so cmax .ge. 1. ! Bail out if cmax will be too big. aij = abs ( a ( lc ) ) if ( aij < aijtol ) cycle Colj cmax = amax / aij end if ! aij  is big enough.  Its maximum multiplier is cmax. if ( merit == mbest ) then ! Break ties. ! (Initializing mbest \"too big\" prevents getting here if ! nothing has been found yet.) ! In this version we minimize cmax ! but if it is already small we maximize the pivot. if ( lbest <= gamma . and . cmax <= gamma ) then if ( abest >= aij ) cycle Colj else if ( lbest <= cmax ) cycle Colj end if end if ! aij  is the best pivot so far. ibest = i jbest = j mbest = merit abest = aij lbest = cmax if ( merit == 0 ) exit Cols ! Col or row of length 1 end do Colj if ( ncol >= maxcol ) exit Cols end do Cols end subroutine lu1mCP","tags":"","loc":"proc/lu1mcp.html"},{"title":"lu1mSP – AoC-2023","text":"private  subroutine lu1mSP(m, n, lena, maxmn, Ltol, maxcol, ibest, jbest, mbest, a, indc, q, locc, iqloc) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(in) :: maxmn real(kind=rp), intent(in) :: Ltol integer(kind=ip), intent(in) :: maxcol integer(kind=ip), intent(out) :: ibest integer(kind=ip), intent(out) :: jbest integer(kind=ip), intent(out) :: mbest real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: q (n) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(in) :: iqloc (m) Called by proc~~lu1msp~~CalledByGraph proc~lu1msp lusol::lu1mSP proc~lu1fad lusol::lu1fad proc~lu1fad->proc~lu1msp proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1mSP ( m , n , lena , maxmn , & Ltol , maxcol , & ibest , jbest , mbest , & a , indc , q , locc , iqloc ) integer ( ip ), intent ( in ) :: m , n , lena , maxmn , maxcol real ( rp ), intent ( in ) :: Ltol , a ( lena ) integer ( ip ), intent ( in ) :: indc ( lena ), q ( n ), iqloc ( m ), locc ( n ) integer ( ip ), intent ( out ) :: ibest , jbest , mbest !------------------------------------------------------------------ ! lu1mSP  is intended for symmetric matrices that are either ! definite or quasi-definite. ! lu1mSP  uses a Markowitz criterion to select a pivot element for ! the next stage of a sparse LU factorization of a symmetric matrix, ! subject to a Threshold Symmetric Pivoting stability criterion ! (TSP) restricted to diagonal elements to preserve symmetry. ! This bounds the elements of L and U and should have rank-revealing ! properties analogous to Threshold Rook Pivoting for unsymmetric ! matrices. ! ! 14 Dec 2002: First version of lu1mSP derived from lu1mRP. !              There is no safeguard to ensure that A is symmetric. ! 14 Dec 2002: Current version of lu1mSP. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent. !------------------------------------------------------------------ integer ( ip ) :: i , j , kbest , lc , lc1 , lc2 , & lq , lq1 , lq2 , merit , ncol , nz , nz1 real ( rp ) :: abest , aij , amax , atolj !------------------------------------------------------------------ ! Search cols of length nz = 1, then cols of length nz = 2, etc. !------------------------------------------------------------------ abest = zero ibest = 0 kbest = maxmn + 1 mbest = - 1 ncol = 0 nz1 = 0 NZS : do nz = 1 , maxmn ! nz1    = nz - 1 ! if (mbest <= nz1**2) exit if ( kbest <= nz1 ) exit NZS if ( ibest > 0 ) then if ( ncol >= maxcol ) go to 200 end if if ( nz > m ) go to 200 !--------------------------------------------------------------- ! Search the set of columns of length  nz. !--------------------------------------------------------------- lq1 = iqloc ( nz ) lq2 = n if ( nz < m ) lq2 = iqloc ( nz + 1 ) - 1 Cols : do lq = lq1 , lq2 ncol = ncol + 1 j = q ( lq ) lc1 = locc ( j ) lc2 = lc1 + nz1 amax = abs ( a ( lc1 ) ) atolj = amax / Ltol ! Min size of pivots in col j ! Test all aijs in this column. ! Ignore everything except the diagonal. Colj : do lc = lc1 , lc2 i = indc ( lc ) if ( i /= j ) cycle Colj ! Skip off-diagonals. ! merit  = nz1 * nz1 ! if (merit > mbest) cycle if ( nz1 > kbest ) cycle Colj ! aij  has a promising merit. ! Apply the Threshold Partial Pivoting stability test ! (which is equivalent to Threshold Rook Pivoting for ! symmetric matrices). ! We require aij to be sufficiently large ! compared to other nonzeros in column j. aij = abs ( a ( lc ) ) if ( aij < atolj ) cycle Colj ! aij  is big enough. merit = nz1 * nz1 if ( merit == mbest ) then ! Break ties. ! (Initializing mbest < 0 prevents getting here if ! nothing has been found yet.) if ( abest >= aij ) cycle Colj end if ! aij  is the best pivot so far. ibest = i jbest = j kbest = nz1 mbest = merit abest = aij if ( nz == 1 ) exit NZS end do Colj ! Finished with that column. if ( ibest > 0 ) then if ( ncol >= maxcol ) exit Cols end if end do Cols ! See if it's time to quit. 200 if ( ibest > 0 ) then if ( ncol >= maxcol ) exit NZS end if ! Press on with next nz. nz1 = nz if ( ibest > 0 ) kbest = mbest / nz1 end do NZS end subroutine lu1mSP","tags":"","loc":"proc/lu1msp.html"},{"title":"lu1pen – AoC-2023","text":"private  subroutine lu1pen(m, melim, ncold, nspare, ilast, lpivc1, lpivc2, lpivr1, lpivr2, lrow, lenc, lenr, locc, locr, indc, indr, ifill, jfill) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: melim integer(kind=ip), intent(in) :: ncold integer(kind=ip), intent(in) :: nspare integer(kind=ip), intent(out) :: ilast integer(kind=ip), intent(in) :: lpivc1 integer(kind=ip), intent(in) :: lpivc2 integer(kind=ip), intent(in) :: lpivr1 integer(kind=ip), intent(in) :: lpivr2 integer(kind=ip), intent(inout) :: lrow integer(kind=ip), intent(inout) :: lenc (*) integer(kind=ip), intent(inout) :: lenr (*) integer(kind=ip), intent(in) :: locc (*) integer(kind=ip), intent(inout) :: locr (*) integer(kind=ip), intent(inout) :: indc (*) integer(kind=ip), intent(inout) :: indr (*) integer(kind=ip), intent(in) :: ifill (melim) integer(kind=ip), intent(in) :: jfill (ncold) Called by proc~~lu1pen~~CalledByGraph proc~lu1pen lusol::lu1pen proc~lu1fad lusol::lu1fad proc~lu1fad->proc~lu1pen proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1pen ( m , melim , ncold , nspare , ilast , & lpivc1 , lpivc2 , lpivr1 , lpivr2 , lrow , & lenc , lenr , locc , locr , & indc , indr , ifill , jfill ) integer ( ip ), intent ( in ) :: m , melim , ncold , nspare , & lpivc1 , lpivc2 , lpivr1 , lpivr2 integer ( ip ), intent ( in ) :: locc ( * ), ifill ( melim ), jfill ( ncold ) integer ( ip ), intent ( inout ) :: lrow integer ( ip ), intent ( inout ) :: indc ( * ), indr ( * ), lenc ( * ), lenr ( * ) integer ( ip ), intent ( inout ) :: locr ( * ) integer ( ip ), intent ( out ) :: ilast !------------------------------------------------------------------ ! lu1pen deals with pending fill-in in the row file. ! ifill(ll) says if a row involved in the new column of L ! has to be updated.  If positive, it is the total ! length of the final updated row. ! jfill(lu) says if a column involved in the new row of U ! contains any pending fill-ins.  If positive, it points ! to the first fill-in in the column that has yet to be ! added to the row file. ! ! 16 Apr 1989: First version of lu1pen. ! 23 Mar 2001: ilast used and updated. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent. ! 14 Jul 2015: (William Gandler) Fix deceptive loop !              do l = lrow + 1, lrow + nspare !                 lrow    = l !------------------------------------------------------------------ integer ( ip ) :: i , j , l , l1 , l2 , last , lc , lc1 , lc2 , ll , lr , lr1 , lr2 , lu ll = 0 do lc = lpivc1 , lpivc2 ll = ll + 1 if ( ifill ( ll ) == 0 ) cycle ! Another row has pending fill. ! First, add some spare space at the end ! of the current last row. ! 14 Jul 2015: (William Gandler) Fix deceptive loop !              (same as fix in previous comment) l1 = lrow + 1 l2 = lrow + nspare do l = l1 , l2 !  lrow    = l indr ( l ) = 0 end do lrow = l2 ! Now move row i to the end of the row file. i = indc ( lc ) ilast = i lr1 = locr ( i ) lr2 = lr1 + lenr ( i ) - 1 locr ( i ) = lrow + 1 do lr = lr1 , lr2 lrow = lrow + 1 indr ( lrow ) = indr ( lr ) indr ( lr ) = 0 end do lrow = lrow + ifill ( ll ) end do ! Scan all columns of  D  and insert the pending fill-in ! into the row file. lu = 1 do lr = lpivr1 , lpivr2 lu = lu + 1 if ( jfill ( lu ) == 0 ) cycle j = indr ( lr ) lc1 = locc ( j ) + jfill ( lu ) - 1 lc2 = locc ( j ) + lenc ( j ) - 1 do lc = lc1 , lc2 i = indc ( lc ) - m if ( i > 0 ) then indc ( lc ) = i last = locr ( i ) + lenr ( i ) indr ( last ) = j lenr ( i ) = lenr ( i ) + 1 end if end do end do end subroutine lu1pen","tags":"","loc":"proc/lu1pen.html"},{"title":"lu1mxc – AoC-2023","text":"private  subroutine lu1mxc(k1, k2, q, a, indc, lenc, locc) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: k1 integer(kind=ip), intent(in) :: k2 integer(kind=ip), intent(in) :: q (k2) real(kind=rp), intent(inout) :: a (*) integer(kind=ip), intent(inout) :: indc (*) integer(kind=ip), intent(in) :: lenc (*) integer(kind=ip), intent(in) :: locc (*) Called by proc~~lu1mxc~~CalledByGraph proc~lu1mxc lusol::lu1mxc proc~lu1fad lusol::lu1fad proc~lu1fad->proc~lu1mxc proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1mxc ( k1 , k2 , q , a , indc , lenc , locc ) integer ( ip ), intent ( in ) :: k1 , k2 integer ( ip ), intent ( in ) :: q ( k2 ), lenc ( * ), locc ( * ) integer ( ip ), intent ( inout ) :: indc ( * ) real ( rp ), intent ( inout ) :: a ( * ) !------------------------------------------------------------------ ! lu1mxc  moves the largest element in each of columns q(k1:k2) ! to the top of its column. ! If k1 > k2, nothing happens. ! ! 06 May 2002: (and earlier) !              All columns k1:k2 must have one or more elements. ! 07 May 2002: Allow for empty columns.  The heap routines need to !              find 0.0 as the \"largest element\". ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent. ! 13 Dec 2015: BUG!  We can't set a(lc1) = zero for an empty col. !              We need to fix the heap routines another way. !              Here, fixed the case lenc(j) = 0. !------------------------------------------------------------------ integer ( ip ) :: i , j , k , l , lc , lc1 , lc2 real ( rp ) :: amax do k = k1 , k2 j = q ( k ) lc1 = locc ( j ) ! The next 10 lines are equivalent to ! l      = idamax( lenc(j), a(lc1), 1 )  +  lc1 - 1 ! >>>>>>>> lc2 = lc1 + lenc ( j ) - 1 amax = zero l = lc1 do lc = lc1 , lc2 if ( amax < abs ( a ( lc ) )) then amax = abs ( a ( lc ) ) l = lc end if end do ! >>>>>>>> ! Note that empty columns do nothing (l = lc1). if ( l > lc1 ) then amax = a ( l ) a ( l ) = a ( lc1 ) a ( lc1 ) = amax i = indc ( l ) indc ( l ) = indc ( lc1 ) indc ( lc1 ) = i end if end do end subroutine lu1mxc","tags":"","loc":"proc/lu1mxc.html"},{"title":"lu1mxr – AoC-2023","text":"private  subroutine lu1mxr(mark, k1, k2, m, n, lena, inform, a, indc, lenc, locc, indr, lenr, locr, p, markc, markr, Amaxr) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: mark integer(kind=ip), intent(in) :: k1 integer(kind=ip), intent(in) :: k2 integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(out) :: inform real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: lenc (n) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: lenr (m) integer(kind=ip), intent(in) :: locr (m) integer(kind=ip), intent(in) :: p (k2) integer(kind=ip), intent(inout) :: markc (n) integer(kind=ip), intent(inout) :: markr (m) real(kind=rp), intent(inout) :: Amaxr (m) Called by proc~~lu1mxr~~CalledByGraph proc~lu1mxr lusol::lu1mxr proc~lu1fad lusol::lu1fad proc~lu1fad->proc~lu1mxr proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1mxr ( mark , k1 , k2 , m , n , lena , inform , & a , indc , lenc , locc , indr , lenr , locr , & p , markc , markr , Amaxr ) integer ( ip ), intent ( in ) :: mark , k1 , k2 , m , n , lena integer ( ip ), intent ( out ) :: inform integer ( ip ), intent ( in ) :: indc ( lena ), lenc ( n ), locc ( n ), & indr ( lena ), lenr ( m ), locr ( m ), p ( k2 ) real ( rp ), intent ( in ) :: a ( lena ) integer ( ip ), intent ( inout ) :: markc ( n ), markr ( m ) real ( rp ), intent ( inout ) :: Amaxr ( m ) !------------------------------------------------------------------ ! lu1mxr  finds the largest element in each of rows i = p(k1:k2) ! and stores it in each Amaxr(i). ! The nonzeros are stored column-wise in (a,indc,lenc,locc) ! and their structure is     row-wise in (  indr,lenr,locr). ! ! 11 Jun 2002: First version of lu1mxr. !              Allow for empty columns. ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent. ! 03 Apr 2013: Recoded to improve efficiency.  Need new arrays !              markc(n), markr(m) and local array cols(n). ! !              First call:  mark = 0, k1 = 1, k2 = m. !              Initialize all of markc(n), markr(m), Amaxr(m). !              Columns are searched only once. !              cols(n) is not used. ! !              Later: mark := mark + 1 (greater than for previous call). !              Cols involved in rows p(k1:k2) are searched only once. !              cols(n) is local storage. !              markc(:), markr(:) are marked (= mark) in some places. !              For next call with new mark, !              all of markc, markr will initially appear unmarked. ! 28 Sep 2015: inform is now an output to mean i is invalid. !------------------------------------------------------------------ integer ( ip ) :: cols ( n ) integer ( ip ) :: i , j , k , lc , lc1 , lc2 , lr , lr1 , lr2 , ncol inform = 0 if ( mark == 0 ) then ! First call: Find Amaxr(1:m) for original A. markr ( 1 : m ) = 0 markc ( 1 : n ) = 0 Amaxr ( 1 : m ) = zero do j = 1 , n lc1 = locc ( j ) lc2 = lc1 + lenc ( j ) - 1 do lc = lc1 , lc2 i = indc ( lc ) Amaxr ( i ) = max ( Amaxr ( i ), abs ( a ( lc )) ) end do end do else ! Later calls: Find Amaxr(i) for rows i = p(k1:k2). ncol = 0 do k = k1 , k2 ! Search rows to find which cols are involved. i = p ( k ) markr ( i ) = mark ! Mark this row Amaxr ( i ) = zero lr1 = locr ( i ) lr2 = lr1 + lenr ( i ) - 1 do lr = lr1 , lr2 ! Mark all unmarked cols in this row. j = indr ( lr ) ! Build up a list of which ones they are. if ( markc ( j ) /= mark ) then markc ( j ) = mark ncol = ncol + 1 cols ( ncol ) = j end if end do end do do k = 1 , ncol ! Search involved columns. j = cols ( k ) lc1 = locc ( j ) lc2 = lc1 + lenc ( j ) - 1 do lc = lc1 , lc2 i = indc ( lc ) ! 25 Sep 2015: Check for invalid i that would cause a crash. ! if (i > m) then !    write(*,*) 'lu1mxr fatal error: i =', i !    inform = 10 !    return ! end if if ( markr ( i ) == mark ) then Amaxr ( i ) = max ( Amaxr ( i ), abs ( a ( lc )) ) end if end do end do end if end subroutine lu1mxr","tags":"","loc":"proc/lu1mxr.html"},{"title":"lu1or1 – AoC-2023","text":"private  subroutine lu1or1(m, n, nelem, lena, small, a, indc, indr, lenc, lenr, Amax, numnz, lerr, inform) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: nelem integer(kind=ip), intent(in) :: lena real(kind=rp), intent(in) :: small real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: indc (lena) integer(kind=ip), intent(inout) :: indr (lena) integer(kind=ip), intent(out) :: lenc (n) integer(kind=ip), intent(out) :: lenr (m) real(kind=rp) :: Amax integer(kind=ip) :: numnz integer(kind=ip), intent(out) :: lerr integer(kind=ip), intent(out) :: inform Called by proc~~lu1or1~~CalledByGraph proc~lu1or1 lusol::lu1or1 proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1or1 proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1or1 ( m , n , nelem , lena , small , & a , indc , indr , lenc , lenr , & Amax , numnz , lerr , inform ) integer ( ip ), intent ( in ) :: m , n , nelem , lena real ( rp ), intent ( in ) :: small real ( rp ), intent ( inout ) :: a ( lena ) integer ( ip ), intent ( inout ) :: indc ( lena ), indr ( lena ) integer ( ip ), intent ( out ) :: lerr , inform integer ( ip ), intent ( out ) :: lenc ( n ), lenr ( m ) !------------------------------------------------------------------ ! lu1or1  organizes the elements of an  m by n  matrix  A  as ! follows.  On entry, the parallel arrays   a, indc, indr, ! contain  nelem  entries of the form     aij,    i,    j, ! in any order.  nelem  must be positive. ! ! Entries not larger than the input parameter  small  are treated as ! zero and removed from   a, indc, indr.  The remaining entries are ! defined to be nonzero.  numnz  returns the number of such nonzeros ! and  Amax  returns the magnitude of the largest nonzero. ! The arrays  lenc, lenr  return the number of nonzeros in each ! column and row of  A. ! ! inform = 0  on exit, except  inform = 1  if any of the indices in ! indc, indr  imply that the element  aij  lies outside the  m by n ! dimensions of  A. ! ! xx Feb 1985: Original version. ! 17 Oct 2000: a, indc, indr now have size lena to allow nelem = 0. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. !------------------------------------------------------------------ integer ( ip ) :: i , j , l , numnz real ( rp ) :: Amax lenr ( 1 : m ) = 0 lenc ( 1 : n ) = 0 lerr = 0 Amax = zero numnz = nelem do l = nelem , 1 , - 1 if ( abs ( a ( l )) > small ) then i = indc ( l ) j = indr ( l ) Amax = max ( Amax , abs ( a ( l )) ) if ( i < 1 . or . i > m ) go to 910 if ( j < 1 . or . j > n ) go to 910 lenr ( i ) = lenr ( i ) + 1 lenc ( j ) = lenc ( j ) + 1 else ! Replace a negligible element by last element.  Since ! we are going backwards, we know the last element is ok. a ( l ) = a ( numnz ) indc ( l ) = indc ( numnz ) indr ( l ) = indr ( numnz ) numnz = numnz - 1 end if end do inform = 0 return 910 lerr = l inform = 1 return end subroutine lu1or1","tags":"","loc":"proc/lu1or1.html"},{"title":"lu1or2 – AoC-2023","text":"private  subroutine lu1or2(n, numa, lena, a, inum, jnum, lenc, locc) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: numa integer(kind=ip), intent(in) :: lena real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: inum (lena) integer(kind=ip), intent(inout) :: jnum (lena) integer(kind=ip), intent(in) :: lenc (n) integer(kind=ip), intent(out) :: locc (n) Called by proc~~lu1or2~~CalledByGraph proc~lu1or2 lusol::lu1or2 proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1or2 proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1or2 ( n , numa , lena , a , inum , jnum , lenc , locc ) integer ( ip ), intent ( in ) :: n , numa , lena integer ( ip ), intent ( in ) :: lenc ( n ) integer ( ip ), intent ( inout ) :: inum ( lena ), jnum ( lena ) real ( rp ), intent ( inout ) :: a ( lena ) integer ( ip ), intent ( out ) :: locc ( n ) !------------------------------------------------------------------ ! lu1or2  sorts a list of matrix elements  a(i,j)  into column ! order, given  numa  entries  a(i,j),  i,  j  in the parallel ! arrays  a, inum, jnum  respectively.  The matrix is assumed ! to have n columns and an arbitrary number of rows. ! ! On entry, lenc(*) must contain the length of each column. ! ! On exit,  a(*) and inum(*)  are sorted,  jnum(*) = 0,  and ! locc(j)  points to the start of column j. ! ! lu1or2  is derived from mc20ad, a routine in the Harwell ! Subroutine Library, author J. K. Reid. ! xx Feb 1985: Original version. ! 17 Oct 2000: a, inum, jnum now have size lena to allow nelem = 0. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. !------------------------------------------------------------------ integer ( ip ) :: i , ice , icep , j , ja , jb , jce , jcep , l real ( rp ) :: ace , acep ! Set  loc(j)  to point to the beginning of column  j. l = 1 do j = 1 , n locc ( j ) = l l = l + lenc ( j ) end do ! Sort the elements into column order. ! The algorithm is an in-place sort and is of order  numa. do i = 1 , numa ! Establish the current entry. jce = jnum ( i ) if ( jce == 0 ) cycle ace = a ( i ) ice = inum ( i ) jnum ( i ) = 0 ! Chain from current entry. do j = 1 , numa ! The current entry is not in the correct position. ! Determine where to store it. l = locc ( jce ) locc ( jce ) = locc ( jce ) + 1 ! Save the contents of that location. acep = a ( l ) icep = inum ( l ) jcep = jnum ( l ) ! Store current entry. a ( l ) = ace inum ( l ) = ice jnum ( l ) = 0 ! If next current entry needs to be processed, ! copy it into current entry. if ( jcep == 0 ) exit ace = acep ice = icep jce = jcep end do end do ! Reset loc(j) to point to the start of column j. ja = 1 do j = 1 , n jb = locc ( j ) locc ( j ) = ja ja = jb end do end subroutine lu1or2","tags":"","loc":"proc/lu1or2.html"},{"title":"lu1or3 – AoC-2023","text":"private  subroutine lu1or3(m, n, lena, indc, lenc, locc, iw, lerr, inform) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: lenc (n) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(out) :: iw (m) integer(kind=ip), intent(out) :: lerr integer(kind=ip), intent(out) :: inform Called by proc~~lu1or3~~CalledByGraph proc~lu1or3 lusol::lu1or3 proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1or3 proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1or3 ( m , n , lena , indc , lenc , locc , iw , lerr , inform ) integer ( ip ), intent ( in ) :: m , n , lena integer ( ip ), intent ( in ) :: indc ( lena ), lenc ( n ), locc ( n ) integer ( ip ), intent ( out ) :: lerr , inform integer ( ip ), intent ( out ) :: iw ( m ) !------------------------------------------------------------------ ! lu1or3  looks for duplicate elements in an m by n matrix A ! defined by the column list  indc, lenc, locc. ! iw  is used as a work vector of length  m. ! ! xx Feb 1985: Original version. ! 17 Oct 2000: indc, indr now have size lena to allow nelem = 0. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. !------------------------------------------------------------------ integer ( ip ) :: i , j , l , l1 , l2 iw ( 1 : m ) = 0 lerr = 0 do j = 1 , n if ( lenc ( j ) > 0 ) then l1 = locc ( j ) l2 = l1 + lenc ( j ) - 1 do l = l1 , l2 i = indc ( l ) if ( iw ( i ) == j ) go to 910 iw ( i ) = j end do end if end do inform = 0 return 910 lerr = l inform = 1 return end subroutine lu1or3","tags":"","loc":"proc/lu1or3.html"},{"title":"lu1or4 – AoC-2023","text":"private  subroutine lu1or4(m, n, nelem, lena, indc, indr, lenc, lenr, locc, locr) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: nelem integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(out) :: indr (lena) integer(kind=ip), intent(in) :: lenc (n) integer(kind=ip), intent(in) :: lenr (m) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(out) :: locr (m) Called by proc~~lu1or4~~CalledByGraph proc~lu1or4 lusol::lu1or4 proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1or4 proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1or4 ( m , n , nelem , lena , indc , indr , lenc , lenr , locc , locr ) integer ( ip ), intent ( in ) :: m , n , nelem , lena integer ( ip ), intent ( in ) :: indc ( lena ), lenc ( n ), locc ( n ), lenr ( m ) integer ( ip ), intent ( out ) :: indr ( lena ), locr ( m ) !------------------------------------------------------------------ ! lu1or4     constructs a row list  indr, locr ! from a corresponding column list  indc, locc, ! given the lengths of both columns and rows in  lenc, lenr. ! ! xx Feb 1985: Original version. ! 17 Oct 2000: indc, indr now have size lena to allow nelem = 0. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. !------------------------------------------------------------------ integer ( ip ) :: i , j , jdummy , l , l1 , l2 , lr ! Initialize  locr(i)  to point just beyond where the ! last component of row  i  will be stored. l = 1 do i = 1 , m l = l + lenr ( i ) locr ( i ) = l end do ! By processing the columns backwards and decreasing  locr(i) ! each time it is accessed, it will end up pointing to the ! beginning of row  i  as required. l2 = nelem j = n + 1 do jdummy = 1 , n j = j - 1 if ( lenc ( j ) > 0 ) then l1 = locc ( j ) do l = l1 , l2 i = indc ( l ) lr = locr ( i ) - 1 locr ( i ) = lr indr ( lr ) = j end do l2 = l1 - 1 end if end do end subroutine lu1or4","tags":"","loc":"proc/lu1or4.html"},{"title":"lu1pq1 – AoC-2023","text":"private  subroutine lu1pq1(m, n, len, iperm, loc, inv, num) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: len (m) integer(kind=ip), intent(out) :: iperm (m) integer(kind=ip), intent(out) :: loc (n) integer(kind=ip), intent(out) :: inv (m) integer(kind=ip), intent(out) :: num (n) Called by proc~~lu1pq1~~CalledByGraph proc~lu1pq1 lusol::lu1pq1 proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1pq1 proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1pq1 ( m , n , len , iperm , loc , inv , num ) integer ( ip ), intent ( in ) :: m , n integer ( ip ), intent ( in ) :: len ( m ) integer ( ip ), intent ( out ) :: iperm ( m ), loc ( n ), inv ( m ) integer ( ip ), intent ( out ) :: num ( n ) ! workspace !------------------------------------------------------------------ ! lu1pq1  constructs a permutation  iperm  from the array  len. ! ! On entry: ! len(i)  holds the number of nonzeros in the i-th row (say) !         of an m by n matrix. ! num(*)  can be anything (workspace). ! ! On exit: ! iperm   contains a list of row numbers in the order !         rows of length 0,  rows of length 1,..., rows of length n. ! loc(nz) points to the first row containing  nz  nonzeros, !         nz = 1, n. ! inv(i)  points to the position of row i within iperm(*). ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. !------------------------------------------------------------------ integer ( ip ) :: i , l , nz , nzero ! Count the number of rows of each length. nzero = 0 num ( 1 : n ) = 0 loc ( 1 : n ) = 0 do i = 1 , m nz = len ( i ) if ( nz == 0 ) then nzero = nzero + 1 else num ( nz ) = num ( nz ) + 1 end if end do ! Set starting locations for each length. l = nzero + 1 do nz = 1 , n loc ( nz ) = l l = l + num ( nz ) num ( nz ) = 0 end do ! Form the list. nzero = 0 do i = 1 , m nz = len ( i ) if ( nz == 0 ) then nzero = nzero + 1 iperm ( nzero ) = i else l = loc ( nz ) + num ( nz ) iperm ( l ) = i num ( nz ) = num ( nz ) + 1 end if end do ! Define the inverse of iperm. do l = 1 , m i = iperm ( l ) inv ( i ) = l end do end subroutine lu1pq1","tags":"","loc":"proc/lu1pq1.html"},{"title":"lu1pq2 – AoC-2023","text":"private  subroutine lu1pq2(nzpiv, nzchng, indr, lenold, lennew, iqloc, q, iqinv) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: nzpiv integer(kind=ip), intent(out) :: nzchng integer(kind=ip), intent(inout) :: indr (nzpiv) integer(kind=ip), intent(in) :: lenold (nzpiv) integer(kind=ip), intent(in) :: lennew (*) integer(kind=ip), intent(inout) :: iqloc (*) integer(kind=ip), intent(inout) :: q (*) integer(kind=ip), intent(inout) :: iqinv (*) Called by proc~~lu1pq2~~CalledByGraph proc~lu1pq2 lusol::lu1pq2 proc~lu1fad lusol::lu1fad proc~lu1fad->proc~lu1pq2 proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1pq2 ( nzpiv , nzchng , indr , lenold , lennew , iqloc , q , iqinv ) integer ( ip ), intent ( in ) :: nzpiv integer ( ip ), intent ( in ) :: lenold ( nzpiv ), lennew ( * ) integer ( ip ), intent ( inout ) :: indr ( nzpiv ), iqloc ( * ), q ( * ), iqinv ( * ) integer ( ip ), intent ( out ) :: nzchng !=============================================================== ! lu1pq2 frees the space occupied by the pivot row, ! and updates the column permutation q. ! ! Also used to free the pivot column and update the row perm p. ! ! nzpiv   (input)    is the length of the pivot row (or column). ! nzchng  (output)   is the net change in total nonzeros. ! ! 14 Apr 1989:  First version. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. !=============================================================== integer ( ip ) :: j , jnew , l , lnew , lr , next , nz , nznew nzchng = 0 do lr = 1 , nzpiv j = indr ( lr ) indr ( lr ) = 0 nz = lenold ( lr ) nznew = lennew ( j ) if ( nz /= nznew ) then l = iqinv ( j ) nzchng = nzchng + ( nznew - nz ) ! l above is the position of column j in q  (so j = q(l)). if ( nz < nznew ) then ! Column j has to move toward the end of q. 110 next = nz + 1 lnew = iqloc ( next ) - 1 if ( lnew /= l ) then jnew = q ( lnew ) q ( l ) = jnew iqinv ( jnew ) = l end if l = lnew iqloc ( next ) = lnew nz = next if ( nz < nznew ) go to 110 else ! Column j has to move toward the front of q. 120 lnew = iqloc ( nz ) if ( lnew /= l ) then jnew = q ( lnew ) q ( l ) = jnew iqinv ( jnew ) = l end if l = lnew iqloc ( nz ) = lnew + 1 nz = nz - 1 if ( nz > nznew ) go to 120 end if q ( lnew ) = j iqinv ( j ) = lnew end if end do end subroutine lu1pq2","tags":"","loc":"proc/lu1pq2.html"},{"title":"lu1pq3 – AoC-2023","text":"private  subroutine lu1pq3(n, len, iperm, iw, nrank) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: len (n) integer(kind=ip), intent(inout) :: iperm (n) integer(kind=ip), intent(out) :: iw (n) integer(kind=ip) :: nrank Called by proc~~lu1pq3~~CalledByGraph proc~lu1pq3 lusol::lu1pq3 proc~lu1fad lusol::lu1fad proc~lu1fad->proc~lu1pq3 proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1pq3 ( n , len , iperm , iw , nrank ) integer ( ip ), intent ( in ) :: n integer ( ip ), intent ( in ) :: len ( n ) integer ( ip ), intent ( inout ) :: iperm ( n ) integer ( ip ), intent ( out ) :: iw ( n ) ! workspace !------------------------------------------------------------------ ! lu1pq3  looks at the permutation  iperm(*)  and moves any entries ! to the end whose corresponding length  len(*)  is zero. ! ! 09 Feb 1994: Added work array iw(*) to improve efficiency. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. !------------------------------------------------------------------ integer ( ip ) :: i , k , nrank , nzero nrank = 0 nzero = 0 do k = 1 , n i = iperm ( k ) if ( len ( i ) == 0 ) then nzero = nzero + 1 iw ( nzero ) = i else nrank = nrank + 1 iperm ( nrank ) = i end if end do do k = 1 , nzero iperm ( nrank + k ) = iw ( k ) end do end subroutine lu1pq3","tags":"","loc":"proc/lu1pq3.html"},{"title":"lu1rec – AoC-2023","text":"private  subroutine lu1rec(n, reals, luparm, ltop, ilast, lena, a, ind, lenc, locc) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: n logical, intent(in) :: reals integer(kind=ip), intent(inout) :: luparm (30) integer(kind=ip), intent(inout) :: ltop integer(kind=ip), intent(out) :: ilast integer(kind=ip), intent(in) :: lena real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: ind (lena) integer(kind=ip), intent(inout) :: lenc (n) integer(kind=ip), intent(inout) :: locc (n) Called by proc~~lu1rec~~CalledByGraph proc~lu1rec lusol::lu1rec proc~lu1fad lusol::lu1fad proc~lu1fad->proc~lu1rec proc~lu7add lusol::lu7add proc~lu7add->proc~lu1rec proc~lu7elm lusol::lu7elm proc~lu7elm->proc~lu1rec proc~lu7for lusol::lu7for proc~lu7for->proc~lu1rec proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~lu8rpc lusol::lu8rpc proc~lu8rpc->proc~lu7add proc~lu8rpc->proc~lu7elm proc~lu8rpc->proc~lu7for proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1rec ( n , reals , luparm , ltop , ilast , & lena , a , ind , lenc , locc ) logical , intent ( in ) :: reals integer ( ip ), intent ( in ) :: n , lena integer ( ip ), intent ( inout ) :: ltop integer ( ip ), intent ( out ) :: ilast integer ( ip ), intent ( inout ) :: luparm ( 30 ), ind ( lena ), lenc ( n ), locc ( n ) real ( rp ), intent ( inout ) :: a ( lena ) !------------------------------------------------------------------ ! lu1rec recovers space in the column or row lists. ! 00 Jun 1983: Original version of lu1rec followed John Reid's !              compression routine in LA05.  It recovered space !              in ind(*) and optionally a(*) by eliminating entries !              with ind(l) = 0. !              The elements of ind(*) could not be negative. !              If len(i) was positive, entry i contained !              that many elements, starting at  loc(i). !              Otherwise, entry i was eliminated. ! ! 23 Mar 2001: Realised we could have len(i) = 0 in rare cases! !              (Mostly during TCP when the pivot row contains !              a column of length 1 that couldn't be a pivot.) !              Revised storage scheme to !                 keep        entries with       ind(l) >  0, !                 squeeze out entries with -n <= ind(l) <= 0, !              and to allow len(i) = 0. !              Empty items are moved to the end of the compressed !              ind(*) and/or a(*) arrays are given one empty space. !              Items with len(i) < 0 are still eliminated. ! ! 27 Mar 2001: Decided to use only ind(l) > 0 and = 0 in lu1fad. !              Still have to keep entries with len(i) = 0. ! ! On exit: ! ltop         is the length of useful entries in ind(*), a(*). ! ind(ltop+1)  is \"i=ilast\" such that len(i), loc(i) belong to the !              last item in ind(*), a(*). ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. ! 20 Dec 2015: ilast is output instead of ind(ltop+1). !------------------------------------------------------------------ integer ( ip ) :: i , k , klast , l , leni , lprint , nempty , nout nempty = 0 do i = 1 , n leni = lenc ( i ) if ( leni > 0 ) then l = locc ( i ) + leni - 1 lenc ( i ) = ind ( l ) ind ( l ) = - ( n + i ) else if ( leni == 0 ) then nempty = nempty + 1 end if end do k = 0 klast = 0 ! Previous k ilast = 0 ! Last entry moved. do l = 1 , ltop i = ind ( l ) if ( i > 0 ) then k = k + 1 ind ( k ) = i if ( reals ) a ( k ) = a ( l ) else if ( i < - n ) then ! This is the end of entry  i. i = - ( i + n ) ilast = i k = k + 1 ind ( k ) = lenc ( i ) if ( reals ) a ( k ) = a ( l ) locc ( i ) = klast + 1 lenc ( i ) = k - klast klast = k end if end do ! Move any empty items to the end, adding 1 free entry for each. if ( nempty > 0 ) then do i = 1 , n if ( lenc ( i ) == 0 ) then k = k + 1 locc ( i ) = k ind ( k ) = 0 ilast = i end if end do end if nout = luparm ( 1 ) lprint = luparm ( 2 ) if ( lprint >= 50 ) write ( nout , 1000 ) ltop , k , reals , nempty luparm ( 26 ) = luparm ( 26 ) + 1 ! ncp ! 20 Dec 2015: Return ilast itself instead of ind(ltop + 1). ltop = k ! ind(ltop+1) = ilast return 1000 format ( ' lu1rec.  File compressed from' , i10 , '   to' , i10 , l3 , '  nempty =' , i8 ) end subroutine lu1rec","tags":"","loc":"proc/lu1rec.html"},{"title":"lu1slk – AoC-2023","text":"private  subroutine lu1slk(m, n, lena, q, iqloc, a, indc, locc, nslack, w) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(in) :: q (n) integer(kind=ip), intent(in) :: iqloc (m) real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(out) :: nslack real(kind=rp), intent(out) :: w (n) Called by proc~~lu1slk~~CalledByGraph proc~lu1slk lusol::lu1slk proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1slk proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1slk ( m , n , lena , q , iqloc , a , indc , locc , nslack , w ) integer ( ip ), intent ( in ) :: m , n , lena integer ( ip ), intent ( in ) :: q ( n ), iqloc ( m ), indc ( lena ), locc ( n ) integer ( ip ), intent ( out ) :: nslack real ( rp ), intent ( in ) :: a ( lena ) real ( rp ), intent ( out ) :: w ( n ) !------------------------------------------------------------------ ! lu1slk  sets w(j) > 0 if column j is a unit vector. ! ! 21 Nov 2000: First version.  lu1fad needs it for TCP. !              Note that w(*) is nominally an integer(ip) array, !              but the only spare space is the double array w(*). ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. ! 12 Dec 2015: Always call lu1slk from lu1fac to obtain nslack. !              Need indc(*) and markr(*) to count 1 slack per row. !------------------------------------------------------------------ integer ( ip ) :: markr ( m ) integer ( ip ) :: i , j , lc1 , lq , lq1 , lq2 nslack = 0 markr ( 1 : m ) = 0 w ( 1 : n ) = zero ! Check all columns of length 1. lq1 = iqloc ( 1 ) lq2 = n if ( m > 1 ) lq2 = iqloc ( 2 ) - 1 do lq = lq1 , lq2 j = q ( lq ) lc1 = locc ( j ) if ( abs ( a ( lc1 ) ) == one ) then i = indc ( lc1 ) if ( markr ( i ) == 0 ) then nslack = nslack + 1 markr ( i ) = i w ( j ) = one end if end if end do end subroutine lu1slk","tags":"","loc":"proc/lu1slk.html"},{"title":"lu1ful – AoC-2023","text":"private  subroutine lu1ful(m, n, lena, lenD, lu1, TPP, mleft, nleft, nrank, nrowu, lenL, lenU, nsing, keepLU, small, a, d, indc, indr, p, q, lenc, lenr, locc, ipinv, ipvt) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(in) :: lenD integer(kind=ip), intent(in) :: lu1 logical, intent(in) :: TPP integer(kind=ip), intent(in) :: mleft integer(kind=ip), intent(in) :: nleft integer(kind=ip), intent(in) :: nrank integer(kind=ip), intent(in) :: nrowu integer(kind=ip), intent(inout) :: lenL integer(kind=ip), intent(inout) :: lenU integer(kind=ip), intent(out) :: nsing logical, intent(in) :: keepLU real(kind=rp), intent(in) :: small real(kind=rp), intent(inout) :: a (lena) real(kind=rp), intent(out) :: d (lenD) integer(kind=ip), intent(inout) :: indc (lena) integer(kind=ip), intent(inout) :: indr (lena) integer(kind=ip), intent(inout) :: p (m) integer(kind=ip), intent(inout) :: q (n) integer(kind=ip), intent(inout) :: lenc (n) integer(kind=ip), intent(inout) :: lenr (m) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(out) :: ipinv (m) integer(kind=ip), intent(out) :: ipvt (m) Calls proc~~lu1ful~~CallsGraph proc~lu1ful lusol::lu1ful proc~lu1dcp lusol::lu1DCP proc~lu1ful->proc~lu1dcp proc~lu1dpp lusol::lu1DPP proc~lu1ful->proc~lu1dpp proc~jdamax lusol::jdamax proc~lu1dcp->proc~jdamax proc~lu1dpp->proc~jdamax Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~lu1ful~~CalledByGraph proc~lu1ful lusol::lu1ful proc~lu1fad lusol::lu1fad proc~lu1fad->proc~lu1ful proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1ful ( m , n , lena , lenD , lu1 , TPP , & mleft , nleft , nrank , nrowu , & lenL , lenU , nsing , & keepLU , small , & a , d , indc , indr , p , q , & lenc , lenr , locc , ipinv , ipvt ) logical , intent ( in ) :: TPP , keepLU integer ( ip ), intent ( in ) :: m , n , lena , lenD , lu1 , & mleft , nleft , nrank , nrowu integer ( ip ), intent ( in ) :: locc ( n ) real ( rp ), intent ( in ) :: small integer ( ip ), intent ( inout ) :: lenL , lenU integer ( ip ), intent ( inout ) :: indc ( lena ), indr ( lena ), p ( m ), q ( n ), & lenc ( n ) , lenr ( m ) real ( rp ), intent ( inout ) :: a ( lena ) integer ( ip ), intent ( out ) :: ipvt ( m ), ipinv ( m ) ! workspace integer ( ip ), intent ( out ) :: nsing ! not used outside real ( rp ), intent ( out ) :: d ( lenD ) !------------------------------------------------------------------ ! lu1ful computes a dense (full) LU factorization of the ! mleft by nleft matrix that remains to be factored at the ! beginning of the nrowu-th pass through the main loop of lu1fad. ! ! 02 May 1989: First version. ! 05 Feb 1994: Column interchanges added to lu1DPP. ! 08 Feb 1994: ipinv reconstructed, since lu1pq3 may alter p. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. !------------------------------------------------------------------ integer ( ip ) :: i , ibest , ipbase , j , jbest , k , l , l1 , l2 , & la , lc , lc1 , lc2 , ld , ldbase , ldiagU , & lkk , lkn , ll , lq , lu , nrowd , ncold real ( rp ) :: ai , aj !------------------------------------------------------------------ ! If lu1pq3 moved any empty rows, reset ipinv = inverse of p. !------------------------------------------------------------------ if ( nrank < m ) then do l = 1 , m i = p ( l ) ipinv ( i ) = l end do end if !------------------------------------------------------------------ ! Copy the remaining matrix into the dense matrix D. !------------------------------------------------------------------ d ( 1 : lenD ) = zero ipbase = nrowu - 1 ldbase = 1 - nrowu do lq = nrowu , n j = q ( lq ) lc1 = locc ( j ) lc2 = lc1 + lenc ( j ) - 1 do lc = lc1 , lc2 i = indc ( lc ) ld = ldbase + ipinv ( i ) d ( ld ) = a ( lc ) end do ldbase = ldbase + mleft end do !------------------------------------------------------------------ ! Call our favorite dense LU factorizer. !------------------------------------------------------------------ if ( TPP ) then call lu1DPP ( d , mleft , mleft , nleft , small , nsing , ipvt , q ( nrowu ) ) else call lu1DCP ( d , mleft , mleft , nleft , small , nsing , ipvt , q ( nrowu ) ) end if !------------------------------------------------------------------ ! Move D to the beginning of A, ! and pack L and U at the top of a, indc, indr. ! In the process, apply the row permutation to p. ! lkk points to the diagonal of U. !------------------------------------------------------------------ a ( 1 : lenD ) = d ( 1 : lenD ) ldiagU = lena - n lkk = 1 lkn = lenD - mleft + 1 lu = lu1 do k = 1 , min ( mleft , nleft ) l1 = ipbase + k l2 = ipbase + ipvt ( k ) if ( l1 /= l2 ) then i = p ( l1 ) p ( l1 ) = p ( l2 ) p ( l2 ) = i end if ibest = p ( l1 ) jbest = q ( l1 ) if ( keepLU ) then !=========================================================== ! Pack the next column of L. !=========================================================== la = lkk ll = lu nrowd = 1 do i = k + 1 , mleft la = la + 1 ai = a ( la ) if ( abs ( ai ) > small ) then nrowd = nrowd + 1 ll = ll - 1 a ( ll ) = ai indc ( ll ) = p ( ipbase + i ) indr ( ll ) = ibest end if end do !=========================================================== ! Pack the next row of U. ! We go backwards through the row of D ! so the diagonal ends up at the front of the row of  U. ! Beware -- the diagonal may be zero. !=========================================================== la = lkn + mleft lu = ll ncold = 0 do j = nleft , k , - 1 la = la - mleft aj = a ( la ) if ( abs ( aj ) > small . or . j == k ) then ncold = ncold + 1 lu = lu - 1 a ( lu ) = aj indr ( lu ) = q ( ipbase + j ) end if end do lenr ( ibest ) = - ncold lenc ( jbest ) = - nrowd lenL = lenL + nrowd - 1 lenU = lenU + ncold lkn = lkn + 1 else !=========================================================== ! Store just the diagonal of U, in natural order. !=========================================================== a ( ldiagU + jbest ) = a ( lkk ) end if lkk = lkk + mleft + 1 end do end subroutine lu1ful","tags":"","loc":"proc/lu1ful.html"},{"title":"lu1DPP – AoC-2023","text":"private  subroutine lu1DPP(a, lda, m, n, small, nsing, ipvt, q) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: a (lda,n) integer(kind=ip), intent(in) :: lda integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n real(kind=rp), intent(in) :: small integer(kind=ip), intent(out) :: nsing integer(kind=ip), intent(out) :: ipvt (m) integer(kind=ip), intent(inout) :: q (n) Calls proc~~lu1dpp~~CallsGraph proc~lu1dpp lusol::lu1DPP proc~jdamax lusol::jdamax proc~lu1dpp->proc~jdamax Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~lu1dpp~~CalledByGraph proc~lu1dpp lusol::lu1DPP proc~lu1ful lusol::lu1ful proc~lu1ful->proc~lu1dpp proc~lu1fad lusol::lu1fad proc~lu1fad->proc~lu1ful proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1DPP ( a , lda , m , n , small , nsing , ipvt , q ) integer ( ip ), intent ( in ) :: lda , m , n real ( rp ), intent ( in ) :: small integer ( ip ), intent ( inout ) :: q ( n ) real ( rp ), intent ( inout ) :: a ( lda , n ) integer ( ip ), intent ( out ) :: nsing ! not used outside integer ( ip ), intent ( out ) :: ipvt ( m ) !------------------------------------------------------------------ ! lu1DPP factors a dense m x n matrix A by Gaussian elimination, ! using row interchanges for stability, as in dgefa from LINPACK. ! This version also uses column interchanges if all elements in a ! pivot column are smaller than (or equal to) \"small\".  Such columns ! are changed to zero and permuted to the right-hand end. ! ! As in LINPACK, ipvt(*) keeps track of pivot rows. ! Rows of U are interchanged, but we don't have to physically ! permute rows of L.  In contrast, column interchanges are applied ! directly to the columns of both L and U, and to the column ! permutation vector q(*). ! ! 02 May 1989: First version derived from dgefa !              in LINPACK (version dated 08/14/78). ! 05 Feb 1994: Generalized to treat rectangular matrices !              and use column interchanges when necessary. !              ipvt is retained, but column permutations are applied !              directly to q(*). ! 21 Dec 1994: Bug found via example from Steve Dirkse. !              Loop 100 added to set ipvt(*) for singular rows. ! 26 Mar 2006: nsing redefined (see below). !              Changed to implicit none. ! ! 10 Jan 2010: First f90 version.  Need to do more f90-ing. ! 12 Dec 2011: Declare intent and local variables. ! 03 Feb 2012: a is intent(inout), not (out). !              a(kp1:m,j) = t*a(kp1:m,k) + a(kp1:m,j)  needs the last :m !------------------------------------------------------------------ ! ! On entry: ! ! a       Array holding the matrix A to be factored. ! lda     The leading dimension of the array  a. ! m       The number of rows    in  A. ! n       The number of columns in  A. ! small   A drop tolerance.  Must be zero or positive. ! ! On exit: ! ! a       An upper triangular matrix and the multipliers !         which were used to obtain it. !         The factorization can be written  A = L*U  where ! L       is a product of permutation and unit lower !         triangular matrices and  U  is upper triangular. ! nsing   Number of singularities detected. ! 26 Mar 2006: nsing redefined to be more meaningful. !              Users may define rankU = n - nsing and regard !              U as upper-trapezoidal, with the first rankU columns !              being triangular and the rest trapezoidal. !              It would be better to return rankU, but we still !              return nsing for compatibility (even though lu1fad !              no longer uses it). ! ipvt    Records the pivot rows. ! q       A vector to which column interchanges are applied. !------------------------------------------------------------------ integer ( ip ) :: i , j , k , kp1 , l , last , lencol , rankU real ( rp ) :: t rankU = 0 k = 1 last = n !------------------------------------------------------------------ ! Start of elimination loop. !------------------------------------------------------------------ 10 kp1 = k + 1 lencol = m - k + 1 ! Find l, the pivot row. l = jdamax ( lencol , a ( k : m , k ), i1 ) + k - 1 ipvt ( k ) = l if ( abs ( a ( l , k ) ) <= small ) then !============================================================== ! Do column interchange, changing old pivot column to zero. ! Reduce \"last\" and try again with same k. !============================================================== j = q ( last ) q ( last ) = q ( k ) q ( k ) = j do i = 1 , k - 1 t = a ( i , last ) a ( i , last ) = a ( i , k ) a ( i , k ) = t end do do i = k , m t = a ( i , last ) a ( i , last ) = zero a ( i , k ) = t end do last = last - 1 if ( k <= last ) go to 10 else rankU = rankU + 1 if ( k < m ) then !=========================================================== ! Do row interchange if necessary. !=========================================================== if ( l /= k ) then t = a ( l , k ) a ( l , k ) = a ( k , k ) a ( k , k ) = t end if !=========================================================== ! Compute multipliers. ! Do row elimination with column indexing. !=========================================================== t = - one / a ( k , k ) ! call dscal ( m-k, t, a(kp1,k), i1 ) a ( kp1 : m , k ) = t * a ( kp1 : m , k ) do j = kp1 , last t = a ( l , j ) if ( l /= k ) then a ( l , j ) = a ( k , j ) a ( k , j ) = t end if ! call daxpy ( m-k, t, a(kp1,k), i1, a(kp1,j), i1 ) a ( kp1 : m , j ) = t * a ( kp1 : m , k ) + a ( kp1 : m , j ) end do k = k + 1 if ( k <= last ) go to 10 end if end if ! Set ipvt(*) for singular rows. do k = last + 1 , m ipvt ( k ) = k end do nsing = n - rankU end subroutine lu1DPP","tags":"","loc":"proc/lu1dpp.html"},{"title":"lu1DCP – AoC-2023","text":"private  subroutine lu1DCP(a, lda, m, n, small, nsing, ipvt, q) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: a (lda,n) integer(kind=ip), intent(in) :: lda integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n real(kind=rp), intent(in) :: small integer(kind=ip), intent(out) :: nsing integer(kind=ip), intent(out) :: ipvt (m) integer(kind=ip), intent(inout) :: q (n) Calls proc~~lu1dcp~~CallsGraph proc~lu1dcp lusol::lu1DCP proc~jdamax lusol::jdamax proc~lu1dcp->proc~jdamax Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~lu1dcp~~CalledByGraph proc~lu1dcp lusol::lu1DCP proc~lu1ful lusol::lu1ful proc~lu1ful->proc~lu1dcp proc~lu1fad lusol::lu1fad proc~lu1fad->proc~lu1ful proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu1DCP ( a , lda , m , n , small , nsing , ipvt , q ) integer ( ip ), intent ( in ) :: lda , m , n real ( rp ), intent ( in ) :: small integer ( ip ), intent ( inout ) :: q ( n ) real ( rp ), intent ( inout ) :: a ( lda , n ) integer ( ip ), intent ( out ) :: nsing ! not used outside integer ( ip ), intent ( out ) :: ipvt ( m ) !------------------------------------------------------------------ ! lu1DCP factors a dense m x n matrix A by Gaussian elimination, ! using Complete Pivoting (row and column interchanges) for ! stability. ! This version also uses column interchanges if all elements in a ! pivot column are smaller than (or equal to) \"small\".  Such columns ! are changed to zero and permuted to the right-hand end. ! ! As in LINPACK's dgefa, ipvt(*) keeps track of pivot rows. ! Rows of U are interchanged, but we don't have to physically ! permute rows of L.  In contrast, column interchanges are applied ! directly to the columns of both L and U, and to the column ! permutation vector q(*). ! ! 01 May 2002: First dense Complete Pivoting, derived from lu1DPP. ! 07 May 2002: Another break needed at end of first loop. ! 26 Mar 2006: Cosmetic mods while looking for \"nsing\" bug when m<n. !              nsing redefined (see below). !              Changed to implicit none. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. ! 03 Feb 2012: a(kp1:m,j) = t*a(kp1:m,k) + a(kp1:m,j)  needs the last :m ! 21 Dec 2015: t = 0 caused divide by zero. !              Add test to exit if aijmax <= small. !------------------------------------------------------------------ ! ! On entry: ! a       Array holding the matrix A to be factored. ! lda     The leading dimension of the array  a. ! m       The number of rows    in  A. ! n       The number of columns in  A. ! small   A drop tolerance.  Must be zero or positive. ! ! On exit: ! a       An upper triangular matrix and the multipliers !         that were used to obtain it. !         The factorization can be written A = L*U, where !         L is a product of permutation and unit lower !         triangular matrices and U is upper triangular. ! nsing   Number of singularities detected. ! ! 26 Mar 2006: nsing redefined to be more meaningful. !              Users may define rankU = n - nsing and regard !              U as upper-trapezoidal, with the first rankU columns !              being triangular and the rest trapezoidal. !              It would be better to return rankU, but we still !              return nsing for compatibility (even though lu1fad !              no longer uses it). ! ipvt    Records the pivot rows. ! q       A vector to which column interchanges are applied. !------------------------------------------------------------------ real ( rp ) :: aijmax , ajmax , t integer ( ip ) :: i , imax , j , jlast , jmax , jnew , & k , kp1 , l , last , lencol , rankU rankU = 0 lencol = m + 1 last = n !----------------------------------------------------------------- ! Start of elimination loop. !----------------------------------------------------------------- do k = 1 , n kp1 = k + 1 lencol = lencol - 1 ! Find the biggest aij in row imax and column jmax. aijmax = zero imax = k jmax = k jlast = last do j = k , jlast 10 l = jdamax ( lencol , a ( k : m , j ), i1 ) + k - 1 ajmax = abs ( a ( l , j )) if ( ajmax <= small ) then !======================================================== ! Do column interchange, changing old column to zero. ! Reduce \"last\" and try again with same j. !======================================================== jnew = q ( last ) q ( last ) = q ( j ) q ( j ) = jnew do i = 1 , k - 1 t = a ( i , last ) a ( i , last ) = a ( i , j ) a ( i , j ) = t end do do i = k , m t = a ( i , last ) a ( i , last ) = zero a ( i , j ) = t end do last = last - 1 if ( j <= last ) go to 10 ! repeat go to 200 ! break end if ! Check if this column has biggest aij so far. if ( aijmax < ajmax ) then aijmax = ajmax imax = l jmax = j end if if ( j >= last ) go to 200 ! break end do 200 ipvt ( k ) = imax ! 21 Dec 2015: Exit if aijmax is essentially zero. if ( aijmax <= small ) go to 500 rankU = rankU + 1 if ( jmax /= k ) then ! Do column interchange (k and jmax). jnew = q ( jmax ) q ( jmax ) = q ( k ) q ( k ) = jnew do i = 1 , m t = a ( i , jmax ) a ( i , jmax ) = a ( i , k ) a ( i , k ) = t end do end if if ( k < m ) then ! Do row interchange if necessary. t = a ( imax , k ) if ( imax /= k ) then a ( imax , k ) = a ( k , k ) a ( k , k ) = t end if !=========================================================== ! Compute multipliers. ! Do row elimination with column indexing. !=========================================================== t = - one / t ! call dscal ( m-k, t, a(kp1,k), i1 ) a ( kp1 : m , k ) = t * a ( kp1 : m , k ) do j = kp1 , last t = a ( imax , j ) if ( imax /= k ) then a ( imax , j ) = a ( k , j ) a ( k , j ) = t end if ! call daxpy ( m-k, t, a(kp1,k), i1, a(kp1,j), i1 ) a ( kp1 : m , j ) = t * a ( kp1 : m , k ) + a ( kp1 : m , j ) end do else go to 500 ! break end if if ( k >= last ) go to 500 ! break end do ! Set ipvt(*) for singular rows. 500 do k = last + 1 , m ipvt ( k ) = k end do nsing = n - rankU end subroutine lu1DCP","tags":"","loc":"proc/lu1dcp.html"},{"title":"Hbuild – AoC-2023","text":"private  subroutine Hbuild(Ha, Hj, Hk, N, Nk, hops) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: Ha (N) integer(kind=ip), intent(inout) :: Hj (N) integer(kind=ip), intent(inout) :: Hk (Nk) integer(kind=ip), intent(in) :: N integer(kind=ip), intent(in) :: Nk integer(kind=ip), intent(out) :: hops Calls proc~~hbuild~~CallsGraph proc~hbuild lusol::Hbuild proc~hinsert lusol::Hinsert proc~hbuild->proc~hinsert proc~hup lusol::Hup proc~hinsert->proc~hup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hbuild~~CalledByGraph proc~hbuild lusol::Hbuild proc~lu1fad lusol::lu1fad proc~lu1fad->proc~hbuild proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine Hbuild ( Ha , Hj , Hk , N , Nk , hops ) integer ( ip ), intent ( in ) :: N , Nk integer ( ip ), intent ( inout ) :: Hj ( N ), Hk ( Nk ) integer ( ip ), intent ( out ) :: hops real ( rp ), intent ( inout ) :: Ha ( N ) !================================================================== ! Hbuild initializes the heap by inserting each element of Ha. ! Input:  Ha, Hj. ! Output: Ha, Hj, Hk, hops. ! ! 01 May 2002: Use k for new length of heap, not k-1 for old length. ! 05 May 2002: Use kk in call to stop loop variable k being altered. !              (Actually Hinsert no longer alters that parameter.) ! 07 May 2002: ftnchek wants us to protect Nk, Ha(k), Hj(k) too. ! 07 May 2002: Current version of Hbuild. ! 12 Dec 2011: First f90 version. !================================================================== integer ( ip ) :: h , jv , k , kk , Nkk real ( rp ) :: v Nkk = Nk hops = 0 do k = 1 , N kk = k v = Ha ( k ) jv = Hj ( k ) call Hinsert ( Ha , Hj , Hk , kk , Nkk , v , jv , h ) hops = hops + h end do end subroutine Hbuild","tags":"","loc":"proc/hbuild.html"},{"title":"Hchange – AoC-2023","text":"private  subroutine Hchange(Ha, Hj, Hk, N, Nk, k, v, jv, hops) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: Ha (N) integer(kind=ip), intent(inout) :: Hj (N) integer(kind=ip), intent(inout) :: Hk (Nk) integer(kind=ip), intent(in) :: N integer(kind=ip), intent(in) :: Nk integer(kind=ip), intent(in) :: k real(kind=rp), intent(in) :: v integer(kind=ip), intent(in) :: jv integer(kind=ip), intent(out) :: hops Calls proc~~hchange~~CallsGraph proc~hchange lusol::Hchange proc~hdown lusol::Hdown proc~hchange->proc~hdown proc~hup lusol::Hup proc~hchange->proc~hup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hchange~~CalledByGraph proc~hchange lusol::Hchange proc~hdelete lusol::Hdelete proc~hdelete->proc~hchange proc~lu1fad lusol::lu1fad proc~lu1fad->proc~hchange proc~lu1fad->proc~hdelete proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine Hchange ( Ha , Hj , Hk , N , Nk , k , v , jv , hops ) integer ( ip ), intent ( in ) :: N , Nk , k , jv real ( rp ), intent ( in ) :: v integer ( ip ), intent ( inout ) :: Hj ( N ), Hk ( Nk ) real ( rp ), intent ( inout ) :: Ha ( N ) integer ( ip ), intent ( out ) :: hops !================================================================== ! Hchange changes Ha(k) to v in heap of length N. ! ! 01 May 2002: Need Nk for length of Hk. ! 07 May 2002: Protect input parameters N, Nk, k. ! 07 May 2002: Current version of Hchange. ! 12 Dec 2011: First f90 version. !================================================================== integer ( ip ) :: kx , Nx , Nkx real ( rp ) :: v1 Nx = N Nkx = Nk kx = k v1 = Ha ( k ) Ha ( k ) = v Hj ( k ) = jv Hk ( jv ) = k if ( v1 < v ) then call Hup ( Ha , Hj , Hk , Nx , Nkx , kx , hops ) else call Hdown ( Ha , Hj , Hk , Nx , Nkx , kx , hops ) end if end subroutine Hchange","tags":"","loc":"proc/hchange.html"},{"title":"Hdelete – AoC-2023","text":"private  subroutine Hdelete(Ha, Hj, Hk, Nin, N, Nk, k, hops) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: Ha (Nin) integer(kind=ip), intent(inout) :: Hj (Nin) integer(kind=ip), intent(inout) :: Hk (Nk) integer(kind=ip), intent(in) :: Nin integer(kind=ip), intent(inout) :: N integer(kind=ip), intent(in) :: Nk integer(kind=ip), intent(in) :: k integer(kind=ip), intent(out) :: hops Calls proc~~hdelete~~CallsGraph proc~hdelete lusol::Hdelete proc~hchange lusol::Hchange proc~hdelete->proc~hchange proc~hdown lusol::Hdown proc~hchange->proc~hdown proc~hup lusol::Hup proc~hchange->proc~hup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hdelete~~CalledByGraph proc~hdelete lusol::Hdelete proc~lu1fad lusol::lu1fad proc~lu1fad->proc~hdelete proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine Hdelete ( Ha , Hj , Hk , Nin , N , Nk , k , hops ) integer ( ip ), intent ( in ) :: Nin , Nk , k integer ( ip ), intent ( inout ) :: N integer ( ip ), intent ( inout ) :: Hj ( Nin ), Hk ( Nk ) real ( rp ), intent ( inout ) :: Ha ( Nin ) integer ( ip ), intent ( out ) :: hops !================================================================== ! Hdelete deletes Ha(k) from heap of length N. ! ! 03 Apr 2002: Current version of Hdelete. ! 01 May 2002: Need Nk for length of Hk. ! 07 May 2002: Protect input parameters N, Nk, k. ! 19 Dec 2004: Nin is new input parameter for length of Hj, Ha. ! 19 Dec 2004: Current version of Hdelete. ! 12 Dec 2011: First f90 version. !================================================================== integer ( ip ) :: jv , kx , Nkx , Nx real ( rp ) :: v kx = k Nkx = Nk Nx = N v = Ha ( N ) jv = Hj ( N ) N = N - 1 hops = 0 if ( k <= N ) then call Hchange ( Ha , Hj , Hk , Nx , Nkx , kx , v , jv , hops ) end if end subroutine Hdelete","tags":"","loc":"proc/hdelete.html"},{"title":"Hdown – AoC-2023","text":"private  subroutine Hdown(Ha, Hj, Hk, N, Nk, kk, hops) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: Ha (N) integer(kind=ip), intent(inout) :: Hj (N) integer(kind=ip), intent(inout) :: Hk (Nk) integer(kind=ip), intent(in) :: N integer(kind=ip), intent(in) :: Nk integer(kind=ip), intent(in) :: kk integer(kind=ip), intent(out) :: hops Called by proc~~hdown~~CalledByGraph proc~hdown lusol::Hdown proc~hchange lusol::Hchange proc~hchange->proc~hdown proc~hdelete lusol::Hdelete proc~hdelete->proc~hchange proc~lu1fad lusol::lu1fad proc~lu1fad->proc~hchange proc~lu1fad->proc~hdelete proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine Hdown ( Ha , Hj , Hk , N , Nk , kk , hops ) integer ( ip ), intent ( in ) :: N , Nk , kk integer ( ip ), intent ( inout ) :: Hj ( N ), Hk ( Nk ) real ( rp ), intent ( inout ) :: Ha ( N ) integer ( ip ), intent ( out ) :: hops !================================================================== ! Hdown  updates heap by moving down tree from node k. ! ! 01 May 2002: Need Nk for length of Hk. ! 05 May 2002: Change input parameter k to kk to stop k being output. ! 05 May 2002: Current version of Hdown. ! 12 Dec 2011: First f90 version. !================================================================== integer ( ip ) :: j , jj , jv , k , N2 real ( rp ) :: v k = kk hops = 0 v = Ha ( k ) jv = Hj ( k ) N2 = N / 2 do if ( k > N2 ) exit hops = hops + 1 j = k + k if ( j < N ) then if ( Ha ( j ) < Ha ( j + 1 )) j = j + 1 end if if ( v >= Ha ( j )) exit Ha ( k ) = Ha ( j ) jj = Hj ( j ) Hj ( k ) = jj Hk ( jj ) = k k = j end do Ha ( k ) = v Hj ( k ) = jv Hk ( jv ) = k end subroutine Hdown","tags":"","loc":"proc/hdown.html"},{"title":"Hinsert – AoC-2023","text":"private  subroutine Hinsert(Ha, Hj, Hk, N, Nk, v, jv, hops) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: Ha (N) integer(kind=ip), intent(inout) :: Hj (N) integer(kind=ip), intent(inout) :: Hk (Nk) integer(kind=ip), intent(inout) :: N integer(kind=ip), intent(in) :: Nk real(kind=rp), intent(in) :: v integer(kind=ip), intent(in) :: jv integer(kind=ip), intent(out) :: hops Calls proc~~hinsert~~CallsGraph proc~hinsert lusol::Hinsert proc~hup lusol::Hup proc~hinsert->proc~hup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hinsert~~CalledByGraph proc~hinsert lusol::Hinsert proc~hbuild lusol::Hbuild proc~hbuild->proc~hinsert proc~lu1fad lusol::lu1fad proc~lu1fad->proc~hbuild proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine Hinsert ( Ha , Hj , Hk , N , Nk , v , jv , hops ) integer ( ip ), intent ( in ) :: Nk , jv real ( rp ), intent ( in ) :: v integer ( ip ), intent ( inout ) :: N integer ( ip ), intent ( inout ) :: Hj ( N ), Hk ( Nk ) real ( rp ), intent ( inout ) :: Ha ( N ) integer ( ip ), intent ( out ) :: hops !================================================================== ! Hinsert inserts (v,jv) into heap of length N-1 ! to make heap of length N. ! ! 03 Apr 2002: First version of Hinsert. ! 01 May 2002: Require N to be final length, not old length. !              Need Nk for length of Hk. ! 07 May 2002: Protect input parameters N, Nk. ! 07 May 2002: Current version of Hinsert. ! 12 Dec 2011: First f90 version. !================================================================== integer ( ip ) :: kk , Nkk , Nnew Nnew = N Nkk = Nk kk = Nnew Ha ( Nnew ) = v Hj ( Nnew ) = jv Hk ( jv ) = Nnew call Hup ( Ha , Hj , Hk , Nnew , Nkk , kk , hops ) end subroutine Hinsert","tags":"","loc":"proc/hinsert.html"},{"title":"Hup – AoC-2023","text":"private  subroutine Hup(Ha, Hj, Hk, N, Nk, kk, hops) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: Ha (N) integer(kind=ip), intent(inout) :: Hj (N) integer(kind=ip), intent(inout) :: Hk (Nk) integer(kind=ip), intent(in) :: N integer(kind=ip), intent(in) :: Nk integer(kind=ip), intent(in) :: kk integer(kind=ip), intent(out) :: hops Called by proc~~hup~~CalledByGraph proc~hup lusol::Hup proc~hchange lusol::Hchange proc~hchange->proc~hup proc~hinsert lusol::Hinsert proc~hinsert->proc~hup proc~hbuild lusol::Hbuild proc~hbuild->proc~hinsert proc~hdelete lusol::Hdelete proc~hdelete->proc~hchange proc~lu1fad lusol::lu1fad proc~lu1fad->proc~hchange proc~lu1fad->proc~hbuild proc~lu1fad->proc~hdelete proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu1fad proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine Hup ( Ha , Hj , Hk , N , Nk , kk , hops ) integer ( ip ), intent ( in ) :: N , Nk , kk integer ( ip ), intent ( inout ) :: Hj ( N ), Hk ( Nk ) real ( rp ), intent ( inout ) :: Ha ( N ) integer ( ip ), intent ( out ) :: hops !================================================================== ! Hup updates heap by moving up tree from node k. ! ! 01 May 2002: Need Nk for length of Hk. ! 05 May 2002: Change input parameter k to kk to stop k being output. ! 05 May 2002: Current version of Hup. ! 13 Dec 2011: First f90 version. !================================================================== integer ( ip ) :: j , jv , k , k2 real ( rp ) :: v k = kk hops = 0 v = Ha ( k ) jv = Hj ( k ) do if ( k < 2 ) exit k2 = k / 2 if ( v < Ha ( k2 )) exit hops = hops + 1 Ha ( k ) = Ha ( k2 ) j = Hj ( k2 ) Hj ( k ) = j Hk ( j ) = k k = k2 end do Ha ( k ) = v Hj ( k ) = jv Hk ( jv ) = k end subroutine Hup","tags":"","loc":"proc/hup.html"},{"title":"lu6sol – AoC-2023","text":"public  subroutine lu6sol(mode, m, n, v, w, lena, luparm, parmlu, a, indc, indr, p, q, lenc, lenr, locc, locr, inform) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: mode integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n real(kind=rp), intent(inout) :: v (m) real(kind=rp), intent(inout) :: w (n) integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: p (m) integer(kind=ip), intent(in) :: q (n) integer(kind=ip), intent(in) :: lenc (n) integer(kind=ip), intent(in) :: lenr (m) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(in) :: locr (m) integer(kind=ip), intent(out) :: inform Calls proc~~lu6sol~~CallsGraph proc~lu6sol lusol::lu6sol proc~lu6l lusol::lu6L proc~lu6sol->proc~lu6l proc~lu6ld lusol::lu6LD proc~lu6sol->proc~lu6ld proc~lu6lt lusol::lu6Lt proc~lu6sol->proc~lu6lt proc~lu6u lusol::lu6U proc~lu6sol->proc~lu6u proc~lu6ut lusol::lu6Ut proc~lu6sol->proc~lu6ut Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~lu6sol~~CalledByGraph proc~lu6sol lusol::lu6sol proc~lu8rpc lusol::lu8rpc proc~lu8rpc->proc~lu6sol proc~solve lusol_ez_module::solve proc~solve->proc~lu6sol proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu6sol ( mode , m , n , v , w , & lena , luparm , parmlu , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & inform ) integer ( ip ), intent ( in ) :: mode , m , n , lena integer ( ip ), intent ( in ) :: indc ( lena ), indr ( lena ), p ( m ), q ( n ), & lenc ( n ), lenr ( m ), locc ( n ), locr ( m ) real ( rp ), intent ( in ) :: a ( lena ) integer ( ip ), intent ( inout ) :: luparm ( 30 ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), v ( m ), w ( n ) integer ( ip ), intent ( out ) :: inform !----------------------------------------------------------------------- ! lu6sol  uses the factorization  A = L U  as follows: ! ! mode !  1    v  solves   L v = v(input).   w  is not touched. !  2    v  solves   L'v = v(input).   w  is not touched. !  3    w  solves   U w = v.          v  is not altered. !  4    v  solves   U'v = w.          w  is destroyed. !  5    w  solves   A w = v.          v  is altered as in 1. !  6    v  solves   A'v = w.          w  is destroyed. ! ! If mode = 3,4,5,6, v and w must not be the same arrays. ! ! If lu1fac has just been used to factorize a symmetric matrix A ! (which must be definite or quasi-definite), the factors A = L U ! may be regarded as A = LDL', where D = diag(U).  In such cases, ! ! mode !  7    v  solves   A v = L D L'v = v(input).   w  is not touched. !  8    v  solves       L |D| L'v = v(input).   w  is not touched. ! ! p(*), q(*)        hold row and column numbers in pivotal order. ! lenc(k)           is the length of the k-th column of initial L. ! lenr(i)           is the length of the i-th row of U. ! locc(*)           is not used. ! locr(i)           is the start  of the i-th row of U. ! ! U is assumed to be in upper-trapezoidal form (nrank by n). ! The first entry for each row is the diagonal element ! (according to the permutations p, q).  It is stored at ! location locr(i) in a(*), indr(*). ! ! On exit, inform = 0 except as follows. ! If mode = 3,4,5,6 and if U (and hence A) is singular, then ! inform = 1 if there is a nonzero residual in solving the system ! involving U.  parmlu(20) returns the norm of the residual. ! ! July 1987:   Early version. ! 09 May 1988: f77 version. ! 27 Apr 2000: Abolished the dreaded \"computed go to\". !              But hard to change other \"go to\"s to \"if then else\". ! 15 Dec 2002: lu6L, lu6Lt, lu6U, lu6Ut added to modularize lu6sol. ! 13 Dec 2011: First f90 version. !-------------------------------------------------------------------- if ( mode == 1 ) then ! Solve  L v(new) = v. call lu6L ( inform , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc ) else if ( mode == 2 ) then ! Solve  L'v(new) = v. call lu6Lt ( inform , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc ) else if ( mode == 3 ) then ! Solve  U w = v. call lu6U ( inform , m , n , v , w , & lena , luparm , parmlu , a , indr , p , q , lenr , locr ) else if ( mode == 4 ) then ! Solve  U'v = w. call lu6Ut ( inform , m , n , v , w , & lena , luparm , parmlu , a , indr , p , q , lenr , locr ) else if ( mode == 5 ) then ! Solve  A w      = v ! via    L v(new) = v ! and    U w = v(new). call lu6L ( inform , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc ) call lu6U ( inform , m , n , v , w , & lena , luparm , parmlu , a , indr , p , q , lenr , locr ) else if ( mode == 6 ) then ! Solve  A'v = w ! via    U'v = w ! and    L'v(new) = v. call lu6Ut ( inform , m , n , v , w , & lena , luparm , parmlu , a , indr , p , q , lenr , locr ) call lu6Lt ( inform , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc ) else if ( mode == 7 ) then ! Solve  LDv(bar) = v ! and    L'v(new) = v(bar). call lu6LD ( inform , i1 , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc , locr ) call lu6Lt ( inform , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc ) else if ( mode == 8 ) then ! Solve  L|D|v(bar) = v ! and    L'v(new) = v(bar). call lu6LD ( inform , i2 , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc , locr ) call lu6Lt ( inform , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc ) end if end subroutine lu6sol","tags":"","loc":"proc/lu6sol.html"},{"title":"lu6L – AoC-2023","text":"private  subroutine lu6L(inform, m, n, v, lena, luparm, parmlu, a, indc, indr, lenc) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(out) :: inform integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n real(kind=rp), intent(inout) :: v (m) integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: lenc (n) Called by proc~~lu6l~~CalledByGraph proc~lu6l lusol::lu6L proc~lu6sol lusol::lu6sol proc~lu6sol->proc~lu6l proc~lu8rpc lusol::lu8rpc proc~lu8rpc->proc~lu6sol proc~solve lusol_ez_module::solve proc~solve->proc~lu6sol proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu6L ( inform , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc ) integer ( ip ), intent ( in ) :: m , n , lena integer ( ip ), intent ( in ) :: indc ( lena ), indr ( lena ), lenc ( n ) real ( rp ), intent ( in ) :: a ( lena ) integer ( ip ), intent ( inout ) :: luparm ( 30 ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), v ( m ) integer ( ip ), intent ( out ) :: inform !------------------------------------------------------------------ ! lu6L   solves   L v = v(input). ! ! 15 Dec 2002: First version derived from lu6sol. ! 15 Dec 2002: Current version. ! 13 Dec 2011: First f90 version. !------------------------------------------------------------------ integer ( ip ) :: i , ipiv , j , k , l , l1 , ldummy , len , lenL , lenL0 , numL , numL0 real ( rp ) :: small , vpiv numL0 = luparm ( 20 ) lenL0 = luparm ( 21 ) lenL = luparm ( 23 ) small = parmlu ( 3 ) inform = 0 l1 = lena + 1 do k = 1 , numL0 len = lenc ( k ) l = l1 l1 = l1 - len ipiv = indr ( l1 ) vpiv = v ( ipiv ) if ( abs ( vpiv ) > small ) then !***** This loop could be coded specially. do ldummy = 1 , len l = l - 1 j = indc ( l ) v ( j ) = v ( j ) + a ( l ) * vpiv end do end if end do l = lena - lenL0 + 1 numL = lenL - lenL0 !***** This loop could be coded specially. do ldummy = 1 , numL l = l - 1 i = indr ( l ) if ( abs ( v ( i )) > small ) then j = indc ( l ) v ( j ) = v ( j ) + a ( l ) * v ( i ) end if end do ! Exit. luparm ( 10 ) = inform end subroutine lu6L","tags":"","loc":"proc/lu6l.html"},{"title":"lu6Lt – AoC-2023","text":"private  subroutine lu6Lt(inform, m, n, v, lena, luparm, parmlu, a, indc, indr, lenc) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(out) :: inform integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n real(kind=rp), intent(inout) :: v (m) integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: lenc (n) Called by proc~~lu6lt~~CalledByGraph proc~lu6lt lusol::lu6Lt proc~lu6sol lusol::lu6sol proc~lu6sol->proc~lu6lt proc~lu8rpc lusol::lu8rpc proc~lu8rpc->proc~lu6sol proc~solve lusol_ez_module::solve proc~solve->proc~lu6sol proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu6Lt ( inform , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc ) integer ( ip ), intent ( in ) :: m , n , lena integer ( ip ), intent ( in ) :: indc ( lena ), indr ( lena ), lenc ( n ) real ( rp ), intent ( in ) :: a ( lena ) integer ( ip ), intent ( inout ) :: luparm ( 30 ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), v ( m ) integer ( ip ), intent ( out ) :: inform !------------------------------------------------------------------ ! lu6Lt  solves   L'v = v(input). ! ! 15 Dec 2002: First version derived from lu6sol. ! 15 Dec 2002: Current version. ! 13 Dec 2011: First f90 version. !------------------------------------------------------------------ integer ( ip ) :: i , ipiv , j , k , l , l1 , l2 , len , lenL , lenL0 , numL0 real ( rp ) :: small , sum numL0 = luparm ( 20 ) lenL0 = luparm ( 21 ) lenL = luparm ( 23 ) small = parmlu ( 3 ) inform = 0 l1 = lena - lenL + 1 l2 = lena - lenL0 !***** This loop could be coded specially. do l = l1 , l2 j = indc ( l ) if ( abs ( v ( j )) > small ) then i = indr ( l ) v ( i ) = v ( i ) + a ( l ) * v ( j ) end if end do do k = numL0 , 1 , - 1 len = lenc ( k ) sum = zero l1 = l2 + 1 l2 = l2 + len !***** This loop could be coded specially. do l = l1 , l2 j = indc ( l ) sum = sum + a ( l ) * v ( j ) end do ipiv = indr ( l1 ) v ( ipiv ) = v ( ipiv ) + sum end do ! Exit. luparm ( 10 ) = inform end subroutine lu6Lt","tags":"","loc":"proc/lu6lt.html"},{"title":"lu6U – AoC-2023","text":"private  subroutine lu6U(inform, m, n, v, w, lena, luparm, parmlu, a, indr, p, q, lenr, locr) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(out) :: inform integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n real(kind=rp), intent(in) :: v (m) real(kind=rp), intent(out) :: w (n) integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: p (m) integer(kind=ip), intent(in) :: q (n) integer(kind=ip), intent(in) :: lenr (m) integer(kind=ip), intent(in) :: locr (m) Called by proc~~lu6u~~CalledByGraph proc~lu6u lusol::lu6U proc~lu6sol lusol::lu6sol proc~lu6sol->proc~lu6u proc~lu8rpc lusol::lu8rpc proc~lu8rpc->proc~lu6sol proc~solve lusol_ez_module::solve proc~solve->proc~lu6sol proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu6U ( inform , m , n , v , w , & lena , luparm , parmlu , a , indr , p , q , lenr , locr ) integer ( ip ), intent ( in ) :: m , n , lena integer ( ip ), intent ( in ) :: indr ( lena ), p ( m ), q ( n ), lenr ( m ), locr ( m ) real ( rp ), intent ( in ) :: a ( lena ) real ( rp ), intent ( in ) :: v ( m ) integer ( ip ), intent ( inout ) :: luparm ( 30 ) real ( rp ), intent ( inout ) :: parmlu ( 30 ) integer ( ip ), intent ( out ) :: inform real ( rp ), intent ( out ) :: w ( n ) !------------------------------------------------------------------ ! lu6U   solves   U w = v.          v  is not altered. ! ! 15 Dec 2002: First version derived from lu6sol. ! 15 Dec 2002: Current version. ! 13 Dec 2011: First f90 version. !------------------------------------------------------------------ integer ( ip ) :: i , j , k , klast , l , l1 , l2 , l3 , nrank , nrank1 real ( rp ) :: resid , small , t nrank = luparm ( 16 ) small = parmlu ( 3 ) inform = 0 nrank1 = nrank + 1 resid = zero ! Find the first nonzero in v(1:nrank), counting backwards. do klast = nrank , 1 , - 1 i = p ( klast ) if ( abs ( v ( i )) > small ) exit end do do k = klast + 1 , n j = q ( k ) w ( j ) = zero end do ! Do the back-substitution, using rows 1:klast of U. do k = klast , 1 , - 1 i = p ( k ) t = v ( i ) l1 = locr ( i ) l2 = l1 + 1 l3 = l1 + lenr ( i ) - 1 !***** This loop could be coded specially. do l = l2 , l3 j = indr ( l ) t = t - a ( l ) * w ( j ) end do j = q ( k ) if ( abs ( t ) <= small ) then w ( j ) = zero else w ( j ) = t / a ( l1 ) end if end do ! Compute residual for overdetermined systems. do k = nrank1 , m i = p ( k ) resid = resid + abs ( v ( i )) end do ! Exit. if ( resid > zero ) inform = 1 luparm ( 10 ) = inform parmlu ( 20 ) = resid end subroutine lu6U","tags":"","loc":"proc/lu6u.html"},{"title":"lu6Ut – AoC-2023","text":"private  subroutine lu6Ut(inform, m, n, v, w, lena, luparm, parmlu, a, indr, p, q, lenr, locr) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(out) :: inform integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n real(kind=rp), intent(out) :: v (m) real(kind=rp), intent(inout) :: w (n) integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: p (m) integer(kind=ip), intent(in) :: q (n) integer(kind=ip), intent(in) :: lenr (m) integer(kind=ip), intent(in) :: locr (m) Called by proc~~lu6ut~~CalledByGraph proc~lu6ut lusol::lu6Ut proc~lu6sol lusol::lu6sol proc~lu6sol->proc~lu6ut proc~lu8rpc lusol::lu8rpc proc~lu8rpc->proc~lu6sol proc~solve lusol_ez_module::solve proc~solve->proc~lu6sol proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu6Ut ( inform , m , n , v , w , & lena , luparm , parmlu , a , indr , p , q , lenr , locr ) integer ( ip ), intent ( in ) :: m , n , lena integer ( ip ), intent ( in ) :: indr ( lena ), p ( m ), q ( n ), lenr ( m ), locr ( m ) real ( rp ), intent ( in ) :: a ( lena ) integer ( ip ), intent ( inout ) :: luparm ( 30 ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), w ( n ) integer ( ip ), intent ( out ) :: inform real ( rp ), intent ( out ) :: v ( m ) !------------------------------------------------------------------ ! lu6Ut  solves   U'v = w.          w  is destroyed. ! ! 15 Dec 2002: First version derived from lu6sol. ! 15 Dec 2002: Current version. ! 13 Dec 2011: First f90 version. !------------------------------------------------------------------ integer ( ip ) :: i , j , k , l , l1 , l2 , nrank , nrank1 real ( rp ) :: resid , small , t nrank = luparm ( 16 ) small = parmlu ( 3 ) inform = 0 nrank1 = nrank + 1 resid = zero do k = nrank1 , m i = p ( k ) v ( i ) = zero end do ! Do the forward-substitution, skipping columns of U(transpose) ! when the associated element of w(*) is negligible. do k = 1 , nrank i = p ( k ) j = q ( k ) t = w ( j ) if ( abs ( t ) <= small ) then v ( i ) = zero cycle end if l1 = locr ( i ) t = t / a ( l1 ) v ( i ) = t l2 = l1 + lenr ( i ) - 1 l1 = l1 + 1 !***** This loop could be coded specially. do l = l1 , l2 j = indr ( l ) w ( j ) = w ( j ) - t * a ( l ) end do end do ! Compute residual for overdetermined systems. do k = nrank1 , n j = q ( k ) resid = resid + abs ( w ( j )) end do ! Exit. if ( resid > zero ) inform = 1 luparm ( 10 ) = inform parmlu ( 20 ) = resid end subroutine lu6Ut","tags":"","loc":"proc/lu6ut.html"},{"title":"lu6LD – AoC-2023","text":"private  subroutine lu6LD(inform, mode, m, n, v, lena, luparm, parmlu, a, indc, indr, lenc, locr) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(out) :: inform integer(kind=ip), intent(in) :: mode integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n real(kind=rp), intent(inout) :: v (m) integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: lenc (n) integer(kind=ip), intent(in) :: locr (m) Called by proc~~lu6ld~~CalledByGraph proc~lu6ld lusol::lu6LD proc~lu6sol lusol::lu6sol proc~lu6sol->proc~lu6ld proc~lu8rpc lusol::lu8rpc proc~lu8rpc->proc~lu6sol proc~solve lusol_ez_module::solve proc~solve->proc~lu6sol proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu6LD ( inform , mode , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc , locr ) integer ( ip ), intent ( in ) :: mode , m , n , lena integer ( ip ), intent ( in ) :: indc ( lena ), indr ( lena ), lenc ( n ), locr ( m ) real ( rp ), intent ( in ) :: a ( lena ) integer ( ip ), intent ( inout ) :: luparm ( 30 ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), v ( m ) integer ( ip ), intent ( out ) :: inform !------------------------------------------------------------------- ! lu6LD  assumes lu1fac has computed factors A = LU of a ! symmetric definite or quasi-definite matrix A, ! using Threshold Symmetric Pivoting (TSP),   luparm(6) = 3, ! or    Threshold Diagonal  Pivoting (TDP),   luparm(6) = 4. ! It also assumes that no updates have been performed. ! In such cases,  U = D L', where D = diag(U). ! lu6LDL returns v as follows: ! ! mode ! 1    v  solves   L D v = v(input). ! 2    v  solves   L|D|v = v(input). ! ! 15 Dec 2002: First version of lu6LD. ! 15 Dec 2002: Current version. ! 13 Dec 2011: First f90 version. !----------------------------------------------------------------------- ! ! Solve L D v(new) = v  or  L|D|v(new) = v, depending on mode. ! The code for L is the same as in lu6L, ! but when a nonzero entry of v arises, we divide by ! the corresponding entry of D or |D|. integer ( ip ) :: ipiv , j , k , l , l1 , ldummy , len , numL0 real ( rp ) :: diag , small , vpiv numL0 = luparm ( 20 ) small = parmlu ( 3 ) inform = 0 l1 = lena + 1 do k = 1 , numL0 len = lenc ( k ) l = l1 l1 = l1 - len ipiv = indr ( l1 ) vpiv = v ( ipiv ) if ( abs ( vpiv ) > small ) then !***** This loop could be coded specially. do ldummy = 1 , len l = l - 1 j = indc ( l ) v ( j ) = v ( j ) + a ( l ) * vpiv end do ! Find diag = U(ipiv,ipiv) and divide by diag or |diag|. l = locr ( ipiv ) diag = a ( l ) if ( mode == 2 ) diag = abs ( diag ) v ( ipiv ) = vpiv / diag end if end do end subroutine lu6LD","tags":"","loc":"proc/lu6ld.html"},{"title":"lu6chk – AoC-2023","text":"private  subroutine lu6chk(mode, m, n, nslack, w, lena, luparm, parmlu, a, indc, indr, p, q, lenc, lenr, locc, locr, inform) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: mode integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: nslack real(kind=rp), intent(inout) :: w (n) integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: p (m) integer(kind=ip), intent(in) :: q (n) integer(kind=ip), intent(in) :: lenc (n) integer(kind=ip), intent(in) :: lenr (m) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(in) :: locr (m) integer(kind=ip), intent(inout) :: inform Called by proc~~lu6chk~~CalledByGraph proc~lu6chk lusol::lu6chk proc~lu1fac lusol::lu1fac proc~lu1fac->proc~lu6chk proc~solve lusol_ez_module::solve proc~solve->proc~lu1fac proc~test_1 main::test_1 proc~test_1->proc~solve proc~test_2 main::test_2 proc~test_2->proc~solve program~main main program~main->proc~test_1 program~main->proc~test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu6chk ( mode , m , n , nslack , w , lena , luparm , parmlu , & a , indc , indr , p , q , lenc , lenr , locc , locr , inform ) integer ( ip ), intent ( in ) :: mode , m , n , nslack , lena integer ( ip ), intent ( in ) :: indc ( lena ), indr ( lena ), p ( m ), q ( n ), & lenc ( n ), lenr ( m ), locc ( n ), locr ( m ) real ( rp ), intent ( in ) :: a ( lena ) integer ( ip ), intent ( inout ) :: inform integer ( ip ), intent ( inout ) :: luparm ( 30 ) real ( rp ), intent ( inout ) :: parmlu ( 30 ) real ( rp ), intent ( inout ) :: w ( n ) !----------------------------------------------------------------- ! lu6chk  looks at the LU factorization  A = L*U. ! ! If mode = 1, lu6chk is being called by lu1fac. ! (Other modes not yet implemented.) ! The important input parameters are ! ! lprint = luparm(2) ! luparm(6) = 1 if TRP ! keepLU = luparm(8) ! Utol1  = parmlu(4) ! Utol2  = parmlu(5) ! ! and the significant output parameters are ! ! inform = luparm(10) ! nsing  = luparm(11) ! jsing  = luparm(12) ! jumin  = luparm(19) ! Lmax   = parmlu(11) ! Umax   = parmlu(12) ! DUmax  = parmlu(13) ! DUmin  = parmlu(14) ! and      w(*). ! ! Lmax  and Umax  return the largest elements in L and U. ! DUmax and DUmin return the largest and smallest diagonals of U ! (excluding diagonals that are exactly zero). ! ! In general, w(j) is set to the maximum absolute element in ! the j-th column of U.  However, if the corresponding diagonal ! of U is small in absolute terms or relative to w(j) ! (as judged by the parameters Utol1, Utol2 respectively), ! then w(j) is changed to - w(j). ! ! Thus, if w(j) is not positive, the j-th column of A ! appears to be dependent on the other columns of A. ! The number of such columns, and the position of the last one, ! are returned as nsing and jsing. ! ! Note that nrank is assumed to be set already, and is not altered. ! Typically, nsing will satisfy      nrank + nsing = n,  but if ! Utol1 and Utol2 are rather large,  nsing > n - nrank   may occur. ! ! If keepLU = 0, !              Lmax  and Umax  are already set by lu1fac. !              The diagonals of U are in the top of A. !              Only Utol1 is used in the singularity test to set w(*). ! ! inform = 0  if A appears to have full column rank (nsing = 0). ! inform = 1  otherwise (nsing > 0). ! ! 00 Jul 1987: Early version. ! 09 May 1988: f77 version. ! 11 Mar 2001: Allow for keepLU = 0. ! 17 Nov 2001: Briefer output for singular factors. ! 05 May 2002: Comma needed in format 1100 (via Kenneth Holmstrom). ! 06 May 2002: With keepLU = 0, diags of U are in natural order. !              They were not being extracted correctly. ! 23 Apr 2004: TRP can judge singularity better by comparing !              all diagonals to DUmax. ! 27 Jun 2004: (PEG) Allow write only if nout > 0 . ! 13 Dec 2011: First f90 version. ! 12 Dec 2015: nslack ensures slacks are kept with w(j) > 0. !------------------------------------------------------------------ character ( 1 ) :: mnkey logical :: keepLU , TRP integer ( ip ) :: i , j , jsing , jumin , k , l , l1 , l2 , ldiagU , lenL , & lprint , ndefic , nout , nrank , nsing real ( rp ) :: aij , diag , DUmax , DUmin , Lmax , Umax , Utol1 , Utol2 nout = luparm ( 1 ) lprint = luparm ( 2 ) TRP = luparm ( 6 ) == 1 ! Threshold Rook Pivoting keepLU = luparm ( 8 ) /= 0 nrank = luparm ( 16 ) lenL = luparm ( 23 ) Utol1 = parmlu ( 4 ) Utol2 = parmlu ( 5 ) inform = 0 Lmax = zero Umax = zero nsing = 0 jsing = 0 jumin = 0 DUmax = zero DUmin = 1.0d+30 ! w(j) is already set by lu1slk. ! w(1:n) = zero if ( keepLU ) then !-------------------------------------------------------------- ! Find  Lmax. !-------------------------------------------------------------- do l = lena + 1 - lenL , lena Lmax = max ( Lmax , abs ( a ( l )) ) end do !-------------------------------------------------------------- ! Find Umax and set w(j) = maximum element in j-th column of U. !-------------------------------------------------------------- do k = nslack + 1 , nrank ! 12 Dec 2015: Allow for nslack. i = p ( k ) l1 = locr ( i ) l2 = l1 + lenr ( i ) - 1 do l = l1 , l2 j = indr ( l ) aij = abs ( a ( l ) ) w ( j ) = max ( w ( j ), aij ) Umax = max ( Umax , aij ) end do end do parmlu ( 11 ) = Lmax parmlu ( 12 ) = Umax !-------------------------------------------------------------- ! Find DUmax and DUmin, the extreme diagonals of U. !-------------------------------------------------------------- do k = nslack + 1 , nrank ! 12 Dec 2015: Allow for nslack. j = q ( k ) i = p ( k ) l1 = locr ( i ) diag = abs ( a ( l1 ) ) DUmax = max ( DUmax , diag ) if ( DUmin > diag ) then DUmin = diag jumin = j end if end do else !-------------------------------------------------------------- ! keepLU = 0. ! Only diag(U) is stored.  Set w(*) accordingly. ! Find DUmax and DUmin, the extreme diagonals of U. !-------------------------------------------------------------- ldiagU = lena - n do k = nslack + 1 , nrank ! 12 Dec 2015: Allow for nslack. j = q ( k ) ! diag   = abs( a(ldiagU + k) ) ! 06 May 2002: Diags diag = abs ( a ( ldiagU + j ) ) ! are in natural order w ( j ) = diag DUmax = max ( DUmax , diag ) if ( DUmin > diag ) then DUmin = diag jumin = j end if end do end if !-------------------------------------------------------------- ! Negate w(j) if the corresponding diagonal of U is ! too small in absolute terms or relative to the other elements ! in the same column of  U. ! ! 23 Apr 2004: TRP ensures that diags are NOT small relative to !              other elements in their own column. !              Much better, we can compare all diags to DUmax. ! 13 Nov 2015: This causes slacks to replace slacks when DUmax !              is big.  It seems better to leave Utol1 alone. ! 12 Dec 2015: Allow for nslack. !              DUmax now excludes slack rows, so we can !              reset Utol1 again for TRP. !-------------------------------------------------------------- if ( mode == 1 . and . TRP ) then Utol1 = max ( Utol1 , Utol2 * DUmax ) end if if ( keepLU ) then do k = nslack + 1 , n ! 12 Dec 2015: Allow for nslack. j = q ( k ) if ( k > nrank ) then diag = zero else i = p ( k ) l1 = locr ( i ) diag = abs ( a ( l1 ) ) end if if ( diag <= Utol1 . or . diag <= Utol2 * w ( j )) then nsing = nsing + 1 jsing = j w ( j ) = - w ( j ) end if end do else ! keepLU = 0 do k = nslack + 1 , n ! 12 Dec 2015: Allow for nslack. j = q ( k ) diag = w ( j ) if ( diag <= Utol1 ) then nsing = nsing + 1 jsing = j w ( j ) = - w ( j ) end if end do end if !----------------------------------------------------------------- ! Set output parameters. !----------------------------------------------------------------- if ( jumin == 0 ) DUmin = zero luparm ( 11 ) = nsing luparm ( 12 ) = jsing luparm ( 19 ) = jumin parmlu ( 13 ) = DUmax parmlu ( 14 ) = DUmin if ( nsing > 0 ) then ! The matrix has been judged singular. inform = 1 ndefic = n - nrank if ( nout > 0 . and . lprint >= 0 ) then if ( m > n ) then mnkey = '>' else if ( m == n ) then mnkey = '=' else mnkey = '<' end if write ( nout , 1100 ) mnkey , nrank , ndefic , nsing end if end if ! Exit. luparm ( 10 ) = inform return 1100 format ( ' Singular(m' , a , 'n)' , '  rank' , i9 , '  n-rank' , i8 , '  nsing' , i9 ) end subroutine lu6chk","tags":"","loc":"proc/lu6chk.html"},{"title":"lu7add – AoC-2023","text":"private  subroutine lu7add(m, n, jadd, v, lena, luparm, parmlu, lenL, lenU, lrow, nrank, a, indr, p, lenr, locr, inform, klast, vnorm) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: jadd real(kind=rp), intent(inout) :: v (m) integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) integer(kind=ip), intent(inout) :: lenL integer(kind=ip), intent(inout) :: lenU integer(kind=ip), intent(inout) :: lrow integer(kind=ip), intent(in) :: nrank real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: indr (lena) integer(kind=ip), intent(in) :: p (m) integer(kind=ip), intent(inout) :: lenr (m) integer(kind=ip), intent(inout) :: locr (m) integer(kind=ip), intent(out) :: inform integer(kind=ip), intent(out) :: klast real(kind=rp), intent(out) :: vnorm Calls proc~~lu7add~~CallsGraph proc~lu7add lusol::lu7add proc~lu1rec lusol::lu1rec proc~lu7add->proc~lu1rec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~lu7add~~CalledByGraph proc~lu7add lusol::lu7add proc~lu8rpc lusol::lu8rpc proc~lu8rpc->proc~lu7add Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu7add ( m , n , jadd , v , lena , luparm , parmlu , & lenL , lenU , lrow , nrank , & a , indr , p , lenr , locr , & inform , klast , vnorm ) integer ( ip ), intent ( in ) :: m , n , jadd , lena , nrank , & p ( m ) integer ( ip ), intent ( inout ) :: luparm ( 30 ), lenL , lenU , lrow , & indr ( lena ), lenr ( m ), locr ( m ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), a ( lena ), v ( m ) integer ( ip ), intent ( out ) :: inform , klast real ( rp ), intent ( out ) :: vnorm !------------------------------------------------------------------ ! lu7add  inserts the first nrank elements of the vector v(*) ! as column jadd of U.  We assume that U does not yet have any ! entries in this column. ! Elements no larger than parmlu(3) are treated as zero. ! klast  will be set so that the last row to be affected ! (in pivotal order) is row p(klast). ! ! 09 May 1988: First f77 version. ! 13 Dec 2011: First f90 version. ! 20 Dec 2015: ilast is now output by lu1rec. !------------------------------------------------------------------ integer ( ip ) :: i , ilast , j , k , leni , l , lr1 , lr2 , minfre , nfree real ( rp ) :: small small = parmlu ( 3 ) vnorm = zero klast = 0 do k = 1 , nrank i = p ( k ) if ( abs ( v ( i )) <= small ) cycle klast = k vnorm = vnorm + abs ( v ( i )) leni = lenr ( i ) ! Compress row file if necessary. minfre = leni + 1 nfree = lena - lenL - lrow if ( nfree < minfre ) then call lu1rec ( m , . true ., luparm , lrow , ilast , & lena , a , indr , lenr , locr ) nfree = lena - lenL - lrow if ( nfree < minfre ) go to 970 end if ! Move row i to the end of the row file, ! unless it is already there. ! No need to move if there is a gap already. if ( leni == 0 ) locr ( i ) = lrow + 1 lr1 = locr ( i ) lr2 = lr1 + leni - 1 if ( lr2 == lrow ) go to 150 if ( indr ( lr2 + 1 ) == 0 ) go to 180 locr ( i ) = lrow + 1 do l = lr1 , lr2 lrow = lrow + 1 a ( lrow ) = a ( l ) j = indr ( l ) indr ( l ) = 0 indr ( lrow ) = j end do 150 lr2 = lrow lrow = lrow + 1 ! Add the element of  v. 180 lr2 = lr2 + 1 a ( lr2 ) = v ( i ) indr ( lr2 ) = jadd lenr ( i ) = leni + 1 lenU = lenU + 1 end do ! Normal exit. inform = 0 go to 990 ! Not enough storage. 970 inform = 7 990 return end subroutine lu7add","tags":"","loc":"proc/lu7add.html"},{"title":"lu7cyc – AoC-2023","text":"private  subroutine lu7cyc(kfirst, klast, p) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: kfirst integer(kind=ip), intent(in) :: klast integer(kind=ip), intent(inout) :: p (klast) Called by proc~~lu7cyc~~CalledByGraph proc~lu7cyc lusol::lu7cyc proc~lu8rpc lusol::lu8rpc proc~lu8rpc->proc~lu7cyc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu7cyc ( kfirst , klast , p ) integer ( ip ), intent ( in ) :: kfirst , klast integer ( ip ), intent ( inout ) :: p ( klast ) !------------------------------------------------------------------ ! lu7cyc performs a cyclic permutation on the row or column ordering ! stored in p, moving entry kfirst down to klast. ! If kfirst .ge. klast, lu7cyc should not be called. ! Sometimes klast = 0 and nothing should happen. ! ! 09 May 1988: First f77 version. ! 13 Dec 2011: First f90 version. !------------------------------------------------------------------ integer ( ip ) :: ifirst , k if ( kfirst < klast ) then ifirst = p ( kfirst ) do k = kfirst , klast - 1 p ( k ) = p ( k + 1 ) end do p ( klast ) = ifirst end if end subroutine lu7cyc","tags":"","loc":"proc/lu7cyc.html"},{"title":"lu7elm – AoC-2023","text":"private  subroutine lu7elm(m, n, jelm, v, lena, luparm, parmlu, lenL, lenU, lrow, nrank, a, indc, indr, p, q, lenr, locc, locr, inform, diag) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: jelm real(kind=rp), intent(in) :: v (m) integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) integer(kind=ip), intent(inout) :: lenL integer(kind=ip), intent(in) :: lenU integer(kind=ip), intent(inout) :: lrow integer(kind=ip), intent(in) :: nrank real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: indc (lena) integer(kind=ip), intent(inout) :: indr (lena) integer(kind=ip), intent(inout) :: p (m) integer(kind=ip), intent(in) :: q (n) integer(kind=ip), intent(inout) :: lenr (m) integer(kind=ip), intent(inout) :: locc (n) integer(kind=ip), intent(inout) :: locr (m) integer(kind=ip), intent(out) :: inform real(kind=rp), intent(out) :: diag Calls proc~~lu7elm~~CallsGraph proc~lu7elm lusol::lu7elm proc~lu1rec lusol::lu1rec proc~lu7elm->proc~lu1rec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~lu7elm~~CalledByGraph proc~lu7elm lusol::lu7elm proc~lu8rpc lusol::lu8rpc proc~lu8rpc->proc~lu7elm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu7elm ( m , n , jelm , v , lena , luparm , parmlu , & lenL , lenU , lrow , nrank , & a , indc , indr , p , q , lenr , locc , locr , & inform , diag ) integer ( ip ), intent ( in ) :: m , n , jelm , lena , nrank integer ( ip ), intent ( in ) :: lenU , q ( n ) ! not used real ( rp ), intent ( in ) :: v ( m ) integer ( ip ), intent ( inout ) :: luparm ( 30 ), lenL , lrow , & indc ( lena ), indr ( lena ), p ( m ), & lenr ( m ), locc ( n ), locr ( m ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), a ( lena ) integer ( ip ), intent ( out ) :: inform real ( rp ), intent ( out ) :: diag !------------------------------------------------------------------ ! lu7elm  eliminates the subdiagonal elements of a vector  v(*), ! where  L*v = y  for some vector y. ! If  jelm > 0,  y  has just become column  jelm  of the matrix  A. ! lu7elm  should not be called unless  m  is greater than  nrank. ! ! inform = 0 if y contained no subdiagonal nonzeros to eliminate. ! inform = 1 if y contained at least one nontrivial subdiagonal. ! inform = 7 if there is insufficient storage. ! ! 09 May 1988: First f77 version. !              No longer calls lu7for at end.  lu8rpc, lu8mod do so. ! 13 Dec 2011: First f90 version. ! 20 Dec 2015: ilast is now output by lu1rec. !------------------------------------------------------------------ integer ( ip ) :: i , ilast , imax , k , kmax , l , l1 , l2 , lmax , & minfre , nfree , nrank1 real ( rp ) :: small , vi , vmax small = parmlu ( 3 ) nrank1 = nrank + 1 diag = zero ! Compress row file if necessary. minfre = m - nrank nfree = lena - lenL - lrow if ( nfree < minfre ) then call lu1rec ( m , . true ., luparm , lrow , ilast , & lena , a , indr , lenr , locr ) nfree = lena - lenL - lrow if ( nfree < minfre ) go to 970 end if ! Pack the subdiagonals of  v  into  L,  and find the largest. vmax = zero kmax = 0 l = lena - lenL + 1 do k = nrank1 , m i = p ( k ) vi = abs ( v ( i )) if ( vi <= small ) cycle l = l - 1 a ( l ) = v ( i ) indc ( l ) = i if ( vmax >= vi ) cycle vmax = vi kmax = k lmax = l end do if ( kmax == 0 ) go to 900 !------------------------------------------------------------------ ! Remove  vmax  by overwriting it with the last packed  v(i). ! Then set the multipliers in  L  for the other elements. !------------------------------------------------------------------ imax = p ( kmax ) vmax = a ( lmax ) a ( lmax ) = a ( l ) indc ( lmax ) = indc ( l ) l1 = l + 1 l2 = lena - lenL lenL = lenL + ( l2 - l ) do l = l1 , l2 a ( l ) = - a ( l ) / vmax indr ( l ) = imax end do ! Move the row containing vmax to pivotal position nrank + 1. p ( kmax ) = p ( nrank1 ) p ( nrank1 ) = imax diag = vmax !------------------------------------------------------------------ ! If jelm is positive, insert  vmax  into a new row of  U. ! This is now the only subdiagonal element. !------------------------------------------------------------------ if ( jelm > 0 ) then lrow = lrow + 1 locr ( imax ) = lrow lenr ( imax ) = 1 a ( lrow ) = vmax indr ( lrow ) = jelm end if inform = 1 go to 990 ! No elements to eliminate. 900 inform = 0 go to 990 ! Not enough storage. 970 inform = 7 990 return end subroutine lu7elm","tags":"","loc":"proc/lu7elm.html"},{"title":"lu7for – AoC-2023","text":"private  subroutine lu7for(m, n, kfirst, klast, lena, luparm, parmlu, lenL, lenU, lrow, a, indc, indr, p, q, lenr, locc, locr, inform, diag) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: kfirst integer(kind=ip), intent(in) :: klast integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) integer(kind=ip), intent(inout) :: lenL integer(kind=ip), intent(inout) :: lenU integer(kind=ip), intent(inout) :: lrow real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: indc (lena) integer(kind=ip), intent(inout) :: indr (lena) integer(kind=ip), intent(inout) :: p (m) integer(kind=ip), intent(in) :: q (n) integer(kind=ip), intent(inout) :: lenr (m) integer(kind=ip), intent(inout) :: locc (n) integer(kind=ip), intent(inout) :: locr (m) integer(kind=ip), intent(out) :: inform real(kind=rp), intent(out) :: diag Calls proc~~lu7for~~CallsGraph proc~lu7for lusol::lu7for proc~lu1rec lusol::lu1rec proc~lu7for->proc~lu1rec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~lu7for~~CalledByGraph proc~lu7for lusol::lu7for proc~lu8rpc lusol::lu8rpc proc~lu8rpc->proc~lu7for Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu7for ( m , n , kfirst , klast , lena , luparm , parmlu , & lenL , lenU , lrow , & a , indc , indr , p , q , lenr , locc , locr , & inform , diag ) integer ( ip ), intent ( in ) :: m , n , kfirst , klast , lena integer ( ip ), intent ( in ) :: q ( n ) integer ( ip ), intent ( inout ) :: luparm ( 30 ), lenL , lenU , lrow integer ( ip ), intent ( inout ) :: indc ( lena ), indr ( lena ), & p ( m ), lenr ( m ), locc ( n ), locr ( m ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), a ( lena ) integer ( ip ), intent ( out ) :: inform real ( rp ), intent ( out ) :: diag !------------------------------------------------------------------ ! lu7for  (forward sweep) updates the LU factorization A = L*U ! when row iw = p(klast) of U is eliminated by a forward ! sweep of stabilized row operations, leaving p*U*q upper triangular. ! ! The row permutation p is updated to preserve stability and/or ! sparsity.  The column permutation q is not altered. ! ! kfirst  is such that row p(kfirst) is the first row involved ! in eliminating row  iw.  (Hence,  kfirst  marks the first nonzero ! in row  iw  in pivotal order.)  If  kfirst  is unknown it may be ! input as  1. ! ! klast   is such that row p(klast) is the row being eliminated. ! klast   is not altered. ! ! lu7for  should be called only if  kfirst .le. klast. ! If  kfirst = klast,  there are no nonzeros to eliminate, but the ! diagonal element of row p(klast) may need to be moved to the ! front of the row. ! ! On entry,  locc(*)  must be zero. ! ! On exit: ! inform = 0  if row iw has a nonzero diagonal (could be small). ! inform = 1  if row iw has no diagonal. ! inform = 7  if there is not enough storage to finish the update. ! ! On a successful exit (inform le 1),  locc(*)  will again be zero. ! !    Jan 1985: Final f66 version. ! 09 May 1988: First f77 version. ! 13 Dec 2011: First f90 version. ! 20 Dec 2015: ilast is now output by lu1rec. !------------------------------------------------------------------ logical :: swappd integer ( ip ) :: ilast , iv , iw , j , jfirst , jlast , jv , & k , kbegin , kstart , kstop , & l , ldiag , lenv , lenw , lfirst , limit , & lv , lv1 , lv2 , lv3 , lw , lw1 , lw2 , & minfre , nfree real ( rp ) :: amult , Ltol , Uspace , small , vj , wj Ltol = parmlu ( 2 ) small = parmlu ( 3 ) Uspace = parmlu ( 6 ) kbegin = kfirst swappd = . false . ! We come back here from below if a row interchange is performed. 100 iw = p ( klast ) lenw = lenr ( iw ) if ( lenw == 0 ) go to 910 lw1 = locr ( iw ) lw2 = lw1 + lenw - 1 jfirst = q ( kbegin ) if ( kbegin >= klast ) go to 700 ! Make sure there is room at the end of the row file ! in case row  iw  is moved there and fills in completely. minfre = n + 1 nfree = lena - lenL - lrow if ( nfree < minfre ) then call lu1rec ( m , . true ., luparm , lrow , ilast , & lena , a , indr , lenr , locr ) lw1 = locr ( iw ) lw2 = lw1 + lenw - 1 nfree = lena - lenL - lrow if ( nfree < minfre ) go to 970 end if ! Set markers on row iw. do l = lw1 , lw2 j = indr ( l ) locc ( j ) = l end do !================================================================== ! Main elimination loop. !================================================================== kstart = kbegin kstop = min ( klast , n ) do k = kstart , kstop jfirst = q ( k ) lfirst = locc ( jfirst ) if ( lfirst == 0 ) go to 490 ! Row  iw  has its first element in column  jfirst. wj = a ( lfirst ) if ( k == klast ) go to 490 !--------------------------------------------------------------- ! We are about to use the first element of row iv ! to eliminate the first element of row iw. ! However, we may wish to interchange the rows instead, ! to preserve stability and/or sparsity. !--------------------------------------------------------------- iv = p ( k ) lenv = lenr ( iv ) lv1 = locr ( iv ) vj = zero if ( lenv == 0 ) go to 150 if ( indr ( lv1 ) /= jfirst ) go to 150 vj = a ( lv1 ) if ( swappd ) go to 200 if ( Ltol * abs ( wj ) < abs ( vj )) go to 200 if ( Ltol * abs ( vj ) < abs ( wj )) go to 150 if ( lenv <= lenw ) go to 200 !--------------------------------------------------------------- ! Interchange rows iv and iw. !--------------------------------------------------------------- 150 p ( klast ) = iv p ( k ) = iw kbegin = k swappd = . true . go to 600 !--------------------------------------------------------------- ! Delete the eliminated element from row iw ! by overwriting it with the last element. !--------------------------------------------------------------- 200 a ( lfirst ) = a ( lw2 ) jlast = indr ( lw2 ) indr ( lfirst ) = jlast indr ( lw2 ) = 0 locc ( jlast ) = lfirst locc ( jfirst ) = 0 lenw = lenw - 1 lenU = lenU - 1 if ( lrow == lw2 ) lrow = lrow - 1 lw2 = lw2 - 1 !--------------------------------------------------------------- ! Form the multiplier and store it in the L file. !--------------------------------------------------------------- if ( abs ( wj ) <= small ) go to 490 amult = - wj / vj l = lena - lenL a ( l ) = amult indr ( l ) = iv indc ( l ) = iw lenL = lenL + 1 !--------------------------------------------------------------- ! Add the appropriate multiple of row iv to row iw. ! We use two different inner loops.  The first one is for the ! case where row iw is not at the end of storage. !--------------------------------------------------------------- if ( lenv == 1 ) go to 490 lv2 = lv1 + 1 lv3 = lv1 + lenv - 1 if ( lw2 == lrow ) go to 400 !............................................................... ! This inner loop will be interrupted only if ! fill-in occurs enough to bump into the next row. !............................................................... do lv = lv2 , lv3 jv = indr ( lv ) lw = locc ( jv ) if ( lw > 0 ) then ! No fill-in. a ( lw ) = a ( lw ) + amult * a ( lv ) if ( abs ( a ( lw )) <= small ) then ! Delete small computed element. a ( lw ) = a ( lw2 ) j = indr ( lw2 ) indr ( lw ) = j indr ( lw2 ) = 0 locc ( j ) = lw locc ( jv ) = 0 lenU = lenU - 1 lenw = lenw - 1 lw2 = lw2 - 1 end if else ! Row iw doesn't have an element in column jv yet ! so there is a fill-in. if ( indr ( lw2 + 1 ) /= 0 ) go to 360 lenU = lenU + 1 lenw = lenw + 1 lw2 = lw2 + 1 a ( lw2 ) = amult * a ( lv ) indr ( lw2 ) = jv locc ( jv ) = lw2 end if end do go to 490 ! Fill-in interrupted the previous loop. ! Move row  iw  to the end of the row file. 360 lv2 = lv locr ( iw ) = lrow + 1 do l = lw1 , lw2 lrow = lrow + 1 a ( lrow ) = a ( l ) j = indr ( l ) indr ( l ) = 0 indr ( lrow ) = j locc ( j ) = lrow end do lw1 = locr ( iw ) lw2 = lrow !............................................................... ! Inner loop with row iw at the end of storage. !............................................................... 400 do lv = lv2 , lv3 jv = indr ( lv ) lw = locc ( jv ) if ( lw > 0 ) then ! No fill-in a ( lw ) = a ( lw ) + amult * a ( lv ) if ( abs ( a ( lw )) <= small ) then ! Delete small computed element a ( lw ) = a ( lw2 ) j = indr ( lw2 ) indr ( lw ) = j indr ( lw2 ) = 0 locc ( j ) = lw locc ( jv ) = 0 lenU = lenU - 1 lenw = lenw - 1 lw2 = lw2 - 1 end if else ! Row iw doesn't have an element in column jv yet ! so there is a fill-in lenU = lenU + 1 lenw = lenw + 1 lw2 = lw2 + 1 a ( lw2 ) = amult * a ( lv ) indr ( lw2 ) = jv locc ( jv ) = lw2 end if end do lrow = lw2 ! The k-th element of row iw has been processed. ! Reset swappd before looking at the next element. 490 swappd = . false . end do !================================================================= ! End of main elimination loop. !================================================================== ! Cancel markers on row iw. 600 lenr ( iw ) = lenw if ( lenw == 0 ) go to 910 do l = lw1 , lw2 j = indr ( l ) locc ( j ) = 0 end do ! Move the diagonal element to the front of row iw. ! At this stage, lenw > 0 and klast <= n. 700 do l = lw1 , lw2 ldiag = l if ( indr ( l ) == jfirst ) go to 730 ! not exit !!! end do go to 910 730 diag = a ( ldiag ) a ( ldiag ) = a ( lw1 ) a ( lw1 ) = diag indr ( ldiag ) = indr ( lw1 ) indr ( lw1 ) = jfirst ! If an interchange is needed, repeat from the beginning with the ! new row iw, knowing that the opposite interchange cannot occur. if ( swappd ) go to 100 inform = 0 go to 950 ! Singular 910 diag = zero inform = 1 ! Force a compression if the file for U is much longer than the ! no. of nonzeros in U (i.e. if lrow is much bigger than lenU). ! This should prevent memory fragmentation when there is far more ! memory than necessary (i.e. when lena is huge). 950 limit = int ( Uspace * real ( lenU )) + m + n + 1000 if ( lrow > limit ) then call lu1rec ( m , . true ., luparm , lrow , ilast , & lena , a , indr , lenr , locr ) end if go to 990 ! Not enough storage. 970 inform = 7 ! Exit. 990 return end subroutine lu7for","tags":"","loc":"proc/lu7for.html"},{"title":"lu7rnk – AoC-2023","text":"private  subroutine lu7rnk(m, n, jsing, lena, parmlu, lenL, lenU, lrow, nrank, a, indc, indr, p, q, lenr, locc, locr, inform, diag) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: jsing integer(kind=ip), intent(in) :: lena real(kind=rp), intent(inout) :: parmlu (30) integer(kind=ip), intent(inout) :: lenL integer(kind=ip), intent(inout) :: lenU integer(kind=ip), intent(inout) :: lrow integer(kind=ip), intent(inout) :: nrank real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: indc (lena) integer(kind=ip), intent(inout) :: indr (lena) integer(kind=ip), intent(in) :: p (m) integer(kind=ip), intent(inout) :: q (n) integer(kind=ip), intent(inout) :: lenr (m) integer(kind=ip), intent(inout) :: locc (n) integer(kind=ip), intent(inout) :: locr (m) integer(kind=ip), intent(out) :: inform real(kind=rp), intent(out) :: diag Called by proc~~lu7rnk~~CalledByGraph proc~lu7rnk lusol::lu7rnk proc~lu8rpc lusol::lu8rpc proc~lu8rpc->proc~lu7rnk Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu7rnk ( m , n , jsing , lena , parmlu , & lenL , lenU , lrow , nrank , & a , indc , indr , p , q , lenr , locc , locr , & inform , diag ) integer ( ip ), intent ( in ) :: m , n , jsing , lena , & p ( m ) integer ( ip ), intent ( inout ) :: lenL , lenU , lrow , nrank , & indc ( lena ), indr ( lena ), q ( n ), & lenr ( m ), locc ( n ), locr ( m ) real ( rp ), intent ( inout ) :: parmlu ( 30 ) ! not used real ( rp ), intent ( inout ) :: a ( lena ) integer ( ip ), intent ( out ) :: inform real ( rp ), intent ( out ) :: diag !------------------------------------------------------------------ ! lu7rnk (check rank) assumes U is currently nrank by n ! and determines if row nrank contains an acceptable pivot. ! If not, the row is deleted and nrank is decreased by 1. ! jsing is an input parameter (not altered).  If jsing is positive, ! column jsing has already been judged dependent.  A substitute ! (if any) must be some other column. ! ! On exit, ! inform = -1 if nrank decreases by 1 !        =  0 if nrank stays the same !        =  1 if there's a fatal error.  (Currently we stop.) ! ! -- Jul 1987: First version. ! 09 May 1988: First f77 version. ! 13 Dec 2011: First f90 version. ! 01 Jan 2012: luparm not used. !------------------------------------------------------------------ integer ( ip ) :: iw , jmax , kmax , l , l1 , l2 , lenw , lmax real ( rp ) :: Umax , Utol1 Utol1 = parmlu ( 4 ) diag = zero ! Find Umax, the largest element in row nrank. iw = p ( nrank ) lenw = lenr ( iw ) if ( lenw == 0 ) go to 400 l1 = locr ( iw ) l2 = l1 + lenw - 1 Umax = zero lmax = l1 do l = l1 , l2 if ( Umax < abs ( a ( l ))) then Umax = abs ( a ( l )) lmax = l end if end do ! Find which column that guy is in (in pivotal order). ! Interchange him with column nrank, then move him to be ! the new diagonal at the front of row nrank. diag = a ( lmax ) jmax = indr ( lmax ) l = 0 do kmax = nrank , n if ( q ( kmax ) == jmax ) then l = kmax ! l allows check below for fatal error exit end if end do if ( l == 0 ) go to 800 ! Fatal error q ( kmax ) = q ( nrank ) q ( nrank ) = jmax a ( lmax ) = a ( l1 ) a ( l1 ) = diag indr ( lmax ) = indr ( l1 ) indr ( l1 ) = jmax ! See if the new diagonal is big enough. if ( Umax <= Utol1 ) go to 400 if ( jmax == jsing ) go to 400 !------------------------------------------------------------------ ! The rank stays the same. !------------------------------------------------------------------ inform = 0 go to 900 !------------------------------------------------------------------ ! The rank decreases by one. !------------------------------------------------------------------ 400 inform = - 1 nrank = nrank - 1 if ( lenw > 0 ) then ! Delete row nrank from U. lenU = lenU - lenw lenr ( iw ) = 0 do l = l1 , l2 indr ( l ) = 0 end do if ( l2 == lrow ) then ! This row was at the end of the data structure. ! We have to reset lrow. ! Preceding rows might already have been deleted, so we ! have to be prepared to go all the way back to 1. do l = 1 , l2 if ( indr ( lrow ) > 0 ) go to 900 lrow = lrow - 1 end do end if end if go to 900 ! 15 Dec 2011: Fatal error (should never happen!). ! This is a safeguard during work on the f90 version. 800 inform = 1 write ( * , * ) 'Fatal error in LUSOL lu7rnk.  Stopping now' stop 900 return end subroutine lu7rnk","tags":"","loc":"proc/lu7rnk.html"},{"title":"lu7zap – AoC-2023","text":"private  subroutine lu7zap(m, n, jzap, kzap, lena, lenU, lrow, nrank, a, indr, p, q, lenr, locr) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: jzap integer(kind=ip), intent(out) :: kzap integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: lenU integer(kind=ip), intent(inout) :: lrow integer(kind=ip), intent(in) :: nrank real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: indr (lena) integer(kind=ip), intent(in) :: p (m) integer(kind=ip), intent(inout) :: q (n) integer(kind=ip), intent(inout) :: lenr (m) integer(kind=ip), intent(inout) :: locr (m) Called by proc~~lu7zap~~CalledByGraph proc~lu7zap lusol::lu7zap proc~lu8rpc lusol::lu8rpc proc~lu8rpc->proc~lu7zap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu7zap ( m , n , jzap , kzap , lena , lenU , lrow , nrank , & a , indr , p , q , lenr , locr ) integer ( ip ), intent ( in ) :: m , n , jzap , lena , nrank , & p ( m ) integer ( ip ), intent ( inout ) :: lenU , lrow , & indr ( lena ), q ( n ), lenr ( m ), locr ( m ) real ( rp ), intent ( inout ) :: a ( lena ) integer ( ip ), intent ( out ) :: kzap !------------------------------------------------------------------ ! lu7zap  eliminates all nonzeros in column  jzap  of  U. ! It also sets  kzap  to the position of  jzap  in pivotal order. ! Thus, on exit we have  q(kzap) = jzap. ! ! -- Jul 1987: nrank added. ! 10 May 1988: First f77 version. ! 13 Dec 2011: First f90 version. !------------------------------------------------------------------ integer ( ip ) :: i , k , leni , l , lr1 , lr2 do k = 1 , nrank i = p ( k ) leni = lenr ( i ) if ( leni == 0 ) go to 90 lr1 = locr ( i ) lr2 = lr1 + leni - 1 do l = lr1 , lr2 if ( indr ( l ) == jzap ) go to 60 end do go to 90 ! Delete the old element. 60 a ( l ) = a ( lr2 ) indr ( l ) = indr ( lr2 ) indr ( lr2 ) = 0 lenr ( i ) = leni - 1 lenU = lenU - 1 ! Stop if we know there are no more rows containing  jzap. 90 kzap = k if ( q ( k ) == jzap ) go to 800 end do ! nrank must be smaller than n because we haven't found kzap yet. do k = nrank + 1 , n kzap = k if ( q ( k ) == jzap ) exit end do ! See if we zapped the last element in the file. 800 if ( lrow > 0 ) then if ( indr ( lrow ) == 0 ) lrow = lrow - 1 end if end subroutine lu7zap","tags":"","loc":"proc/lu7zap.html"},{"title":"lu8rpc – AoC-2023","text":"public  subroutine lu8rpc(mode1, mode2, m, n, jrep, v, w, lena, luparm, parmlu, a, indc, indr, p, q, lenc, lenr, locc, locr, inform, diag, vnorm) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: mode1 integer(kind=ip), intent(in) :: mode2 integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: jrep real(kind=rp), intent(inout) :: v (m) real(kind=rp), intent(inout) :: w (n) integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: indc (lena) integer(kind=ip), intent(inout) :: indr (lena) integer(kind=ip), intent(inout) :: p (m) integer(kind=ip), intent(inout) :: q (n) integer(kind=ip), intent(inout) :: lenc (n) integer(kind=ip), intent(inout) :: lenr (m) integer(kind=ip), intent(inout) :: locc (n) integer(kind=ip), intent(inout) :: locr (m) integer(kind=ip), intent(out) :: inform real(kind=rp), intent(out) :: diag real(kind=rp), intent(out) :: vnorm Calls proc~~lu8rpc~~CallsGraph proc~lu8rpc lusol::lu8rpc proc~lu6sol lusol::lu6sol proc~lu8rpc->proc~lu6sol proc~lu7add lusol::lu7add proc~lu8rpc->proc~lu7add proc~lu7cyc lusol::lu7cyc proc~lu8rpc->proc~lu7cyc proc~lu7elm lusol::lu7elm proc~lu8rpc->proc~lu7elm proc~lu7for lusol::lu7for proc~lu8rpc->proc~lu7for proc~lu7rnk lusol::lu7rnk proc~lu8rpc->proc~lu7rnk proc~lu7zap lusol::lu7zap proc~lu8rpc->proc~lu7zap proc~lu6l lusol::lu6L proc~lu6sol->proc~lu6l proc~lu6ld lusol::lu6LD proc~lu6sol->proc~lu6ld proc~lu6lt lusol::lu6Lt proc~lu6sol->proc~lu6lt proc~lu6u lusol::lu6U proc~lu6sol->proc~lu6u proc~lu6ut lusol::lu6Ut proc~lu6sol->proc~lu6ut proc~lu1rec lusol::lu1rec proc~lu7add->proc~lu1rec proc~lu7elm->proc~lu1rec proc~lu7for->proc~lu1rec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lu8rpc ( mode1 , mode2 , m , n , jrep , v , w , & lena , luparm , parmlu , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & inform , diag , vnorm ) integer ( ip ), intent ( in ) :: mode1 , mode2 , m , n , jrep , lena integer ( ip ), intent ( inout ) :: luparm ( 30 ), & indc ( lena ), indr ( lena ), p ( m ), q ( n ), & lenc ( n ), lenr ( m ), locc ( n ), locr ( m ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), a ( lena ), v ( m ), & w ( n ) ! not used integer ( ip ), intent ( out ) :: inform real ( rp ), intent ( out ) :: diag , vnorm !------------------------------------------------------------------ ! lu8rpc  updates the LU factorization A = L*U when column jrep ! is replaced by some vector v = a(new). ! ! lu8rpc  is an implementation of the Bartels-Golub update, ! designed for the case where A is rectangular and/or singular. ! L is a product of stabilized eliminations (m x m, nonsingular). ! P U Q is upper trapezoidal (m x n, rank nrank). ! ! If  mode1 = 0,  the old column is taken to be zero ! (so it does not have to be removed from U). ! ! If  mode1 = 1,  the old column need not have been zero. ! ! If  mode2 = 0,  the new column is taken to be zero. !                 v(*) is not used or altered. ! ! If  mode2 = 1,  v(*) must contain the new column a(new). ! On exit,  v(*)  will satisfy L*v = a(new). ! ! If  mode2 = 2,  v(*) must satisfy L*v = a(new). ! ! The array w(*) is not used or altered. ! ! On entry, all elements of locc are assumed to be zero. ! On a successful exit (inform /= 7), this will again be true. ! ! On exit: ! inform = -1  if the rank of U decreased by 1. ! inform =  0  if the rank of U stayed the same. ! inform =  1  if the rank of U increased by 1. ! inform =  2  if the update seemed to be unstable !              (diag much bigger than vnorm). ! inform =  7  if the update was not completed (lack of storage). ! inform =  8  if jrep is not between 1 and n. ! ! -- Jan 1985: Original F66 version. ! -- Jul 1987: Modified to maintain U in trapezoidal form. ! 10 May 1988: First f77 version. ! 16 Oct 2000: Added test for instability (inform = 2). ! 13 Dec 2011: First f90 version. !------------------------------------------------------------------ logical :: singlr integer ( ip ) :: iw , j1 , jsing , klast , krep , & l1 , lenL , lenU , lprint , lrow , nout , nrank , nrank0 real ( rp ) :: Utol1 , Utol2 nout = luparm ( 1 ) lprint = luparm ( 2 ) nrank = luparm ( 16 ) lenL = luparm ( 23 ) lenU = luparm ( 24 ) lrow = luparm ( 25 ) Utol1 = parmlu ( 4 ) Utol2 = parmlu ( 5 ) nrank0 = nrank diag = zero vnorm = zero if ( jrep < 1 ) go to 980 if ( jrep > n ) go to 980 !------------------------------------------------------------------ ! If mode1 = 0, there are no elements to be removed from  U ! but we still have to set  krep  (using a backward loop). ! Otherwise, use lu7zap to remove column  jrep  from  U ! and set  krep  at the same time. !------------------------------------------------------------------ if ( mode1 == 0 ) then krep = n + 1 10 krep = krep - 1 if ( q ( krep ) /= jrep ) go to 10 else call lu7zap ( m , n , jrep , krep , lena , lenU , lrow , nrank , & a , indr , p , q , lenr , locr ) end if !------------------------------------------------------------------ ! Insert a new column of u and find klast. !------------------------------------------------------------------ if ( mode2 == 0 ) then klast = 0 else if ( mode2 == 1 ) then ! Transform v = a(new) to satisfy  L*v = a(new). call lu6sol ( i1 , m , n , v , w , lena , luparm , parmlu , & a , indc , indr , p , q , & lenc , lenr , locc , locr , inform ) end if ! Insert into U any nonzeros in the top of v. ! row p(klast) will contain the last nonzero in pivotal order. ! Note that klast will be in the range ( 0, nrank ). call lu7add ( m , n , jrep , v , & lena , luparm , parmlu , & lenL , lenU , lrow , nrank , & a , indr , p , lenr , locr , & inform , klast , vnorm ) if ( inform == 7 ) go to 970 end if !------------------------------------------------------------------ ! In general, the new column causes U to look like this: ! !                 krep        n                 krep  n ! !                ....a.........          ..........a... !                 .  a        .           .        a  . !                  . a        .            .       a  . !                   .a        .             .      a  . !        P U Q =     a        .    or        .     a  . !                    b.       .               .    a  . !                    b .      .                .   a  . !                    b  .     .                 .  a  . !                    b   ......                  ..a...  nrank !                    c                             c !                    c                             c !                    c                             c     m ! !     klast points to the last nonzero \"a\" or \"b\". !     klast = 0 means all \"a\" and \"b\" entries are zero. !------------------------------------------------------------------ if ( mode2 == 0 ) then if ( krep > nrank ) go to 900 else if ( nrank < m ) then ! Eliminate any \"c\"s (in either case). ! Row nrank + 1 may end up containing one nonzero. call lu7elm ( m , n , jrep , v , lena , luparm , parmlu , & lenL , lenU , lrow , nrank , & a , indc , indr , p , q , lenr , locc , locr , & inform , diag ) if ( inform == 7 ) go to 970 if ( inform == 1 ) then ! The nonzero is apparently significant. ! Increase nrank by 1 and make klast point to the bottom. nrank = nrank + 1 klast = nrank end if end if if ( nrank < n ) then ! The column rank is low. ! ! In the first case, we want the new column to end up in ! position nrank, so the trapezoidal columns will have a chance ! later on (in lu7rnk) to pivot in that position. ! ! Otherwise the new column is not part of the triangle.  We ! swap it into position nrank so we can judge it for singularity. ! lu7rnk might choose some other trapezoidal column later. if ( krep < nrank ) then klast = nrank else q ( krep ) = q ( nrank ) q ( nrank ) = jrep krep = nrank end if end if !------------------------------------------------------------------ ! If krep < klast, there are some \"b\"s to eliminate: ! !                  krep ! !                ....a......... !                 .  a        . !                  . a        . !                   .a        . !        P U Q =     a        .  krep !                    b.       . !                    b .      . !                    b  .     . !                    b   ......  nrank ! !     If krep == klast, there are no \"b\"s, but the last \"a\" still !     has to be moved to the front of row krep (by lu7for). !------------------------------------------------------------------ if ( krep <= klast ) then ! Perform a cyclic permutation on the current pivotal order, ! and eliminate the resulting row spike.  krep becomes klast. ! The final diagonal (if any) will be correctly positioned at ! the front of the new krep-th row.  nrank stays the same. call lu7cyc ( krep , klast , p ) call lu7cyc ( krep , klast , q ) call lu7for ( m , n , krep , klast , & lena , luparm , parmlu , & lenL , lenU , lrow , & a , indc , indr , p , q , lenr , locc , locr , & inform , diag ) if ( inform == 7 ) go to 970 krep = klast ! Test for instability (diag much bigger than vnorm). singlr = vnorm < Utol2 * abs ( diag ) if ( singlr ) go to 920 end if !------------------------------------------------------------------ ! Test for singularity in column krep (where krep .le. nrank). !------------------------------------------------------------------ diag = zero iw = p ( krep ) singlr = lenr ( iw ) == 0 if (. not . singlr ) then l1 = locr ( iw ) j1 = indr ( l1 ) singlr = j1 /= jrep if (. not . singlr ) then diag = a ( l1 ) singlr = abs ( diag ) <= Utol1 . or . & abs ( diag ) <= Utol2 * vnorm end if end if if ( singlr . and . krep < nrank ) then ! Perform cyclic permutations to move column jrep to the end. ! Move the corresponding row to position nrank ! then eliminate the resulting row spike. call lu7cyc ( krep , nrank , p ) call lu7cyc ( krep , n , q ) call lu7for ( m , n , krep , nrank , & lena , luparm , parmlu , & lenL , lenU , lrow , & a , indc , indr , p , q , lenr , locc , locr , & inform , diag ) if ( inform == 7 ) go to 970 end if ! Find the best column to be in position nrank. ! If singlr, it can't be the new column, jrep. ! If nothing satisfactory exists, nrank will be decreased. if ( singlr . or . nrank < n ) then jsing = 0 if ( singlr ) jsing = jrep call lu7rnk ( m , n , jsing , lena , parmlu , & lenL , lenU , lrow , nrank , & a , indc , indr , p , q , lenr , locc , locr , & inform , diag ) end if !------------------------------------------------------------------ ! Set inform for exit. !------------------------------------------------------------------ 900 if ( nrank == nrank0 ) then inform = 0 else if ( nrank < nrank0 ) then inform = - 1 if ( nrank0 == n ) then if ( nout > 0 . and . lprint >= 0 ) write ( nout , 1100 ) jrep , diag end if else inform = 1 end if go to 990 ! Instability. 920 inform = 2 if ( nout > 0 . and . lprint >= 0 ) write ( nout , 1200 ) jrep , diag go to 990 ! Not enough storage. 970 inform = 7 if ( nout > 0 . and . lprint >= 0 ) write ( nout , 1700 ) lena go to 990 ! jrep  is out of range. 980 inform = 8 if ( nout > 0 . and . lprint >= 0 ) write ( nout , 1800 ) m , n , jrep ! Exit. 990 luparm ( 10 ) = inform luparm ( 15 ) = luparm ( 15 ) + 1 luparm ( 16 ) = nrank luparm ( 23 ) = lenL luparm ( 24 ) = lenU luparm ( 25 ) = lrow return 1100 format ( / ' lu8rpc  warning.  Singularity after replacing column.' , & '    jrep =' , i8 , '    diag =' , es12 . 2 ) 1200 format ( / ' lu8rpc  warning.  Instability after replacing column.' , & '    jrep =' , i8 , '    diag =' , es12 . 2 ) 1700 format ( / ' lu8rpc  error...  Insufficient storage.' , & '    lena =' , i8 ) 1800 format ( / ' lu8rpc  error...  jrep  is out of range.' , & '    m =' , i8 , '    n =' , i8 , '    jrep =' , i8 ) end subroutine lu8rpc","tags":"","loc":"proc/lu8rpc.html"},{"title":"destination – AoC-2023","text":"pure function destination(initial, direction, steps) result(final) get destination point Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(2) :: initial character(len=1), intent(in) :: direction integer(kind=ip), intent(in) :: steps Return Value integer(kind=ip), dimension(2) x,y of desination point Called by proc~~destination~~CalledByGraph proc~destination problem_18::destination proc~go~3 problem_18::go proc~go~3->proc~destination program~problem_18 problem_18 program~problem_18->proc~go~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function destination ( initial , direction , steps ) result ( final ) !! get destination point integer ( ip ), dimension ( 2 ), intent ( in ) :: initial character ( len = 1 ), intent ( in ) :: direction integer ( ip ), intent ( in ) :: steps integer ( ip ), dimension ( 2 ) :: final !! x,y of desination point select case ( direction ) case ( 'R' ); final = [ initial ( 1 ), initial ( 2 ) + steps ] case ( 'L' ); final = [ initial ( 1 ), initial ( 2 ) - steps ] case ( 'D' ); final = [ initial ( 1 ) + steps , initial ( 2 )] case ( 'U' ); final = [ initial ( 1 ) - steps , initial ( 2 )] end select end function destination","tags":"","loc":"proc/destination.html"},{"title":"go – AoC-2023","text":"subroutine go(partb, iresult) Arguments Type Intent Optional Attributes Name logical, intent(in) :: partb if solving part b integer(kind=ip), intent(out) :: iresult Calls proc~~go~3~~CallsGraph proc~go~3 problem_18::go interface~split aoc_utilities::split proc~go~3->interface~split proc~destination problem_18::destination proc~go~3->proc~destination proc~hex2int aoc_utilities::hex2int proc~go~3->proc~hex2int proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~go~3->proc~number_of_lines_in_file proc~parea aoc_utilities::parea proc~go~3->proc~parea proc~read_line aoc_utilities::read_line proc~go~3->proc~read_line proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~go~3~~CalledByGraph proc~go~3 problem_18::go program~problem_18 problem_18 program~problem_18->proc~go~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine go ( partb , iresult ) logical , intent ( in ) :: partb !! if solving part b integer ( ip ), intent ( out ) :: iresult integer :: iunit , iline , n_lines , n character ( len = :), allocatable :: line , hex type ( string ), dimension (:), allocatable :: vals character ( len = 1 ) :: direction integer ( ip ), dimension ( 2 ) :: iloc , iloc2 integer ( ip ) :: ival , isteps real ( wp ), dimension (:), allocatable :: xvec , yvec character ( len = 1 ), dimension ( 0 : 3 ) :: direction_str = [ 'R' , 'D' , 'L' , 'U' ] ! directions for part b : 0,1,2,3 ! open(newunit=iunit, file='inputs/day18_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day18.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) iloc = [ 0 , 0 ] ! where to start isteps = 0 xvec = [ 0 ]; yvec = [ 0 ] do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ! direction, number, (hex) if ( partb ) then ! values encoded in hex hex = vals ( 3 )% str ival = hex2int ( hex ( 3 : 7 )) direction = direction_str ( int ( hex ( 8 : 8 ))) else direction = vals ( 1 )% str ival = int ( vals ( 2 )% str ) end if isteps = isteps + ival ! keep track of the total perimeter size iloc2 = destination ( iloc , direction , ival ) ! destination oint xvec = [ xvec , real ( iloc2 ( 1 ), wp )] ! save the points of the polygon yvec = [ yvec , real ( iloc2 ( 2 ), wp )] ! iloc = iloc2 ! update for next move end do close ( iunit ) ! the area including the boundary = area + 1/2 the perimeter + 1 ! using NSWC parea function! n = size ( xvec ) iresult = int ( abs ( parea ( yvec , xvec , n )) + real ( isteps , wp ) / 2_ip + 1_ip , ip ) end subroutine go","tags":"","loc":"proc/go~3.html"},{"title":"is_node – AoC-2023","text":"pure function is_node(i, j) returns true if a node is at these coordinates Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value logical Source Code pure logical function is_node ( i , j ) !! returns true if a node is at these coordinates integer ( ip ), intent ( in ) :: i , j is_node = any ( inodes == i . and . jnodes == j ) end function is_node","tags":"","loc":"proc/is_node.html"},{"title":"node_number – AoC-2023","text":"pure function node_number(i, j) returns the index of these coordinates in\nthe list of nodes (0 if it is not a node) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value integer(kind=ip) Called by proc~~node_number~~CalledByGraph proc~node_number problem_23::node_number proc~build_graph problem_23::build_graph proc~build_graph->proc~node_number proc~build_graph->proc~build_graph proc~go~4 problem_23::go proc~go~4->proc~build_graph program~problem_23 problem_23 program~problem_23->proc~go~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer ( ip ) function node_number ( i , j ) !! returns the index of these coordinates in !! the list of nodes (0 if it is not a node) integer ( ip ), intent ( in ) :: i , j integer ( ip ), dimension ( 1 ) :: iloc iloc = findloc ( inodes == i . and . jnodes == j , . true .) node_number = iloc ( 1 ) end function node_number","tags":"","loc":"proc/node_number.html"},{"title":"count_adjacent – AoC-2023","text":"pure function count_adjacent(i, j) result(icount) count the number of adjacent cells not a tree Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value integer(kind=ip) Calls proc~~count_adjacent~~CallsGraph proc~count_adjacent problem_23::count_adjacent proc~not_tree problem_23::not_tree proc~count_adjacent->proc~not_tree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~count_adjacent~~CalledByGraph proc~count_adjacent problem_23::count_adjacent proc~go~4 problem_23::go proc~go~4->proc~count_adjacent program~problem_23 problem_23 program~problem_23->proc~go~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function count_adjacent ( i , j ) result ( icount ) !! count the number of adjacent cells not a tree integer ( ip ), intent ( in ) :: i , j integer ( ip ) :: icount icount = 0 if ( i >= 1 ) icount = icount + count ([ not_tree ( i - 1 , j )]) if ( i <= nrows ) icount = icount + count ([ not_tree ( i + 1 , j )]) if ( j <= ncols ) icount = icount + count ([ not_tree ( i , j + 1 )]) if ( j >= 1 ) icount = icount + count ([ not_tree ( i , j - 1 )]) end function count_adjacent","tags":"","loc":"proc/count_adjacent.html"},{"title":"get_cell – AoC-2023","text":"pure function get_cell(i, j) result(a) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i coordinates integer(kind=ip), intent(in) :: j coordinates Return Value character(len=1) Called by proc~~get_cell~~CalledByGraph proc~get_cell problem_23::get_cell proc~build_graph problem_23::build_graph proc~build_graph->proc~get_cell proc~build_graph->proc~build_graph proc~go~4 problem_23::go proc~go~4->proc~build_graph program~problem_23 problem_23 program~problem_23->proc~go~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function get_cell ( i , j ) result ( a ) integer ( ip ), intent ( in ) :: i , j !! coordinates character ( len = 1 ) :: a if ( slopes ) then a = array ( i , j ) else a = '.' ! ignore the slopes for part b end if end function get_cell","tags":"","loc":"proc/get_cell.html"},{"title":"not_tree – AoC-2023","text":"pure function not_tree(i, j) returns true if the cell isn't a tree Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i coordinates integer(kind=ip), intent(in) :: j coordinates Return Value logical Called by proc~~not_tree~~CalledByGraph proc~not_tree problem_23::not_tree proc~count_adjacent problem_23::count_adjacent proc~count_adjacent->proc~not_tree proc~go~4 problem_23::go proc~go~4->proc~count_adjacent program~problem_23 problem_23 program~problem_23->proc~go~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function not_tree ( i , j ) !! returns true if the cell isn't a tree integer ( ip ), intent ( in ) :: i , j !! coordinates if ( i < 1 . or . i > nrows . or . j < 1 . or . j > ncols ) then not_tree = . false . ! off the board, call it a tree else not_tree = array ( i , j ) /= '#' end if end function not_tree","tags":"","loc":"proc/not_tree.html"},{"title":"go – AoC-2023","text":"subroutine go(case, filename, parta) solve the case Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: case case name for printing character(len=*), intent(in) :: filename input file to read logical, intent(in) :: parta if this is part a, then consider the slopes Calls proc~~go~4~~CallsGraph proc~go~4 problem_23::go proc~build_graph problem_23::build_graph proc~go~4->proc~build_graph proc~count_adjacent problem_23::count_adjacent proc~go~4->proc~count_adjacent proc~dijkstra problem_23::dijkstra proc~go~4->proc~dijkstra proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~go~4->proc~read_file_to_char_array proc~traverse~2 problem_23::traverse proc~go~4->proc~traverse~2 proc~build_graph->proc~build_graph proc~add_edge~2 problem_23::add_edge proc~build_graph->proc~add_edge~2 proc~get_cell problem_23::get_cell proc~build_graph->proc~get_cell proc~node_number problem_23::node_number proc~build_graph->proc~node_number proc~not_tree problem_23::not_tree proc~count_adjacent->proc~not_tree proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line proc~traverse~2->proc~traverse~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~go~4~~CalledByGraph proc~go~4 problem_23::go program~problem_23 problem_23 program~problem_23->proc~go~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine go ( case , filename , parta ) !! solve the case character ( len =* ), intent ( in ) :: case !! case name for printing character ( len =* ), intent ( in ) :: filename !! input file to read logical , intent ( in ) :: parta !! if this is part a, then consider the slopes integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: istart , iend , idist , i , j logical , parameter :: use_dijkstra = . false . !.... doesn't work yet .... don't know why ....... ! initialize: max_dist = 0 slopes = parta if ( allocated ( nodes )) deallocate ( nodes ) if ( allocated ( visited )) deallocate ( visited ) if ( allocated ( nodes_visited )) deallocate ( nodes_visited ) if ( allocated ( inodes )) deallocate ( inodes ) if ( allocated ( jnodes )) deallocate ( jnodes ) if ( allocated ( node_dist )) deallocate ( node_dist ) if ( allocated ( node_prev )) deallocate ( node_prev ) ! read the data file: array = read_file_to_char_array ( filename ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) iloc = findloc ( array ( 1 ,:), '.' ); istart = iloc ( 1 ) ! get start and end columns iloc = findloc ( array ( nrows ,:), '.' ); iend = iloc ( 1 ) ! ! identify the coordinates of all the nodes: inodes = [ 1 ] ! start node jnodes = [ istart ] do i = 1 , nrows do j = 1 , ncols if ( count_adjacent ( i , j ) >= 3 ) then inodes = [ inodes , i ] jnodes = [ jnodes , j ] end if end do end do inodes = [ inodes , nrows ] ! end node jnodes = [ jnodes , iend ] total_nodes = size ( inodes ) ! for each node, find the other nodes they are ! connected to and the distances between them (the edges) allocate ( nodes ( total_nodes )) allocate ( visited ( nrows , ncols )) do i = 1 , total_nodes visited = . false . idist = 0 call build_graph ( i , inodes ( i ), jnodes ( i ), idist , visited ) end do if ( use_dijkstra ) then !write(*,*) 'hello use_dijkstra'         ! ... something wrong here... don't get the right answer ! based on AOC 2021, Problem 15 allocate ( node_dist ( total_nodes )); node_dist = - 1 ; node_dist ( 1 ) = 0 allocate ( node_prev ( total_nodes )); node_prev = - 1 allocate ( nodes_visited ( total_nodes )); nodes_visited = . false . do iloc = maxloc ( node_dist , mask = . not . nodes_visited ) i = iloc ( 1 ) nodes_visited ( i ) = . true . if ( i == total_nodes ) exit ! we are done! !write(*,*) 'visited ', i if ( allocated ( nodes ( i )% inext )) then do j = 1 , size ( nodes ( i )% inext ) ! adjacent nodes to this one call dijkstra ( i , j ) end do end if !if (all(nodes_visited)) exit ! done end do !write(*,*) case, node_dist(size(node_dist)) ! result for this case (last node) !write(*,*) nodes_visited !write(*,*) node_dist else ! start at first, and find the longest that gets to the last. ! recursively traverse the graph. visited = . false . allocate ( nodes_visited ( total_nodes )); nodes_visited = . false . call traverse ( 1_ip , 0_ip , nodes_visited ) write ( * , * ) case , max_dist ! result for this case end if end subroutine go","tags":"","loc":"proc/go~4.html"},{"title":"dijkstra – AoC-2023","text":"subroutine dijkstra(u, inext) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: u integer(kind=ip), intent(in) :: inext Called by proc~~dijkstra~~CalledByGraph proc~dijkstra problem_23::dijkstra proc~go~4 problem_23::go proc~go~4->proc~dijkstra program~problem_23 problem_23 program~problem_23->proc~go~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dijkstra ( u , inext ) integer ( ip ), intent ( in ) :: u ! current integer ( ip ), intent ( in ) :: inext ! index in inext array of the next node integer ( ip ) :: idist associate ( next_node => nodes ( u )% inext ( inext ), & distance_to_next_node => nodes ( u )% idist ( inext )) if ( nodes_visited ( next_node )) return ! already visited this one idist = node_dist ( u ) + distance_to_next_node ! add distance from u to v if ( idist > node_dist ( next_node )) then !write(*,*) 'highest so far: ', idist node_dist ( next_node ) = idist node_prev ( next_node ) = u end if end associate end subroutine dijkstra","tags":"","loc":"proc/dijkstra.html"},{"title":"build_graph – AoC-2023","text":"recursive subroutine build_graph(node_num, i, j, idist, visited) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: node_num current node number integer(kind=ip), intent(in) :: i current position integer(kind=ip), intent(in) :: j current position integer(kind=ip), intent(in) :: idist current distance (number of steps) logical, intent(in), dimension(:,:) :: visited elements visited in this path (not counting this one) Calls proc~~build_graph~~CallsGraph proc~build_graph problem_23::build_graph proc~build_graph->proc~build_graph proc~add_edge~2 problem_23::add_edge proc~build_graph->proc~add_edge~2 proc~get_cell problem_23::get_cell proc~build_graph->proc~get_cell proc~node_number problem_23::node_number proc~build_graph->proc~node_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~build_graph~~CalledByGraph proc~build_graph problem_23::build_graph proc~build_graph->proc~build_graph proc~go~4 problem_23::go proc~go~4->proc~build_graph program~problem_23 problem_23 program~problem_23->proc~go~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine build_graph ( node_num , i , j , idist , visited ) integer ( ip ), intent ( in ) :: node_num !! current node number integer ( ip ), intent ( in ) :: i , j !! current position integer ( ip ), intent ( in ) :: idist !! current distance (number of steps) logical , dimension (:,:), intent ( in ) :: visited !! elements visited in this path (not counting this one) logical , dimension (:,:), allocatable :: tmp_visited integer ( ip ) :: child_node_num if ( i < 1 . or . i > nrows . or . j < 1 . or . j > ncols ) return if ( visited ( i , j )) return if ( array ( i , j ) == '#' ) return ! can't continue from here ! go until we hit another node child_node_num = node_number ( i , j ) if ( child_node_num > 0 . and . child_node_num /= node_num ) then ! we have reached another node call add_edge ( node_num , child_node_num , idist ) else ! continue processing this edge tmp_visited = visited !make a copy and mark this one tmp_visited ( i , j ) = . true . ! we are here now associate ( a => get_cell ( i , j )) ! paths (.), forest (#), and steep slopes (&#94;, >, v, and <). select case ( a ) case ( '.' ) ! path call build_graph ( node_num , i - 1 , j , idist + 1 , tmp_visited ) call build_graph ( node_num , i + 1 , j , idist + 1 , tmp_visited ) call build_graph ( node_num , i , j + 1 , idist + 1 , tmp_visited ) call build_graph ( node_num , i , j - 1 , idist + 1 , tmp_visited ) ! these don't have a choice, must go in these directions: case ( '&#94;' ); call build_graph ( node_num , i - 1 , j , idist + 1 , tmp_visited ) case ( 'v' ); call build_graph ( node_num , i + 1 , j , idist + 1 , tmp_visited ) case ( '>' ); call build_graph ( node_num , i , j + 1 , idist + 1 , tmp_visited ) case ( '<' ); call build_graph ( node_num , i , j - 1 , idist + 1 , tmp_visited ) end select end associate end if end subroutine build_graph","tags":"","loc":"proc/build_graph.html"},{"title":"traverse – AoC-2023","text":"recursive subroutine traverse(node_num, idist, nodes_visited) traverse the graph until we get to the end and check the max distance Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: node_num current node integer(kind=ip), intent(in) :: idist distance to get here logical, intent(in), dimension(:) :: nodes_visited Called by proc~~traverse~2~~CalledByGraph proc~traverse~2 problem_23::traverse proc~traverse~2->proc~traverse~2 proc~go~4 problem_23::go proc~go~4->proc~traverse~2 program~problem_23 problem_23 program~problem_23->proc~go~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine traverse ( node_num , idist , nodes_visited ) !! traverse the graph until we get to the end and check the max distance integer ( ip ), intent ( in ) :: node_num !! current node integer ( ip ), intent ( in ) :: idist !! distance to get here logical , dimension (:), intent ( in ) :: nodes_visited logical , dimension (:), allocatable :: tmp_nodes_visited integer :: i if ( nodes_visited ( node_num )) return ! already visited this node if ( node_num == total_nodes ) then ! reached the destination if ( idist > max_dist ) max_dist = idist ! best so far else ! are their child nodes? if ( allocated ( nodes ( node_num )% inext )) then tmp_nodes_visited = nodes_visited tmp_nodes_visited ( node_num ) = . true . ! mark this node do i = 1 , size ( nodes ( node_num )% inext ) call traverse ( nodes ( node_num )% inext ( i ), idist + nodes ( node_num )% idist ( i ), tmp_nodes_visited ) end do end if end if end subroutine traverse","tags":"","loc":"proc/traverse~2.html"},{"title":"add_edge – AoC-2023","text":"subroutine add_edge(inode, ichild, idist) add an edge to this node (path to another node with the specified distance) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: inode integer(kind=ip), intent(in) :: ichild integer(kind=ip), intent(in) :: idist Called by proc~~add_edge~2~~CalledByGraph proc~add_edge~2 problem_23::add_edge proc~build_graph problem_23::build_graph proc~build_graph->proc~add_edge~2 proc~build_graph->proc~build_graph proc~go~4 problem_23::go proc~go~4->proc~build_graph program~problem_23 problem_23 program~problem_23->proc~go~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine add_edge ( inode , ichild , idist ) !! add an edge to this node (path to another node with the specified distance) integer ( ip ), intent ( in ) :: inode , ichild , idist if (. not . allocated ( nodes ( inode )% inext )) then allocate ( nodes ( inode )% inext ( 0 )) allocate ( nodes ( inode )% idist ( 0 )) end if nodes ( inode )% inext = [ nodes ( inode )% inext , ichild ] nodes ( inode )% idist = [ nodes ( inode )% idist , idist ] end subroutine add_edge","tags":"","loc":"proc/add_edge~2.html"},{"title":"go – AoC-2023","text":"recursive function go(ipattern, ints) result(ival) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ipattern integer(kind=ip), intent(in), dimension(:) :: ints Return Value integer(kind=ip) Calls proc~~go~5~~CallsGraph proc~go~5 problem_12b::go proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~go~5->proc~get_from_cache~2 proc~ipoint problem_12b::ipoint proc~go~5->proc~ipoint proc~ipound problem_12b::ipound proc~go~5->proc~ipound proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~go~5->proc~put_in_cache~2 proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 proc~ipoint->proc~go~5 proc~ipound->proc~go~5 ints_tmp ints_tmp proc~ipound->ints_tmp ipattern_tmp ipattern_tmp proc~ipound->ipattern_tmp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~go~5~~CalledByGraph proc~go~5 problem_12b::go proc~ipoint problem_12b::ipoint proc~go~5->proc~ipoint proc~ipound problem_12b::ipound proc~go~5->proc~ipound proc~ipoint->proc~go~5 proc~ipound->proc~go~5 program~problem_12b problem_12b program~problem_12b->proc~go~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive function go ( ipattern , ints ) result ( ival ) integer ( ip ), dimension (:), intent ( in ) :: ipattern integer ( ip ), dimension (:), intent ( in ) :: ints integer ( ip ) :: ival integer ( ip ), dimension (:), allocatable :: ival_vec integer ( ip ) :: idx logical :: found ! first check the cache: call cache % get ([ ipattern , ints ], idx , ival_vec , found ) if ( found ) then ival = ival_vec ( 1 ) else if ( size ( ints ) == 0 ) then ! no more ints ival = merge ( 0 , 1 , any ( ipattern == NUMBER )) ! if any more numbers, invalid else if ( size ( ipattern ) == 0 ) then ival = 0 ! too many ints else ! process next element in pattern select case ( ipattern ( 1 )) case ( NUMBER ); ival = ipound ( ipattern , ints ) case ( POINT ); ival = ipoint ( ipattern , ints ) case ( QUESTION ); ival = ipoint ( ipattern , ints ) + ipound ( ipattern , ints ) end select end if ! cache this function call: ival_vec = [ ival ] call cache % put ( idx ,[ ipattern , ints ], ival_vec ) end if end function go","tags":"","loc":"proc/go~5.html"},{"title":"ipound – AoC-2023","text":"recursive function ipound(ipattern, ints) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ipattern first char is a # integer(kind=ip), intent(in), dimension(:) :: ints Return Value integer(kind=ip) Calls proc~~ipound~~CallsGraph proc~ipound problem_12b::ipound ints_tmp ints_tmp proc~ipound->ints_tmp ipattern_tmp ipattern_tmp proc~ipound->ipattern_tmp proc~go~5 problem_12b::go proc~ipound->proc~go~5 proc~go~5->proc~ipound proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~go~5->proc~get_from_cache~2 proc~ipoint problem_12b::ipoint proc~go~5->proc~ipoint proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~go~5->proc~put_in_cache~2 proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 proc~ipoint->proc~go~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ipound~~CalledByGraph proc~ipound problem_12b::ipound proc~go~5 problem_12b::go proc~ipound->proc~go~5 proc~go~5->proc~ipound proc~ipoint problem_12b::ipoint proc~go~5->proc~ipoint proc~ipoint->proc~go~5 program~problem_12b problem_12b program~problem_12b->proc~go~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive integer ( ip ) function ipound ( ipattern , ints ) integer ( ip ), dimension (:), intent ( in ) :: ipattern !! first char is a # integer ( ip ), dimension (:), intent ( in ) :: ints integer ( ip ), dimension (:), allocatable :: this_group ! check for the number of # that correspond to the first group if ( size ( ipattern ) >= ints ( 1 )) then this_group = ipattern ( 1 : ints ( 1 )) where ( this_group == QUESTION ) this_group = NUMBER ! replace ? with # if ( any ( this_group /= NUMBER )) then ! can't fit all the #'s so not valid ipound = 0 return else ! so far so good end if else ! not enough room to hold all the #'s ipound = 0 return end if if ( size ( ipattern ) == ints ( 1 )) then ! if this is the last group, then we are done ipound = merge ( 1 , 0 , size ( ints ) == 1 ) else ! the next character after this number must be a ? or . if ( size ( ipattern ) >= ints ( 1 ) + 1 ) then if ( any ( ipattern ( ints ( 1 ) + 1 ) == [ QUESTION , POINT ])) then block integer ( ip ), dimension (:), allocatable :: ipattern_tmp , ints_tmp ! to handle edge cases ! skip it and process the next group if ( size ( ipattern ) >= ints ( 1 ) + 2 ) then ipattern_tmp = ipattern ( ints ( 1 ) + 2 :) else allocate ( ipattern_tmp ( 0 )) end if if ( size ( ints ) >= 2 ) then ints_tmp = ints ( 2 :) else allocate ( ints_tmp ( 0 )) end if ipound = go ( ipattern_tmp , ints_tmp ) return end block end if end if ! not valid at this point ipound = 0 end if end function ipound","tags":"","loc":"proc/ipound.html"},{"title":"ipoint – AoC-2023","text":"recursive function ipoint(ipattern, ints) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ipattern first char is a . integer(kind=ip), intent(in), dimension(:) :: ints Return Value integer(kind=ip) Calls proc~~ipoint~~CallsGraph proc~ipoint problem_12b::ipoint proc~go~5 problem_12b::go proc~ipoint->proc~go~5 proc~go~5->proc~ipoint proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~go~5->proc~get_from_cache~2 proc~ipound problem_12b::ipound proc~go~5->proc~ipound proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~go~5->proc~put_in_cache~2 proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 proc~ipound->proc~go~5 ints_tmp ints_tmp proc~ipound->ints_tmp ipattern_tmp ipattern_tmp proc~ipound->ipattern_tmp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ipoint~~CalledByGraph proc~ipoint problem_12b::ipoint proc~go~5 problem_12b::go proc~ipoint->proc~go~5 proc~go~5->proc~ipoint proc~ipound problem_12b::ipound proc~go~5->proc~ipound proc~ipound->proc~go~5 program~problem_12b problem_12b program~problem_12b->proc~go~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive integer ( ip ) function ipoint ( ipattern , ints ) integer ( ip ), dimension (:), intent ( in ) :: ipattern !! first char is a . integer ( ip ), dimension (:), intent ( in ) :: ints if ( size ( ipattern ) <= 1 ) then ipoint = go ([ integer ( ip ) :: ], ints ) ! done, pass in empty array else ipoint = go ( ipattern ( 2 :), ints ) ! skip it and go to next one end if end function ipoint","tags":"","loc":"proc/ipoint.html"},{"title":"go – AoC-2023","text":"function go(time, distance) result(iproduct) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: time integer(kind=ip), intent(in), dimension(:) :: distance Return Value integer(kind=ip) Called by proc~~go~8~~CalledByGraph proc~go~8 problem_6::go program~problem_6 problem_6 program~problem_6->proc~go~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function go ( time , distance ) result ( iproduct ) integer ( ip ), dimension (:), intent ( in ) :: time integer ( ip ), dimension (:), intent ( in ) :: distance integer ( ip ) :: iproduct integer ( ip ) :: i , ihold , iways , idistance iproduct = 1 do i = 1 , size ( time ) iways = 0 do ihold = 1 , time ( i ) ! time to hold the button idistance = ihold * ( time ( i ) - ihold ) if ( idistance > distance ( i )) iways = iways + 1 end do iproduct = iproduct * iways end do end function go","tags":"","loc":"proc/go~8.html"},{"title":"d2norm – AoC-2023","text":"private pure function d2norm(a, b) Returns with precautions to avoid overflow. History 21 Mar 1990: First version. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b Return Value real(kind=wp) Called by proc~~d2norm~~CalledByGraph proc~d2norm lsqr_module::d2norm proc~lsqr lsqr_module::lsqr_solver%LSQR proc~lsqr->proc~d2norm proc~solve_ez lsqr_module::lsqr_solver_ez%solve_ez proc~solve_ez->proc~lsqr proc~test~2 lsqrtest_module::test_solver%test proc~test~2->proc~lsqr proc~lsqr_test lsqrtest_module::lsqr_test proc~lsqr_test->proc~test~2 proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver proc~nlesolver_solver->proc~solve_ez program~main~3 main program~main~3->proc~solve_ez program~main~2 main program~main~2->proc~lsqr_test program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->proc~nlesolver_solver program~sparse_test sparse_test program~sparse_test->proc~nlesolver_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function d2norm ( a , b ) real ( wp ) :: d2norm real ( wp ), intent ( in ) :: a real ( wp ), intent ( in ) :: b real ( wp ) :: scale scale = abs ( a ) + abs ( b ) if ( scale == zero ) then d2norm = zero else d2norm = scale * sqrt ( ( a / scale ) ** 2 + ( b / scale ) ** 2 ) end if end function d2norm","tags":"","loc":"proc/d2norm.html"},{"title":"initialize_ez – AoC-2023","text":"private  subroutine initialize_ez(me, m, n, a, irow, icol, atol, btol, conlim, itnlim, nout) Constructor for lsqr_solver_ez . Type Bound lsqr_solver_ez Arguments Type Intent Optional Attributes Name class( lsqr_solver_ez ), intent(out) :: me integer, intent(in) :: m number of rows in A matrix integer, intent(in) :: n number of columns in A matrix real(kind=wp), intent(in), dimension(:) :: a nonzero elements of A integer, intent(in), dimension(:) :: irow row indices of nonzero elements of A integer, intent(in), dimension(:) :: icol column indices of nonzero elements of A real(kind=wp), intent(in), optional :: atol relative error in definition of A real(kind=wp), intent(in), optional :: btol relative error in definition of b real(kind=wp), intent(in), optional :: conlim An upper limit on cond(Abar) , the apparent\ncondition number of the matrix Abar . integer, intent(in), optional :: itnlim max iterations integer, intent(in), optional :: nout output unit for printing Called by proc~~initialize_ez~~CalledByGraph proc~initialize_ez lsqr_module::lsqr_solver_ez%initialize_ez proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver proc~nlesolver_solver->proc~initialize_ez program~main~3 main program~main~3->proc~initialize_ez program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->proc~nlesolver_solver program~sparse_test sparse_test program~sparse_test->proc~nlesolver_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize_ez ( me , m , n , a , irow , icol , atol , btol , conlim , itnlim , nout ) implicit none class ( lsqr_solver_ez ), intent ( out ) :: me integer , intent ( in ) :: m !! number of rows in `A` matrix integer , intent ( in ) :: n !! number of columns in `A` matrix integer , dimension (:), intent ( in ) :: irow !! row indices of nonzero elements of `A` integer , dimension (:), intent ( in ) :: icol !! column indices of nonzero elements of `A` real ( wp ), dimension (:), intent ( in ) :: a !! nonzero elements of `A` real ( wp ), intent ( in ), optional :: atol !! relative error in definition of `A` real ( wp ), intent ( in ), optional :: btol !! relative error in definition of `b` real ( wp ), intent ( in ), optional :: conlim !! An upper limit on `cond(Abar)`, the apparent !! condition number of the matrix `Abar`. integer , intent ( in ), optional :: itnlim !! max iterations integer , intent ( in ), optional :: nout !! output unit for printing ! check for consistent inputs: if ( any ( size ( a ) /= [ size ( irow ), size ( icol )])) error stop 'invalid a,icol,irow sizes in initialize_ez' if ( any ( irow > m )) error stop 'invalid irow or m in initialize_ez' if ( any ( icol > n )) error stop 'invalid icol or n in initialize_ez' me % num_nonzero_elements = size ( irow ) me % m = m me % n = n me % irow = irow me % icol = icol me % a = a ! optional inputs: if ( present ( atol )) me % atol = atol if ( present ( btol )) me % btol = btol if ( present ( conlim )) me % conlim = conlim if ( present ( itnlim )) me % itnlim = itnlim if ( present ( nout )) me % nout = nout end subroutine initialize_ez","tags":"","loc":"proc/initialize_ez.html"},{"title":"aprod_ez – AoC-2023","text":"private  subroutine aprod_ez(me, mode, m, n, x, y) The internal aprod function for the lsqr_solver_ez class. Type Bound lsqr_solver_ez Arguments Type Intent Optional Attributes Name class( lsqr_solver_ez ), intent(inout) :: me integer, intent(in) :: mode If mode = 1 , compute y = y + A*x . y should be altered without changing x. If mode = 2 , compute x = x + A(transpose)*y . x should be altered without changing y . integer, intent(in) :: m number of rows in A matrix integer, intent(in) :: n number of columns in A matrix real(kind=wp), intent(inout), dimension(:) :: x [n] real(kind=wp), intent(inout), dimension(:) :: y [m] Source Code subroutine aprod_ez ( me , mode , m , n , x , y ) implicit none class ( lsqr_solver_ez ), intent ( inout ) :: me integer , intent ( in ) :: mode !! * If `mode = 1`, compute `y = y + A*x`. !!   `y` should be altered without changing x. !! * If `mode = 2`, compute `x = x + A(transpose)*y`. !!   `x` should be altered without changing `y`. integer , intent ( in ) :: m !! number of rows in `A` matrix integer , intent ( in ) :: n !! number of columns in `A` matrix real ( wp ), dimension (:), intent ( inout ) :: x !! [n] real ( wp ), dimension (:), intent ( inout ) :: y !! [m] integer :: i !! counter integer :: r !! row index integer :: c !! column index if ( m /= me % m . or . n /= me % n ) error stop 'lsqr_solver_ez class not properly initialized' select case ( mode ) case ( 1 ) ! y = y + A*x !   A    x   Ax !  ---   -   - !  X0X   X   X !  0X0 * X = X !  00X   X   X !  00X       X ! A*x: if (. not . allocated ( me % Ax )) allocate ( me % Ax ( me % m )) me % Ax = zero do i = 1 , me % num_nonzero_elements r = me % irow ( i ) c = me % icol ( i ) me % Ax ( r ) = me % Ax ( r ) + me % a ( i ) * x ( c ) end do y = y + me % Ax case ( 2 ) ! x = x + A(transpose)*y !   A     Y   ATy !  ---    -   - !  X000   Y   X !  0X00 * Y = X !  X0XX   Y   X !         Y ! A(transpose)*y if (. not . allocated ( me % Aty )) allocate ( me % Aty ( me % n )) me % Aty = zero do i = 1 , me % num_nonzero_elements r = me % irow ( i ) c = me % icol ( i ) me % Aty ( c ) = me % Aty ( c ) + me % a ( i ) * y ( r ) end do x = x + me % Aty case default error stop 'invalid mode in aprod_ez' end select end subroutine aprod_ez","tags":"","loc":"proc/aprod_ez.html"},{"title":"solve_ez – AoC-2023","text":"private  subroutine solve_ez(me, b, damp, x, istop, se, itn, anorm, acond, rnorm, arnorm, xnorm) Wrapper for LSQR for the easy version of the class. Type Bound lsqr_solver_ez Arguments Type Intent Optional Attributes Name class( lsqr_solver_ez ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%m) :: b real(kind=wp), intent(in) :: damp real(kind=wp), intent(out), dimension(me%n) :: x the computed solution x . integer, intent(out) :: istop exit code (see LSQR ). real(kind=wp), intent(out), optional, dimension(me%n) :: se integer, intent(out), optional :: itn real(kind=wp), intent(out), optional :: anorm real(kind=wp), intent(out), optional :: acond real(kind=wp), intent(out), optional :: rnorm real(kind=wp), intent(out), optional :: arnorm real(kind=wp), intent(out), optional :: xnorm Calls proc~~solve_ez~~CallsGraph proc~solve_ez lsqr_module::lsqr_solver_ez%solve_ez proc~lsqr lsqr_module::lsqr_solver%LSQR proc~solve_ez->proc~lsqr aprod aprod proc~lsqr->aprod proc~d2norm lsqr_module::d2norm proc~lsqr->proc~d2norm proc~dcopy lsqpblas_module::dcopy proc~lsqr->proc~dcopy proc~dnrm2 lsqpblas_module::dnrm2 proc~lsqr->proc~dnrm2 proc~dscal lsqpblas_module::dscal proc~lsqr->proc~dscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~solve_ez~~CalledByGraph proc~solve_ez lsqr_module::lsqr_solver_ez%solve_ez proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver proc~nlesolver_solver->proc~solve_ez program~main~3 main program~main~3->proc~solve_ez program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->proc~nlesolver_solver program~sparse_test sparse_test program~sparse_test->proc~nlesolver_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine solve_ez ( me , b , damp , x , istop , & se , itn , anorm , acond , rnorm , arnorm , xnorm ) implicit none class ( lsqr_solver_ez ), intent ( inout ) :: me real ( wp ), dimension ( me % m ), intent ( in ) :: b real ( wp ), intent ( in ) :: damp real ( wp ), dimension ( me % n ), intent ( out ) :: x !! the computed solution `x`. integer , intent ( out ) :: istop !! exit code (see [[lsqr]]). real ( wp ), dimension ( me % n ), intent ( out ), optional :: se integer , intent ( out ) , optional :: itn real ( wp ), intent ( out ), optional :: anorm real ( wp ), intent ( out ), optional :: acond real ( wp ), intent ( out ), optional :: rnorm real ( wp ), intent ( out ), optional :: arnorm real ( wp ), intent ( out ), optional :: xnorm real ( wp ), dimension (:), allocatable :: u !! copy of `b` for call to [[lsqr]] real ( wp ), dimension (:), allocatable :: se_ logical :: wantse !! if `se` is to be returned integer :: itn_ real ( wp ) :: anorm_ , acond_ , rnorm_ , arnorm_ , xnorm_ ! get optional inputs: wantse = present ( se ) if ( wantse ) then allocate ( se_ ( me % n )) else allocate ( se_ ( 1 )) ! not needed end if allocate ( u ( me % m )) if (. not . allocated ( me % v )) allocate ( me % v ( me % n )) if (. not . allocated ( me % w )) allocate ( me % w ( me % n )) u = b ! make a copy for input to lsqr (since it will be overwritten) ! main routine: call me % lsqr ( me % m , me % n , damp , wantse , & u , me % v , me % w , x , se_ , & me % atol , me % btol , me % conlim , me % itnlim , me % nout , & istop , itn_ , anorm_ , acond_ , rnorm_ , arnorm_ , xnorm_ ) ! optional outputs: if ( wantse ) se = se_ if ( present ( itn )) itn = itn_ if ( present ( anorm )) anorm = anorm_ if ( present ( acond )) acond = acond_ if ( present ( rnorm )) rnorm = rnorm_ if ( present ( arnorm )) arnorm = arnorm_ if ( present ( xnorm )) xnorm = xnorm_ end subroutine solve_ez","tags":"","loc":"proc/solve_ez.html"},{"title":"LSQR – AoC-2023","text":"private  subroutine LSQR(me, m, n, damp, wantse, u, v, w, x, se, atol, btol, conlim, itnlim, nout, istop, itn, anorm, acond, rnorm, arnorm, xnorm) LSQR finds a solution to the following problems: Unsymmetric equations -- solve: Linear least squares  -- solve (in the least-squares sense): Damped least squares  -- solve (in the least-squares sense): where A is a matrix with m rows and n columns, b is an\n  m-vector, and damp is a scalar.  (All quantities are real.)\n  The matrix A is intended to be large and sparse.  It is accessed\n  by means of subroutine calls to aprod . The rhs vector b is input via u, and subsequently overwritten. Note:  LSQR uses an iterative method to approximate the solution.\n  The number of iterations required to reach a certain accuracy\n  depends strongly on the scaling of the problem.  Poor scaling of\n  the rows or columns of A should therefore be avoided where\n  possible. For example, in problem 1 the solution is unaltered by\n  row-scaling.  If a row of A is very small or large compared to\n  the other rows of A, the corresponding row of ( A  b ) should be\n  scaled up or down. In problems 1 and 2, the solution x is easily recovered\n  following column-scaling.  Unless better information is known,\n  the nonzero columns of A should be scaled so that they all have\n  the same Euclidean norm (e.g., 1.0). In problem 3, there is no freedom to re-scale if damp is\n  nonzero.  However, the value of damp should be assigned only\n  after attention has been paid to the scaling of A. The parameter damp is intended to help regularize\n  ill-conditioned systems, by preventing the true solution from\n  being very large.  Another aid to regularization is provided by\n  the parameter acond, which may be used to terminate iterations\n  before the computed solution becomes very large. Note that x is not an input parameter.\n  If some initial estimate x0 is known and if damp = 0,\n  one could proceed as follows: Compute a residual vector . Use LSQR to solve the system . Add the correction dx to obtain a final solution . This requires that x0 be available before and after the call\n  to LSQR.  To judge the benefits, suppose LSQR takes k1 iterations\n  to solve A x = b and k2 iterations to solve A dx = r0.\n  If x0 is \"good\", norm(r0) will be smaller than norm(b).\n  If the same stopping tolerances atol and btol are used for each\n  system, k1 and k2 will be similar, but the final solution x0 + dx\n  should be more accurate.  The only way to reduce the total work\n  is to use a larger stopping tolerance for the second system.\n  If some value btol is suitable for A x = b, the larger value\n  btol norm(b)/norm(r0)  should be suitable for A*dx = r0. Preconditioning is another way to reduce the number of iterations.\n  If it is possible to solve a related system M x = b efficiently,\n  where M approximates A in some helpful way\n  (e.g. M - A has low rank or its elements are small relative to\n  those of A), LSQR may converge more rapidly on the system\n        A M(inverse) z = b,\n  after which x can be recovered by solving M x = z. NOTE: If A is symmetric, LSQR should not be used!\n  Alternatives are the symmetric conjugate-gradient method (cg)\n  and/or SYMMLQ.\n  SYMMLQ is an implementation of symmetric cg that applies to\n  any symmetric A and will converge more rapidly than LSQR.\n  If A is positive definite, there are other implementations of\n  symmetric cg that require slightly less work per iteration\n  than SYMMLQ (but will take the same number of iterations). Notation The following quantities are used in discussing the subroutine\n parameters: Abar   =  (   A    ),         bbar  =  ( b )\n               ( damp*I )                   ( 0 )\n\n     r      = b  -  A*x,           rbar  = bbar  -  Abar*x\n\n     rnorm  = sqrt( norm(r)**2  +  damp**2 * norm(x)* *2 )\n            = norm( rbar )\n\n     relpr  = the relative precision of floating-point arithmetic\n              on the machine being used.  On most machines,\n              relpr is about 1.0e-7 and 1.0d-16 in single and double\n              precision respectively. LSQR  minimizes the function rnorm with respect to x . References C.C. Paige and M.A. Saunders,  LSQR: An algorithm for sparse\n    linear equations and sparse least squares,\n    ACM Transactions on Mathematical Software 8, 1 (March 1982),\n    pp. 43-71. C.C. Paige and M.A. Saunders,  Algorithm 583, LSQR: Sparse\n    linear equations and least-squares problems,\n    ACM Transactions on Mathematical Software 8, 2 (June 1982),\n    pp. 195-209. C.L. Lawson, R.J. Hanson, D.R. Kincaid and F.T. Krogh,\n    Basic linear algebra subprograms for Fortran usage,\n    ACM Transactions on Mathematical Software 5, 3 (Sept 1979),\n    pp. 308-323 and 324-325. LSQR development 22 Feb 1982: LSQR sent to ACM TOMS to become Algorithm 583. 15 Sep 1985: Final F66 version.  LSQR sent to \"misc\" in netlib. 13 Oct 1987: Bug (Robert Davies, DSIR).  Have to delete\n                     if ( (one + dabs(t)) <= one ) GO TO 200\n                  from loop 200.  The test was an attempt to reduce\n                  underflows, but caused w(i) not to be updated. 17 Mar 1989: First F77 version. 04 May 1989: Bug (David Gay, AT&T).  When the second beta is zero,\n                  rnorm = 0 and\n                  test2 = arnorm / (anorm * rnorm) overflows.\n                  Fixed by testing for rnorm = 0. 05 May 1989: Sent to \"misc\" in netlib. 14 Mar 1990: Bug (John Tomlin via IBM OSL testing).\n                  Setting rhbar2 = rhobar**2 + dampsq can give zero\n                  if rhobar underflows and damp = 0.\n                  Fixed by testing for damp = 0 specially. 15 Mar 1990: Converted to lower case. 21 Mar 1990: d2norm introduced to avoid overflow in numerous\n                  items like  c = sqrt( a 2 + b 2 ). 04 Sep 1991: wantse added as an argument to LSQR, to make\n                  standard errors optional.  This saves storage and\n                  time when se(*) is not wanted. 13 Feb 1992: istop now returns a value in [1,5], not [1,7].\n                  1, 2 or 3 means that x solves one of the problems\n                  Ax = b,  min norm(Ax - b)  or  damped least squares.\n                  4 means the limit on cond(A) was reached.\n                  5 means the limit on iterations was reached. 07 Dec 1994: Keep track of dxmax = max_k norm( phi_k * d_k ).\n                  So far, this is just printed at the end.\n                  A large value (relative to norm(x)) indicates\n                  significant cancellation in forming\n                  x  = D*f  = sum( phi_k * d_k ).\n                  A large column of D need NOT be serious if the\n                  corresponding phi_k is small. 27 Dec 1994: Include estimate of alfa_opt in iteration log.\n                  alfa_opt is the optimal scale factor for the\n                  residual in the \"augmented system\", as described by\n                  A. Bjorck (1992),\n                  Pivoting and stability in the augmented system method,\n                  in D. F. Griffiths and G. A. Watson (eds.),\n                  \"Numerical Analysis 1991\",\n                  Proceedings of the 14th Dundee Conference,\n                  Pitman Research Notes in Mathematics 260,\n                  Longman Scientific and Technical, Harlow, Essex, 1992. 12 Nov 2019 : Jacob Williams : significant refactoring into modern Fortran. Author Michael A. Saunders, Dept of Operations Research, Stanford University Note The number of iterations required by LSQR will usually decrease\n      if the computation is performed in higher precision. Type Bound lsqr_solver Arguments Type Intent Optional Attributes Name class( lsqr_solver ), intent(inout) :: me integer, intent(in) :: m the number of rows in A . integer, intent(in) :: n the number of columns in A . real(kind=wp), intent(in) :: damp The damping parameter for problem 3 above.\n(damp should be 0.0 for problems 1 and 2.)\nIf the system A*x = b is incompatible, values\nof damp in the range 0 to sqrt(relpr)*norm(A) will probably have a negligible effect.\nLarger values of damp will tend to decrease\nthe norm of x and reduce the number of\niterations required by LSQR. The work per iteration and the storage needed\nby LSQR are the same for all values of damp . logical, intent(in) :: wantse A logical variable to say if the array se(*) of standard error estimates should be computed.\nIf m > n or damp > 0 ,  the system is\noverdetermined and the standard errors may be\nuseful.  (See the first LSQR reference.)\nOtherwise ( m <= n and damp = 0 ) they do not\nmean much.  Some time and storage can be saved\nby setting wantse = .false. and using any\nconvenient array for se(*) , which won't be\ntouched. real(kind=wp), intent(inout) :: u (m) The rhs vector b .  Beware that u is\nover-written by LSQR. real(kind=wp), intent(inout) :: v (n) workspace real(kind=wp), intent(inout) :: w (n) workspace real(kind=wp), intent(out) :: x (n) Returns the computed solution x . real(kind=wp), intent(out), dimension(*) :: se If wantse is true, the dimension of se must be n or more. se(*) then returns standard error\nestimates for the components of x .\nFor each i , se(i) is set to the value rnorm * sqrt( sigma(i,i) / t ) ,\nwhere sigma(i,i) is an estimate of the i-th\ndiagonal of the inverse of Abar(transpose)*Abar and:\n* t = 1      if  m <= n * t = m - n  if  m > n  and  damp = 0 * t = m      if  damp /= 0 If wantse is false, se(*) will not be touched.\nThe actual parameter can be any suitable array\nof any length. real(kind=wp), intent(in) :: atol An estimate of the relative error in the data\ndefining the matrix A .  For example,\nif A is accurate to about 6 digits, set atol = 1.0e-6 . real(kind=wp), intent(in) :: btol An estimate of the relative error in the data\ndefining the rhs vector b .  For example,\nif b is accurate to about 6 digits, set btol = 1.0e-6 . real(kind=wp), intent(in) :: conlim An upper limit on cond(Abar) , the apparent\ncondition number of the matrix Abar .\nIterations will be terminated if a computed\nestimate of cond(Abar) exceeds conlim .\nThis is intended to prevent certain small or\nzero singular values of A or Abar from\ncoming into effect and causing unwanted growth\nin the computed solution. conlim and damp may be used separately or\ntogether to regularize ill-conditioned systems. Normally, conlim should be in the range\n1000 to 1/relpr . Suggested value: conlim = 1/(100*relpr) for compatible systems, conlim = 1/(10*sqrt(relpr)) for least squares. Note:  If the user is not concerned about the parameters atol , btol and conlim , any or all of them may be set\nto zero.  The effect will be the same as the values relpr , relpr and 1/relpr respectively. integer, intent(in) :: itnlim An upper limit on the number of iterations.\nSuggested value:\n* itnlim = n/2 for well-conditioned systems\n  with clustered singular values,\n* itnlim = 4*n otherwise. integer, intent(in) :: nout File number for printed output.  If nonzero,\na summary will be printed on file nout . integer, intent(out) :: istop An integer giving the reason for termination: 0 -- x = 0  is the exact solution.\n  No iterations were performed. 1 -- The equations A*x = b are probably\n  compatible. Norm(A*x - b) is sufficiently\n  small, given the values of atol and btol . 2 -- damp is zero.  The system A*x = b is probably\n  not compatible.  A least-squares solution has\n  been obtained that is sufficiently accurate,\n  given the value of atol . 3 -- damp is nonzero.  A damped least-squares\n  solution has been obtained that is sufficiently\n  accurate, given the value of atol . 4 -- An estimate of cond(Abar) has exceeded conlim .  The system A*x = b appears to be\n  ill-conditioned.  Otherwise, there could be an\n  error in subroutine aprod . 5 -- The iteration limit itnlim was reached. integer, intent(out) :: itn The number of iterations performed. real(kind=wp), intent(out) :: anorm An estimate of the Frobenius norm of Abar .\nThis is the square-root of the sum of squares\nof the elements of Abar .\nIf damp is small and if the columns of A have all been scaled to have length 1.0, anorm should increase to roughly sqrt(n) .\nA radically different value for anorm may\nindicate an error in subroutine aprod (there\nmay be an inconsistency between modes 1 and 2). real(kind=wp), intent(out) :: acond An estimate of cond(Abar) , the condition\nnumber of Abar .  A very high value of acond may again indicate an error in aprod . real(kind=wp), intent(out) :: rnorm An estimate of the final value of norm(rbar) ,\nthe function being minimized (see notation\nabove).  This will be small if A*x = b has\na solution. real(kind=wp), intent(out) :: arnorm An estimate of the final value of norm( Abar(transpose)*rbar ) , the norm of\nthe residual for the usual normal equations.\nThis should be small in all cases.  (arnorm\nwill often be smaller than the true value\ncomputed from the output vector x .) real(kind=wp), intent(out) :: xnorm An estimate of the norm of the final\nsolution vector x . Calls proc~~lsqr~~CallsGraph proc~lsqr lsqr_module::lsqr_solver%LSQR aprod aprod proc~lsqr->aprod proc~d2norm lsqr_module::d2norm proc~lsqr->proc~d2norm proc~dcopy lsqpblas_module::dcopy proc~lsqr->proc~dcopy proc~dnrm2 lsqpblas_module::dnrm2 proc~lsqr->proc~dnrm2 proc~dscal lsqpblas_module::dscal proc~lsqr->proc~dscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~lsqr~~CalledByGraph proc~lsqr lsqr_module::lsqr_solver%LSQR proc~solve_ez lsqr_module::lsqr_solver_ez%solve_ez proc~solve_ez->proc~lsqr proc~test~2 lsqrtest_module::test_solver%test proc~test~2->proc~lsqr proc~lsqr_test lsqrtest_module::lsqr_test proc~lsqr_test->proc~test~2 proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver proc~nlesolver_solver->proc~solve_ez program~main~3 main program~main~3->proc~solve_ez program~main~2 main program~main~2->proc~lsqr_test program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->proc~nlesolver_solver program~sparse_test sparse_test program~sparse_test->proc~nlesolver_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine LSQR ( me , m , n , damp , wantse , & u , v , w , x , se , & atol , btol , conlim , itnlim , nout , & istop , itn , anorm , acond , rnorm , arnorm , xnorm ) class ( lsqr_solver ), intent ( inout ) :: me integer , intent ( in ) :: m !! the number of rows in `A`. integer , intent ( in ) :: n !! the number of columns in `A`. real ( wp ), intent ( in ) :: damp !! The damping parameter for problem 3 above. !! (damp should be 0.0 for problems 1 and 2.) !! If the system `A*x = b` is incompatible, values !! of `damp` in the range 0 to `sqrt(relpr)*norm(A)` !! will probably have a negligible effect. !! Larger values of `damp` will tend to decrease !! the norm of `x` and reduce the number of !! iterations required by LSQR. !! !! The work per iteration and the storage needed !! by LSQR are the same for all values of `damp`. logical , intent ( in ) :: wantse !! A logical variable to say if the array `se(*)` !! of standard error estimates should be computed. !! If `m > n`  or  `damp > 0`,  the system is !! overdetermined and the standard errors may be !! useful.  (See the first LSQR reference.) !! Otherwise (`m <= n`  and  `damp = 0`) they do not !! mean much.  Some time and storage can be saved !! by setting `wantse = .false.` and using any !! convenient array for `se(*)`, which won't be !! touched. real ( wp ), intent ( inout ) :: u ( m ) !! The rhs vector `b`.  Beware that `u` is !! over-written by LSQR. real ( wp ), intent ( inout ) :: v ( n ) !! workspace real ( wp ), intent ( inout ) :: w ( n ) !! workspace real ( wp ), intent ( out ) :: x ( n ) !! Returns the computed solution `x`. real ( wp ), dimension ( * ), intent ( out ) :: se !! If `wantse` is true, the dimension of `se` must be !! `n` or more. `se(*)` then returns standard error !! estimates for the components of `x`. !! For each `i`, `se(i)` is set to the value !! `rnorm * sqrt( sigma(i,i) / t )`, !! where `sigma(i,i)` is an estimate of the i-th !! diagonal of the inverse of `Abar(transpose)*Abar` !! and: !! * `t = 1      if  m <= n` !! * `t = m - n  if  m > n  and  damp = 0` !! * `t = m      if  damp /= 0` !! !! If `wantse` is false, `se(*)` will not be touched. !! The actual parameter can be any suitable array !! of any length. real ( wp ), intent ( in ) :: atol !! An estimate of the relative error in the data !! defining the matrix `A`.  For example, !! if `A` is accurate to about 6 digits, set !! `atol = 1.0e-6`. real ( wp ), intent ( in ) :: btol !! An estimate of the relative error in the data !! defining the rhs vector `b`.  For example, !! if `b` is accurate to about 6 digits, set !! `btol = 1.0e-6`. real ( wp ), intent ( in ) :: conlim !! An upper limit on `cond(Abar)`, the apparent !! condition number of the matrix `Abar`. !! Iterations will be terminated if a computed !! estimate of `cond(Abar)` exceeds `conlim`. !! This is intended to prevent certain small or !! zero singular values of `A` or `Abar` from !! coming into effect and causing unwanted growth !! in the computed solution. !! !! `conlim` and `damp` may be used separately or !! together to regularize ill-conditioned systems. !! !! Normally, `conlim` should be in the range !! 1000 to `1/relpr`. !! !! Suggested value: !! !! * `conlim = 1/(100*relpr)` for compatible systems, !! * `conlim = 1/(10*sqrt(relpr))` for least squares. !! !! Note:  If the user is not concerned about the parameters !! `atol`, `btol` and `conlim`, any or all of them may be set !! to zero.  The effect will be the same as the values !! `relpr`, `relpr` and `1/relpr` respectively. integer , intent ( in ) :: itnlim !! An upper limit on the number of iterations. !! Suggested value: !! * `itnlim = n/2` for well-conditioned systems !!   with clustered singular values, !! * `itnlim = 4*n` otherwise. integer , intent ( in ) :: nout !! File number for printed output.  If nonzero, !! a summary will be printed on file `nout`. integer , intent ( out ) :: istop !! An integer giving the reason for termination: !! !! * 0 -- `x` = 0  is the exact solution. !!   No iterations were performed. !! * 1 -- The equations `A*x = b` are probably !!   compatible.  `Norm(A*x - b)` is sufficiently !!   small, given the values of `atol` and `btol`. !! * 2 -- `damp` is zero.  The system `A*x = b` is probably !!   not compatible.  A least-squares solution has !!   been obtained that is sufficiently accurate, !!   given the value of `atol`. !! * 3 -- `damp` is nonzero.  A damped least-squares !!   solution has been obtained that is sufficiently !!   accurate, given the value of `atol`. !! * 4 -- An estimate of `cond(Abar)` has exceeded !!   `conlim`.  The system `A*x = b` appears to be !!   ill-conditioned.  Otherwise, there could be an !!   error in subroutine `aprod`. !! * 5 -- The iteration limit `itnlim` was reached. integer , intent ( out ) :: itn !! The number of iterations performed. real ( wp ), intent ( out ) :: anorm !! An estimate of the Frobenius norm of `Abar`. !! This is the square-root of the sum of squares !! of the elements of `Abar`. !! If `damp` is small and if the columns of `A` !! have all been scaled to have length 1.0, !! `anorm` should increase to roughly `sqrt(n)`. !! A radically different value for `anorm` may !! indicate an error in subroutine `aprod` (there !! may be an inconsistency between modes 1 and 2). real ( wp ), intent ( out ) :: acond !! An estimate of `cond(Abar)`, the condition !! number of `Abar`.  A very high value of `acond` !! may again indicate an error in `aprod`. real ( wp ), intent ( out ) :: rnorm !! An estimate of the final value of `norm(rbar)`, !! the function being minimized (see notation !! above).  This will be small if `A*x = b` has !! a solution. real ( wp ), intent ( out ) :: arnorm !! An estimate of the final value of !! `norm( Abar(transpose)*rbar )`, the norm of !! the residual for the usual normal equations. !! This should be small in all cases.  (arnorm !! will often be smaller than the true value !! computed from the output vector `x`.) real ( wp ), intent ( out ) :: xnorm !! An estimate of the norm of the final !! solution vector `x`. logical :: damped integer :: i , maxdx , nconv , nstop real ( wp ) :: alfopt , alpha , beta , bnorm , & cs , cs1 , cs2 , ctol , & delta , dknorm , dnorm , dxk , dxmax , & gamma , gambar , phi , phibar , psi , & res2 , rho , rhobar , rhbar1 , & rhs , rtol , sn , sn1 , sn2 , & t , tau , temp , test1 , test2 , test3 , & theta , t1 , t2 , t3 , xnorm1 , z , zbar logical :: print_iter logical , parameter :: extra = . true . !! for extra printing below. character ( len =* ), parameter :: enter = ' Enter LSQR.  ' character ( len =* ), parameter :: exit = ' Exit  LSQR.  ' character ( len =* ), dimension ( 0 : 5 ), parameter :: msg = [ 'The exact solution is x = 0                          ' ,& 'A solution to Ax = b was found, given atol, btol     ' ,& 'A least-squares solution was found, given atol       ' ,& 'A damped least-squares solution was found, given atol' ,& 'Cond(Abar) seems to be too large, given conlim       ' ,& 'The iteration limit was reached                      ' ] ! Initialize. if ( nout /= 0 ) then write ( nout , '(//A)' ) enter // '     Least-squares solution of  Ax = b' write ( nout , '(A,I7,A,I7,A)' ) ' The matrix  A  has' , m , ' rows   and' , n , ' columns' write ( nout , '(1P,A,E22.14,3X,A,L10)' ) ' damp   =' , damp , 'wantse =' , wantse write ( nout , '(1P,A,E10.2,15x,A,E10.2)' ) ' atol   =' , atol , 'conlim =' , conlim write ( nout , '(1P,A,E10.2,15x,A,I10)' ) ' btol   =' , btol , 'itnlim =' , itnlim end if damped = damp > zero itn = 0 istop = 0 nstop = 0 maxdx = 0 if ( conlim > zero ) then ctol = one / conlim else ctol = zero end if anorm = zero acond = zero dnorm = zero dxmax = zero res2 = zero psi = zero xnorm = zero xnorm1 = zero cs2 = - one sn2 = zero z = zero ! Set up the first vectors u and v for the bidiagonalization. ! These satisfy  beta*u = b,  alpha*v = A(transpose)*u. do i = 1 , n v ( i ) = zero x ( i ) = zero end do if ( wantse ) then do i = 1 , n se ( i ) = zero end do end if alpha = zero beta = dnrm2 ( m , u , 1 ) if ( beta > zero ) then call dscal ( m , ( one / beta ), u , 1 ) call me % aprod ( 2 , m , n , v , u ) alpha = dnrm2 ( n , v , 1 ) end if if ( alpha > zero ) then call dscal ( n , ( one / alpha ), v , 1 ) call dcopy ( n , v , 1 , w , 1 ) end if arnorm = alpha * beta if ( arnorm /= zero ) then rhobar = alpha phibar = beta bnorm = beta rnorm = beta if ( nout /= 0 ) then if ( damped ) then write ( nout , '(//A)' ) & '   Itn       x(1)           Function     Compatible   LS     Norm Abar Cond Abar' else write ( nout , '(//A)' ) & '   Itn       x(1)           Function     Compatible   LS        Norm A    Cond A' end if test1 = one test2 = alpha / beta if ( extra ) then write ( nout , '(80X,A)' ) '    phi    dknorm   dxk  alfa_opt' end if write ( nout , '(1P, I6, 2E17.9, 4E10.2, E9.1, 3E8.1)' ) itn , x ( 1 ), rnorm , test1 , test2 write ( nout , '(A)' ) '' end if do ! Main iteration loop. itn = itn + 1 ! Perform the next step of the bidiagonalization to obtain the ! next  beta, u, alpha, v.  These satisfy the relations ! beta*u  = A*v  -  alpha*u, ! alpha*v  = A(transpose)*u  -  beta*v. call dscal ( m , ( - alpha ), u , 1 ) call me % aprod ( 1 , m , n , v , u ) beta = dnrm2 ( m , u , 1 ) ! Accumulate  anorm = || Bk || = sqrt( sum of  alpha**2 + beta**2 + damp**2 ). temp = d2norm ( alpha , beta ) temp = d2norm ( temp , damp ) anorm = d2norm ( anorm , temp ) if ( beta > zero ) then call dscal ( m , ( one / beta ), u , 1 ) call dscal ( n , ( - beta ), v , 1 ) call me % aprod ( 2 , m , n , v , u ) alpha = dnrm2 ( n , v , 1 ) if ( alpha > zero ) then call dscal ( n , ( one / alpha ), v , 1 ) end if end if ! Use a plane rotation to eliminate the damping parameter. ! This alters the diagonal (rhobar) of the lower-bidiagonal matrix. rhbar1 = rhobar if ( damped ) then rhbar1 = d2norm ( rhobar , damp ) cs1 = rhobar / rhbar1 sn1 = damp / rhbar1 psi = sn1 * phibar phibar = cs1 * phibar end if ! Use a plane rotation to eliminate the subdiagonal element (beta) ! of the lower-bidiagonal matrix, giving an upper-bidiagonal matrix. rho = d2norm ( rhbar1 , beta ) cs = rhbar1 / rho sn = beta / rho theta = sn * alpha rhobar = - cs * alpha phi = cs * phibar phibar = sn * phibar tau = sn * phi ! Update  x, w  and (perhaps) the standard error estimates. t1 = phi / rho t2 = - theta / rho t3 = one / rho dknorm = zero if ( wantse ) then do i = 1 , n t = w ( i ) x ( i ) = t1 * t + x ( i ) w ( i ) = t2 * t + v ( i ) t = ( t3 * t ) ** 2 se ( i ) = t + se ( i ) dknorm = t + dknorm end do else do i = 1 , n t = w ( i ) x ( i ) = t1 * t + x ( i ) w ( i ) = t2 * t + v ( i ) dknorm = ( t3 * t ) ** 2 + dknorm end do end if ! Monitor the norm of d_k, the update to x. ! dknorm = norm( d_k ) ! dnorm  = norm( D_k ),        where   D_k = (d_1, d_2, ..., d_k ) ! dxk    = norm( phi_k d_k ),  where new x = x_k + phi_k d_k. dknorm = sqrt ( dknorm ) dnorm = d2norm ( dnorm , dknorm ) dxk = abs ( phi * dknorm ) if ( dxmax < dxk ) then dxmax = dxk maxdx = itn end if ! Use a plane rotation on the right to eliminate the ! super-diagonal element (theta) of the upper-bidiagonal matrix. ! Then use the result to estimate  norm(x). delta = sn2 * rho gambar = - cs2 * rho rhs = phi - delta * z zbar = rhs / gambar xnorm = d2norm ( xnorm1 , zbar ) gamma = d2norm ( gambar , theta ) cs2 = gambar / gamma sn2 = theta / gamma z = rhs / gamma xnorm1 = d2norm ( xnorm1 , z ) ! Test for convergence. ! First, estimate the norm and condition of the matrix  Abar, ! and the norms of  rbar  and  Abar(transpose)*rbar. acond = anorm * dnorm res2 = d2norm ( res2 , psi ) rnorm = d2norm ( res2 , phibar ) arnorm = alpha * abs ( tau ) ! Now use these norms to estimate certain other quantities, ! some of which will be small near a solution. alfopt = sqrt ( rnorm / ( dnorm * xnorm ) ) test1 = rnorm / bnorm test2 = zero if ( rnorm > zero ) test2 = arnorm / ( anorm * rnorm ) test3 = one / acond t1 = test1 / ( one + anorm * xnorm / bnorm ) rtol = btol + atol * anorm * xnorm / bnorm ! The following tests guard against extremely small values of ! atol, btol  or  ctol.  (The user may have set any or all of ! the parameters  atol, btol, conlim  to zero.) ! The effect is equivalent to the normal tests using ! atol = relpr,  btol = relpr,  conlim = 1/relpr. t3 = one + test3 t2 = one + test2 t1 = one + t1 if ( itn >= itnlim ) istop = 5 if ( t3 <= one ) istop = 4 if ( t2 <= one ) istop = 2 if ( t1 <= one ) istop = 1 ! Allow for tolerances set by the user. if ( test3 <= ctol ) istop = 4 if ( test2 <= atol ) istop = 2 if ( test1 <= rtol ) istop = 1 ! See if it is time to print something. if ( nout /= 0 ) then print_iter = ( n <= 40 ) . or . & ( itn <= 10 ) . or . & ( itn >= itnlim - 10 ) . or . & ( mod ( itn , 10 ) == 0 ) . or . & ( test3 <= 2.0 * ctol ) . or . & ( test2 <= 1 0.0 * atol ) . or . & ( test1 <= 1 0.0 * rtol ) . or . & ( istop /= 0 ) if ( print_iter ) then ! Print a line for this iteration. ! \"extra\" is for experimental purposes. if ( extra ) then write ( nout , '(1P, I6, 2E17.9, 4E10.2, E9.1, 3E8.1)' ) & itn , x ( 1 ), rnorm , test1 , test2 , anorm , acond , phi , dknorm , dxk , alfopt else write ( nout , '(1P, I6, 2E17.9, 4E10.2, E9.1, 3E8.1)' ) & itn , x ( 1 ), rnorm , test1 , test2 , anorm , acond end if !if (mod(itn,10) == 0) write(nout, '(A)') '' end if end if ! Stop if appropriate. ! The convergence criteria are required to be met on nconv ! consecutive iterations, where nconv is set below. ! Suggested value:  nconv = 1, 2 or 3. if ( istop == 0 ) then nstop = 0 else nconv = 1 nstop = nstop + 1 if ( nstop < nconv . and . itn < itnlim ) istop = 0 end if if ( istop /= 0 ) exit end do ! End of iteration loop. ! Finish off the standard error estimates. if ( wantse ) then t = one if ( m > n ) t = m - n if ( damped ) t = m t = rnorm / sqrt ( t ) do i = 1 , n se ( i ) = t * sqrt ( se ( i ) ) end do end if end if ! Decide if istop = 2 or 3. ! Print the stopping condition. if ( damped . and . istop == 2 ) istop = 3 if ( nout /= 0 ) then write ( nout , '(//A,5X,A,I2,15X,A,I8)' ) exit , 'istop  =' , istop , 'itn    =' , itn write ( nout , '(1P,A,5X,A,E12.5,5X,A,E12.5)' ) exit , 'anorm  =' , anorm , 'acond  =' , acond write ( nout , '(1P,A,5X,A,E12.5,5X,A,E12.5)' ) exit , 'bnorm  =' , bnorm , 'xnorm  =' , xnorm write ( nout , '(1P,A,5X,A,E12.5,5X,A,E12.5)' ) exit , 'rnorm  =' , rnorm , 'arnorm =' , arnorm write ( nout , '(1P,A,5X,A,E8.1,A,I8)' ) exit , 'max dx =' , dxmax , ' occurred at itn ' , maxdx write ( nout , '(1P,A,5X,A,E8.1,A)' ) exit , '       =' , dxmax / ( xnorm + 1.0e-20_wp ), '*xnorm' write ( nout , '(A,5X,A)' ) exit , msg ( istop ) end if end subroutine LSQR","tags":"","loc":"proc/lsqr.html"},{"title":"acheck – AoC-2023","text":"private  subroutine acheck(me, m, n, nout, eps, v, w, x, y, inform) Checks the two modes of aprod for LSQR . acheck may be called to test the user-written subroutine\n  aprod required by LSQR and CRAIG.  For some m x n matrix A,\n  aprod with mode = 1 and 2 supplies LSQR and CRAIG with products\n  of the form\n     y := y + Ax  and  x := x + A'y\n  respectively, where A' means A(transpose).\n  acheck tries to verify that A and A' refer to the same matrix. Method We cook up some \"unlikely\" vectors x and y of unit length\n  and test if  y'(y + Ax)  =  x'(x + A'y). History 04 Sep 1991  Initial design and code.\n   Michael Saunders, Dept of Operations Research,\n   Stanford University 10 Feb 1992  aprod and eps added as parameters.\n   tol defined via power. Type Bound lsqr_solver Arguments Type Intent Optional Attributes Name class( lsqr_solver ), intent(inout) :: me integer, intent(in) :: m No. of rows of A. integer, intent(in) :: n No. of columns of A. integer, intent(in) :: nout A file number for printed output. real(kind=wp), intent(in) :: eps The machine precision. real(kind=wp) :: v (n) real(kind=wp) :: w (m) real(kind=wp) :: x (n) real(kind=wp) :: y (m) integer, intent(out) :: inform Error indicator.\ninform = 0 if aprod seems to be\nconsistent.\ninform = 1 otherwise. Calls proc~~acheck~~CallsGraph proc~acheck lsqr_module::lsqr_solver%acheck aprod aprod proc~acheck->aprod proc~dcopy lsqpblas_module::dcopy proc~acheck->proc~dcopy proc~ddot lsqpblas_module::ddot proc~acheck->proc~ddot proc~dnrm2 lsqpblas_module::dnrm2 proc~acheck->proc~dnrm2 proc~dscal lsqpblas_module::dscal proc~acheck->proc~dscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~acheck~~CalledByGraph proc~acheck lsqr_module::lsqr_solver%acheck proc~test~2 lsqrtest_module::test_solver%test proc~test~2->proc~acheck proc~lsqr_test lsqrtest_module::lsqr_test proc~lsqr_test->proc~test~2 program~main~2 main program~main~2->proc~lsqr_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine acheck ( me , m , n , nout , eps , & v , w , x , y , inform ) implicit none class ( lsqr_solver ), intent ( inout ) :: me integer , intent ( in ) :: m !! No. of rows of A. integer , intent ( in ) :: n !! No. of columns of A. integer , intent ( in ) :: nout !! A file number for printed output. integer , intent ( out ) :: inform !! Error indicator. !! inform = 0 if aprod seems to be !! consistent. !! inform = 1 otherwise. real ( wp ), intent ( in ) :: eps !! The machine precision. real ( wp ) :: v ( n ) real ( wp ) :: w ( m ) real ( wp ) :: x ( n ) real ( wp ) :: y ( m ) real ( wp ), parameter :: power = 0.5_wp !! eps**power is used as the tolerance for judging !! whether `y'(y + Ax)  =  x'(x + A'y)` !! to sufficient accuracy. !! power should be in the range (0.25, 0.9) say. !! For example, power = 0.75 means that we are happy !! if three quarters of the available digits agree. !! power = 0.5 seems a reasonable requirement !! (asking for half the digits to agree). integer :: i , j real ( wp ) :: alfa , beta , t , test1 , test2 , test3 , tol tol = eps ** power if ( nout /= 0 ) write ( nout , '(//A)' ) & 'Enter acheck. Test of aprod for LSQR and CRAIG' ! ================================================================== ! Cook up some \"unlikely\" vectors x and y of unit length. ! ================================================================== t = one do j = 1 , n t = t + one x ( j ) = sqrt ( t ) end do t = one do i = 1 , m t = t + one y ( i ) = one / sqrt ( t ) end do alfa = dnrm2 ( n , x , 1 ) beta = dnrm2 ( m , y , 1 ) call dscal ( n , ( one / alfa ), x , 1 ) call dscal ( m , ( one / beta ), y , 1 ) ! ================================================================== ! Test if y'(y + Ax) = x'(x + A'y). ! ================================================================== ! First set w = y + Ax, v = x + A'y. call dcopy ( m , y , 1 , w , 1 ) call dcopy ( n , x , 1 , v , 1 ) call me % aprod ( 1 , m , n , x , w ) call me % aprod ( 2 , m , n , v , y ) ! Now set alfa = y'w, beta = x'v. alfa = ddot ( m , y , 1 , w , 1 ) beta = ddot ( n , x , 1 , v , 1 ) test1 = abs ( alfa - beta ) test2 = one + abs ( alfa ) + abs ( beta ) test3 = test1 / test2 ! See if alfa and beta are essentially the same. if ( test3 <= tol ) then inform = 0 if ( nout /= 0 ) write ( nout , '(1P,A,1X,E10.1)' ) & 'aprod seems OK. Relative error =' , test3 else inform = 1 if ( nout /= 0 ) write ( nout , '(1P,A,1X,E10.1)' ) & 'aprod seems incorrect. Relative error =' , test3 end if end subroutine acheck","tags":"","loc":"proc/acheck.html"},{"title":"xcheck – AoC-2023","text":"private  subroutine xcheck(me, m, n, nout, anorm, damp, eps, b, u, v, w, x, inform, test1, test2, test3) Tests if x solves a certain least-squares problem. xcheck computes residuals and norms associated with the\n  vector x and the least-squares problem solved by LSQR or CRAIG.\n  It determines whether x seems to be a solution to any of three\n  possible systems: Ax = b min norm(Ax - b) min norm(Ax - b)&#94;2 + damp&#94;2 * norm(x)&#94;2 History 07 Feb 1992  Initial design and code.\n   Michael Saunders, Dept of Operations Research,\n   Stanford University. Type Bound lsqr_solver Arguments Type Intent Optional Attributes Name class( lsqr_solver ), intent(inout) :: me integer, intent(in) :: m The number of rows in A. integer, intent(in) :: n The number of columns in A. integer, intent(in) :: nout A file number for printed output.\nIf nout = 0, nothing is printed. real(kind=wp), intent(in) :: anorm An estimate of norm(A) or\nnorm( A, delta*I ) if delta > 0.\nNormally this will be available\nfrom LSQR or CRAIG. real(kind=wp), intent(in) :: damp Possibly defines a damped problem. real(kind=wp), intent(in) :: eps Machine precision. real(kind=wp), intent(in) :: b (m) The right-hand side of Ax = b etc. real(kind=wp), intent(out) :: u (m) On exit, u = r (where r = b - Ax). real(kind=wp), intent(out) :: v (n) On exit, v = A'r. real(kind=wp), intent(out) :: w (n) On exit, w = A'r - damp&#94;2 x. real(kind=wp), intent(in) :: x (n) The given estimate of a solution. integer, intent(out) :: inform inform = 0 if b = 0 and x = 0.\ninform = 1, 2 or 3 if x seems to\nsolve systems 1 2 or 3 above. real(kind=wp), intent(out) :: test1 These are dimensionless quantities\nthat should be \"small\" if x does\nseem to solve one of the systems.\n\"small\" means less than\ntol = eps**power, where power is\ndefined as a parameter below. real(kind=wp), intent(out) :: test2 These are dimensionless quantities\nthat should be \"small\" if x does\nseem to solve one of the systems.\n\"small\" means less than\ntol = eps**power, where power is\ndefined as a parameter below. real(kind=wp), intent(out) :: test3 These are dimensionless quantities\nthat should be \"small\" if x does\nseem to solve one of the systems.\n\"small\" means less than\ntol = eps**power, where power is\ndefined as a parameter below. Calls proc~~xcheck~~CallsGraph proc~xcheck lsqr_module::lsqr_solver%xcheck aprod aprod proc~xcheck->aprod proc~dcopy lsqpblas_module::dcopy proc~xcheck->proc~dcopy proc~dnrm2 lsqpblas_module::dnrm2 proc~xcheck->proc~dnrm2 proc~dscal lsqpblas_module::dscal proc~xcheck->proc~dscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~xcheck~~CalledByGraph proc~xcheck lsqr_module::lsqr_solver%xcheck proc~test~2 lsqrtest_module::test_solver%test proc~test~2->proc~xcheck proc~lsqr_test lsqrtest_module::lsqr_test proc~lsqr_test->proc~test~2 program~main~2 main program~main~2->proc~lsqr_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine xcheck ( me , m , n , nout , anorm , damp , eps , & b , u , v , w , x , & inform , test1 , test2 , test3 ) implicit none class ( lsqr_solver ), intent ( inout ) :: me integer , intent ( in ) :: m !! The number of rows in A. integer , intent ( in ) :: n !! The number of columns in A. integer , intent ( in ) :: nout !! A file number for printed output. !! If nout = 0, nothing is printed. integer , intent ( out ) :: inform !! inform = 0 if b = 0 and x = 0. !! inform = 1, 2 or 3 if x seems to !! solve systems 1 2 or 3 above. real ( wp ), intent ( in ) :: anorm !! An estimate of norm(A) or !! norm( A, delta*I ) if delta > 0. !! Normally this will be available !! from LSQR or CRAIG. real ( wp ), intent ( in ) :: damp !! Possibly defines a damped problem. real ( wp ), intent ( in ) :: eps !! Machine precision. real ( wp ), intent ( out ) :: test1 !! These are dimensionless quantities !! that should be \"small\" if x does !! seem to solve one of the systems. !! \"small\" means less than !! tol = eps**power, where power is !! defined as a parameter below. real ( wp ), intent ( out ) :: test2 !! These are dimensionless quantities !! that should be \"small\" if x does !! seem to solve one of the systems. !! \"small\" means less than !! tol = eps**power, where power is !! defined as a parameter below. real ( wp ), intent ( out ) :: test3 !! These are dimensionless quantities !! that should be \"small\" if x does !! seem to solve one of the systems. !! \"small\" means less than !! tol = eps**power, where power is !! defined as a parameter below. real ( wp ), intent ( in ) :: b ( m ) !! The right-hand side of Ax = b etc. real ( wp ), intent ( out ) :: u ( m ) !! On exit, u = r (where r = b - Ax). real ( wp ), intent ( out ) :: v ( n ) !! On exit, v = A'r. real ( wp ), intent ( out ) :: w ( n ) !! On exit, w = A'r - damp&#94;2 x. real ( wp ), intent ( in ) :: x ( n ) !! The given estimate of a solution. real ( wp ), parameter :: power = 0.5_wp integer :: j real ( wp ) :: bnorm , dampsq , rho1 , rho2 , sigma1 , sigma2 , & tol , snorm , xnorm , xsnorm real ( wp ), dimension ( n ) :: xtmp dampsq = damp ** 2 tol = eps ** power xtmp = x ! Compute u = b - Ax via u = -b + Ax, u = -u. ! This is usual residual vector r. call dcopy ( m , b , 1 , u , 1 ) call dscal ( m , ( - one ), u , 1 ) call me % aprod ( 1 , m , n , xtmp , u ) call dscal ( m , ( - one ), u , 1 ) ! Compute v = A'u via v = 0, v = v + A'u. do j = 1 , n v ( j ) = zero end do call me % aprod ( 2 , m , n , v , u ) ! Compute w = A'u - damp**2 * x. ! This will be close to zero in all cases ! if x is close to a solution. call dcopy ( n , v , 1 , w , 1 ) if ( damp /= zero ) then do j = 1 , n w ( j ) = w ( j ) - dampsq * x ( j ) end do end if ! Compute the norms associated with b, x, u, v, w. bnorm = dnrm2 ( m , b , 1 ) xnorm = dnrm2 ( n , x , 1 ) rho1 = dnrm2 ( m , u , 1 ) sigma1 = dnrm2 ( n , v , 1 ) if ( nout /= 0 ) then write ( nout , '(//A)' ) 'Enter xcheck. Does x solve Ax = b, etc?' write ( nout , '(1P,A,E10.3)' ) ' damp            =' , damp write ( nout , '(1P,A,E10.3)' ) ' norm(x)         =' , xnorm write ( nout , '(1P,A,E15.8,A)' ) ' norm(r)         =' , rho1 , ' = rho1' write ( nout , '(1P,A,E10.3,5X,A)' ) ' norm(A''r)       =' , sigma1 , ' = sigma1' end if if ( damp == zero ) then rho2 = rho1 sigma2 = sigma1 else rho2 = sqrt ( rho1 ** 2 + dampsq * xnorm ** 2 ) sigma2 = dnrm2 ( n , w , 1 ) snorm = rho1 / damp xsnorm = rho2 / damp if ( nout /= 0 ) then write ( nout , '(1P/A,E10.3)' ) ' norm(s)         =' , snorm write ( nout , '(1P,A,E10.3)' ) ' norm(x,s)       =' , xsnorm write ( nout , '(1P,A,E15.8,A)' ) ' norm(rbar)      =' , rho2 , ' = rho2' write ( nout , '(1P,A,E10.3,5X,A)' ) ' norm(Abar''rbar) =' , sigma2 , ' = sigma2' end if end if ! See if x seems to solve Ax = b or min norm(Ax - b) ! or the damped least-squares system. if ( bnorm == zero . and . xnorm == zero ) then inform = 0 test1 = zero test2 = zero test3 = zero else inform = 4 test1 = rho1 / ( bnorm + anorm * xnorm ) test2 = zero if ( rho1 > zero ) test2 = sigma1 / ( anorm * rho1 ) test3 = test2 if ( rho2 > zero ) test3 = sigma2 / ( anorm * rho2 ) if ( test3 <= tol ) inform = 3 if ( test2 <= tol ) inform = 2 if ( test1 <= tol ) inform = 1 end if if ( nout /= 0 ) then write ( nout , '(/A,I2)' ) ' inform          =' , inform write ( nout , '(1P,A,E10.3)' ) ' tol             =' , tol write ( nout , '(1P,A,E10.3,A)' ) ' test1           =' , test1 , ' (Ax = b)' write ( nout , '(1P,A,E10.3,A)' ) ' test2           =' , test2 , ' (least-squares)' write ( nout , '(1P,A,E10.3,A)' ) ' test3           =' , test3 , ' (damped least-squares)' end if end subroutine xcheck","tags":"","loc":"proc/xcheck.html"},{"title":"get_all_pieces_above – AoC-2023","text":"recursive function get_all_pieces_above(i) result(ipieces) reursively get a list of all pieces above piece i Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i Return Value integer(kind=ip), dimension(:), allocatable Calls proc~~get_all_pieces_above~~CallsGraph proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->proc~get_all_pieces_above interface~unique aoc_utilities::unique proc~get_all_pieces_above->interface~unique proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~get_all_pieces_above->proc~get_from_cache~2 proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~get_all_pieces_above->proc~put_in_cache~2 proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 proc~get_pieces_above->interface~unique interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_all_pieces_above~~CalledByGraph proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->proc~get_all_pieces_above program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_above Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive function get_all_pieces_above ( i ) result ( ipieces ) !! reursively get a list of all pieces above piece i integer ( ip ), intent ( in ) :: i integer ( ip ), dimension (:), allocatable :: ipieces integer :: j !! counter logical :: found integer ( ip ) :: idx call above_cache % get ([ i ], idx , ipieces , found ) if (. not . found ) then allocate ( ipieces ( 0 )) associate ( tmp => get_pieces_above ( i )) if ( size ( tmp ) > 0 ) then ipieces = [ ipieces , tmp ] ! ones directly above do j = 1 , size ( tmp ) ! go up the tree ipieces = [ ipieces , get_all_pieces_above ( tmp ( j ))] end do ipieces = unique ( ipieces ) end if end associate call above_cache % put ( idx ,[ i ], ipieces ) end if end function get_all_pieces_above","tags":"","loc":"proc/get_all_pieces_above.html"},{"title":"get_all_pieces_below – AoC-2023","text":"recursive function get_all_pieces_below(i, iskip) result(ipieces) reursively get a list of all pieces below piece i Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: iskip skip this one and it's children Return Value integer(kind=ip), dimension(:), allocatable Calls proc~~get_all_pieces_below~~CallsGraph proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->proc~get_all_pieces_below interface~unique aoc_utilities::unique proc~get_all_pieces_below->interface~unique proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~get_all_pieces_below->proc~get_from_cache~2 proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~get_all_pieces_below->proc~put_in_cache~2 proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 proc~get_pieces_below->interface~unique interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_all_pieces_below~~CalledByGraph proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->proc~get_all_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_all_pieces_below Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive function get_all_pieces_below ( i , iskip ) result ( ipieces ) !! reursively get a list of all pieces below piece i integer ( ip ), intent ( in ) :: i integer ( ip ), intent ( in ) :: iskip !! skip this one and it's children integer ( ip ), dimension (:), allocatable :: ipieces integer :: j !! counter logical :: found integer ( ip ) :: idx integer ( ip ), dimension (:), allocatable :: tmp call below_cache % get ([ i , iskip ], idx , ipieces , found ) if (. not . found ) then allocate ( ipieces ( 0 )) if ( i == iskip ) return tmp = get_pieces_below ( i ) if ( size ( tmp ) > 0 ) then tmp = pack ( tmp , tmp /= iskip ) ! remove the skipped one ipieces = [ ipieces , tmp ] ! ones directly below do j = 1 , size ( tmp ) ! go down the tree ipieces = [ ipieces , get_all_pieces_below ( tmp ( j ), iskip = iskip )] end do ipieces = unique ( ipieces ) end if call below_cache % put ( idx ,[ i , iskip ], ipieces ) end if end function get_all_pieces_below","tags":"","loc":"proc/get_all_pieces_below.html"},{"title":"get_pieces_above – AoC-2023","text":"function get_pieces_above(i) result(ipieces) get set of pieces directly above piece i Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i Return Value integer(kind=ip), dimension(:), allocatable Calls proc~~get_pieces_above~~CallsGraph proc~get_pieces_above problem_22::get_pieces_above interface~unique aoc_utilities::unique proc~get_pieces_above->interface~unique proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_pieces_above~~CalledByGraph proc~get_pieces_above problem_22::get_pieces_above proc~get_all_pieces_above problem_22::get_all_pieces_above proc~get_all_pieces_above->proc~get_pieces_above proc~get_all_pieces_above->proc~get_all_pieces_above program~problem_22 problem_22 program~problem_22->proc~get_pieces_above program~problem_22->proc~get_all_pieces_above Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function get_pieces_above ( i ) result ( ipieces ) !! get set of pieces directly above piece i integer ( ip ), intent ( in ) :: i integer ( ip ), dimension (:), allocatable :: ipieces integer ( ip ) :: x , y , z !! counter allocate ( ipieces ( 0 )) do x = istart_array ( i , 1 ), iend_array ( i , 1 ) do y = istart_array ( i , 2 ), iend_array ( i , 2 ) do z = istart_array ( i , 3 ), iend_array ( i , 3 ) if ( z + 1 <= ubound ( array , 3 )) then if ( array ( x , y , z + 1 ) /= 0 ) ipieces = [ ipieces , array ( x , y , z + 1 )] ! above this one end if end do end do end do ipieces = unique ( pack ( ipieces , ipieces /= i )) ! exclude the ones in this piece end function get_pieces_above","tags":"","loc":"proc/get_pieces_above.html"},{"title":"get_pieces_below – AoC-2023","text":"function get_pieces_below(i) result(ipieces) get set of pieces directly below piece i Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i Return Value integer(kind=ip), dimension(:), allocatable Calls proc~~get_pieces_below~~CallsGraph proc~get_pieces_below problem_22::get_pieces_below interface~unique aoc_utilities::unique proc~get_pieces_below->interface~unique proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_pieces_below~~CalledByGraph proc~get_pieces_below problem_22::get_pieces_below proc~get_all_pieces_below problem_22::get_all_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_all_pieces_below->proc~get_all_pieces_below proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~get_pieces_below program~problem_22 problem_22 program~problem_22->proc~get_pieces_below program~problem_22->proc~get_all_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~drop problem_22::drop proc~drop->proc~move_piece_down proc~initialize->proc~drop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function get_pieces_below ( i ) result ( ipieces ) !! get set of pieces directly below piece i integer ( ip ), intent ( in ) :: i integer ( ip ), dimension (:), allocatable :: ipieces integer ( ip ) :: x , y , z !! counter allocate ( ipieces ( 0 )) do x = istart_array ( i , 1 ), iend_array ( i , 1 ) do y = istart_array ( i , 2 ), iend_array ( i , 2 ) do z = istart_array ( i , 3 ), iend_array ( i , 3 ) if ( z - 1 > 0 ) then ! 0 is the floor if ( array ( x , y , z - 1 ) /= 0 ) ipieces = [ ipieces , array ( x , y , z - 1 )] ! below this one end if end do end do end do ipieces = unique ( pack ( ipieces , ipieces /= i )) ! exclude the ones in this piece end function get_pieces_below","tags":"","loc":"proc/get_pieces_below.html"},{"title":"initialize – AoC-2023","text":"subroutine initialize() read the data Arguments None Calls proc~~initialize~~CallsGraph proc~initialize problem_22::initialize interface~split aoc_utilities::split proc~initialize->interface~split proc~drop problem_22::drop proc~initialize->proc~drop proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~initialize->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~initialize->proc~read_line proc~update_array problem_22::update_array proc~initialize->proc~update_array proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~move_piece_down problem_22::move_piece_down proc~drop->proc~move_piece_down proc~move_piece_down->proc~update_array proc~get_pieces_below problem_22::get_pieces_below proc~move_piece_down->proc~get_pieces_below proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 interface~unique aoc_utilities::unique proc~get_pieces_below->interface~unique proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~initialize~~CalledByGraph proc~initialize problem_22::initialize program~problem_22 problem_22 program~problem_22->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize () !! read the data ! open(newunit=iunit, file='inputs/day22_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day22.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) if ( allocated ( istart_array )) deallocate ( istart_array ); allocate ( istart_array ( n_lines , 3 )) if ( allocated ( iend_array )) deallocate ( iend_array ); allocate ( iend_array ( n_lines , 3 )) do i = 1 , n_lines line = read_line ( iunit ); start_end = split ( line , '~' ) starts = split ( start_end ( 1 )% str , ',' ) ends = split ( start_end ( 2 )% str , ',' ) istart_array ( i ,:) = [( int ( starts ( j )% str ), j = 1 , 3 )] iend_array ( i ,:) = [( int ( ends ( j )% str ), j = 1 , 3 )] end do close ( iunit ) ! create the array to hold all the pieces: if ( allocated ( array )) deallocate ( array ) allocate ( array ( 0 : maxval ([ istart_array (:, 1 ), iend_array (:, 1 )]),& 0 : maxval ([ istart_array (:, 2 ), iend_array (:, 2 )]),& 0 : maxval ([ istart_array (:, 3 ), iend_array (:, 3 )]))) call update_array () ! set array values from the start/end arrays call drop () ! continue forward in time until all the bricks settle. end subroutine initialize","tags":"","loc":"proc/initialize.html"},{"title":"drop – AoC-2023","text":"subroutine drop() continue forward in time until all the bricks settle. Arguments None Calls proc~~drop~~CallsGraph proc~drop problem_22::drop proc~move_piece_down problem_22::move_piece_down proc~drop->proc~move_piece_down proc~get_pieces_below problem_22::get_pieces_below proc~move_piece_down->proc~get_pieces_below proc~update_array problem_22::update_array proc~move_piece_down->proc~update_array interface~unique aoc_utilities::unique proc~get_pieces_below->interface~unique proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~drop~~CalledByGraph proc~drop problem_22::drop proc~initialize problem_22::initialize proc~initialize->proc~drop program~problem_22 problem_22 program~problem_22->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine drop () !! continue forward in time until all the bricks settle. logical :: moved , tmp_moved integer ( ip ) :: i do moved = . false . do i = 1 , n_lines call move_piece_down ( i , tmp_moved ) if ( tmp_moved ) moved = . true . ! at least one was moved end do if (. not . moved ) exit ! done moving all the pieces end do end subroutine drop","tags":"","loc":"proc/drop.html"},{"title":"update_array – AoC-2023","text":"subroutine update_array() populate the array using the start/end indices Arguments None Called by proc~~update_array~~CalledByGraph proc~update_array problem_22::update_array proc~initialize problem_22::initialize proc~initialize->proc~update_array proc~drop problem_22::drop proc~initialize->proc~drop proc~move_piece_down problem_22::move_piece_down proc~move_piece_down->proc~update_array proc~drop->proc~move_piece_down program~problem_22 problem_22 program~problem_22->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine update_array () !! populate the array using the start/end indices integer :: i array = 0 do i = 1 , n_lines array ( istart_array ( i , 1 ): iend_array ( i , 1 ),& istart_array ( i , 2 ): iend_array ( i , 2 ),& istart_array ( i , 3 ): iend_array ( i , 3 )) = i end do end subroutine update_array","tags":"","loc":"proc/update_array.html"},{"title":"move_piece_down – AoC-2023","text":"subroutine move_piece_down(i, moved) move a piece down (fall one square) if it can be moved Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i piece number logical, intent(out) :: moved if it was actually movec Calls proc~~move_piece_down~~CallsGraph proc~move_piece_down problem_22::move_piece_down proc~get_pieces_below problem_22::get_pieces_below proc~move_piece_down->proc~get_pieces_below proc~update_array problem_22::update_array proc~move_piece_down->proc~update_array interface~unique aoc_utilities::unique proc~get_pieces_below->interface~unique proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~move_piece_down~~CalledByGraph proc~move_piece_down problem_22::move_piece_down proc~drop problem_22::drop proc~drop->proc~move_piece_down proc~initialize problem_22::initialize proc~initialize->proc~drop program~problem_22 problem_22 program~problem_22->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine move_piece_down ( i , moved ) !! move a piece down (fall one square) if it can be moved integer ( ip ), intent ( in ) :: i !! piece number logical , intent ( out ) :: moved !! if it was actually movec moved = . false . if ( size ( get_pieces_below ( i )) == 0 ) then ! can only move if nothing below if ( istart_array ( i , 3 ) > 1 . and . iend_array ( i , 3 ) > 1 ) then istart_array ( i , 3 ) = istart_array ( i , 3 ) - 1 iend_array ( i , 3 ) = iend_array ( i , 3 ) - 1 moved = . true . call update_array () end if end if end subroutine move_piece_down","tags":"","loc":"proc/move_piece_down.html"},{"title":"in_seed_list – AoC-2023","text":"function in_seed_list(iseed) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: iseed Return Value logical Called by proc~~in_seed_list~~CalledByGraph proc~in_seed_list problem_5::in_seed_list program~problem_5 problem_5 program~problem_5->proc~in_seed_list Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code logical function in_seed_list ( iseed ) ! for part b, is the seed in the initial list integer ( ip ), intent ( in ) :: iseed integer :: i do i = 1 , size ( seeds_list ), 2 if ( iseed >= seeds_list ( i ) . and . iseed <= seeds_list ( i ) + seeds_list ( i + 1 ) - 1 ) then in_seed_list = . true . return end if end do in_seed_list = . false . end function in_seed_list","tags":"","loc":"proc/in_seed_list.html"},{"title":"map – AoC-2023","text":"pure function map(ival, m, reverse) result(idest) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: ival type( mapping ), intent(in) :: m logical, intent(in) :: reverse Return Value integer(kind=ip) Called by proc~~map~~CalledByGraph proc~map problem_5::map proc~traverse~3 problem_5::traverse proc~traverse~3->proc~map program~problem_5 problem_5 program~problem_5->proc~traverse~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function map ( ival , m , reverse ) result ( idest ) integer ( ip ), intent ( in ) :: ival type ( mapping ), intent ( in ) :: m logical , intent ( in ) :: reverse ! if reversed, go from: dest -> src integer ( ip ) :: idest integer :: i if ( reverse ) then do i = 1 , size ( m % src_start ) ! locate ival (dest) in the dest start:end range if ( ival >= m % dest_start ( i ) . and . ival <= m % dest_end ( i )) then ! found it, map to dest idest = m % src_start ( i ) + ( ival - m % dest_start ( i )) ! this is the resultant isource return end if end do else do i = 1 , size ( m % src_start ) ! locate ival (source) in the source start:end range if ( ival >= m % src_start ( i ) . and . ival <= m % src_end ( i )) then ! found it, map to dest idest = m % dest_start ( i ) + ( ival - m % src_start ( i )) return end if end do end if idest = ival ! if not found in any of the sets end function map","tags":"","loc":"proc/map.html"},{"title":"traverse – AoC-2023","text":"pure function traverse(iseed, reverse) result(ilocation) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: iseed logical, intent(in) :: reverse if reverse, then ilocation -> iseed Return Value integer(kind=ip) Calls proc~~traverse~3~~CallsGraph proc~traverse~3 problem_5::traverse proc~map problem_5::map proc~traverse~3->proc~map Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~traverse~3~~CalledByGraph proc~traverse~3 problem_5::traverse program~problem_5 problem_5 program~problem_5->proc~traverse~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function traverse ( iseed , reverse ) result ( ilocation ) integer ( ip ), intent ( in ) :: iseed logical , intent ( in ) :: reverse !! if reverse, then ilocation -> iseed integer ( ip ) :: ilocation integer :: i ilocation = iseed ! initialize if ( reverse ) then do i = NSTAGES , 1 , - 1 ilocation = map ( ilocation , mappings ( i ), reverse ) ! this is really iseed end do else do i = 1 , NSTAGES ilocation = map ( ilocation , mappings ( i ), reverse ) end do end if end function traverse","tags":"","loc":"proc/traverse~3.html"},{"title":"populate – AoC-2023","text":"subroutine populate(nums, m) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(3) :: nums type( mapping ), intent(inout) :: m Called by proc~~populate~~CalledByGraph proc~populate problem_5::populate program~problem_5 problem_5 program~problem_5->proc~populate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine populate ( nums , m ) integer ( ip ), dimension ( 3 ), intent ( in ) :: nums ! the three numbers from the line: ! [dest range start, src range start, range length type ( mapping ), intent ( inout ) :: m ! structure to add this data to associate ( dest => nums ( 1 ), source => nums ( 2 ), range => nums ( 3 ) ) m % dest_start = [ m % dest_start , dest ] m % dest_end = [ m % dest_end , dest + range - 1 ] m % src_start = [ m % src_start , source ] m % src_end = [ m % src_end , source + range - 1 ] end associate end subroutine populate","tags":"","loc":"proc/populate.html"},{"title":"pipe_info – AoC-2023","text":"pure function pipe_info(p) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: p Return Value character(len=2) Called by proc~~pipe_info~~CalledByGraph proc~pipe_info problem_10::pipe_info proc~move problem_10::move proc~move->proc~pipe_info proc~move->proc~move program~problem_10 problem_10 program~problem_10->proc~move Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/pipe_info.html"},{"title":"move – AoC-2023","text":"recursive subroutine move(i, j, direction, distance, save_path) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: direction integer, intent(inout), dimension(:,:) :: distance logical, intent(in) :: save_path to save the path coordinates Calls proc~~move~~CallsGraph proc~move problem_10::move proc~move->proc~move proc~pipe_info problem_10::pipe_info proc~move->proc~pipe_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~move~~CalledByGraph proc~move problem_10::move proc~move->proc~move program~problem_10 problem_10 program~problem_10->proc~move Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive subroutine move ( i , j , direction , distance , save_path ) integer , intent ( in ) :: i , j , direction integer , dimension (:,:), intent ( inout ) :: distance logical , intent ( in ) :: save_path !! to save the path coordinates integer :: inew , jnew , imove logical :: valid_move select case ( direction ) case ( 1 ); inew = i - 1 ; jnew = j ! north case ( 2 ); inew = i + 1 ; jnew = j ! south case ( 3 ); inew = i ; jnew = j + 1 ! east case ( 4 ); inew = i ; jnew = j - 1 ! west end select if ( visited ( inew , jnew ) . or . array ( inew , jnew ) == '.' ) return ! can we move in this direction? valid_move = . false . associate ( current_pipe => array ( i , j ), & current_distance => distance ( i , j ), & move_to => array ( inew , jnew ) ) select case ( current_pipe ) case ( 'S' ) ! don't know what the first pip is, so have to try them all select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '|' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south end select case ( '-' ) select case ( direction ) case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'L' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select case ( 'J' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '7' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'F' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select end select if ( valid_move ) then distance ( inew , jnew ) = current_distance + 1 visited ( inew , jnew ) = . true . do imove = 1 , 4 call move ( inew , jnew , imove , distance , save_path ) end do if ( save_path ) then x = [ x , real ( inew , wp )] ! save cordinates of point on the path y = [ y , real ( jnew , wp )] end if end if end associate end subroutine move","tags":"","loc":"proc/move.html"},{"title":"rating – AoC-2023","text":"pure function rating(p) Arguments Type Intent Optional Attributes Name type( part ), intent(in) :: p Return Value integer(kind=ip) Called by proc~~rating~~CalledByGraph proc~rating problem_19::rating program~problem_19 problem_19 program~problem_19->proc~rating Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer ( ip ) function rating ( p ) type ( part ), intent ( in ) :: p rating = sum ( p % xmas ) end function rating","tags":"","loc":"proc/rating.html"},{"title":"process – AoC-2023","text":"function process(p) result(accepted) process this part through all the workflows. Arguments Type Intent Optional Attributes Name type( part ), intent(in) :: p Return Value logical Calls proc~~process~2~~CallsGraph proc~process~2 problem_19::process proc~workflow_name_to_index~2 problem_19::workflow_name_to_index proc~process~2->proc~workflow_name_to_index~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~process~2~~CalledByGraph proc~process~2 problem_19::process program~problem_19 problem_19 program~problem_19->proc~process~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function process ( p ) result ( accepted ) !! process this part through all the workflows. type ( part ), intent ( in ) :: p logical :: accepted integer :: i , irule i = workflow_name_to_index ( 'in' ) ! start at the first workflow irule = 1 ! first rule do associate ( r => workflows ( i )% rules ( irule ) ) ! check if we are done if ( r % accept ) then ; accepted = . true .; return ; end if if ( r % reject ) then ; accepted = . false .; return ; end if if ( r % operator > 0 ) then ! process the operator select case ( r % operator ) case ( 1 ) ! < if ( p % xmas ( r % operator_arg ) < r % operator_val ) then ! check if done if ( r % goto == 'A' ) then ; accepted = . true .; return ; end if if ( r % goto == 'R' ) then ; accepted = . false .; return ; end if ! go to next workflow: i = workflow_name_to_index ( r % goto ) !write(*,*) 'goto '//r%goto irule = 1 ! start at first rule of new workflow else irule = irule + 1 ! next rule end if case ( 2 ) ! > if ( p % xmas ( r % operator_arg ) > r % operator_val ) then ! check if done if ( r % goto == 'A' ) then ; accepted = . true .; return ; end if if ( r % goto == 'R' ) then ; accepted = . false .; return ; end if ! go to next workflow: i = workflow_name_to_index ( r % goto ) irule = 1 ! start at first rule of new workflow else irule = irule + 1 ! next rule end if end select else ! goto another workflow i = workflow_name_to_index ( r % goto ) irule = 1 ! start at first rule of new workflow end if end associate end do end function process","tags":"","loc":"proc/process~2.html"},{"title":"workflow_name_to_index – AoC-2023","text":"function workflow_name_to_index(name) result(idx) get the index of this workflow in the array Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value integer Called by proc~~workflow_name_to_index~2~~CalledByGraph proc~workflow_name_to_index~2 problem_19::workflow_name_to_index proc~process~2 problem_19::process proc~process~2->proc~workflow_name_to_index~2 program~problem_19 problem_19 program~problem_19->proc~process~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function workflow_name_to_index ( name ) result ( idx ) !! get the index of this workflow in the array character ( len =* ), intent ( in ) :: name integer :: idx do idx = 1 , size ( workflows ) if ( name == workflows ( idx )% name ) return ! found it end do if ( idx > size ( workflows )) error stop 'workflow not found: ' // name end function workflow_name_to_index","tags":"","loc":"proc/workflow_name_to_index~2.html"},{"title":"parse_rule – AoC-2023","text":"function parse_rule(s) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value type( rule ) Calls proc~~parse_rule~2~~CallsGraph proc~parse_rule~2 problem_19::parse_rule interface~split aoc_utilities::split proc~parse_rule~2->interface~split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~parse_rule~2~~CalledByGraph proc~parse_rule~2 problem_19::parse_rule program~problem_19 problem_19 program~problem_19->proc~parse_rule~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function parse_rule ( s ) result ( r ) character ( len =* ), intent ( in ) :: s type ( rule ) :: r type ( string ), dimension (:), allocatable :: v character ( len =* ), parameter :: xmas = 'xmas' ! 1,2,3,4 if ( s == 'A' ) then r % accept = . true . else if ( s == 'R' ) then r % reject = . true . else if ( index ( s , '>' ) > 0 ) then v = split ( s ( 3 :), ':' ) ! example: a<2006:qkq r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 2 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else if ( index ( s , '<' ) > 0 ) then v = split ( s ( 3 :), ':' ) r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 1 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else r % goto = s ! it's a workflow name end if end if end function parse_rule","tags":"","loc":"proc/parse_rule~2.html"},{"title":"aoc_utilities – AoC-2023","text":"Helper classes and routines for Advent of Code Author Jacob Williams hex string to int value. lowercase letters assumed!\n  no error checking here! Uses iso_fortran_env module~~aoc_utilities~~UsesGraph module~aoc_utilities aoc_utilities iso_fortran_env iso_fortran_env module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aoc_utilities~~UsedByGraph module~aoc_utilities aoc_utilities module~aoc_cache_module aoc_cache_module module~aoc_cache_module->module~aoc_utilities module~problem_15_module problem_15_module module~problem_15_module->module~aoc_utilities program~problem_1 problem_1 program~problem_1->module~aoc_utilities program~problem_10 problem_10 program~problem_10->module~aoc_utilities program~problem_11 problem_11 program~problem_11->module~aoc_utilities program~problem_12 problem_12 program~problem_12->module~aoc_utilities program~problem_12b problem_12b program~problem_12b->module~aoc_utilities program~problem_12b->module~aoc_cache_module program~problem_13 problem_13 program~problem_13->module~aoc_utilities program~problem_15 problem_15 program~problem_15->module~aoc_utilities program~problem_15->module~problem_15_module program~problem_16 problem_16 program~problem_16->module~aoc_utilities program~problem_17 problem_17 program~problem_17->module~aoc_utilities program~problem_17->module~aoc_cache_module program~problem_17~2 problem_17 program~problem_17~2->module~aoc_utilities program~problem_18 problem_18 program~problem_18->module~aoc_utilities program~problem_19 problem_19 program~problem_19->module~aoc_utilities program~problem_19b problem_19b program~problem_19b->module~aoc_utilities program~problem_2 problem_2 program~problem_2->module~aoc_utilities program~problem_21 problem_21 program~problem_21->module~aoc_utilities program~problem_22 problem_22 program~problem_22->module~aoc_utilities program~problem_22->module~aoc_cache_module program~problem_23 problem_23 program~problem_23->module~aoc_utilities program~problem_25 problem_25 program~problem_25->module~aoc_utilities program~problem_3 problem_3 program~problem_3->module~aoc_utilities program~problem_4 problem_4 program~problem_4->module~aoc_utilities program~problem_5 problem_5 program~problem_5->module~aoc_utilities program~problem_6 problem_6 program~problem_6->module~aoc_utilities program~problem_7 problem_7 program~problem_7->module~aoc_utilities program~problem_8 problem_8 program~problem_8->module~aoc_utilities program~problem_9 problem_9 program~problem_9->module~aoc_utilities Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: wp = real64 default real kind [8 bytes] integer, public, parameter :: ip = int64 default int kind integer, private, parameter :: chunk_size = 100 for dynamic allocations type( clock ), public :: clk a public clock to use for timing in the problems Interfaces public        interface sort private  subroutine sort_ascending (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_64 (ivec) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout), dimension(:) :: ivec public        interface parse private  function parse_nums64 (line) result(ints) parse space-deliminated ip sequence (positive or negative) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=ip), dimension(:), allocatable public        interface split private pure function split1 (str, token) result(vals) Split a character string using a token.\n  This routine is inspired by the Python split function. Example character ( len = :), allocatable :: s type ( string ), dimension (:), allocatable :: vals s = '1,2,3,4,5' call split ( s , ',' , vals ) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable private pure function split2 (s, token) result(vals) Split a string , given a token. Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: s character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable public        interface int private pure elemental function string_to_int (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer private pure function char_to_int (str) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer private pure function char_to_int64 (str, kind) result(i) Basic string to integer(ip) routine.\nHacky hack just so we can overload as int() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: kind Return Value integer(kind=ip) private pure function char_array_to_int (str_array) result(i) Character array to integer routine Arguments Type Intent Optional Attributes Name character(len=1), intent(in), dimension(:) :: str_array example ['1','3'] --> 13 Return Value integer public        interface unique private  function unique32 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec Return Value integer, dimension(:), allocatable private  function unique64 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: vec Return Value integer(kind=ip), dimension(:), allocatable public        interface startswith test if a string starts with a specified substring private pure function startswith_cc (str, substring) starts with function for strings Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_ss (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str type( string ), intent(in) :: substring Return Value logical private pure function startswith_sc (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_cs (str, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str type( string ), intent(in) :: substring Return Value logical public        interface swap private pure elemental subroutine swap32 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap64 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: i1 integer(kind=ip), intent(inout) :: i2 private pure elemental subroutine swap_str (i1, i2) Swap two character string values Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: i1 character(len=*), intent(inout) :: i2 public        interface manhatten_distance private pure function manhatten_distance_64 (x1, y1, x2, y2) Manhattan distance between two ip points. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: x1 integer(kind=ip), intent(in) :: y1 integer(kind=ip), intent(in) :: x2 integer(kind=ip), intent(in) :: y2 Return Value integer(kind=ip) Derived Types type, public :: clock Components Type Visibility Attributes Name Initial integer(kind=ip), private :: begin integer(kind=ip), private :: end integer(kind=ip), private :: rate Type-Bound Procedures procedure, public :: tic => clock_start procedure, public :: toc => clock_end type, public :: string a type containing an allocatable character string.\nso we can have an array of strings of different lengths. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: str Type-Bound Procedures procedure, public :: to_int => string_to_int convert to integer procedure, public :: to_int_64 => string_to_int_64 type, public :: int64_vec an type that contains an allocatable ip array.\nso we can have an array of these. Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(:), allocatable :: vals Functions private pure function char_to_int (str) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer private pure elemental function string_to_int (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer private pure elemental function string_to_int_64 (me) result(i) Basic string to integer routine Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: me Return Value integer(kind=ip) private pure function char_to_int64 (str, kind) result(i) Basic string to integer(ip) routine.\nHacky hack just so we can overload as int() Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: kind Return Value integer(kind=ip) private pure function char_array_to_int (str_array) result(i) Character array to integer routine Arguments Type Intent Optional Attributes Name character(len=1), intent(in), dimension(:) :: str_array example ['1','3'] --> 13 Return Value integer public pure function int_array_to_char_array (iarray) result(carray) integer array to Character array Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: iarray Return Value character(len=1), dimension(:,:), allocatable public  function read_file_to_char_array (filename, border) result(array) Read a file into a 2d character array. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=1), intent(in), optional :: border if true, extra border is added with this char Return Value character(len=1), dimension(:,:), allocatable public  function read_file_to_int_array (filename) result(array) Read a file into a 2d character array. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer, dimension(:,:), allocatable public  function read_file_to_integer_array (filename) result(iarray) Read a file into an integer array (one element per line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer, dimension(:), allocatable public  function read_file_to_integer64_array (filename) result(iarray) Read a file into an ip integer array (one element per line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer(kind=ip), dimension(:), allocatable public  function number_of_lines_in_file (iunit) result(n_lines) Returns the number of lines in a file (assumed to be open) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit the file unit number\n(assumed to be open) Return Value integer the number of lines in the file private pure function split2 (s, token) result(vals) Split a string , given a token. Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: s character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable private pure function split1 (str, token) result(vals) Split a character string using a token.\n  This routine is inspired by the Python split function. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: token Return Value type( string ), dimension(:), allocatable public  function read_line (iunit, status_ok) result(line) Reads the next line from a file. Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit logical, intent(out), optional :: status_ok true if no problems Return Value character(len=:), allocatable private  function unique32 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec Return Value integer, dimension(:), allocatable private  function unique64 (vec) result(vec_unique) Return only the unique values from vec. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: vec Return Value integer(kind=ip), dimension(:), allocatable public  function parse_ints (line) result(ints) parse positive ints from a string that also includes text Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer, dimension(:), allocatable public  function parse_ints64 (line) result(ints) Parse positive ints from a string that also includes text Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=ip), dimension(:), allocatable private  function parse_nums64 (line) result(ints) parse space-deliminated ip sequence (positive or negative) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer(kind=ip), dimension(:), allocatable private pure function startswith_cc (str, substring) starts with function for strings Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_ss (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str type( string ), intent(in) :: substring Return Value logical private pure function startswith_sc (str, substring) Arguments Type Intent Optional Attributes Name type( string ), intent(in) :: str character(len=*), intent(in) :: substring Return Value logical private pure function startswith_cs (str, substring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str type( string ), intent(in) :: substring Return Value logical public  function is_number (c) returns true if the character is a number from 0 to 9. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical public  function is_not_number (c) returns true if the character is not a number. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical public  function str_to_array (s) result(a) convert the character string to an array of characters Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value character(len=1), dimension(len(s)) public pure function lcm (i, j) LCM. based on code from NCAR Command Language Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value integer(kind=ip) public pure function reverse (ivals) result(ireverse) Reverse an ip vector Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals Return Value integer(kind=ip), dimension(size(ivals)) public pure function diff (ivals) result(idiff) Difference ip vector Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals Return Value integer(kind=ip), dimension(:), allocatable public  function parea (x, y, nb) given a sequence of nb points (x(i),y(i)). parea computes\nthe area bounded by the closed polygonal curve which passes\nthrough the points in the order that they are indexed. the\nfinal point of the curve is assumed to be the first point\ngiven. therefore, it need not be listed at the end of x and\ny. the curve is not required to be simple. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (nb) real(kind=wp), intent(in) :: y (nb) integer, intent(in) :: nb Return Value real(kind=wp) private pure function manhatten_distance_64 (x1, y1, x2, y2) Manhattan distance between two ip points. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: x1 integer(kind=ip), intent(in) :: y1 integer(kind=ip), intent(in) :: x2 integer(kind=ip), intent(in) :: y2 Return Value integer(kind=ip) public pure function str_to_int_array_with_mapping (str, ichars, iints) result(array) Convert a string to a numeric array by mapping characters to integers (user-specified) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=1), intent(in), dimension(:) :: ichars characters to process integer, intent(in), dimension(:) :: iints int values of the chars Return Value integer, dimension(:), allocatable public pure function str_to_int64_array_with_mapping (str, ichars, iints) result(array) Convert a string to a numeric array by mapping characters to integers (user-specified) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=1), intent(in), dimension(:) :: ichars characters to process integer(kind=ip), intent(in), dimension(:) :: iints int values of the chars Return Value integer(kind=ip), dimension(:), allocatable public pure function hex2int (hex) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: hex Return Value integer public pure function cross (r, v) result(c) Cross product of two real 3x1 vectors Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r real(kind=wp), intent(in), dimension(3) :: v Return Value real(kind=wp), dimension(3) Subroutines private  subroutine clock_start (me) Start the clock Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me private  subroutine clock_end (me, case_str) Print runtime in milliseconds form the start of the clock. Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: me character(len=*), intent(in) :: case_str description of the case private  subroutine sort_ascending (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_64 (ivec) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout), dimension(:) :: ivec private pure elemental subroutine swap32 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap64 (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(inout) :: i1 integer(kind=ip), intent(inout) :: i2 private pure elemental subroutine swap_str (i1, i2) Swap two character string values Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: i1 character(len=*), intent(inout) :: i2 private pure subroutine expand_vector (vec, n, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) public pure subroutine locpt (x0, y0, x, y, n, l, m) given a polygonal line connecting the vertices (x(i),y(i))\n  (i = 1,...,n) taken in this order. it is assumed that the\n  polygonal path is a loop, where (x(n),y(n)) = (x(1),y(1))\n  or there is an arc from (x(n),y(n)) to (x(1),y(1)). Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: y0 real(kind=wp), intent(in), dimension(n) :: x real(kind=wp), intent(in), dimension(n) :: y integer, intent(in) :: n integer, intent(out) :: l integer, intent(out) :: m public  subroutine inverse (a, ainv, status_ok) inverse of a 2x2 matrix. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2,2) :: a real(kind=wp), intent(out), dimension(2,2) :: ainv logical, intent(out) :: status_ok","tags":"","loc":"module/aoc_utilities.html"},{"title":"fmin_module – AoC-2023","text":"Module for fmin 1D derative-free function minimizer. License [BSD-3](https: Note The default real kind ( wp ) can be\n      changed using optional preprocessor flags.\n      This library was built with real kind: real(kind=real64) [8 bytes] Uses iso_fortran_env module~~fmin_module~~UsesGraph module~fmin_module fmin_module iso_fortran_env iso_fortran_env module~fmin_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~fmin_module~~UsedByGraph module~fmin_module fmin_module module~nlesolver_module nlesolver_module module~nlesolver_module->module~fmin_module program~test test program~test->module~fmin_module program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->module~nlesolver_module program~sparse_test sparse_test program~sparse_test->module~nlesolver_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: fmin_rk = real64 real kind used by this module [8 bytes] integer, private, parameter :: wp = fmin_rk local copy of fmin_rk with a shorter name Abstract Interfaces abstract interface private  function func(x) result(f) interface for user function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x indep. variable Return Value real(kind=wp) function value f(x) Functions public  function fmin (f, ax, bx, tol) result(xmin) An approximation x to the point where f attains a minimum on\n  the interval (ax,bx) is determined. Read more… Arguments Type Intent Optional Attributes Name procedure( func ) :: f the function to minimize real(kind=wp), intent(in) :: ax left endpoint of initial interval real(kind=wp), intent(in) :: bx right endpoint of initial interval real(kind=wp), intent(in) :: tol desired length of the interval of\nuncertainty of the final result (>=0) Return Value real(kind=wp) abcissa approximating the point where\nf attains a minimum","tags":"","loc":"module/fmin_module.html"},{"title":"numdiff_cache_module – AoC-2023","text":"For caching function evaluations. Uses numdiff_utilities_module iso_fortran_env numdiff_kinds_module module~~numdiff_cache_module~~UsesGraph module~numdiff_cache_module numdiff_cache_module iso_fortran_env iso_fortran_env module~numdiff_cache_module->iso_fortran_env module~numdiff_kinds_module numdiff_kinds_module module~numdiff_cache_module->module~numdiff_kinds_module module~numdiff_utilities_module numdiff_utilities_module module~numdiff_cache_module->module~numdiff_utilities_module module~numdiff_kinds_module->iso_fortran_env module~numdiff_utilities_module->module~numdiff_kinds_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~numdiff_cache_module~~UsedByGraph module~numdiff_cache_module numdiff_cache_module module~numerical_differentiation_module numerical_differentiation_module module~numerical_differentiation_module->module~numdiff_cache_module program~test1 test1 program~test1->module~numerical_differentiation_module program~test2 test2 program~test2->module~numerical_differentiation_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, private :: fx an [x,f(x)] cached pair. Components Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:), allocatable :: x vector of input values real(kind=wp), private, dimension(:), allocatable :: f vector of output functions f(x) note: only the elements indicated by ifs will have valid values. The others will\nbe dummy values. integer, private, dimension(:), allocatable :: ifs elements of f present in the cache\n(this is just an array of the indices\npresent in f ) type, public :: function_cache a vector function cache. Components Type Visibility Attributes Name Initial integer, private :: n = 0 size of x integer, private :: m = 0 size of f type( fx ), private, dimension(:), allocatable :: c the cache of f(x) integer, private :: chunk_size = 100 for resizing vectors\nin the unique function Type-Bound Procedures procedure, public :: initialize => initialize_cache procedure, public :: get => get_from_cache procedure, public :: put => put_in_cache procedure, public :: destroy => destroy_cache procedure, public :: print => print_cache Functions private pure function vector_djb_hash (r) result(hash) DJB hash algorithm for a real(wp) vector. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: r the vector Return Value integer(kind=ip) the hash value Subroutines private  subroutine initialize_cache (me, isize, n, m, chunk_size) Initialize the cache. Must be called first before use. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: isize the size of the hash table integer, intent(in) :: n number of independant variables (x) integer, intent(in) :: m number of functions (f) integer, intent(in), optional :: chunk_size chunk size to speed up reallocation\nof arrays. A good value is a guess for\nthe actual number of elements of f that\nwill be saved per value of x [default is 100] private  subroutine print_cache (me, iunit) Print the contents of the cache. Used for debugging. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: iunit file unit for writing\n(assumed to be opened) private  subroutine get_from_cache (me, x, ifs, i, f, xfound, ffound) Check if the x vector is in the cache, if so return f .\nNote that only some of the elements may be present, so it will return\nthe ones there are there, and indicate which ones were found. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x independant variable vector integer, intent(in), dimension(:) :: ifs elements of f needed integer, intent(out) :: i index in the hash table real(kind=wp), intent(out), dimension(:) :: f f(x) from the cache (if it was found) logical, intent(out) :: xfound if x was found in the cache logical, intent(out), dimension(size(ifs)) :: ffound which ifs were found in the cache private  subroutine put_in_cache (me, i, x, f, ifs) Put a value into the cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: i index in the hash table real(kind=wp), intent(in), dimension(:) :: x independant variable vector (dimension n ) real(kind=wp), intent(in), dimension(:) :: f function vector f(x) (dimension m ) integer, intent(in), dimension(:) :: ifs elements of f to add (should all be >0, <=m ) private  subroutine destroy_cache (me) Destroy a cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(out) :: me","tags":"","loc":"module/numdiff_cache_module.html"},{"title":"dag_module – AoC-2023","text":"DAG Module. Used by module~~dag_module~~UsedByGraph module~dag_module dag_module program~dag_example dag_example program~dag_example->module~dag_module program~problem_25 problem_25 program~problem_25->module~dag_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, private :: vertex a vertex of a directed acyclic graph (DAG) Components Type Visibility Attributes Name Initial integer, private, dimension(:), allocatable :: edges these are the vertices that this vertex depends on integer, private :: ivertex = 0 vertex number logical, private :: checking = .false. used for toposort logical, private :: marked = .false. used for toposort character(len=:), private, allocatable :: label used for diagraph character(len=:), private, allocatable :: attributes used for diagraph Type-Bound Procedures generic, public :: set_edges => set_edge_vector , add_edge procedure, public :: set_edge_vector procedure, public :: add_edge type, public :: dag a directed acyclic graph (DAG) Components Type Visibility Attributes Name Initial integer, private :: n = 0 number of vertices type( vertex ), private, dimension(:), allocatable :: vertices the vertices in the DAG. Type-Bound Procedures procedure, public :: set_vertices => dag_set_vertices procedure, public :: set_edges => dag_set_edges procedure, public :: set_vertex_info => dag_set_vertex_info procedure, public :: toposort => dag_toposort procedure, public :: generate_digraph => dag_generate_digraph procedure, public :: generate_dependency_matrix => dag_generate_dependency_matrix procedure, public :: save_digraph => dag_save_digraph procedure, public :: get_edges => dag_get_edges procedure, public :: get_dependencies => dag_get_dependencies procedure, public :: destroy => dag_destroy Functions private pure function dag_get_edges (me, ivertex) result(edges) get the edges for the vertex (all the the vertices\nthat this vertex depends on). Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer, intent(in) :: ivertex Return Value integer, dimension(:), allocatable private pure function dag_get_dependencies (me, ivertex) result(dep) get all the vertices that depend on this vertex. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer, intent(in) :: ivertex Return Value integer, dimension(:), allocatable the set of all vertices\nthan depend on ivertex private  function dag_generate_digraph (me, rankdir, dpi) result(str) Generate a Graphviz digraph structure for the DAG. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer, intent(in), optional :: dpi resolution (e.g. 300) Return Value character(len=:), allocatable private pure function integer_to_string (i) result(s) Integer to allocatable string. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=:), allocatable Subroutines private  subroutine dag_destroy (me) Destroy the dag . Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me private  subroutine set_edge_vector (me, edges) specify the edge indices for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in), dimension(:) :: edges private  subroutine add_edge (me, edge) add an edge index for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in) :: edge private  subroutine dag_set_vertices (me, nvertices) set the number of vertices in the dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: nvertices number of vertices private  subroutine dag_set_vertex_info (me, ivertex, label, attributes) set info about a vertex in a dag. Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: ivertex vertex number character(len=*), intent(in), optional :: label if a label is not set,\nthen the integer vertex\nnumber is used. character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. private  subroutine dag_set_edges (me, ivertex, edges) set the edges for a vertex in a dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: ivertex vertex number integer, intent(in), dimension(:) :: edges private  subroutine dag_toposort (me, order, istat) Main toposort routine Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: order the toposort order integer, intent(out) :: istat Status flag: Read more… private  subroutine dag_generate_dependency_matrix (me, mat) Generate the dependency matrix for the DAG. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me logical, intent(out), dimension(:,:), allocatable :: mat dependency matrix private  subroutine dag_save_digraph (me, filename, rankdir, dpi) Generate a Graphviz digraph structure for the DAG and write it to a file. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: filename file name for diagraph character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer, intent(in), optional :: dpi resolution (e.g. 300)","tags":"","loc":"module/dag_module.html"},{"title":"numdiff_kinds_module – AoC-2023","text":"Numeric kinds for NumDiff. Note The default real kind ( wp ) can be\n      changed using optional preprocessor flags.\n      This library was built with real kind: real(kind=real64) [8 bytes] Uses iso_fortran_env module~~numdiff_kinds_module~~UsesGraph module~numdiff_kinds_module numdiff_kinds_module iso_fortran_env iso_fortran_env module~numdiff_kinds_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~numdiff_kinds_module~~UsedByGraph module~numdiff_kinds_module numdiff_kinds_module module~diff_module diff_module module~diff_module->module~numdiff_kinds_module module~dsm_module dsm_module module~dsm_module->module~numdiff_kinds_module module~numdiff_cache_module numdiff_cache_module module~numdiff_cache_module->module~numdiff_kinds_module module~numdiff_utilities_module numdiff_utilities_module module~numdiff_cache_module->module~numdiff_utilities_module module~numdiff_utilities_module->module~numdiff_kinds_module module~numerical_differentiation_module numerical_differentiation_module module~numerical_differentiation_module->module~numdiff_kinds_module module~numerical_differentiation_module->module~diff_module module~numerical_differentiation_module->module~dsm_module module~numerical_differentiation_module->module~numdiff_cache_module module~numerical_differentiation_module->module~numdiff_utilities_module program~dsm_test dsm_test program~dsm_test->module~numdiff_kinds_module program~dsm_test->module~dsm_module program~test1 test1 program~test1->module~numdiff_kinds_module program~test1->module~numerical_differentiation_module program~test2 test2 program~test2->module~numdiff_kinds_module program~test2->module~numerical_differentiation_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: wp = real64 default real kind [8 bytes]","tags":"","loc":"module/numdiff_kinds_module.html"},{"title":"nlesolver_module – AoC-2023","text":"A basic multidimensional nonlinear equation solver, using a Newton-Raphson type direct method. Features Works with square, under-determined, or over-determined systems. Uses LAPACK routines ( dgesv or dgels ) to solve the linear system. Has a Broyden update option. Has various line search options. References https: http: http: http: Author Jacob Williams License BSD-3 Todo add an istat output to func and grad, for user stopping\n      or to take a smaller stop (if istat>0 take a smaller step, if istat<0 abort) Note The default real kind ( wp ) can be\n      changed using optional preprocessor flags.\n      This library was built with real kind: real(kind=real64) [8 bytes] Uses fmin_module iso_fortran_env module~~nlesolver_module~~UsesGraph module~nlesolver_module nlesolver_module iso_fortran_env iso_fortran_env module~nlesolver_module->iso_fortran_env module~fmin_module fmin_module module~nlesolver_module->module~fmin_module module~fmin_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~nlesolver_module~~UsedByGraph module~nlesolver_module nlesolver_module program~nlesolver_test_1 nlesolver_test_1 program~nlesolver_test_1->module~nlesolver_module program~sparse_test sparse_test program~sparse_test->module~nlesolver_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: nlesolver_rk = real64 real kind used by this module [8 bytes] integer, private, parameter :: wp = nlesolver_rk local copy of nlesolver_rk with a shorter name real(kind=wp), private, parameter :: zero = 0.0_wp real(kind=wp), private, parameter :: one = 1.0_wp real(kind=wp), private, parameter :: two = 2.0_wp real(kind=wp), private, parameter :: eps = epsilon(one) machine real(kind=wp), private, parameter :: big = huge(one) Abstract Interfaces abstract interface private  subroutine func_func(me, x, f) compute the function Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: f abstract interface private  subroutine grad_func(me, x, g) compute the gradient of the function (Jacobian). Dense version. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:,:) :: g abstract interface private  subroutine grad_func_sparse(me, x, g) compute the gradient of the function (Jacobian). Sparse version. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: g sparse jacobian. length is n_nonzeros abstract interface private  subroutine export_func(me, x, f, iter) export an iteration: Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: f integer, intent(in) :: iter iteration number abstract interface private  subroutine wait_func(me, user_stop) enable a user-triggered stop of the iterations: Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me logical, intent(out) :: user_stop abstract interface private  subroutine linesearch_func(me, xold, p, x, f, fvec, fjac, fjac_sparse) line search method. Note that not all inputs/outputs are\nused by all methods. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: xold previous value of x real(kind=wp), intent(in), dimension(me%n) :: p search direction real(kind=wp), intent(out), dimension(me%n) :: x new x real(kind=wp), intent(inout) :: f real(kind=wp), intent(inout), dimension(me%m) :: fvec real(kind=wp), intent(in), optional, dimension(:,:) :: fjac jacobian matrix [dense] real(kind=wp), intent(in), optional, dimension(:) :: fjac_sparse jacobian matrix [sparse] Derived Types type, public :: nlesolver_type Nonlinear equations solver class. Components Type Visibility Attributes Name Initial integer, private :: n = 0 number of opt vars integer, private :: m = 0 number of constraints integer, private :: max_iter = 100 maximum number of iterations real(kind=wp), private :: tol = 1.0e-6_wp convergence tolerance for function values real(kind=wp), private :: alpha = 1.0_wp step length (when specified constant) real(kind=wp), private :: alpha_min = 0.1_wp minimum step length (when allowed to vary) real(kind=wp), private :: alpha_max = 1.0_wp maximum step length (when allowed to vary) real(kind=wp), private :: tolx = 1.0e-8_wp convergence tolerance for x real(kind=wp), private :: c = 0.5_wp backtracking linesearch parameter (0,1) real(kind=wp), private :: tau = 0.5_wp backtracking linesearch parameter (0,1) real(kind=wp), private :: fmin_tol = 1.0e-5_wp tolerance for \"exact\" linesearch integer, private :: n_intervals = 2 number of intervals for fixed point linesearch logical, private :: use_broyden = .false. if true, a Broyden update is used\nrather than computing the Jacobian\nat every step. The grad function is\nonly called for the initial evaluation. integer, private :: broyden_update_n = 4 if this value is >0 , the Broyden update\nis computed at most this many times before\nthe full Jacobian is recomputed. integer, private :: n_uphill_max = 5 maximum number of consecutive steps\nto allow where the value of f increases logical, private :: verbose = .false. verbose output printing integer, private :: iunit = output_unit output unit for printing (assumed to be open). character(len=:), private, allocatable :: message latest status message integer, private :: istat = -999 latest status message procedure( func_func ), private, pointer :: func => null() user-supplied routine to compute the function procedure( export_func ), private, pointer :: export_iteration => null() user-supplied routine to export iterations procedure( wait_func ), private, pointer :: user_input_check => null() user-supplied routine to enable user to stop iterations procedure( linesearch_func ), private, pointer :: linesearch => null() line search method (determined by step_mode user input in initialize ) integer, private :: sparsity_mode = 1 sparsity mode: Read more… integer, private :: n_nonzeros = -1 number of nonzero Jacobian elements (used for sparsity_mode > 1 ) integer, private, dimension(:), allocatable :: irow sparsity pattern nonzero elements row indices. integer, private, dimension(:), allocatable :: icol sparsity pattern nonzero elements column indices real(kind=wp), private :: atol = zero relative error in definition of A real(kind=wp), private :: btol = zero relative error in definition of b real(kind=wp), private :: conlim = zero An upper limit on cond(Abar) , the apparent\ncondition number of the matrix Abar . integer, private :: itnlim = 100 max iterations integer, private :: nout = 0 output unit for printing real(kind=wp), private :: damp = zero damp parameter for LSQR integer, private :: lusol_method = 0 procedure( grad_func ), private, pointer :: grad => null() user-supplied routine to compute the gradient of the function (dense version) procedure( grad_func_sparse ), private, pointer :: grad_sparse => null() user-supplied routine to compute the gradient of the function (sparse version) Type-Bound Procedures procedure, public :: initialize => initialize_nlesolver_variables procedure, public :: solve => nlesolver_solver procedure, public :: destroy => destroy_nlesolver_variables procedure, public :: status => get_status procedure, private :: set_status Subroutines private  subroutine set_status (me, istat, string, i, r) Set status flag and message. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me integer, intent(in) :: istat status code character(len=*), intent(in) :: string status message integer, intent(in), optional :: i an integer value to append real(kind=wp), intent(in), optional :: r a real value to append private  subroutine get_status (me, istat, message) Return the status code and message from the nlesolver_type class. Read more… Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me integer, intent(out), optional :: istat Integer status code. character(len=:), intent(out), optional, allocatable :: message Text status message private  subroutine initialize_nlesolver_variables (me, n, m, max_iter, tol, alpha, alpha_min, alpha_max, tolx, fmin_tol, backtrack_c, backtrack_tau, use_broyden, broyden_update_n, step_mode, func, grad, grad_sparse, export_iteration, user_input_check, verbose, iunit, n_uphill_max, n_intervals, sparsity_mode, irow, icol, atol, btol, conlim, damp, itnlim, nout, lusol_method) Constructor for the class. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me integer, intent(in) :: n number of optimization variables integer, intent(in) :: m number of constraints integer, intent(in) :: max_iter maximum number of iterations real(kind=wp), intent(in) :: tol function convergence tolerance real(kind=wp), intent(in), optional :: alpha constant step length for step_mode=1 (0,1] real(kind=wp), intent(in), optional :: alpha_min minimum step length (0,1] real(kind=wp), intent(in), optional :: alpha_max maximum step length (0,1] real(kind=wp), intent(in), optional :: tolx convergence tolerance for changes in x real(kind=wp), intent(in), optional :: fmin_tol convergence tolerance for fmin (used when step_mode=3 ) real(kind=wp), intent(in), optional :: backtrack_c backtracking linesearch parameter (0,1) real(kind=wp), intent(in), optional :: backtrack_tau backtracking linesearch parameter (0,1) logical, intent(in), optional :: use_broyden use a Broyden update (default is False) integer, intent(in), optional :: broyden_update_n For Broyden mode, update the full Jacobian\nat most every this many iterations (must be >1)\nIf <=1 then Jacobian is only computed on the\nfirst iteration. integer, intent(in), optional :: step_mode step mode: Read more… procedure( func_func ) :: func computes the function vector procedure( grad_func ), optional :: grad computes the jacobian [required for dense mode: sparsity_mode=1 ] procedure( grad_func_sparse ), optional :: grad_sparse computes the jacobian [required for sparse mode: sparsity_mode>1 ] procedure( export_func ), optional :: export_iteration function to export each iteration procedure( wait_func ), optional :: user_input_check check for user input (to stop solver if necessary) logical, intent(in), optional :: verbose for verbose status printing integer, intent(in), optional :: iunit unit for verbose printing (assumed to be open).\nby default this is output_unit . integer, intent(in), optional :: n_uphill_max maximum number of consecutive steps\nto allow where the value of f increases integer, intent(in), optional :: n_intervals number of intervals for fixed point linesearch integer, intent(in), optional :: sparsity_mode sparsity mode: Read more… integer, intent(in), optional, dimension(:) :: irow sparsity pattern nonzero elements row indices.\nmust be specified with icol and be the same length ( n_nonzeros ). integer, intent(in), optional, dimension(:) :: icol sparsity pattern nonzero elements column indices\nmust be specified with icol and be the same length ( n_nonzeros ). real(kind=wp), intent(in), optional :: atol LSQR: relative error in definition of A real(kind=wp), intent(in), optional :: btol LSQR: relative error in definition of b real(kind=wp), intent(in), optional :: conlim condition number of the matrix Abar . real(kind=wp), intent(in), optional :: damp LSQR: damp factor integer, intent(in), optional :: itnlim LSQR: max iterations integer, intent(in), optional :: nout LSQR: output unit for printing integer, intent(in), optional :: lusol_method private  subroutine nlesolver_solver (me, x) Main solver. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x private  subroutine destroy_nlesolver_variables (me) Destructor Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(out) :: me private  subroutine linear_solver (m, n, a, b, x, info) Solve the linear system: , using a dense, direct method. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m number of rows in a integer, intent(in) :: n number of columns in a real(kind=wp), intent(in), dimension(m,n) :: a A matrix of the linear system real(kind=wp), intent(in), dimension(m) :: b RHS of the linear system real(kind=wp), intent(out), dimension(n) :: x the solution of the linear system. integer, intent(out) :: info output status flag ( =0 if success) private  subroutine simple_step (me, xold, p, x, f, fvec, fjac, fjac_sparse) Take a simple step in the search direction of p * alpha . Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: xold previous value of x real(kind=wp), intent(in), dimension(me%n) :: p search direction real(kind=wp), intent(out), dimension(me%n) :: x new x real(kind=wp), intent(inout) :: f magnitude of fvec real(kind=wp), intent(inout), dimension(me%m) :: fvec function vector real(kind=wp), intent(in), optional, dimension(:,:) :: fjac jacobian matrix [dense] real(kind=wp), intent(in), optional, dimension(:) :: fjac_sparse jacobian matrix [sparse] private  subroutine backtracking_linesearch (me, xold, p, x, f, fvec, fjac, fjac_sparse) Backtracking line search. Read more… Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: xold previous value of x real(kind=wp), intent(in), dimension(me%n) :: p search direction real(kind=wp), intent(out), dimension(me%n) :: x new x real(kind=wp), intent(inout) :: f magnitude of fvec real(kind=wp), intent(inout), dimension(me%m) :: fvec function vector real(kind=wp), intent(in), optional, dimension(:,:) :: fjac jacobian matrix [dense] real(kind=wp), intent(in), optional, dimension(:) :: fjac_sparse jacobian matrix [sparse] private  subroutine exact_linesearch (me, xold, p, x, f, fvec, fjac, fjac_sparse) An exact linesearch that uses a derivative-free minimizer to\nfind the minimum value of f(x) between x = xold + p * alpha_min and x = xold + p * alpha_max . Read more… Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: xold previous value of x real(kind=wp), intent(in), dimension(me%n) :: p search direction real(kind=wp), intent(out), dimension(me%n) :: x new x real(kind=wp), intent(inout) :: f magnitude of fvec real(kind=wp), intent(inout), dimension(me%m) :: fvec function vector real(kind=wp), intent(in), optional, dimension(:,:) :: fjac jacobian matrix [dense] real(kind=wp), intent(in), optional, dimension(:) :: fjac_sparse jacobian matrix [sparse] private  subroutine fixed_point_linesearch (me, xold, p, x, f, fvec, fjac, fjac_sparse) A simple search that just evaluates the function at a specified\nnumber of points and picks the one with the minimum function value. Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: xold previous value of x real(kind=wp), intent(in), dimension(me%n) :: p search direction real(kind=wp), intent(out), dimension(me%n) :: x new x real(kind=wp), intent(inout) :: f magnitude of fvec real(kind=wp), intent(inout), dimension(me%m) :: fvec function vector real(kind=wp), intent(in), optional, dimension(:,:) :: fjac jacobian matrix [dense] real(kind=wp), intent(in), optional, dimension(:) :: fjac_sparse jacobian matrix [sparse]","tags":"","loc":"module/nlesolver_module.html"},{"title":"numdiff_utilities_module – AoC-2023","text":"Utility routines. Uses numdiff_kinds_module module~~numdiff_utilities_module~~UsesGraph module~numdiff_utilities_module numdiff_utilities_module module~numdiff_kinds_module numdiff_kinds_module module~numdiff_utilities_module->module~numdiff_kinds_module iso_fortran_env iso_fortran_env module~numdiff_kinds_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~numdiff_utilities_module~~UsedByGraph module~numdiff_utilities_module numdiff_utilities_module module~numdiff_cache_module numdiff_cache_module module~numdiff_cache_module->module~numdiff_utilities_module module~numerical_differentiation_module numerical_differentiation_module module~numerical_differentiation_module->module~numdiff_utilities_module module~numerical_differentiation_module->module~numdiff_cache_module program~test1 test1 program~test1->module~numerical_differentiation_module program~test2 test2 program~test2->module~numerical_differentiation_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: max_size_for_insertion_sort = 20 max size for using insertion sort. Interfaces public        interface expand_vector private pure subroutine expand_vector_int (vec, n, chunk_size, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) private pure subroutine expand_vector_real (vec, n, chunk_size, val, finished) Add elements to the real vector in chunks. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) real(kind=wp), intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) public        interface unique private  function unique_int (vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value integer, dimension(:), allocatable unique elements of ivec private  function unique_real (vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value real(kind=wp), dimension(:), allocatable unique elements of ivec public        interface sort_ascending private  subroutine sort_ascending_int (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_real (ivec) Sorts a real array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: ivec private        interface swap private pure elemental subroutine swap_int (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap_real (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: i1 real(kind=wp), intent(inout) :: i2 Functions private  function unique_int (vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value integer, dimension(:), allocatable unique elements of ivec private  function unique_real (vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector (sorted in ascending order). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value real(kind=wp), dimension(:), allocatable unique elements of ivec public pure function equal_within_tol (vals, tol) result(equal) Returns true if the values in the array are the same\n(to within the specified absolute tolerance). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: vals a set of values real(kind=wp), intent(in) :: tol a positive tolerance value Return Value logical true if they are equal\nwithin the tolerance public  function divide_interval (num_points) result(points) Returns a set of slightly randomized equally-spaced\n  points that divide an interval. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_points the number of points in the interval Return Value real(kind=wp), dimension(:), allocatable the resultant vector Subroutines private pure subroutine expand_vector_int (vec, n, chunk_size, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) private pure subroutine expand_vector_real (vec, n, chunk_size, val, finished) Add elements to the real vector in chunks. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) real(kind=wp), intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) private  subroutine sort_ascending_int (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private  subroutine sort_ascending_real (ivec) Sorts a real array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: ivec private pure elemental subroutine swap_int (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 private pure elemental subroutine swap_real (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: i1 real(kind=wp), intent(inout) :: i2","tags":"","loc":"module/numdiff_utilities_module.html"},{"title":"dsm_module – AoC-2023","text":"Jacobian partitioning using the DSM algorithm. Reference Argonne National Laboratory. MINPACK Project. July 1983.\n    Thomas F. Coleman, Burton S. Garbow, Jorge J. More Thomas F. Coleman, Burton S. Garbow, Jorge J. More, \"Algorithm 618:\n    FORTRAN subroutines for estimating sparse Jacobian Matrices\",\n    ACM Transactions on Mathematical Software (TOMS),\n    Volume 10 Issue 3, Sept. 1984, Pages 346-347 History Jacob Williams, Nov. 2016, extensive refactoring into modern Fortran. Uses numdiff_kinds_module module~~dsm_module~~UsesGraph module~dsm_module dsm_module module~numdiff_kinds_module numdiff_kinds_module module~dsm_module->module~numdiff_kinds_module iso_fortran_env iso_fortran_env module~numdiff_kinds_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~dsm_module~~UsedByGraph module~dsm_module dsm_module module~numerical_differentiation_module numerical_differentiation_module module~numerical_differentiation_module->module~dsm_module program~dsm_test dsm_test program~dsm_test->module~dsm_module program~test1 test1 program~test1->module~numerical_differentiation_module program~test2 test2 program~test2->module~numerical_differentiation_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine dsm (m, n, npairs, indrow, indcol, ngrp, maxgrp, mingrp, info, ipntr, jpntr) The purpose of dsm is to determine an optimal or near-\noptimal consistent partition of the columns of a sparse m by n matrix a . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m number of rows of a (>0) integer, intent(in) :: n number of columns of a (>0) integer, intent(in) :: npairs number of ( indrow , indcol ) pairs used\nto describe the sparsity pattern of a (>0) integer, intent(inout), dimension(npairs) :: indrow an integer array of length npairs . on input indrow must contain the row indices of the non-zero elements of a .\non output indrow is permuted so that the corresponding\ncolumn indices are in non-decreasing order. the column\nindices can be recovered from the array jpntr . integer, intent(inout), dimension(npairs) :: indcol an integer array of length npairs . on input indcol must contain the column indices of the non-zero elements of a . on output indcol is permuted so that the corresponding\nrow indices are in non-decreasing order. the row indices\ncan be recovered from the array ipntr . integer, intent(out), dimension(n) :: ngrp specifies the partition of the columns of a .\ncolumn jcol belongs to group ngrp(jcol) . integer, intent(out) :: maxgrp the number of groups in the partition\nof the columns of a . integer, intent(out) :: mingrp a lower bound for the number of groups\nin any consistent partition of the\ncolumns of a . integer, intent(out) :: info for normal termination info = 1 .\nif m , n , or npairs is not positive,\nthen info = 0 . if the k-th element of indrow is not an integer between\n1 and m or the k-th element of indcol is not an integer between 1 and n,\nthen info = -k . integer, intent(out), dimension(m+1) :: ipntr an integer output array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 .\nnote that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(out), dimension(n+1) :: jpntr jpntr is an integer output array of length n + 1 which\nspecifies the locations of the row indices in indrow.\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 .\nnote that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . private  subroutine degr (n, indrow, jpntr, indcol, ipntr, ndeg, iwa) Given the sparsity pattern of an m by n matrix a ,\n  this subroutine determines the degree sequence for\n  the intersection graph of the columns of a . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a . integer, intent(in), dimension(*) :: indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, intent(in), dimension(n+1) :: jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(in), dimension(*) :: indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, intent(in), dimension(*) :: ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(out), dimension(n) :: ndeg an integer output array of length n which\nspecifies the degree sequence. the degree of the j -th column of a is ndeg(j) . integer, dimension(n) :: iwa an integer work array of length n private  subroutine ido (m, n, Indrow, Jpntr, Indcol, Ipntr, Ndeg, List, Maxclq, Iwa1, Iwa2, Iwa3, Iwa4) given the sparsity pattern of an m by n matrix a , this\nsubroutine determines an incidence-degree ordering of the\ncolumns of a . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of a . integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a . integer, intent(in), dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, intent(in), dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(in), dimension(*) :: Indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, intent(in), dimension(m+1) :: Ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, intent(in), dimension(n) :: Ndeg an integer input array of length n which specifies\nthe degree sequence. the degree of the j -th column\nof a is ndeg(j) . integer, intent(out), dimension(n) :: List an integer output array of length n which specifies\nthe incidence-degree ordering of the columns of a . the j -th\ncolumn in this order is list(j) . integer, intent(out) :: Maxclq an integer output variable set to the size\nof the largest clique found during the ordering. integer, dimension(0:n-1) :: Iwa1 integer work array of length n . integer, dimension(n) :: Iwa2 integer work array of length n . integer, dimension(n) :: Iwa3 integer work array of length n . integer, dimension(n) :: Iwa4 integer work array of length n . private  subroutine numsrt (n, Nmax, Num, Mode, Index, Last, Next) Given a sequence of integers, this subroutine groups\n  together those indices with the same sequence value\n  and, optionally, sorts the sequence into either\n  ascending or descending order. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable. integer :: Nmax a positive integer input variable. integer, dimension(n) :: Num an input array of length n which contains the\nsequence of integers to be grouped and sorted. it\nis assumed that the integers are each from the set 0,1,...,nmax . integer :: Mode an integer input variable. the sequence num is\nsorted in ascending order if mode is positive and in\ndescending order if mode is negative. if mode is 0,\nno sorting is done. integer, dimension(n) :: Index an integer output array of length n set so\nthat the sequence num(index(i)), i = 1,2,...,n is sorted according to the setting of mode.\nif mode is 0, index is not referenced. integer, dimension(0:Nmax) :: Last an integer output array of length nmax + 1 . the\nindex of num for the last occurrence of l is last(l) for any l = 0,1,...,nmax unless last(l) = 0 . in\nthis case l does not appear in num . integer, dimension(n) :: Next an integer output array of length n . if num(k) = l , then the index of num for the previous\noccurrence of l is next(k) for any l = 0,1,...,nmax unless next(k) = 0 . in this case there is no previous\noccurrence of l in num . private  subroutine seq (n, Indrow, Jpntr, Indcol, Ipntr, List, Ngrp, Maxgrp, Iwa) given the sparsity pattern of an m by n matrix a , this\nsubroutine determines a consistent partition of the\ncolumns of a by a sequential algorithm. Read more… Arguments Type Intent Optional Attributes Name integer :: n a positive integer input variable set to the number\nof columns of a . integer, dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(*) :: Indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, dimension(*) :: Ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(n) :: List an integer input array of length n which specifies\nthe order to be used by the sequential algorithm.\nthe j -th column in this order is list(j) . integer, dimension(n) :: Ngrp an integer output array of length n which specifies\nthe partition of the columns of a . column jcol belongs\nto group ngrp(jcol) . integer :: Maxgrp an integer output variable which specifies the\nnumber of groups in the partition of the columns of a . integer, dimension(n) :: Iwa an integer work array of length n private  subroutine setr (m, n, Indrow, Jpntr, Indcol, Ipntr, Iwa) given a column-oriented definition of the sparsity pattern\nof an m by n matrix a , this subroutine determines a\nrow-oriented definition of the sparsity pattern of a . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of a . integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a . integer, dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(*) :: Indcol an integer output array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, dimension(m+1) :: Ipntr an integer output array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(1) is set to 1 and that ipntr(m+1)-1 is\nthen the number of non-zero elements of the matrix a . integer, dimension(m) :: Iwa an integer work array of length m . private  subroutine slo (n, Indrow, Jpntr, Indcol, Ipntr, Ndeg, List, Maxclq, Iwa1, Iwa2, Iwa3, Iwa4) given the sparsity pattern of an m by n matrix a , this\nsubroutine determines the smallest-last ordering of the\ncolumns of a . Read more… Arguments Type Intent Optional Attributes Name integer :: n a positive integer input variable set to the number\nof columns of a . integer, dimension(*) :: Indrow an integer input array which contains the row\nindices for the non-zeroes in the matrix a . integer, dimension(n+1) :: Jpntr an integer input array of length n + 1 which\nspecifies the locations of the row indices in indrow .\nthe row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(n+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(*) :: Indcol an integer input array which contains the\ncolumn indices for the non-zeroes in the matrix a . integer, dimension(*) :: Ipntr an integer input array of length m + 1 which\nspecifies the locations of the column indices in indcol .\nthe column indices for row i are indcol(k), k = ipntr(i),...,ipntr(i+1)-1 . note that ipntr(m+1)-1 is then the number of non-zero\nelements of the matrix a . integer, dimension(n) :: Ndeg an integer input array of length n which specifies\nthe degree sequence. the degree of the j -th column\nof a is ndeg(j) . integer, dimension(n) :: List an integer output array of length n which specifies\nthe smallest-last ordering of the columns of a . the j -th\ncolumn in this order is list(j) . integer :: Maxclq an integer output variable set to the size\nof the largest clique found during the ordering. integer, dimension(0:n-1) :: Iwa1 integer work array of length n integer, dimension(n) :: Iwa2 integer work array of length n integer, dimension(n) :: Iwa3 integer work array of length n integer, dimension(n) :: Iwa4 integer work array of length n private  subroutine srtdat (n, Nnz, Indrow, Indcol, Jpntr, Iwa) given the non-zero elements of an m by n matrix a in\narbitrary order as specified by their row and column\nindices, this subroutine permutes these elements so\nthat their column indices are in non-decreasing order. Read more… Arguments Type Intent Optional Attributes Name integer :: n a positive integer input variable set to the number\nof columns of a . integer :: Nnz a positive integer input variable set to the number\nof non-zero elements of a . integer, dimension(Nnz) :: Indrow an integer array of length nnz . on input indrow must contain the row indices of the non-zero elements of a .\non output indrow is permuted so that the corresponding\ncolumn indices of indcol are in non-decreasing order. integer, dimension(Nnz) :: Indcol an integer array of length nnz . on input indcol must contain the column indices of the non-zero elements\nof a . on output indcol is permuted so that these indices\nare in non-decreasing order. integer, dimension(n+1) :: Jpntr an integer output array of length n + 1 which\nspecifies the locations of the row indices in the output indrow . the row indices for column j are indrow(k), k = jpntr(j),...,jpntr(j+1)-1 . note that jpntr(1) is set to 1 and that jpntr(n+1)-1 is then nnz . integer, dimension(n) :: Iwa an integer work array of length n . public  subroutine fdjs (m, n, Col, Ind, Npntr, Ngrp, Numgrp, d, Fjacd, Fjac) Given a consistent partition of the columns of an m by n jacobian matrix into groups, this subroutine computes\n  approximations to those columns in a given group.  the\n  approximations are stored into either a column-oriented\n  or a row-oriented pattern. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of the jacobian matrix. integer, intent(in) :: n a positive integer input variable set to the number\nof columns of the jacobian matrix. logical, intent(in) :: Col a logical input variable. if col is set true, then the\njacobian approximations are stored into a column-oriented\npattern. if col is set false, then the jacobian\napproximations are stored into a row-oriented pattern. integer, dimension(*) :: Ind an integer input array which contains the row\nindices for the non-zeroes in the jacobian matrix\nif col is true, and contains the column indices for\nthe non-zeroes in the jacobian matrix if col is false. integer, dimension(*) :: Npntr an integer input array which specifies the\nlocations of the row indices in ind if col is true, and\nspecifies the locations of the column indices in ind if col is false. if col is true, the indices for column j are ind(k), k = npntr(j),...,npntr(j+1)-1 .\nif col is false, the indices for row i are ind(k), k = npntr(i),...,npntr(i+1)-1 . Note that npntr(n+1)-1 if col is true, or npntr(m+1)-1 if col is false, is then the number of non-zero elements\nof the jacobian matrix. integer, dimension(n) :: Ngrp an integer input array of length n which specifies\nthe partition of the columns of the jacobian matrix.\ncolumn jcol belongs to group ngrp(jcol) . integer :: Numgrp a positive integer input variable set to a group\nnumber in the partition. the columns of the jacobian\nmatrix in this group are to be estimated on this call. real(kind=wp), dimension(n) :: d an input array of length n which contains the\ndifference parameter vector for the estimate of\nthe jacobian matrix columns in group numgrp . real(kind=wp), dimension(m) :: Fjacd an input array of length m which contains\nan approximation to the difference vector jac*d ,\nwhere jac denotes the jacobian matrix. real(kind=wp), dimension(*) :: Fjac an output array of length nnz , where nnz is the\nnumber of its non-zero elements. at each call of fdjs , fjac is updated to include the non-zero elements of the\njacobian matrix for those columns in group numgrp . fjac should not be altered between successive calls to fdjs .","tags":"","loc":"module/dsm_module.html"},{"title":"lsqpblas_module – AoC-2023","text":"this file contains BLAS routines required by subroutines LSQR and acheck . History Jacob Williams : 11/8/2019 : using modernized versions of these routines. Uses lsqr_kinds module~~lsqpblas_module~~UsesGraph module~lsqpblas_module lsqpblas_module module~lsqr_kinds lsqr_kinds module~lsqpblas_module->module~lsqr_kinds iso_fortran_env iso_fortran_env module~lsqr_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~lsqpblas_module~~UsedByGraph module~lsqpblas_module lsqpblas_module module~lsqr_module lsqr_module module~lsqr_module->module~lsqpblas_module module~lsqrtest_module lsqrtest_module module~lsqrtest_module->module~lsqpblas_module module~lsqrtest_module->module~lsqr_module proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver proc~nlesolver_solver->module~lsqr_module program~main~2 main program~main~2->module~lsqrtest_module program~main~3 main program~main~3->module~lsqr_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public  function ddot (n, dx, incx, dy, incy) dot product of two vectors Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: dx (*) integer :: incx real(kind=wp) :: dy (*) integer :: incy Return Value real(kind=wp) public  function dnrm2 (n, x, incx) euclidean norm of a vector. Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: x (*) integer :: incx Return Value real(kind=wp) Subroutines public  subroutine dcopy (n, dx, incx, dy, incy) copies a vector, x , to a vector, y . Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: dx (*) integer :: incx real(kind=wp) :: dy (*) integer :: incy public  subroutine dscal (n, da, dx, incx) scales a vector by a constant. Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: da real(kind=wp) :: dx (*) integer :: incx","tags":"","loc":"module/lsqpblas_module.html"},{"title":"lusol_precision – AoC-2023","text":"Uses iso_fortran_env module~~lusol_precision~~UsesGraph module~lusol_precision lusol_precision iso_fortran_env iso_fortran_env module~lusol_precision->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~lusol_precision~~UsedByGraph module~lusol_precision lusol_precision module~lusol lusol module~lusol->module~lusol_precision module~lusol_ez_module lusol_ez_module module~lusol_ez_module->module~lusol_precision module~lusol_ez_module->module~lusol program~main main program~main->module~lusol_precision program~main->module~lusol_ez_module proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver proc~nlesolver_solver->module~lusol_ez_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer(kind=4), public, parameter :: ip = int64 integer(kind=4), public, parameter :: rp = real64 default real kind [8 bytes]","tags":"","loc":"module/lusol_precision.html"},{"title":"diff_module – AoC-2023","text":"Numerical differentiation of a 1D function f(x) using Neville's process. Authors J. Oliver, \"An algorithm for numerical differentiation of a function\n     of one real variable\", Journal of Computational and Applied Mathematics\n     6 (2) (1980) 145–160. [Algol 60 source in original paper] David Kahaner, Fortran 77 code from NIST Jacob Williams : 2/17/2013 : Converted to modern Fortran.\n     Some refactoring, addition of test cases. Uses numdiff_kinds_module module~~diff_module~~UsesGraph module~diff_module diff_module module~numdiff_kinds_module numdiff_kinds_module module~diff_module->module~numdiff_kinds_module iso_fortran_env iso_fortran_env module~numdiff_kinds_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~diff_module~~UsedByGraph module~diff_module diff_module module~numerical_differentiation_module numerical_differentiation_module module~numerical_differentiation_module->module~diff_module program~test1 test1 program~test1->module~numerical_differentiation_module program~test2 test2 program~test2->module~numerical_differentiation_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface private  function func(me, x) result(fx) interface to function for diff Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me real(kind=wp), intent(in) :: x Return Value real(kind=wp) Derived Types type, public :: diff_func class to define the function for diff Components Type Visibility Attributes Name Initial logical, private :: stop = .false. procedure( func ), private, pointer :: f => null() Type-Bound Procedures procedure, private :: faccur procedure, public :: set_function procedure, public :: compute_derivative => diff procedure, public :: terminate Subroutines private  subroutine set_function (me, f) Author Jacob Williams Date 12/27/2015 Set the function in a diff_func .\nMust be called before diff . Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me procedure( func ) :: f private  subroutine terminate (me) Can be called by the user in the function to terminate the computation.\nThis will set ifail=-1 . Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me private  subroutine diff (me, iord, x0, xmin, xmax, eps, accr, deriv, error, ifail) the procedure diff calculates the first, second or\nthird order derivative of a function by using neville's process to\nextrapolate from a sequence of simple polynomial approximations based on\ninterpolating points distributed symmetrically about x0 (or lying only on\none side of x0 should this be necessary).  if the specified tolerance is\nnon-zero then the procedure attempts to satisfy this absolute or relative\naccuracy requirement, while if it is unsuccessful or if the tolerance is\nset to zero then the result having the minimum achievable estimated error\nis returned instead. Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me integer, intent(in) :: iord 1, 2 or 3 specifies that the first, second or third order\nderivative,respectively, is required. real(kind=wp), intent(in) :: x0 the point at which the derivative of the function is to be calculated. real(kind=wp), intent(in) :: xmin xmin , xmax restrict the interpolating points to lie in [ xmin , xmax ], which\nshould be the largest interval including x0 in which the function is\ncalculable and continuous. real(kind=wp), intent(in) :: xmax xmin , xmax restrict the interpolating points to lie in [ xmin , xmax ], which\nshould be the largest interval including x0 in which the function is\ncalculable and continuous. real(kind=wp), intent(in) :: eps denotes the tolerance, either absolute or relative. eps=0 specifies that\nthe error is to be minimised, while eps>0 or eps<0 specifies that the\nabsolute or relative error, respectively, must not exceed abs(eps) if\npossible.  the accuracy requirement should not be made stricter than\nnecessary, since the amount of computation tends to increase as\nthe magnitude of eps decreases, and is particularly high when eps=0 . real(kind=wp), intent(in) :: accr denotes that the absolute ( accr>0 ) or relative ( accr<0 ) errors in the\ncomputed values of the function are most unlikely to exceed abs(accr) , which\nshould be as small as possible.  if the user cannot estimate accr with\ncomplete confidence, then it should be set to zero. real(kind=wp), intent(out) :: deriv the calculated value of the derivative real(kind=wp), intent(out) :: error an estimated upper bound on the magnitude of the absolute error in\nthe calculated result.  it should always be examined, since in extreme case\nmay indicate that there are no correct significant digits in the value\nreturned for derivative. integer, intent(out) :: ifail will have one of the following values on exit: 0 the procedure was successful. 1 the estimated error in the result exceeds the (non-zero) requested\n     error, but the most accurate result possible has been returned. 2 input data incorrect (derivative and error will be undefined). 3 the interval [ xmin , xmax ] is too small (derivative and error will be\n     undefined). -1 stopped by the user. private  subroutine faccur (me, h0, h1, facc, x0, twoinf, f0, f1, ifail) This procedure attempts to estimate the level of rounding errors in\nthe calculated function values near the point x0+h0 by fitting a\nleast-squares straight-line approximation to the function at the\nsix points x0+h0-j*h1 , ( j = 0,1,3,5,7,9 ), and then setting facc to\ntwice the largest deviation of the function values from this line. hi is adjusted if necessary so that it is approximately 8 times the\nsmallest spacing at which the function values are unequal near x0+h0 . Arguments Type Intent Optional Attributes Name class( diff_func ), intent(inout) :: me real(kind=wp), intent(inout) :: h0 real(kind=wp), intent(inout) :: h1 real(kind=wp), intent(out) :: facc real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: twoinf real(kind=wp), intent(in) :: f0 real(kind=wp), intent(in) :: f1 integer, intent(out) :: ifail 0 if no error, -1 if user termination.","tags":"","loc":"module/diff_module.html"},{"title":"aoc_cache_module – AoC-2023","text":"For caching function evaluations. This is based on the cache module from NumDiff .\nIt has been modified to cache integers ( int64 ) instead of reals. Uses aoc_utilities module~~aoc_cache_module~~UsesGraph module~aoc_cache_module aoc_cache_module module~aoc_utilities aoc_utilities module~aoc_cache_module->module~aoc_utilities iso_fortran_env iso_fortran_env module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aoc_cache_module~~UsedByGraph module~aoc_cache_module aoc_cache_module program~problem_12b problem_12b program~problem_12b->module~aoc_cache_module program~problem_17 problem_17 program~problem_17->module~aoc_cache_module program~problem_22 problem_22 program~problem_22->module~aoc_cache_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, private :: fx an [x,f(x)] cached pair.\nx is a vector and f is a vector. Components Type Visibility Attributes Name Initial integer(kind=ip), private, dimension(:), allocatable :: x vector of input values integer(kind=ip), private, dimension(:), allocatable :: f output functions type, public :: function_cache a vector function cache. Components Type Visibility Attributes Name Initial type( fx ), private, dimension(:), allocatable :: c the cache of f(x) integer, private :: chunk_size = 100 for resizing vectors\nin the unique function Type-Bound Procedures procedure, public :: initialize => initialize_cache procedure, public :: get => get_from_cache procedure, public :: put => put_in_cache procedure, public :: destroy => destroy_cache Functions private pure function vector_djb_hash (r) result(hash) DJB hash algorithm for a integer(ip) vector. Read more… Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: r the vector Return Value integer(kind=ip) the hash value Subroutines private  subroutine initialize_cache (me, isize, chunk_size) Initialize the cache. Must be called first before use. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer, intent(in) :: isize the size of the hash table integer, intent(in), optional :: chunk_size chunk size to speed up reallocation\nof arrays. A good value is a guess for\nthe actual number of elements of f that\nwill be saved per value of x [default is 100] private  subroutine get_from_cache (me, x, i, f, found) Check if the x vector is in the cache, if so return f .\nNote that only some of the elements may be present, so it will return\nthe ones there are there, and indicate which ones were found. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer(kind=ip), intent(in), dimension(:) :: x independant variable vector integer(kind=ip), intent(out) :: i index in the hash table integer(kind=ip), intent(out), dimension(:), allocatable :: f f(x) from the cache (if it was found) logical, intent(out) :: found if x was found in the cache private  subroutine put_in_cache (me, i, x, f) Put a value into the cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(inout) :: me integer(kind=ip), intent(in) :: i index in the hash table integer(kind=ip), intent(in), dimension(:) :: x independant variable vector integer(kind=ip), intent(in), dimension(:) :: f function private  subroutine destroy_cache (me) Destroy a cache. Arguments Type Intent Optional Attributes Name class( function_cache ), intent(out) :: me","tags":"","loc":"module/aoc_cache_module.html"},{"title":"problem_15_module – AoC-2023","text":"A module for problem 15, part 2. Uses iso_fortran_env aoc_utilities module~~problem_15_module~~UsesGraph module~problem_15_module problem_15_module iso_fortran_env iso_fortran_env module~problem_15_module->iso_fortran_env module~aoc_utilities aoc_utilities module~problem_15_module->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~problem_15_module~~UsedByGraph module~problem_15_module problem_15_module program~problem_15 problem_15 program~problem_15->module~problem_15_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: lens Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: label integer(kind=ip), public :: focal_length = 0 type, public :: box Components Type Visibility Attributes Name Initial type( lens ), public, dimension(:), allocatable :: lenses the lenses in the box Type-Bound Procedures procedure, public :: add_lens procedure, public :: remove_lens Subroutines public  subroutine add_lens (me, l) Arguments Type Intent Optional Attributes Name class( box ), intent(inout) :: me type( lens ), intent(in) :: l lense to add public  subroutine remove_lens (me, label) remove the lens with the label (if present) Arguments Type Intent Optional Attributes Name class( box ), intent(inout) :: me character(len=*), intent(in) :: label","tags":"","loc":"module/problem_15_module.html"},{"title":"lsqrtest_module – AoC-2023","text":"Test module for LSQR . These routines define a class of least-squares test problems\n  for testing algorithms LSQR and CRAIG\n  (Paige and Saunders, ACM TOMS, 1982). Author Michael Saunders, Dept of Operations Research, Stanford University. History 1982---1991:  Various versions implemented. 06 Feb 1992:  Test-problem generator lstp generalized to allow\n    any m and n.  lstp is now the same as the generator\n    for LSQR and CRAIG. 30 Nov 1993:  Modified lstp.\n    For a while, damp = 0 implied r = damp*s = 0.\n    This was a result of generating x and s.\n    Reverted to generating x and r as in LSQR paper. 12 Nov 2019 : Jacob Williams : significant refactoring into modern Fortran. Uses lsqpblas_module lsqr_kinds lsqr_module module~~lsqrtest_module~~UsesGraph module~lsqrtest_module lsqrtest_module module~lsqpblas_module lsqpblas_module module~lsqrtest_module->module~lsqpblas_module module~lsqr_kinds lsqr_kinds module~lsqrtest_module->module~lsqr_kinds module~lsqr_module lsqr_module module~lsqrtest_module->module~lsqr_module module~lsqpblas_module->module~lsqr_kinds iso_fortran_env iso_fortran_env module~lsqr_kinds->iso_fortran_env module~lsqr_module->module~lsqpblas_module module~lsqr_module->module~lsqr_kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~lsqrtest_module~~UsedByGraph module~lsqrtest_module lsqrtest_module program~main~2 main program~main~2->module~lsqrtest_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, private, parameter :: lenrw = 10000 Derived Types type, private, extends( lsqr_solver ) :: test_solver Components Type Visibility Attributes Name Initial integer, public :: nout = -1 output unit for printing real(kind=wp), public, dimension(lenrw) :: rw workspace array Type-Bound Procedures procedure, public :: lsqr => LSQR main solver routine procedure, public :: acheck procedure, public :: xcheck procedure, public :: aprod => aprod_test_solver procedure, public :: test procedure, public :: aprod1 procedure, public :: aprod2 procedure, public :: lstp Subroutines public  subroutine lsqr_test () Unit test. Arguments None private  subroutine test (me, m, n, nduplc, npower, damp) This is an example driver routine for running LSQR.\n  It generates a test problem, solves it, and examines the results.\n  Note that subroutine aprod must be declared external\n  if it is used only in the call to LSQR (and acheck). Read more… Arguments Type Intent Optional Attributes Name class( test_solver ), intent(inout) :: me integer :: m integer :: n integer :: nduplc integer :: npower real(kind=wp) :: damp private  subroutine aprod_test_solver (me, mode, m, n, x, y) This is the matrix-vector product routine required by subroutines\nLSQR and CRAIG for a test matrix of the form  A = HY D HZ.\nThe quantities defining D, HY, HZ are in the work array rw,\nfollowed by a work array w.  These are passed to aprod1 and aprod2\nin order to make the code readable. Arguments Type Intent Optional Attributes Name class( test_solver ), intent(inout) :: me integer, intent(in) :: mode integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout), dimension(:) :: x dimension n real(kind=wp), intent(inout), dimension(:) :: y dimension m private  subroutine aprod1 (me, m, n, maxmn, minmn, x, y, d, hy, hz, w) aprod1  computes  y = y + A x  for subroutine aprod,\nwhere A is a test matrix of the form  A = HY D*HZ,\nand the latter matrices HY, D, HZ are represented by\ninput vectors with the same name. Arguments Type Intent Optional Attributes Name class( test_solver ), intent(inout) :: me integer :: m integer :: n integer :: maxmn integer :: minmn real(kind=wp) :: x (n) real(kind=wp) :: y (m) real(kind=wp) :: d (minmn) real(kind=wp) :: hy (m) real(kind=wp) :: hz (n) real(kind=wp) :: w (maxmn) private  subroutine aprod2 (me, m, n, maxmn, minmn, x, y, d, hy, hz, w) aprod2  computes  x = x + A(t) y  for subroutine aprod,\nwhere  A  is a test matrix of the form  A = HY D*HZ,\nand the latter matrices  HY, D, HZ  are represented by\ninput vectors with the same name. Arguments Type Intent Optional Attributes Name class( test_solver ), intent(inout) :: me integer :: m integer :: n integer :: maxmn integer :: minmn real(kind=wp) :: x (n) real(kind=wp) :: y (m) real(kind=wp) :: d (minmn) real(kind=wp) :: hy (m) real(kind=wp) :: hz (n) real(kind=wp) :: w (maxmn) private  subroutine hprod (n, hz, x, y) hprod  applies a Householder transformation stored in  hz\nto get  y = ( I - 2 hz hz(transpose) ) * x. Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: hz (n) real(kind=wp) :: x (n) real(kind=wp) :: y (n) private  subroutine lstp (me, m, n, maxmn, minmn, nduplc, npower, damp, x, b, d, hy, hz, w, acond, rnorm) lstp  generate a sparse least-squares test problem of the form\n           (   A    ) x = ( b )\n           ( damp I )     ( 0 )\nfor solution by LSQR, or a sparse underdetermined system\n              Ax + damp s = b\nfor solution by CRAIG.  The matrix A is m by n and is\nconstructed in the form  A = HY D*HZ,  where D is an m by n\ndiagonal matrix, and HY and HZ are Householder transformations. Read more… Arguments Type Intent Optional Attributes Name class( test_solver ), intent(inout) :: me integer :: m integer :: n integer :: maxmn integer :: minmn integer :: nduplc integer :: npower real(kind=wp) :: damp real(kind=wp) :: x (n) real(kind=wp) :: b (m) real(kind=wp) :: d (minmn) real(kind=wp) :: hy (m) real(kind=wp) :: hz (n) real(kind=wp) :: w (maxmn) real(kind=wp) :: acond real(kind=wp) :: rnorm","tags":"","loc":"module/lsqrtest_module.html"},{"title":"numerical_differentiation_module – AoC-2023","text":"Numerical differentiation module for computing the Jacobian matrix\n(the derivative matrix of m functions w.r.t. n variables) using\nfinite differences. Uses iso_fortran_env numdiff_kinds_module numdiff_utilities_module dsm_module diff_module numdiff_cache_module module~~numerical_differentiation_module~~UsesGraph module~numerical_differentiation_module numerical_differentiation_module iso_fortran_env iso_fortran_env module~numerical_differentiation_module->iso_fortran_env module~diff_module diff_module module~numerical_differentiation_module->module~diff_module module~dsm_module dsm_module module~numerical_differentiation_module->module~dsm_module module~numdiff_cache_module numdiff_cache_module module~numerical_differentiation_module->module~numdiff_cache_module module~numdiff_kinds_module numdiff_kinds_module module~numerical_differentiation_module->module~numdiff_kinds_module module~numdiff_utilities_module numdiff_utilities_module module~numerical_differentiation_module->module~numdiff_utilities_module module~diff_module->module~numdiff_kinds_module module~dsm_module->module~numdiff_kinds_module module~numdiff_cache_module->iso_fortran_env module~numdiff_cache_module->module~numdiff_kinds_module module~numdiff_cache_module->module~numdiff_utilities_module module~numdiff_kinds_module->iso_fortran_env module~numdiff_utilities_module->module~numdiff_kinds_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~numerical_differentiation_module~~UsedByGraph module~numerical_differentiation_module numerical_differentiation_module program~test1 test1 program~test1->module~numerical_differentiation_module program~test2 test2 program~test2->module~numerical_differentiation_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=wp), private, parameter :: zero = 0.0_wp Interfaces public        interface finite_diff_method constructor private  function initialize_finite_difference_method (id, name, class, dx_factors, df_factors, df_den_factor) result(me) Constructor for a finite_diff_method . Note factors are input as integers for convenience, but are converted\n      to reals for the actual computations. (note: this means we can't\n      currently define methods that have non-integer factors). Arguments Type Intent Optional Attributes Name integer, intent(in) :: id unique ID for the method character(len=*), intent(in) :: name the name of the method integer, intent(in) :: class 2=backward diffs, 3=central diffs, etc... integer, intent(in), dimension(:) :: dx_factors multiplicative factors for dx perturbation integer, intent(in), dimension(:) :: df_factors multiplicative factors for accumulating function evaluations integer, intent(in) :: df_den_factor denominator factor for finite difference equation (times dx) Return Value type( finite_diff_method ) Abstract Interfaces abstract interface private  subroutine func(me, x, f, funcs_to_compute) The function (vector array of output functions f , computed\nfrom a vector of input variables x ).\nThis must be defined for all computations. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x array of variables (size n ) real(kind=wp), intent(out), dimension(:) :: f array of functions (size m ) integer, intent(in), dimension(:) :: funcs_to_compute the elements of the\nfunction vector that need\nto be computed (the other\nare ignored) abstract interface private  subroutine spars_f(me, x) The function to compute the sparsity pattern.\nIt populates the irow and icol variables in the class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) abstract interface private  subroutine info_f(me, column, i, x) User-defined info function (optional).\nInforms user what is being done during Jacobian computation.\nIt can be used to perform any setup operations that need to\ndone on the user's end. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in), dimension(:) :: column the columns being computed. integer, intent(in) :: i perturbing these columns for the i th time (1,2,...) real(kind=wp), intent(in), dimension(:) :: x the nominal variable vector abstract interface private  subroutine jacobian_f(me, x, dx, jac) Actual function for computing the Jacobian\ncalled by compute_jacobian . Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0) for each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector (size num_nonzero_elements ) Derived Types type, public :: finite_diff_method defines the finite difference method\nused to compute the Jacobian. Read more… Components Type Visibility Attributes Name Initial integer, private :: id = 0 unique ID for the method character(len=:), private, allocatable :: name the name of the method integer, private :: class = 0 2=backward diffs, 3=central diffs, etc... real(kind=wp), private, dimension(:), allocatable :: dx_factors multiplicative factors for dx perturbation real(kind=wp), private, dimension(:), allocatable :: df_factors multiplicative factors for accumulating function evaluations real(kind=wp), private :: df_den_factor = zero denominator factor for finite difference equation (times dx ) Constructor constructor private\n\n                    \n                    function initialize_finite_difference_method (id, name, class, dx_factors, df_factors, df_den_factor) Constructor for a finite_diff_method . Read more… Type-Bound Procedures procedure, public :: get_formula procedure, public :: print => print_finite_difference_method type, public :: meth_array to store an array of finite_diff_method types\nthis is used when the mode=2 option is used\nin numdiff_type Components Type Visibility Attributes Name Initial type( finite_diff_method ), private, dimension(:), allocatable :: meth type, public :: sparsity_pattern A sparsity pattern Components Type Visibility Attributes Name Initial logical, private :: sparsity_computed = .false. has the sparsity pattern already been computed? integer, private :: num_nonzero_elements = 0 number of nonzero elements in the jacobian\n(will be the dimension of irow and icol ) integer, private, dimension(:), allocatable :: irow sparsity pattern - rows of non-zero elements integer, private, dimension(:), allocatable :: icol sparsity pattern - columns of non-zero elements logical, private :: linear_sparsity_computed = .false. if the linear pattern has been populated integer, private :: num_nonzero_linear_elements = 0 number of constant elements in the jacobian integer, private, dimension(:), allocatable :: linear_irow linear sparsity pattern - rows of non-zero elements integer, private, dimension(:), allocatable :: linear_icol linear sparsity pattern - columns of non-zero elements real(kind=wp), private, dimension(:), allocatable :: linear_vals linear elements of the jacobian integer, private, dimension(:), allocatable :: indices index vector [1,2,...,num_nonzero_elements] for putting df into jac integer, private :: maxgrp = 0 the number of groups in the partition\nof the columns of a . integer, private, dimension(:), allocatable :: ngrp specifies the partition of the columns of a .\ncolumn jcol belongs to group ngrp(jcol) . size(n) Type-Bound Procedures procedure, private :: dsm_wrapper procedure, private :: compute_indices procedure, public :: destroy => destroy_sparsity procedure, public :: print => print_sparsity procedure, public :: columns_in_partition_group type, public :: numdiff_type base type for sparsity and Jacobian computations. Components Type Visibility Attributes Name Initial logical, private :: exception_raised = .false. if true, an exception has been raised integer, private :: istat = 0 a non-zero value will cause all routine to exit.\nthis can be set to -1 by calling terminate . character(len=:), private, allocatable :: error_msg error message (if istat/=0 ) integer, private :: n = 0 number of x variables integer, private :: m = 0 number of f functions real(kind=wp), private, dimension(:), allocatable :: xlow lower bounds on x real(kind=wp), private, dimension(:), allocatable :: xhigh upper bounds on x logical, private :: print_messages = .true. if true, warning messages are printed\nto the error_unit for any errors. integer, private :: chunk_size = 100 chuck size for allocating the arrays (>0) integer, private :: perturb_mode = 1 perturbation mode: Read more… real(kind=wp), private, dimension(:), allocatable :: dpert perturbation vector for x logical, private :: partition_sparsity_pattern = .false. to partition the sparsity pattern using dsm type( sparsity_pattern ), private :: sparsity the sparsity pattern real(kind=wp), private, dimension(:), allocatable :: xlow_for_sparsity lower bounds on x for computing sparsity (optional) real(kind=wp), private, dimension(:), allocatable :: xhigh_for_sparsity upper bounds on x for computing sparsity (optional) real(kind=wp), private, dimension(:), allocatable :: dpert_for_sparsity perturbation vector for x when computing\nsparsity for sparsity_mode=4 integer, private :: num_sparsity_points = 3 for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern.\nSee compute_sparsity_random_2 integer, private :: sparsity_perturb_mode = 1 perturbation mode (if sparsity_mode=4 ): Read more… logical, private :: compute_linear_sparsity_pattern = .false. to also compute the linear sparsity pattern real(kind=wp), private :: linear_sparsity_tol = epsilon(1.0_wp) the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), private :: function_precision_tol = epsilon(1.0_wp) the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, private :: mode = 1 1 = use meth (specified methods), 2 = use class (specified class, method is selected on-the-fly). type( finite_diff_method ), private, dimension(:), allocatable :: meth the finite difference method to use\ncompute the n th column of the Jacobian size(n) .  Either this or class is used integer, private, dimension(:), allocatable :: class the class of method to use to\ncompute the n th column of the Jacobian size(n) . Either this or meth is used type( meth_array ), private, dimension(:), allocatable :: class_meths array of methods for the specified classes.\nused with class when mode=2 real(kind=wp), private :: eps = 1.0e-9_wp tolerance parameter for diff real(kind=wp), private :: acc = 0.0_wp tolerance parameter for diff type( function_cache ), private :: cache if using the function cache logical, private :: use_diff = .false. if we are using the Neville's process method,\nrather than finite differences procedure( func ), private, pointer :: problem_func => null() the user-defined function procedure( func ), private, pointer :: compute_function => null() compute the user-defined function\nthis can point to the problem_func or, if using\nthe cache, it points to compute_function_with_cache . procedure( spars_f ), private, pointer :: compute_sparsity => null() for computing the sparsity pattern procedure( info_f ), private, pointer :: info_function => null() an optional function the user can define\nwhich is called when each column of the jacobian is computed.\nIt can be used to perform any setup operations. procedure( jacobian_f ), private, pointer :: jacobian_function => null() the low-level function called by compute_jacobian that actually computes the jacobian. Type-Bound Procedures procedure, public :: initialize => initialize_numdiff initialize the class procedure, public :: diff_initialize => initialize_numdiff_for_diff initialize the class procedure, public :: compute_jacobian main routine to compute the Jacobian\nusing the selected options. It\nreturns the sparse (vector) form. procedure, public :: compute_jacobian_dense return the dense size(m,n) matrix form of the Jacobian. procedure, public :: compute_jacobian_times_vector returns the product of the Jacobian\nmatrix and an input vector procedure, public :: destroy => destroy_numdiff_type destroy the class procedure, public :: print_sparsity_pattern print the sparsity pattern in vector form to a file procedure, public :: print_sparsity_matrix print the sparsity pattern in matrix form to a file procedure, public :: set_sparsity_pattern manually set the sparsity pattern procedure, public :: select_finite_diff_method select a method in a specified class so\nthat the variable bounds are not violated\nwhen by the perturbations. procedure, public :: select_finite_diff_method_for_partition_group version of select_finite_diff_method for partitioned sparsity pattern. procedure, public :: set_numdiff_bounds can be called to change the variable bounds. procedure, public :: compute_sparsity_pattern if the user needs to compute the sparsity pattern manually.\n(otherwise it will be done the first time the Jacobian is computed) procedure, public :: get_sparsity_pattern returns the sparsity pattern (if it is allocated) procedure, public :: terminate can be called by user to stop the computation procedure, public :: failed to check if an exception was raised. procedure, public :: get_error_status the status of error condition procedure, private :: destroy_sparsity_pattern destroy the sparsity pattern procedure, private :: compute_perturb_vector procedure, private :: compute_perturbation_vector computes the variable perturbation factor procedure, private :: compute_sparsity_perturbation_vector procedure, private :: perturb_x_and_compute_f procedure, private :: perturb_x_and_compute_f_partitioned procedure, private :: set_numdiff_sparsity_bounds procedure, private :: set_sparsity_mode procedure, private :: generate_dense_sparsity_partition procedure, private :: compute_jacobian_for_sparsity procedure, private :: resize_sparsity_vectors procedure, private :: raise_exception procedure, private :: clear_exceptions Functions private  function initialize_finite_difference_method (id, name, class, dx_factors, df_factors, df_den_factor) result(me) Constructor for a finite_diff_method . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: id unique ID for the method character(len=*), intent(in) :: name the name of the method integer, intent(in) :: class 2=backward diffs, 3=central diffs, etc... integer, intent(in), dimension(:) :: dx_factors multiplicative factors for dx perturbation integer, intent(in), dimension(:) :: df_factors multiplicative factors for accumulating function evaluations integer, intent(in) :: df_den_factor denominator factor for finite difference equation (times dx) Return Value type( finite_diff_method ) public  function get_all_methods_in_class (class) result(list_of_methods) Returns all the methods with the given class (i.e., number of points in the formula). Arguments Type Intent Optional Attributes Name integer, intent(in) :: class the class is the number of points in the\nfinite different computation Return Value type( meth_array ) all the methods with the specified class private pure function failed (me) Returns True if an exception has been raised. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(in) :: me Return Value logical private  function integer_to_string (i, with_sign) result(str) Convert an integer to a string. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i the integer logical, intent(in), optional :: with_sign also include the sign (default is False) Return Value character(len=:), allocatable integer converted to a string Subroutines private  subroutine print_finite_difference_method (me, iunit) Print the contents of a finite_diff_method . Used for debugging. Arguments Type Intent Optional Attributes Name class( finite_diff_method ), intent(in) :: me integer, intent(in) :: iunit file unit for printing\n(assumed to be opened) private  subroutine compute_function_with_cache (me, x, f, funcs_to_compute) Wrapper for computing the function, using the cache. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x array of variables (size n ) real(kind=wp), intent(out), dimension(:) :: f array of functions (size m ) integer, intent(in), dimension(:) :: funcs_to_compute the elements of the\nfunction vector that need\nto be computed (the other\nare ignored) private  subroutine get_formula (me, formula) Return a string with the finite difference formula. Read more… Arguments Type Intent Optional Attributes Name class( finite_diff_method ), intent(in) :: me character(len=:), intent(out), allocatable :: formula public  subroutine get_finite_diff_formula (id, formula, name) Return a string with the finite difference formula.\n  Input is the method id code. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: id the id code for the method character(len=:), intent(out), allocatable :: formula the formula string character(len=:), intent(out), optional, allocatable :: name private  subroutine get_finite_difference_method (id, fd, found) Return a finite_diff_method given the id code.\n  (the id codes begin at 1, are sequential, and uniquely define the method). Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: id the id code for the method type( finite_diff_method ), intent(out) :: fd this method (can be used\nin compute_jacobian ) logical, intent(out) :: found true if it was found private  subroutine select_finite_diff_method (me, x, xlow, xhigh, dx, list_of_methods, fd, status_ok) Select a finite diff method of a given class so that the perturbations\nof x will not violate the variable bounds. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in) :: x the variable value real(kind=wp), intent(in) :: xlow the variable lower bound real(kind=wp), intent(in) :: xhigh the variable upper bound real(kind=wp), intent(in) :: dx the perturbation value (>0) type( meth_array ), intent(in) :: list_of_methods list of available methods to choose from type( finite_diff_method ), intent(out) :: fd this method can be used logical, intent(out) :: status_ok true if it really doesn't violate the bounds\n(say, the bounds are very close to each other)\nif status_ok=False , then the first method in\nthe given class is returned in fd . private  subroutine select_finite_diff_method_for_partition_group (me, x, xlow, xhigh, dx, list_of_methods, fd, status_ok) Select a finite diff method of a given class so that the perturbations\nof x will not violate the variable bounds for any variable in the group. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x the variable values real(kind=wp), intent(in), dimension(:) :: xlow the variable lower bounds real(kind=wp), intent(in), dimension(:) :: xhigh the variable upper bounds real(kind=wp), intent(in), dimension(:) :: dx the perturbation values (>0) type( meth_array ), intent(in) :: list_of_methods list of available methods to choose from type( finite_diff_method ), intent(out) :: fd this method can be used logical, intent(out) :: status_ok true if it really doesn't violate the bounds\n(say, the bounds are very close to each other)\nif status_ok=False , then the first method in\nthe given class is returned in fd . private  subroutine initialize_numdiff_for_diff (me, n, m, xlow, xhigh, problem_func, sparsity_mode, info, chunk_size, eps, acc, cache_size, xlow_for_sparsity, xhigh_for_sparsity, dpert_for_sparsity, sparsity_perturb_mode, linear_sparsity_tol, function_precision_tol, num_sparsity_points, print_messages) Alternate version of initialize_numdiff routine when\nusing diff to compute the Jacobian. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: n number of x variables integer, intent(in) :: m number of f functions real(kind=wp), intent(in), dimension(n) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(n) :: xhigh upper bounds on x procedure( func ) :: problem_func the user function that defines the problem\n(returns m functions) integer, intent(in) :: sparsity_mode the sparsity computation method: Read more… procedure( info_f ), optional :: info a function the user can define\nwhich is called when each column\nof the jacobian is computed.\nIt can be used to perform any\nsetup operations. integer, intent(in), optional :: chunk_size chunk size for allocating the arrays\n(must be >0) [default is 100] real(kind=wp), intent(in), optional :: eps tolerance parameter for diff if not present, default is 1.0e-9_wp real(kind=wp), intent(in), optional :: acc tolerance parameter for diff if not present, default is 0.0_wp integer, intent(in), optional :: cache_size if present, this is the cache size\nfor the function cache\n(default is not to enable cache) real(kind=wp), intent(in), optional, dimension(n) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(n) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. real(kind=wp), intent(in), optional, dimension(n) :: dpert_for_sparsity required if sparsity_mode=4 integer, intent(in), optional :: sparsity_perturb_mode perturbation mode (required if sparsity_mode=4 ): Read more… real(kind=wp), intent(in), optional :: linear_sparsity_tol the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), intent(in), optional :: function_precision_tol the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, intent(in), optional :: num_sparsity_points for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern. logical, intent(in), optional :: print_messages if true, print error messages to error_unit .\ndefault is True. private  subroutine set_numdiff_bounds (me, xlow, xhigh) Change the variable bounds in a numdiff_type . Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(:) :: xhigh upper bounds on x private  subroutine set_sparsity_mode (me, sparsity_mode, xlow_for_sparsity, xhigh_for_sparsity) Set sparsity mode. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. real(kind=wp), intent(in), optional, dimension(:) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(:) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. private  subroutine set_numdiff_sparsity_bounds (me, xlow, xhigh) Sets the variable bounds for sparsity in a numdiff_type .\n  These are only used for sparsity_mode=2 . Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), optional, dimension(:) :: xlow lower bounds on x to be used for\nsparsity computation. If not present,\nthen then xlow values in the class are used. real(kind=wp), intent(in), optional, dimension(:) :: xhigh upper bounds on x to be used for\nsparsity computation. If not present,\nthen then xhigh values in the class are used. private  subroutine initialize_numdiff (me, n, m, xlow, xhigh, perturb_mode, dpert, problem_func, sparsity_mode, jacobian_method, jacobian_methods, class, classes, info, chunk_size, partition_sparsity_pattern, cache_size, xlow_for_sparsity, xhigh_for_sparsity, dpert_for_sparsity, sparsity_perturb_mode, linear_sparsity_tol, function_precision_tol, num_sparsity_points) Initialize a numdiff_type class. This must be called first. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: n number of x variables integer, intent(in) :: m number of f functions real(kind=wp), intent(in), dimension(n) :: xlow lower bounds on x real(kind=wp), intent(in), dimension(n) :: xhigh upper bounds on x integer, intent(in) :: perturb_mode perturbation mode: 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), dimension(n) :: dpert perturbation vector for x procedure( func ) :: problem_func the user function that defines the problem\n(returns m functions) integer, intent(in) :: sparsity_mode the sparsity computation method: 1 - assume dense, 2 - three-point simple method, 3 - will be specified by the user in\na subsequent call to set_sparsity_pattern . 4 - computes a two-point jacobian\nat num_sparsity_points points. integer, intent(in), optional :: jacobian_method id code for the finite difference method\nto use for all n variables.\nsee get_finite_difference_method integer, intent(in), optional, dimension(n) :: jacobian_methods id codes for the finite difference method\nto use for each variable.\nsee get_finite_difference_method integer, intent(in), optional :: class method class for the finite difference method\nto use for all n variables.\nsee get_finite_difference_method integer, intent(in), optional, dimension(n) :: classes method class for the finite difference methods\nto use for each variable.\nsee get_finite_difference_method procedure( info_f ), optional :: info a function the user can define\nwhich is called when each column\nof the jacobian is computed.\nIt can be used to perform any\nsetup operations. integer, intent(in), optional :: chunk_size chunk size for allocating the arrays\n(must be >0) [default is 100] logical, intent(in), optional :: partition_sparsity_pattern if the sparisty pattern is to\nbe partitioned using DSM [default is False] integer, intent(in), optional :: cache_size if present, this is the cache size\nfor the function cache\n(default is not to enable cache) real(kind=wp), intent(in), optional, dimension(n) :: xlow_for_sparsity lower bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xlow is used. real(kind=wp), intent(in), optional, dimension(n) :: xhigh_for_sparsity upper bounds on x used for\nsparsity computation (when sparsity_mode is 2). If not\npresent, then xhigh is used. real(kind=wp), intent(in), optional, dimension(n) :: dpert_for_sparsity for sparsity_mode=4 , the perturbation integer, intent(in), optional :: sparsity_perturb_mode perturbation mode (required if sparsity_mode=4 ): 1 - perturbation is dx=dpert , 2 - perturbation is dx=dpert*x , 3 - perturbation is dx=dpert*(1+x) real(kind=wp), intent(in), optional :: linear_sparsity_tol the equality tolerance for derivatives to\nindicate a constant jacobian element (linear sparsity) real(kind=wp), intent(in), optional :: function_precision_tol the function precision. two functions values\nthat are the within this tolerance are\nconsidered the same value. This is used\nwhen estimating the sparsity pattern when sparsity_mode=2 in compute_sparsity_random integer, intent(in), optional :: num_sparsity_points for sparsity_mode=4 , the number of jacobian\nevaluations used to estimate the sparsity pattern. private  subroutine destroy_numdiff_type (me) destroy the numdiff_type class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(out) :: me private  subroutine destroy_sparsity (me) destroy a sparsity_pattern type. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(out) :: me private  subroutine dsm_wrapper (me, n, m, info) Wrapper for dsm to compute the sparsity pattern partition. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(inout) :: me integer, intent(in) :: n number of columns of jacobian matrix integer, intent(in) :: m number of rows of jacobian matrix integer, intent(out) :: info status output from dsm private  subroutine columns_in_partition_group (me, igroup, n_cols, cols, nonzero_rows, indices, status_ok) Returns the columns in a sparsity partition group. Read more… Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(in) :: me integer, intent(in) :: igroup group number. Should be >0 and <=me%mxgrp integer, intent(out) :: n_cols number of columns in the igroup group. integer, intent(out), dimension(:), allocatable :: cols the column numbers in the igroup group.\n(if none, then it is not allocated) integer, intent(out), dimension(:), allocatable :: nonzero_rows the row numbers of all the nonzero\nJacobian elements in this group integer, intent(out), dimension(:), allocatable :: indices nonzero indices in jac for a group logical, intent(out) :: status_ok true if the partition is valid private  subroutine destroy_sparsity_pattern (me) Destroy the sparsity pattern in the class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me private  subroutine compute_indices (me) Computes the indices vector in the class. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(inout) :: me private  subroutine set_sparsity_pattern (me, irow, icol, linear_irow, linear_icol, linear_vals, maxgrp, ngrp) To specify the sparsity pattern directly if it is already known. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in), dimension(:) :: irow sparsity pattern nonzero elements row indices integer, intent(in), dimension(:) :: icol sparsity pattern nonzero elements column indices integer, intent(in), optional, dimension(:) :: linear_irow linear sparsity pattern nonzero elements row indices integer, intent(in), optional, dimension(:) :: linear_icol linear sparsity pattern nonzero elements column indices real(kind=wp), intent(in), optional, dimension(:) :: linear_vals linear sparsity values (constant elements of the Jacobian) integer, intent(in), optional :: maxgrp DSM sparsity partition\n[only used if me%partition_sparsity_pattern=True ] integer, intent(in), optional, dimension(:) :: ngrp DSM sparsity partition (size n )\n[only used if me%partition_sparsity_pattern=True ] private  subroutine compute_sparsity_dense (me, x) assume all elements of Jacobian are non-zero. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) private  subroutine generate_dense_sparsity_partition (me) Generate a \"dense\" sparsity partition. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me private  subroutine compute_sparsity_random (me, x) Compute the sparsity pattern by computing the function at three\n\"random\" points in the [ xlow_for_sparsity , xhigh_for_sparsity ] interval\nand checking if the function values are the same. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n )\n(not used here) private  subroutine resize_sparsity_vectors (me, n_icol, n_irow, n_linear_icol, n_linear_irow, n_linear_vals) Resize the sparsity arrays after accumulating them. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(inout) :: n_icol integer, intent(inout) :: n_irow integer, intent(inout) :: n_linear_icol integer, intent(inout) :: n_linear_irow integer, intent(inout) :: n_linear_vals private  subroutine compute_sparsity_random_2 (me, x) Compute the sparsity pattern by computing a 2-point jacobian at a specified\nnumber of \"random\" points ( num_sparsity_points ) in the\n[ xlow_for_sparsity , xhigh_for_sparsity ] interval and checking if\nthey are the same. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n )\n(not used here) private  subroutine compute_sparsity_pattern (me, x, irow, icol, linear_irow, linear_icol, linear_vals) Computes the sparsity pattern and return it.\nUses the settings currently in the class. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) integer, intent(out), dimension(:), allocatable :: irow sparsity pattern nonzero elements row indices integer, intent(out), dimension(:), allocatable :: icol sparsity pattern nonzero elements column indices integer, intent(out), optional, dimension(:), allocatable :: linear_irow linear sparsity pattern\nnonzero elements row indices integer, intent(out), optional, dimension(:), allocatable :: linear_icol linear sparsity pattern nonzero\nelements column indices real(kind=wp), intent(out), optional, dimension(:), allocatable :: linear_vals linear sparsity values (constant\nelements of the Jacobian) private  subroutine get_sparsity_pattern (me, irow, icol, linear_irow, linear_icol, linear_vals, maxgrp, ngrp) Returns the sparsity pattern from the class.\nIf it hasn't been computed, the output arrays will not be allocated. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: irow sparsity pattern nonzero elements row indices integer, intent(out), dimension(:), allocatable :: icol sparsity pattern nonzero elements column indices integer, intent(out), optional, dimension(:), allocatable :: linear_irow linear sparsity pattern\nnonzero elements row indices integer, intent(out), optional, dimension(:), allocatable :: linear_icol linear sparsity pattern nonzero\nelements column indices real(kind=wp), intent(out), optional, dimension(:), allocatable :: linear_vals linear sparsity values (constant\nelements of the Jacobian) integer, intent(out), optional :: maxgrp DSM sparsity partition integer, intent(out), optional, dimension(:), allocatable :: ngrp DSM sparsity partition private  subroutine compute_jacobian_dense (me, x, jac) just a wrapper for compute_jacobian , that returns a dense ( m x n ) matrix. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:,:), allocatable :: jac the jacobian matrix private  subroutine perturb_x_and_compute_f (me, x, dx_factor, dx, df_factor, column, idx, df) Perturb the specified optimization variable, and compute the function.\nThis routine is designed so that df is accumulated as each function\nevaluation is done, to avoid having to allocate more temporary storage. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x nominal variable vector real(kind=wp), intent(in) :: dx_factor factor to multiply dx real(kind=wp), intent(in), dimension(:) :: dx the perturbation value for this column real(kind=wp), intent(in) :: df_factor factor to multiply function value integer, intent(in) :: column the variable to perturb integer, intent(in), dimension(:) :: idx the elements in this\ncolumn of the Jacobian\nto compute (passed to function) real(kind=wp), intent(inout), dimension(me%m) :: df the accumulated function value\nnote: for the first call, this\nshould be set to zero private  subroutine compute_jacobian_times_vector (me, x, v, z) Returns the product J*v , where J is the m x n Jacobian matrix\n  and v is an n x 1 vector. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(:) :: v vector (size n ) real(kind=wp), intent(out), dimension(:) :: z The product J*v (size m ) private  subroutine compute_jacobian (me, x, jac) Compute the Jacobian. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:), allocatable :: jac sparse jacobian vector private  subroutine compute_jacobian_for_sparsity (me, i, class_meths, x, jac) A separate version of compute_jacobian to be used only when\n  computing the sparsity pattern in compute_sparsity_random_2 .\n  It uses class_meths and the sparsity dperts and bounds. Read more… Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: i the column being computed type( meth_array ), intent(in) :: class_meths set of finite diff methods to use real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(:), allocatable :: jac sparse jacobian vector private  subroutine compute_jacobian_standard (me, x, dx, jac) Compute the Jacobian using finite differences.\n(one column at a time) Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector (size num_nonzero_elements ) private  subroutine compute_jacobian_with_diff (me, x, dx, jac) Compute the Jacobian one element at a time using the Neville's process\nalgorithm diff . This takes a very large number of function evaluations,\nbut should give a very accurate answer. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector (size num_nonzero_elements ) private  subroutine compute_jacobian_partitioned (me, x, dx, jac) Compute the Jacobian using finite differences,\n(using the partitioned sparsity pattern to compute multiple columns\nat a time). Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dx absolute perturbation (>0) for each variable real(kind=wp), intent(out), dimension(:) :: jac sparse jacobian vector private  subroutine perturb_x_and_compute_f_partitioned (me, x, dx_factor, dx, df_factor, columns, idx, df) Perturb the specified optimization variable, and compute the function.\nThis routine is designed so that df is accumulated as each function\nevaluation is done, to avoid having to allocate more temporary storage. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x nominal variable vector real(kind=wp), intent(in) :: dx_factor factor to multiply dx real(kind=wp), intent(in), dimension(:) :: dx the perturbation value for this column real(kind=wp), intent(in) :: df_factor factor to multiply function value integer, intent(in), dimension(:) :: columns the variables to perturb integer, intent(in), dimension(:) :: idx the elements in this\ncolumn of the Jacobian\nto compute (passed to function) real(kind=wp), intent(inout), dimension(me%m) :: df the accumulated function value\nnote: for the first call, this\nshould be set to zero private  subroutine compute_perturb_vector (me, x, dpert, perturb_mode, dx) Compute dx , the perturbation vector for x Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(in), dimension(me%n) :: dpert integer, intent(in) :: perturb_mode real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable private  subroutine compute_perturbation_vector (me, x, dx) Compute dx , the perturbation vector for x used\nwhen computing the gradients. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable private  subroutine compute_sparsity_perturbation_vector (me, x, dx) Compute dx , the perturbation vector for x used\nwhen computing the sparsity pattern. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n) :: x vector of variables (size n ) real(kind=wp), intent(out), dimension(me%n) :: dx absolute perturbation (>0)\nfor each variable private  subroutine print_sparsity (me, n, m, iunit, dense) Print the sparsity pattern. Arguments Type Intent Optional Attributes Name class( sparsity_pattern ), intent(in) :: me integer, intent(in) :: n number of variables (columns of jacobian) integer, intent(in) :: m number of functions (rows of jacobian) integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) logical, intent(in), optional :: dense if present and true, the matrix form\nof the sparsity pattern is printed\n(default is vector form) private  subroutine print_sparsity_pattern (me, iunit) Print the sparsity pattern in vector form ( irow , icol ). Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) private  subroutine print_sparsity_matrix (me, iunit) Print the sparsity pattern in matrix form. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: iunit file unit to write to.\n(assumed to be already opened) private  subroutine terminate (me) A user-callable routine. When called, it will terminate\nall computations and return. The istat return code will be\nset to -1 . This can be called in the function or the info function. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me private  subroutine raise_exception (me, istat, routine, error_msg) Raise an exception. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me integer, intent(in) :: istat error code. character(len=*), intent(in) :: routine the routine where the error was raised. character(len=*), intent(in) :: error_msg error message string. private  subroutine clear_exceptions (me) Clear all exceptions. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me private  subroutine get_error_status (me, istat, error_msg) Returns the current error code and message. Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(in) :: me integer, intent(out), optional :: istat error code ( istat=0 means no errors). character(len=:), intent(out), optional, allocatable :: error_msg error message string.","tags":"","loc":"module/numerical_differentiation_module.html"},{"title":"lusol_ez_module – AoC-2023","text":"Wrapper for LUSOL. Will eventually be moved into a separate repo. Uses lusol_precision lusol module~~lusol_ez_module~~UsesGraph module~lusol_ez_module lusol_ez_module module~lusol lusol module~lusol_ez_module->module~lusol module~lusol_precision lusol_precision module~lusol_ez_module->module~lusol_precision module~lusol->module~lusol_precision iso_fortran_env iso_fortran_env module~lusol_precision->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~lusol_ez_module~~UsedByGraph module~lusol_ez_module lusol_ez_module proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver proc~nlesolver_solver->module~lusol_ez_module program~main main program~main->module~lusol_ez_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: lusol_settings Components Type Visibility Attributes Name Initial integer(kind=ip), public :: nout = 6 integer(kind=ip), public :: lprint = 0 integer(kind=ip), public :: maxcol = 5 integer(kind=ip), public :: method = 0 integer(kind=ip), public :: keepLU = 1 real(kind=rp), public :: Ltol1 = 100.0_rp real(kind=rp), public :: Ltol2 = 10.0_rp real(kind=rp), public :: small = epsilon(1.0_rp)**0.8_rp real(kind=rp), public :: Utol1 = epsilon(1.0_rp)**0.67_rp real(kind=rp), public :: Utol2 = epsilon(1.0_rp)**0.67_rp real(kind=rp), public :: Uspace = 3.0_rp real(kind=rp), public :: dens1 = 0.3_rp real(kind=rp), public :: dens2 = 0.5_rp integer(kind=ip), public :: mode = 5 Subroutines public  subroutine solve (n_cols, n_rows, n_nonzero, irow, icol, mat, b, x, istat, settings) Wrapper for lu1fac + lu6sol to solve a linear system A*x = b . Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_cols n : number of columns in A. integer, intent(in) :: n_rows m : number of rows in A. integer, intent(in) :: n_nonzero number of nonzero elements of A. integer, intent(in), dimension(n_nonzero) :: irow sparsity pattern (size is n_nonzero ) integer, intent(in), dimension(n_nonzero) :: icol sparsity pattern (size is n_nonzero ) real(kind=rp), intent(in), dimension(n_nonzero) :: mat matrix elements (size is n_nonzero ) real(kind=rp), intent(in), dimension(n_rows) :: b right hand side (size is m ) real(kind=rp), intent(out), dimension(n_cols) :: x solution !size is n integer, intent(out) :: istat status code type( lusol_settings ), intent(in), optional :: settings settings (if not present, defaults are used)","tags":"","loc":"module/lusol_ez_module.html"},{"title":"lusol – AoC-2023","text":"Uses lusol_precision module~~lusol~~UsesGraph module~lusol lusol module~lusol_precision lusol_precision module~lusol->module~lusol_precision iso_fortran_env iso_fortran_env module~lusol_precision->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~lusol~~UsedByGraph module~lusol lusol module~lusol_ez_module lusol_ez_module module~lusol_ez_module->module~lusol proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver proc~nlesolver_solver->module~lusol_ez_module program~main main program~main->module~lusol_ez_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer(kind=ip), private, parameter :: i1 = 1 integer(kind=ip), private, parameter :: i2 = 2 real(kind=rp), private, parameter :: zero = 0.0 real(kind=rp), private, parameter :: one = 1.0 Functions private  function jdamax (n, x, incx) result(iAmax) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: n real(kind=rp), intent(in) :: x (:) integer(kind=ip), intent(in) :: incx Return Value integer(kind=ip) Subroutines public  subroutine lu1fac (m, n, nelem, lena, luparm, parmlu, a, indc, indr, p, q, lenc, lenr, locc, locr, iploc, iqloc, ipinv, iqinv, w, inform) ! nelem  = numnz     !!! Don't change nelem.\n! nelem is now numnz below (it might be less than the input value). Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: nelem integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: indc (lena) integer(kind=ip), intent(inout) :: indr (lena) integer(kind=ip), intent(inout) :: p (m) integer(kind=ip), intent(inout) :: q (n) integer(kind=ip), intent(inout) :: lenc (n) integer(kind=ip), intent(inout) :: lenr (m) integer(kind=ip), intent(inout) :: locc (n) integer(kind=ip), intent(inout) :: locr (m) integer(kind=ip), intent(inout) :: iploc (n) integer(kind=ip), intent(inout) :: iqloc (m) integer(kind=ip), intent(inout) :: ipinv (m) integer(kind=ip), intent(inout) :: iqinv (n) real(kind=rp), intent(inout) :: w (n) integer(kind=ip), intent(out) :: inform private  subroutine lu1fad (m, n, nelem, lena, luparm, parmlu, a, indc, indr, p, q, lenc, lenr, locc, locr, iploc, iqloc, ipinv, iqinv, w, lenH, Ha, Hj, Hk, Amaxr, inform, lenL, lenU, minlen, mersum, nUtri, nLtri, ndens1, ndens2, nrank, nslack, Lmax, Umax, DUmax, DUmin, Akmax) !   a(ldiagU + nrowu) = abest ! This was in pivot order.\n!!! DEBUG Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: nelem integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: indc (lena) integer(kind=ip), intent(inout) :: indr (lena) integer(kind=ip), intent(inout) :: p (m) integer(kind=ip), intent(inout) :: q (n) integer(kind=ip), intent(inout) :: lenc (n) integer(kind=ip), intent(inout) :: lenr (m) integer(kind=ip), intent(inout) :: locc (n) integer(kind=ip), intent(inout) :: locr (m) integer(kind=ip), intent(inout) :: iploc (n) integer(kind=ip), intent(inout) :: iqloc (m) integer(kind=ip), intent(inout) :: ipinv (m) integer(kind=ip), intent(inout) :: iqinv (n) real(kind=rp), intent(inout) :: w (n) integer(kind=ip), intent(in) :: lenH real(kind=rp), intent(inout) :: Ha (lenH) integer(kind=ip), intent(inout) :: Hj (lenH) integer(kind=ip), intent(inout) :: Hk (lenH) real(kind=rp), intent(inout) :: Amaxr (m) integer(kind=ip), intent(out) :: inform integer(kind=ip), intent(out) :: lenL integer(kind=ip), intent(out) :: lenU integer(kind=ip), intent(out) :: minlen integer(kind=ip), intent(out) :: mersum integer(kind=ip), intent(out) :: nUtri integer(kind=ip), intent(out) :: nLtri integer(kind=ip), intent(out) :: ndens1 integer(kind=ip), intent(out) :: ndens2 integer(kind=ip), intent(out) :: nrank integer(kind=ip), intent(in) :: nslack real(kind=rp), intent(out) :: Lmax real(kind=rp), intent(out) :: Umax real(kind=rp), intent(out) :: DUmax real(kind=rp), intent(out) :: DUmin real(kind=rp), intent(out) :: Akmax private  subroutine lu1gau (m, melim, ncold, nspare, small, lpivc1, lpivc2, lfirst, lpivr2, lfree, minfre, ilast, jlast, lrow, lcol, lu, nfill, a, indc, indr, lenc, lenr, locc, locr, mark, al, markl, au, ifill, jfill) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: melim integer(kind=ip), intent(in) :: ncold integer(kind=ip), intent(in) :: nspare real(kind=rp), intent(in) :: small integer(kind=ip), intent(in) :: lpivc1 integer(kind=ip), intent(in) :: lpivc2 integer(kind=ip), intent(inout) :: lfirst integer(kind=ip), intent(in) :: lpivr2 integer(kind=ip), intent(in) :: lfree integer(kind=ip), intent(in) :: minfre integer(kind=ip), intent(inout) :: ilast integer(kind=ip), intent(inout) :: jlast integer(kind=ip), intent(inout) :: lrow integer(kind=ip), intent(inout) :: lcol integer(kind=ip), intent(inout) :: lu integer(kind=ip), intent(inout) :: nfill real(kind=rp), intent(inout) :: a (*) integer(kind=ip), intent(inout) :: indc (*) integer(kind=ip), intent(inout) :: indr (*) integer(kind=ip), intent(inout) :: lenc (*) integer(kind=ip), intent(inout) :: lenr (*) integer(kind=ip), intent(inout) :: locc (*) integer(kind=ip), intent(in) :: locr (*) integer(kind=ip), intent(in) :: mark (*) real(kind=rp), intent(in) :: al (melim) integer(kind=ip), intent(inout) :: markl (melim) real(kind=rp), intent(in) :: au (ncold) integer(kind=ip), intent(inout) :: ifill (melim) integer(kind=ip), intent(inout) :: jfill (ncold) private  subroutine lu1mar (m, n, lena, maxmn, TCP, aijtol, Ltol, maxcol, maxrow, ibest, jbest, mbest, a, indc, indr, p, q, lenc, lenr, locc, locr, iploc, iqloc) ! TPP\n! Absolute test for Complete Pivoting Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(in) :: maxmn logical, intent(in) :: TCP real(kind=rp), intent(in) :: aijtol real(kind=rp), intent(in) :: Ltol integer(kind=ip), intent(in) :: maxcol integer(kind=ip), intent(in) :: maxrow integer(kind=ip), intent(out) :: ibest integer(kind=ip), intent(out) :: jbest integer(kind=ip), intent(out) :: mbest real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: p (m) integer(kind=ip), intent(in) :: q (n) integer(kind=ip), intent(in) :: lenc (n) integer(kind=ip), intent(in) :: lenr (m) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(in) :: locr (m) integer(kind=ip), intent(in) :: iploc (n) integer(kind=ip), intent(in) :: iqloc (m) private  subroutine lu1mRP (m, n, lena, maxmn, Ltol, maxcol, maxrow, ibest, jbest, mbest, a, indc, indr, p, q, lenc, lenr, locc, locr, iploc, iqloc, Amaxr) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(in) :: maxmn real(kind=rp), intent(in) :: Ltol integer(kind=ip), intent(in) :: maxcol integer(kind=ip), intent(in) :: maxrow integer(kind=ip), intent(out) :: ibest integer(kind=ip), intent(out) :: jbest integer(kind=ip), intent(out) :: mbest real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: p (m) integer(kind=ip), intent(in) :: q (n) integer(kind=ip), intent(in) :: lenc (n) integer(kind=ip), intent(in) :: lenr (m) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(in) :: locr (m) integer(kind=ip), intent(in) :: iploc (n) integer(kind=ip), intent(in) :: iqloc (m) real(kind=rp), intent(in) :: Amaxr (m) private  subroutine lu1mCP (m, n, lena, aijtol, ibest, jbest, mbest, a, indc, indr, lenc, lenr, locc, Hlen, Ha, Hj) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: lena real(kind=rp), intent(in) :: aijtol integer(kind=ip), intent(out) :: ibest integer(kind=ip), intent(out) :: jbest integer(kind=ip), intent(out) :: mbest real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: lenc (n) integer(kind=ip), intent(in) :: lenr (m) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(in) :: Hlen real(kind=rp), intent(in) :: Ha (Hlen) integer(kind=ip), intent(in) :: Hj (Hlen) private  subroutine lu1mSP (m, n, lena, maxmn, Ltol, maxcol, ibest, jbest, mbest, a, indc, q, locc, iqloc) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(in) :: maxmn real(kind=rp), intent(in) :: Ltol integer(kind=ip), intent(in) :: maxcol integer(kind=ip), intent(out) :: ibest integer(kind=ip), intent(out) :: jbest integer(kind=ip), intent(out) :: mbest real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: q (n) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(in) :: iqloc (m) private  subroutine lu1pen (m, melim, ncold, nspare, ilast, lpivc1, lpivc2, lpivr1, lpivr2, lrow, lenc, lenr, locc, locr, indc, indr, ifill, jfill) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: melim integer(kind=ip), intent(in) :: ncold integer(kind=ip), intent(in) :: nspare integer(kind=ip), intent(out) :: ilast integer(kind=ip), intent(in) :: lpivc1 integer(kind=ip), intent(in) :: lpivc2 integer(kind=ip), intent(in) :: lpivr1 integer(kind=ip), intent(in) :: lpivr2 integer(kind=ip), intent(inout) :: lrow integer(kind=ip), intent(inout) :: lenc (*) integer(kind=ip), intent(inout) :: lenr (*) integer(kind=ip), intent(in) :: locc (*) integer(kind=ip), intent(inout) :: locr (*) integer(kind=ip), intent(inout) :: indc (*) integer(kind=ip), intent(inout) :: indr (*) integer(kind=ip), intent(in) :: ifill (melim) integer(kind=ip), intent(in) :: jfill (ncold) private  subroutine lu1mxc (k1, k2, q, a, indc, lenc, locc) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: k1 integer(kind=ip), intent(in) :: k2 integer(kind=ip), intent(in) :: q (k2) real(kind=rp), intent(inout) :: a (*) integer(kind=ip), intent(inout) :: indc (*) integer(kind=ip), intent(in) :: lenc (*) integer(kind=ip), intent(in) :: locc (*) private  subroutine lu1mxr (mark, k1, k2, m, n, lena, inform, a, indc, lenc, locc, indr, lenr, locr, p, markc, markr, Amaxr) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: mark integer(kind=ip), intent(in) :: k1 integer(kind=ip), intent(in) :: k2 integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(out) :: inform real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: lenc (n) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: lenr (m) integer(kind=ip), intent(in) :: locr (m) integer(kind=ip), intent(in) :: p (k2) integer(kind=ip), intent(inout) :: markc (n) integer(kind=ip), intent(inout) :: markr (m) real(kind=rp), intent(inout) :: Amaxr (m) private  subroutine lu1or1 (m, n, nelem, lena, small, a, indc, indr, lenc, lenr, Amax, numnz, lerr, inform) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: nelem integer(kind=ip), intent(in) :: lena real(kind=rp), intent(in) :: small real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: indc (lena) integer(kind=ip), intent(inout) :: indr (lena) integer(kind=ip), intent(out) :: lenc (n) integer(kind=ip), intent(out) :: lenr (m) real(kind=rp) :: Amax integer(kind=ip) :: numnz integer(kind=ip), intent(out) :: lerr integer(kind=ip), intent(out) :: inform private  subroutine lu1or2 (n, numa, lena, a, inum, jnum, lenc, locc) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: numa integer(kind=ip), intent(in) :: lena real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: inum (lena) integer(kind=ip), intent(inout) :: jnum (lena) integer(kind=ip), intent(in) :: lenc (n) integer(kind=ip), intent(out) :: locc (n) private  subroutine lu1or3 (m, n, lena, indc, lenc, locc, iw, lerr, inform) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: lenc (n) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(out) :: iw (m) integer(kind=ip), intent(out) :: lerr integer(kind=ip), intent(out) :: inform private  subroutine lu1or4 (m, n, nelem, lena, indc, indr, lenc, lenr, locc, locr) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: nelem integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(out) :: indr (lena) integer(kind=ip), intent(in) :: lenc (n) integer(kind=ip), intent(in) :: lenr (m) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(out) :: locr (m) private  subroutine lu1pq1 (m, n, len, iperm, loc, inv, num) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: len (m) integer(kind=ip), intent(out) :: iperm (m) integer(kind=ip), intent(out) :: loc (n) integer(kind=ip), intent(out) :: inv (m) integer(kind=ip), intent(out) :: num (n) private  subroutine lu1pq2 (nzpiv, nzchng, indr, lenold, lennew, iqloc, q, iqinv) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: nzpiv integer(kind=ip), intent(out) :: nzchng integer(kind=ip), intent(inout) :: indr (nzpiv) integer(kind=ip), intent(in) :: lenold (nzpiv) integer(kind=ip), intent(in) :: lennew (*) integer(kind=ip), intent(inout) :: iqloc (*) integer(kind=ip), intent(inout) :: q (*) integer(kind=ip), intent(inout) :: iqinv (*) private  subroutine lu1pq3 (n, len, iperm, iw, nrank) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: len (n) integer(kind=ip), intent(inout) :: iperm (n) integer(kind=ip), intent(out) :: iw (n) integer(kind=ip) :: nrank private  subroutine lu1rec (n, reals, luparm, ltop, ilast, lena, a, ind, lenc, locc) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: n logical, intent(in) :: reals integer(kind=ip), intent(inout) :: luparm (30) integer(kind=ip), intent(inout) :: ltop integer(kind=ip), intent(out) :: ilast integer(kind=ip), intent(in) :: lena real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: ind (lena) integer(kind=ip), intent(inout) :: lenc (n) integer(kind=ip), intent(inout) :: locc (n) private  subroutine lu1slk (m, n, lena, q, iqloc, a, indc, locc, nslack, w) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(in) :: q (n) integer(kind=ip), intent(in) :: iqloc (m) real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(out) :: nslack real(kind=rp), intent(out) :: w (n) private  subroutine lu1ful (m, n, lena, lenD, lu1, TPP, mleft, nleft, nrank, nrowu, lenL, lenU, nsing, keepLU, small, a, d, indc, indr, p, q, lenc, lenr, locc, ipinv, ipvt) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(in) :: lenD integer(kind=ip), intent(in) :: lu1 logical, intent(in) :: TPP integer(kind=ip), intent(in) :: mleft integer(kind=ip), intent(in) :: nleft integer(kind=ip), intent(in) :: nrank integer(kind=ip), intent(in) :: nrowu integer(kind=ip), intent(inout) :: lenL integer(kind=ip), intent(inout) :: lenU integer(kind=ip), intent(out) :: nsing logical, intent(in) :: keepLU real(kind=rp), intent(in) :: small real(kind=rp), intent(inout) :: a (lena) real(kind=rp), intent(out) :: d (lenD) integer(kind=ip), intent(inout) :: indc (lena) integer(kind=ip), intent(inout) :: indr (lena) integer(kind=ip), intent(inout) :: p (m) integer(kind=ip), intent(inout) :: q (n) integer(kind=ip), intent(inout) :: lenc (n) integer(kind=ip), intent(inout) :: lenr (m) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(out) :: ipinv (m) integer(kind=ip), intent(out) :: ipvt (m) private  subroutine lu1DPP (a, lda, m, n, small, nsing, ipvt, q) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: a (lda,n) integer(kind=ip), intent(in) :: lda integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n real(kind=rp), intent(in) :: small integer(kind=ip), intent(out) :: nsing integer(kind=ip), intent(out) :: ipvt (m) integer(kind=ip), intent(inout) :: q (n) private  subroutine lu1DCP (a, lda, m, n, small, nsing, ipvt, q) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: a (lda,n) integer(kind=ip), intent(in) :: lda integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n real(kind=rp), intent(in) :: small integer(kind=ip), intent(out) :: nsing integer(kind=ip), intent(out) :: ipvt (m) integer(kind=ip), intent(inout) :: q (n) private  subroutine Hbuild (Ha, Hj, Hk, N, Nk, hops) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: Ha (N) integer(kind=ip), intent(inout) :: Hj (N) integer(kind=ip), intent(inout) :: Hk (Nk) integer(kind=ip), intent(in) :: N integer(kind=ip), intent(in) :: Nk integer(kind=ip), intent(out) :: hops private  subroutine Hchange (Ha, Hj, Hk, N, Nk, k, v, jv, hops) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: Ha (N) integer(kind=ip), intent(inout) :: Hj (N) integer(kind=ip), intent(inout) :: Hk (Nk) integer(kind=ip), intent(in) :: N integer(kind=ip), intent(in) :: Nk integer(kind=ip), intent(in) :: k real(kind=rp), intent(in) :: v integer(kind=ip), intent(in) :: jv integer(kind=ip), intent(out) :: hops private  subroutine Hdelete (Ha, Hj, Hk, Nin, N, Nk, k, hops) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: Ha (Nin) integer(kind=ip), intent(inout) :: Hj (Nin) integer(kind=ip), intent(inout) :: Hk (Nk) integer(kind=ip), intent(in) :: Nin integer(kind=ip), intent(inout) :: N integer(kind=ip), intent(in) :: Nk integer(kind=ip), intent(in) :: k integer(kind=ip), intent(out) :: hops private  subroutine Hdown (Ha, Hj, Hk, N, Nk, kk, hops) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: Ha (N) integer(kind=ip), intent(inout) :: Hj (N) integer(kind=ip), intent(inout) :: Hk (Nk) integer(kind=ip), intent(in) :: N integer(kind=ip), intent(in) :: Nk integer(kind=ip), intent(in) :: kk integer(kind=ip), intent(out) :: hops private  subroutine Hinsert (Ha, Hj, Hk, N, Nk, v, jv, hops) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: Ha (N) integer(kind=ip), intent(inout) :: Hj (N) integer(kind=ip), intent(inout) :: Hk (Nk) integer(kind=ip), intent(inout) :: N integer(kind=ip), intent(in) :: Nk real(kind=rp), intent(in) :: v integer(kind=ip), intent(in) :: jv integer(kind=ip), intent(out) :: hops private  subroutine Hup (Ha, Hj, Hk, N, Nk, kk, hops) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout) :: Ha (N) integer(kind=ip), intent(inout) :: Hj (N) integer(kind=ip), intent(inout) :: Hk (Nk) integer(kind=ip), intent(in) :: N integer(kind=ip), intent(in) :: Nk integer(kind=ip), intent(in) :: kk integer(kind=ip), intent(out) :: hops public  subroutine lu6sol (mode, m, n, v, w, lena, luparm, parmlu, a, indc, indr, p, q, lenc, lenr, locc, locr, inform) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: mode integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n real(kind=rp), intent(inout) :: v (m) real(kind=rp), intent(inout) :: w (n) integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: p (m) integer(kind=ip), intent(in) :: q (n) integer(kind=ip), intent(in) :: lenc (n) integer(kind=ip), intent(in) :: lenr (m) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(in) :: locr (m) integer(kind=ip), intent(out) :: inform private  subroutine lu6L (inform, m, n, v, lena, luparm, parmlu, a, indc, indr, lenc) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(out) :: inform integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n real(kind=rp), intent(inout) :: v (m) integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: lenc (n) private  subroutine lu6Lt (inform, m, n, v, lena, luparm, parmlu, a, indc, indr, lenc) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(out) :: inform integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n real(kind=rp), intent(inout) :: v (m) integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: lenc (n) private  subroutine lu6U (inform, m, n, v, w, lena, luparm, parmlu, a, indr, p, q, lenr, locr) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(out) :: inform integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n real(kind=rp), intent(in) :: v (m) real(kind=rp), intent(out) :: w (n) integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: p (m) integer(kind=ip), intent(in) :: q (n) integer(kind=ip), intent(in) :: lenr (m) integer(kind=ip), intent(in) :: locr (m) private  subroutine lu6Ut (inform, m, n, v, w, lena, luparm, parmlu, a, indr, p, q, lenr, locr) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(out) :: inform integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n real(kind=rp), intent(out) :: v (m) real(kind=rp), intent(inout) :: w (n) integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: p (m) integer(kind=ip), intent(in) :: q (n) integer(kind=ip), intent(in) :: lenr (m) integer(kind=ip), intent(in) :: locr (m) private  subroutine lu6LD (inform, mode, m, n, v, lena, luparm, parmlu, a, indc, indr, lenc, locr) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(out) :: inform integer(kind=ip), intent(in) :: mode integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n real(kind=rp), intent(inout) :: v (m) integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: lenc (n) integer(kind=ip), intent(in) :: locr (m) private  subroutine lu6chk (mode, m, n, nslack, w, lena, luparm, parmlu, a, indc, indr, p, q, lenc, lenr, locc, locr, inform) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: mode integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: nslack real(kind=rp), intent(inout) :: w (n) integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) real(kind=rp), intent(in) :: a (lena) integer(kind=ip), intent(in) :: indc (lena) integer(kind=ip), intent(in) :: indr (lena) integer(kind=ip), intent(in) :: p (m) integer(kind=ip), intent(in) :: q (n) integer(kind=ip), intent(in) :: lenc (n) integer(kind=ip), intent(in) :: lenr (m) integer(kind=ip), intent(in) :: locc (n) integer(kind=ip), intent(in) :: locr (m) integer(kind=ip), intent(inout) :: inform private  subroutine lu7add (m, n, jadd, v, lena, luparm, parmlu, lenL, lenU, lrow, nrank, a, indr, p, lenr, locr, inform, klast, vnorm) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: jadd real(kind=rp), intent(inout) :: v (m) integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) integer(kind=ip), intent(inout) :: lenL integer(kind=ip), intent(inout) :: lenU integer(kind=ip), intent(inout) :: lrow integer(kind=ip), intent(in) :: nrank real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: indr (lena) integer(kind=ip), intent(in) :: p (m) integer(kind=ip), intent(inout) :: lenr (m) integer(kind=ip), intent(inout) :: locr (m) integer(kind=ip), intent(out) :: inform integer(kind=ip), intent(out) :: klast real(kind=rp), intent(out) :: vnorm private  subroutine lu7cyc (kfirst, klast, p) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: kfirst integer(kind=ip), intent(in) :: klast integer(kind=ip), intent(inout) :: p (klast) private  subroutine lu7elm (m, n, jelm, v, lena, luparm, parmlu, lenL, lenU, lrow, nrank, a, indc, indr, p, q, lenr, locc, locr, inform, diag) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: jelm real(kind=rp), intent(in) :: v (m) integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) integer(kind=ip), intent(inout) :: lenL integer(kind=ip), intent(in) :: lenU integer(kind=ip), intent(inout) :: lrow integer(kind=ip), intent(in) :: nrank real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: indc (lena) integer(kind=ip), intent(inout) :: indr (lena) integer(kind=ip), intent(inout) :: p (m) integer(kind=ip), intent(in) :: q (n) integer(kind=ip), intent(inout) :: lenr (m) integer(kind=ip), intent(inout) :: locc (n) integer(kind=ip), intent(inout) :: locr (m) integer(kind=ip), intent(out) :: inform real(kind=rp), intent(out) :: diag private  subroutine lu7for (m, n, kfirst, klast, lena, luparm, parmlu, lenL, lenU, lrow, a, indc, indr, p, q, lenr, locc, locr, inform, diag) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: kfirst integer(kind=ip), intent(in) :: klast integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) integer(kind=ip), intent(inout) :: lenL integer(kind=ip), intent(inout) :: lenU integer(kind=ip), intent(inout) :: lrow real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: indc (lena) integer(kind=ip), intent(inout) :: indr (lena) integer(kind=ip), intent(inout) :: p (m) integer(kind=ip), intent(in) :: q (n) integer(kind=ip), intent(inout) :: lenr (m) integer(kind=ip), intent(inout) :: locc (n) integer(kind=ip), intent(inout) :: locr (m) integer(kind=ip), intent(out) :: inform real(kind=rp), intent(out) :: diag private  subroutine lu7rnk (m, n, jsing, lena, parmlu, lenL, lenU, lrow, nrank, a, indc, indr, p, q, lenr, locc, locr, inform, diag) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: jsing integer(kind=ip), intent(in) :: lena real(kind=rp), intent(inout) :: parmlu (30) integer(kind=ip), intent(inout) :: lenL integer(kind=ip), intent(inout) :: lenU integer(kind=ip), intent(inout) :: lrow integer(kind=ip), intent(inout) :: nrank real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: indc (lena) integer(kind=ip), intent(inout) :: indr (lena) integer(kind=ip), intent(in) :: p (m) integer(kind=ip), intent(inout) :: q (n) integer(kind=ip), intent(inout) :: lenr (m) integer(kind=ip), intent(inout) :: locc (n) integer(kind=ip), intent(inout) :: locr (m) integer(kind=ip), intent(out) :: inform real(kind=rp), intent(out) :: diag private  subroutine lu7zap (m, n, jzap, kzap, lena, lenU, lrow, nrank, a, indr, p, q, lenr, locr) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: jzap integer(kind=ip), intent(out) :: kzap integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: lenU integer(kind=ip), intent(inout) :: lrow integer(kind=ip), intent(in) :: nrank real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: indr (lena) integer(kind=ip), intent(in) :: p (m) integer(kind=ip), intent(inout) :: q (n) integer(kind=ip), intent(inout) :: lenr (m) integer(kind=ip), intent(inout) :: locr (m) public  subroutine lu8rpc (mode1, mode2, m, n, jrep, v, w, lena, luparm, parmlu, a, indc, indr, p, q, lenc, lenr, locc, locr, inform, diag, vnorm) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: mode1 integer(kind=ip), intent(in) :: mode2 integer(kind=ip), intent(in) :: m integer(kind=ip), intent(in) :: n integer(kind=ip), intent(in) :: jrep real(kind=rp), intent(inout) :: v (m) real(kind=rp), intent(inout) :: w (n) integer(kind=ip), intent(in) :: lena integer(kind=ip), intent(inout) :: luparm (30) real(kind=rp), intent(inout) :: parmlu (30) real(kind=rp), intent(inout) :: a (lena) integer(kind=ip), intent(inout) :: indc (lena) integer(kind=ip), intent(inout) :: indr (lena) integer(kind=ip), intent(inout) :: p (m) integer(kind=ip), intent(inout) :: q (n) integer(kind=ip), intent(inout) :: lenc (n) integer(kind=ip), intent(inout) :: lenr (m) integer(kind=ip), intent(inout) :: locc (n) integer(kind=ip), intent(inout) :: locr (m) integer(kind=ip), intent(out) :: inform real(kind=rp), intent(out) :: diag real(kind=rp), intent(out) :: vnorm","tags":"","loc":"module/lusol.html"},{"title":"lsqr_kinds – AoC-2023","text":"Module for LSQR kinds and parameters History Jacob Williams : 8 Nov 2019 : created module Uses iso_fortran_env module~~lsqr_kinds~~UsesGraph module~lsqr_kinds lsqr_kinds iso_fortran_env iso_fortran_env module~lsqr_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~lsqr_kinds~~UsedByGraph module~lsqr_kinds lsqr_kinds module~lsqpblas_module lsqpblas_module module~lsqpblas_module->module~lsqr_kinds module~lsqr_module lsqr_module module~lsqr_module->module~lsqr_kinds module~lsqr_module->module~lsqpblas_module module~lsqrtest_module lsqrtest_module module~lsqrtest_module->module~lsqr_kinds module~lsqrtest_module->module~lsqpblas_module module~lsqrtest_module->module~lsqr_module program~main~3 main program~main~3->module~lsqr_kinds program~main~3->module~lsqr_module proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver proc~nlesolver_solver->module~lsqr_module program~main~2 main program~main~2->module~lsqrtest_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: wp = real64 default real kind [8 bytes] real(kind=wp), public, parameter :: zero = 0.0_wp real(kind=wp), public, parameter :: one = 1.0_wp","tags":"","loc":"module/lsqr_kinds.html"},{"title":"lsqr_module – AoC-2023","text":"Module for LSQR . History Jacob Williams : 8 Nov 2019 : created module Uses lsqpblas_module lsqr_kinds module~~lsqr_module~~UsesGraph module~lsqr_module lsqr_module module~lsqpblas_module lsqpblas_module module~lsqr_module->module~lsqpblas_module module~lsqr_kinds lsqr_kinds module~lsqr_module->module~lsqr_kinds module~lsqpblas_module->module~lsqr_kinds iso_fortran_env iso_fortran_env module~lsqr_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~lsqr_module~~UsedByGraph module~lsqr_module lsqr_module module~lsqrtest_module lsqrtest_module module~lsqrtest_module->module~lsqr_module proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver proc~nlesolver_solver->module~lsqr_module program~main~3 main program~main~3->module~lsqr_module program~main~2 main program~main~2->module~lsqrtest_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface private  subroutine aprod_func(me, mode, m, n, x, y) User function to access the sparse matrix A . Arguments Type Intent Optional Attributes Name class( lsqr_solver ), intent(inout) :: me integer, intent(in) :: mode If mode = 1 , compute y = y + A*x . y should be altered without changing x. If mode = 2 , compute x = x + A(transpose)*y . x should be altered without changing y . integer, intent(in) :: m number of rows in A matrix integer, intent(in) :: n number of columns in A matrix real(kind=wp), intent(inout), dimension(:) :: x real(kind=wp), intent(inout), dimension(:) :: y Derived Types type, public :: lsqr_solver main class to access the lsqr solver. Read more… Type-Bound Procedures procedure( aprod_func ), public, deferred :: aprod User function to access the sparse matrix A . procedure, public :: lsqr => LSQR main solver routine procedure, public :: acheck procedure, public :: xcheck type, public, extends( lsqr_solver ) :: lsqr_solver_ez a simplier version of lsqr_solver where\nthe aprod function is provided internally.\nTo use, first call the initialize method\nto set the matrix and other inputs. Components Type Visibility Attributes Name Initial integer, private :: m = 0 number of rows in A matrix integer, private :: n = 0 number of columns in A matrix integer, private :: num_nonzero_elements = 0 number of nonzero elements in A matrix integer, private, dimension(:), allocatable :: irow sparsity row indices integer, private, dimension(:), allocatable :: icol sparsity column indices real(kind=wp), private, dimension(:), allocatable :: a sparse A matrix real(kind=wp), private :: atol = zero relative error in definition of A real(kind=wp), private :: btol = zero relative error in definition of b real(kind=wp), private :: conlim = zero An upper limit on cond(Abar) , the apparent\ncondition number of the matrix Abar . integer, private :: itnlim = 100 max iterations integer, private :: nout = 0 output unit for printing real(kind=wp), private, dimension(:), allocatable :: Ax A*x (dimension m) real(kind=wp), private, dimension(:), allocatable :: Aty A(transpose)*y (dimension n) real(kind=wp), private, dimension(:), allocatable :: v workspace array (dimension n) real(kind=wp), private, dimension(:), allocatable :: w workspace array (dimension n) Type-Bound Procedures procedure, public :: lsqr => LSQR main solver routine procedure, public :: acheck procedure, public :: xcheck procedure, public :: initialize => initialize_ez Constructor. Must be call first. procedure, public :: solve => solve_ez procedure, public :: aprod => aprod_ez internal routine Functions private pure function d2norm (a, b) Returns with precautions to avoid overflow. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b Return Value real(kind=wp) Subroutines private  subroutine initialize_ez (me, m, n, a, irow, icol, atol, btol, conlim, itnlim, nout) Constructor for lsqr_solver_ez . Arguments Type Intent Optional Attributes Name class( lsqr_solver_ez ), intent(out) :: me integer, intent(in) :: m number of rows in A matrix integer, intent(in) :: n number of columns in A matrix real(kind=wp), intent(in), dimension(:) :: a nonzero elements of A integer, intent(in), dimension(:) :: irow row indices of nonzero elements of A integer, intent(in), dimension(:) :: icol column indices of nonzero elements of A real(kind=wp), intent(in), optional :: atol relative error in definition of A real(kind=wp), intent(in), optional :: btol relative error in definition of b real(kind=wp), intent(in), optional :: conlim An upper limit on cond(Abar) , the apparent\ncondition number of the matrix Abar . integer, intent(in), optional :: itnlim max iterations integer, intent(in), optional :: nout output unit for printing private  subroutine aprod_ez (me, mode, m, n, x, y) The internal aprod function for the lsqr_solver_ez class. Arguments Type Intent Optional Attributes Name class( lsqr_solver_ez ), intent(inout) :: me integer, intent(in) :: mode Read more… integer, intent(in) :: m number of rows in A matrix integer, intent(in) :: n number of columns in A matrix real(kind=wp), intent(inout), dimension(:) :: x [n] real(kind=wp), intent(inout), dimension(:) :: y [m] private  subroutine solve_ez (me, b, damp, x, istop, se, itn, anorm, acond, rnorm, arnorm, xnorm) Wrapper for LSQR for the easy version of the class. Arguments Type Intent Optional Attributes Name class( lsqr_solver_ez ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%m) :: b real(kind=wp), intent(in) :: damp real(kind=wp), intent(out), dimension(me%n) :: x the computed solution x . integer, intent(out) :: istop exit code (see LSQR ). real(kind=wp), intent(out), optional, dimension(me%n) :: se integer, intent(out), optional :: itn real(kind=wp), intent(out), optional :: anorm real(kind=wp), intent(out), optional :: acond real(kind=wp), intent(out), optional :: rnorm real(kind=wp), intent(out), optional :: arnorm real(kind=wp), intent(out), optional :: xnorm private  subroutine LSQR (me, m, n, damp, wantse, u, v, w, x, se, atol, btol, conlim, itnlim, nout, istop, itn, anorm, acond, rnorm, arnorm, xnorm) LSQR finds a solution to the following problems: Read more… Arguments Type Intent Optional Attributes Name class( lsqr_solver ), intent(inout) :: me integer, intent(in) :: m the number of rows in A . integer, intent(in) :: n the number of columns in A . real(kind=wp), intent(in) :: damp The damping parameter for problem 3 above.\n(damp should be 0.0 for problems 1 and 2.)\nIf the system A*x = b is incompatible, values\nof damp in the range 0 to sqrt(relpr)*norm(A) will probably have a negligible effect.\nLarger values of damp will tend to decrease\nthe norm of x and reduce the number of\niterations required by LSQR. Read more… logical, intent(in) :: wantse A logical variable to say if the array se(*) of standard error estimates should be computed.\nIf m > n or damp > 0 ,  the system is\noverdetermined and the standard errors may be\nuseful.  (See the first LSQR reference.)\nOtherwise ( m <= n and damp = 0 ) they do not\nmean much.  Some time and storage can be saved\nby setting wantse = .false. and using any\nconvenient array for se(*) , which won't be\ntouched. real(kind=wp), intent(inout) :: u (m) The rhs vector b .  Beware that u is\nover-written by LSQR. real(kind=wp), intent(inout) :: v (n) workspace real(kind=wp), intent(inout) :: w (n) workspace real(kind=wp), intent(out) :: x (n) Returns the computed solution x . real(kind=wp), intent(out), dimension(*) :: se If wantse is true, the dimension of se must be n or more. se(*) then returns standard error\nestimates for the components of x .\nFor each i , se(i) is set to the value rnorm * sqrt( sigma(i,i) / t ) ,\nwhere sigma(i,i) is an estimate of the i-th\ndiagonal of the inverse of Abar(transpose)*Abar and:\n* t = 1      if  m <= n * t = m - n  if  m > n  and  damp = 0 * t = m      if  damp /= 0 Read more… real(kind=wp), intent(in) :: atol An estimate of the relative error in the data\ndefining the matrix A .  For example,\nif A is accurate to about 6 digits, set atol = 1.0e-6 . real(kind=wp), intent(in) :: btol An estimate of the relative error in the data\ndefining the rhs vector b .  For example,\nif b is accurate to about 6 digits, set btol = 1.0e-6 . real(kind=wp), intent(in) :: conlim An upper limit on cond(Abar) , the apparent\ncondition number of the matrix Abar .\nIterations will be terminated if a computed\nestimate of cond(Abar) exceeds conlim .\nThis is intended to prevent certain small or\nzero singular values of A or Abar from\ncoming into effect and causing unwanted growth\nin the computed solution. Read more… integer, intent(in) :: itnlim An upper limit on the number of iterations.\nSuggested value:\n* itnlim = n/2 for well-conditioned systems\n  with clustered singular values,\n* itnlim = 4*n otherwise. integer, intent(in) :: nout File number for printed output.  If nonzero,\na summary will be printed on file nout . integer, intent(out) :: istop An integer giving the reason for termination: Read more… integer, intent(out) :: itn The number of iterations performed. real(kind=wp), intent(out) :: anorm An estimate of the Frobenius norm of Abar .\nThis is the square-root of the sum of squares\nof the elements of Abar .\nIf damp is small and if the columns of A have all been scaled to have length 1.0, anorm should increase to roughly sqrt(n) .\nA radically different value for anorm may\nindicate an error in subroutine aprod (there\nmay be an inconsistency between modes 1 and 2). real(kind=wp), intent(out) :: acond An estimate of cond(Abar) , the condition\nnumber of Abar .  A very high value of acond may again indicate an error in aprod . real(kind=wp), intent(out) :: rnorm An estimate of the final value of norm(rbar) ,\nthe function being minimized (see notation\nabove).  This will be small if A*x = b has\na solution. real(kind=wp), intent(out) :: arnorm An estimate of the final value of norm( Abar(transpose)*rbar ) , the norm of\nthe residual for the usual normal equations.\nThis should be small in all cases.  (arnorm\nwill often be smaller than the true value\ncomputed from the output vector x .) real(kind=wp), intent(out) :: xnorm An estimate of the norm of the final\nsolution vector x . private  subroutine acheck (me, m, n, nout, eps, v, w, x, y, inform) Checks the two modes of aprod for LSQR . Read more… Arguments Type Intent Optional Attributes Name class( lsqr_solver ), intent(inout) :: me integer, intent(in) :: m No. of rows of A. integer, intent(in) :: n No. of columns of A. integer, intent(in) :: nout A file number for printed output. real(kind=wp), intent(in) :: eps The machine precision. real(kind=wp) :: v (n) real(kind=wp) :: w (m) real(kind=wp) :: x (n) real(kind=wp) :: y (m) integer, intent(out) :: inform Error indicator.\ninform = 0 if aprod seems to be\nconsistent.\ninform = 1 otherwise. private  subroutine xcheck (me, m, n, nout, anorm, damp, eps, b, u, v, w, x, inform, test1, test2, test3) Tests if x solves a certain least-squares problem. Read more… Arguments Type Intent Optional Attributes Name class( lsqr_solver ), intent(inout) :: me integer, intent(in) :: m The number of rows in A. integer, intent(in) :: n The number of columns in A. integer, intent(in) :: nout A file number for printed output.\nIf nout = 0, nothing is printed. real(kind=wp), intent(in) :: anorm An estimate of norm(A) or\nnorm( A, delta*I ) if delta > 0.\nNormally this will be available\nfrom LSQR or CRAIG. real(kind=wp), intent(in) :: damp Possibly defines a damped problem. real(kind=wp), intent(in) :: eps Machine precision. real(kind=wp), intent(in) :: b (m) The right-hand side of Ax = b etc. real(kind=wp), intent(out) :: u (m) On exit, u = r (where r = b - Ax). real(kind=wp), intent(out) :: v (n) On exit, v = A'r. real(kind=wp), intent(out) :: w (n) On exit, w = A'r - damp&#94;2 x. real(kind=wp), intent(in) :: x (n) The given estimate of a solution. integer, intent(out) :: inform inform = 0 if b = 0 and x = 0.\ninform = 1, 2 or 3 if x seems to\nsolve systems 1 2 or 3 above. real(kind=wp), intent(out) :: test1 These are dimensionless quantities\nthat should be \"small\" if x does\nseem to solve one of the systems.\n\"small\" means less than\ntol = eps**power, where power is\ndefined as a parameter below. real(kind=wp), intent(out) :: test2 These are dimensionless quantities\nthat should be \"small\" if x does\nseem to solve one of the systems.\n\"small\" means less than\ntol = eps**power, where power is\ndefined as a parameter below. real(kind=wp), intent(out) :: test3 These are dimensionless quantities\nthat should be \"small\" if x does\nseem to solve one of the systems.\n\"small\" means less than\ntol = eps**power, where power is\ndefined as a parameter below.","tags":"","loc":"module/lsqr_module.html"},{"title":"test2 – AoC-2023","text":"Uses iso_fortran_env numdiff_kinds_module pyplot_module numerical_differentiation_module program~~test2~~UsesGraph program~test2 test2 iso_fortran_env iso_fortran_env program~test2->iso_fortran_env module~numdiff_kinds_module numdiff_kinds_module program~test2->module~numdiff_kinds_module module~numerical_differentiation_module numerical_differentiation_module program~test2->module~numerical_differentiation_module pyplot_module pyplot_module program~test2->pyplot_module module~numdiff_kinds_module->iso_fortran_env module~numerical_differentiation_module->iso_fortran_env module~numerical_differentiation_module->module~numdiff_kinds_module module~diff_module diff_module module~numerical_differentiation_module->module~diff_module module~dsm_module dsm_module module~numerical_differentiation_module->module~dsm_module module~numdiff_cache_module numdiff_cache_module module~numerical_differentiation_module->module~numdiff_cache_module module~numdiff_utilities_module numdiff_utilities_module module~numerical_differentiation_module->module~numdiff_utilities_module module~diff_module->module~numdiff_kinds_module module~dsm_module->module~numdiff_kinds_module module~numdiff_cache_module->iso_fortran_env module~numdiff_cache_module->module~numdiff_kinds_module module~numdiff_cache_module->module~numdiff_utilities_module module~numdiff_utilities_module->module~numdiff_kinds_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Test2 for the numerical differentiation module.\nMakes a plot of the errors using different methods and step sizes. Calls program~~test2~~CallsGraph program~test2 test2 add_plot add_plot program~test2->add_plot initialize initialize program~test2->initialize proc~compute_jacobian numerical_differentiation_module::numdiff_type%compute_jacobian program~test2->proc~compute_jacobian proc~deriv test2::deriv program~test2->proc~deriv proc~destroy_numdiff_type numerical_differentiation_module::numdiff_type%destroy_numdiff_type program~test2->proc~destroy_numdiff_type proc~failed numerical_differentiation_module::numdiff_type%failed program~test2->proc~failed proc~get_error_status numerical_differentiation_module::numdiff_type%get_error_status program~test2->proc~get_error_status proc~get_finite_diff_formula numerical_differentiation_module::get_finite_diff_formula program~test2->proc~get_finite_diff_formula savefig savefig program~test2->savefig proc~compute_perturbation_vector numerical_differentiation_module::numdiff_type%compute_perturbation_vector proc~compute_jacobian->proc~compute_perturbation_vector proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_jacobian->proc~raise_exception proc~get_finite_difference_method numerical_differentiation_module::get_finite_difference_method proc~get_finite_diff_formula->proc~get_finite_difference_method proc~get_formula numerical_differentiation_module::finite_diff_method%get_formula proc~get_finite_diff_formula->proc~get_formula proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_perturbation_vector->proc~compute_perturb_vector proc~integer_to_string~2 numerical_differentiation_module::integer_to_string proc~get_formula->proc~integer_to_string~2 proc~compute_perturb_vector->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: n = 1 number of variables integer, parameter :: m = 1 number of functions real(kind=wp), parameter,               dimension(n) :: x = 1.0_wp point at which to compute the derivative real(kind=wp), parameter,               dimension(n) :: xlow = -100000.0_wp bounds not really needed real(kind=wp), parameter,               dimension(n) :: xhigh = 100000.0_wp integer, parameter :: perturb_mode = 1 absolute step integer, parameter :: cache_size = 0 0 indicates not to use cache integer, parameter :: sparsity_mode = 1 assume dense integer, parameter,               dimension(*) :: methods = [1, 3, 10, 21, 36, 500, 600, 700, 800] array of method IDs:\n[1,3,10,21,36,500,600,700,800]\nforward + all the central diff ones integer, parameter :: exp_star = -ceiling(log10(epsilon(1.0_wp))) exponent to start with integer, parameter :: exp_stop = -2 exponent to end with integer, parameter :: exp_step = -1 ecponent step integer, parameter :: exp_scale = 5 number of substeps from one to the next type( numdiff_type ) :: my_prob main class to compute the derivatives integer :: i method counter integer :: j counter real(kind=wp), dimension(:), allocatable :: jac jacobian integer :: func_evals function evaluation counter character(len=:), allocatable :: error_msg error message string real(kind=wp), dimension(n) :: dpert perturbation step size integer :: ipert perturbation step size counter real(kind=wp) :: error diff from true derivative integer :: num_dperts number of dperts to test integer :: num_methods number of methods to test real(kind=wp), dimension(:), allocatable :: results_dpert results array - dpert real(kind=wp), dimension(:), allocatable :: results_errors results array - errors type(pyplot) :: plt for plotting the results character(len=:), allocatable :: formula finite diff formula for the plot legend character(len=:), allocatable :: name finite diff name for the plot legend integer :: idx index in results arrays character(len=:), allocatable :: real_kind_str real kind for the plot title real(kind=wp), dimension(3) :: color line color array real(kind=wp), dimension(2) :: ylim plot y limit array Functions function func (x) Problem function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) function deriv (x) Problem function true derivative Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) Subroutines subroutine my_func (me, x, f, funcs_to_compute) Problem function interface for numdiff Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: f integer, intent(in), dimension(:) :: funcs_to_compute Source Code program test2 use iso_fortran_env use numerical_differentiation_module use numdiff_kinds_module , only : wp use pyplot_module implicit none integer , parameter :: n = 1 !! number of variables integer , parameter :: m = 1 !! number of functions real ( wp ), dimension ( n ), parameter :: x = 1.0_wp !! point at which to compute the derivative real ( wp ), dimension ( n ), parameter :: xlow = - 10000 0.0_wp !! bounds not really needed real ( wp ), dimension ( n ), parameter :: xhigh = 10000 0.0_wp !! integer , parameter :: perturb_mode = 1 !! absolute step integer , parameter :: cache_size = 0 !! `0` indicates not to use cache integer , parameter :: sparsity_mode = 1 !! assume dense integer , dimension ( * ), parameter :: methods = [ 1 , 3 , 10 , 21 , 36 , 500 , 600 , 700 , 800 ] !! array of method IDs: !! [1,3,10,21,36,500,600,700,800] !! forward + all the central diff ones integer , parameter :: exp_star = - ceiling ( log10 ( epsilon ( 1.0_wp ))) !! exponent to start with integer , parameter :: exp_stop = - 2 !! exponent to end with integer , parameter :: exp_step = - 1 !! ecponent step integer , parameter :: exp_scale = 5 !! number of substeps from one to the next type ( numdiff_type ) :: my_prob !! main class to compute the derivatives integer :: i !! method counter integer :: j !! counter real ( wp ), dimension (:), allocatable :: jac !! jacobian integer :: func_evals !! function evaluation counter character ( len = :), allocatable :: error_msg !! error message string real ( wp ), dimension ( n ) :: dpert !! perturbation step size integer :: ipert !! perturbation step size counter real ( wp ) :: error !! diff from true derivative integer :: num_dperts !! number of dperts to test integer :: num_methods !! number of methods to test real ( wp ), dimension (:), allocatable :: results_dpert !! results array - dpert real ( wp ), dimension (:), allocatable :: results_errors !! results array - errors type ( pyplot ) :: plt !! for plotting the results character ( len = :), allocatable :: formula !! finite diff formula for the plot legend character ( len = :), allocatable :: name !! finite diff name for the plot legend integer :: idx !! index in results arrays character ( len = :), allocatable :: real_kind_str !! real kind for the plot title real ( wp ), dimension ( 3 ) :: color !! line color array real ( wp ), dimension ( 2 ) :: ylim !! plot y limit array ! size the arrays: num_methods = size ( methods ) num_dperts = size ([( i , i = exp_star * exp_scale , exp_stop * exp_scale , exp_step )]) allocate ( results_errors ( num_dperts )); results_errors = - huge ( 1.0_wp ) ! for plot title: select case ( wp ) case ( REAL32 ); real_kind_str = '[Single Precision]' case ( REAL64 ); real_kind_str = '[Double Precision]' case ( REAL128 ); real_kind_str = '[Quad Precision]' case default ; error stop 'Invalid real kind' end select ! initialize the plot: call plt % initialize ( grid = . true .,& figsize = [ 20 , 10 ],& axes_labelsize = 30 , & xtick_labelsize = 30 , & ytick_labelsize = 30 , & font_size = 30 , & xlabel = 'Finite Difference Perturbation Step Size $h$' ,& ylabel = 'Finite Difference Derivative Error' ,& title = 'Derivative of $x + \\sin(x)$ at $x=1$ ' // real_kind_str ,& legend = . true ., & legend_fontsize = 10 ,& usetex = . true .) ! try different finite diff methods do j = 1 , size ( methods ) idx = 0 i = methods ( j ) ! method id call get_finite_diff_formula ( i , formula , name ) ! cycle through perturbation step sizes: do ipert = exp_star * exp_scale , exp_stop * exp_scale , exp_step idx = idx + 1 ! index for arrays dpert = 1 0.0_wp ** ( - ipert / real ( exp_scale , wp )) ! compute perturbation step size if ( j == 1 ) then if (. not . allocated ( results_dpert )) allocate ( results_dpert ( 0 )) results_dpert = [ results_dpert , dpert ( 1 )] ! save dpert end if func_evals = 0 call my_prob % destroy () call my_prob % initialize ( n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func = my_func ,& sparsity_mode = sparsity_mode ,& jacobian_method = i ,& partition_sparsity_pattern = . false .,& cache_size = cache_size ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) error stop error_msg end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) error stop error_msg end if error = abs ( deriv ( x ( 1 )) - jac ( 1 )) !write(output_unit,'(I5,1X,*(F27.16))') i , dpert, error if ( error <= epsilon ( 1.0_wp )) error = 0.0_wp results_errors ( idx ) = error ! save result end do ! line color for the plot: select case ( j ) case ( 1 ); color = [ 1.0_wp , 0.0_wp , 0.0_wp ] ! red case ( 2 ); color = [ 0.0_wp , 1.0_wp , 0.0_wp ] ! green case default ! blue gradient for the others color = [ real ( j - 2 , wp ) / num_methods , & real ( j - 2 , wp ) / num_methods , & 0.9_wp ] end select ylim = [ 1 0.0_wp ** ( ceiling ( log10 ( epsilon ( 1.0_wp )))), 1.0_wp ] ! plot for this method: call plt % add_plot ( results_dpert , results_errors ,& xscale = 'log' , yscale = 'log' ,& label = formula , linestyle = '.-' , markersize = 5 , linewidth = 2 , & color = color ,& xlim = ylim ,& ylim = ylim ) end do ! save plot: call plt % savefig ( 'results ' // real_kind_str // '.pdf' , pyfile = 'results.py' ) contains function func ( x ) !! Problem function real ( wp ), intent ( in ) :: x real ( wp ) :: func func = x + sin ( x ) end function func function deriv ( x ) !! Problem function true derivative real ( wp ), intent ( in ) :: x real ( wp ) :: deriv deriv = 1.0_wp + cos ( x ) end function deriv subroutine my_func ( me , x , f , funcs_to_compute ) !! Problem function interface for numdiff class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f integer , dimension (:), intent ( in ) :: funcs_to_compute if ( any ( funcs_to_compute == 1 )) f ( 1 ) = func ( x ( 1 )) func_evals = func_evals + 1 end subroutine my_func !******************************************************************************* end program test2","tags":"","loc":"program/test2.html"},{"title":"sparse_test – AoC-2023","text":"Uses nlesolver_module program~~sparse_test~~UsesGraph program~sparse_test sparse_test module~nlesolver_module nlesolver_module program~sparse_test->module~nlesolver_module iso_fortran_env iso_fortran_env module~nlesolver_module->iso_fortran_env module~fmin_module fmin_module module~nlesolver_module->module~fmin_module module~fmin_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Test of a sparse problem. Calls program~~sparse_test~~CallsGraph program~sparse_test sparse_test proc~get_status nlesolver_module::nlesolver_type%get_status program~sparse_test->proc~get_status proc~initialize_nlesolver_variables nlesolver_module::nlesolver_type%initialize_nlesolver_variables program~sparse_test->proc~initialize_nlesolver_variables proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver program~sparse_test->proc~nlesolver_solver proc~set_status nlesolver_module::nlesolver_type%set_status proc~initialize_nlesolver_variables->proc~set_status proc~initialize_ez lsqr_module::lsqr_solver_ez%initialize_ez proc~nlesolver_solver->proc~initialize_ez proc~linear_solver nlesolver_module::linear_solver proc~nlesolver_solver->proc~linear_solver proc~nlesolver_solver->proc~set_status proc~solve_ez lsqr_module::lsqr_solver_ez%solve_ez proc~nlesolver_solver->proc~solve_ez proc~lsqr lsqr_module::lsqr_solver%LSQR proc~solve_ez->proc~lsqr aprod aprod proc~lsqr->aprod proc~d2norm lsqr_module::d2norm proc~lsqr->proc~d2norm proc~dcopy lsqpblas_module::dcopy proc~lsqr->proc~dcopy proc~dnrm2 lsqpblas_module::dnrm2 proc~lsqr->proc~dnrm2 proc~dscal lsqpblas_module::dscal proc~lsqr->proc~dscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: n = 2 integer, parameter :: m = 2 integer, parameter :: max_iter = 100 real(kind=wp), parameter :: tol = 1.0e-8_wp logical, parameter :: verbose = .false. type( nlesolver_type ) :: solver real(kind=wp) :: alpha logical :: use_broyden integer :: step_mode integer :: n_intervals integer :: istat Integer status code. character(len=:), allocatable :: message Text status message real(kind=wp), dimension(n) :: x integer :: f_evals integer :: i character(len=:), allocatable :: description real(kind=wp) :: fmin_tol integer, parameter,               dimension(3) :: icol = [1, 2, 2] integer, parameter,               dimension(3) :: irow = [1, 1, 2] Subroutines subroutine func (me, x, f) compute the function Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: f subroutine grad (me, x, g) compute the gradient of the function (Jacobian): Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:,:) :: g subroutine grad_sparse (me, x, g) compute the gradient of the function (Jacobian): Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: g subroutine export (me, x, f, iter) export an iteration: Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: f integer, intent(in) :: iter iteration number Source Code program sparse_test use nlesolver_module , wp => nlesolver_rk implicit none integer , parameter :: n = 2 integer , parameter :: m = 2 integer , parameter :: max_iter = 100 real ( wp ), parameter :: tol = 1.0e-8_wp logical , parameter :: verbose = . false . type ( nlesolver_type ) :: solver real ( wp ) :: alpha logical :: use_broyden integer :: step_mode integer :: n_intervals integer :: istat !! Integer status code. character ( len = :), allocatable :: message !! Text status message real ( wp ), dimension ( n ) :: x integer :: f_evals integer :: i character ( len = :), allocatable :: description real ( wp ) :: fmin_tol integer , dimension ( 3 ), parameter :: icol = [ 1 , 2 , 2 ] integer , dimension ( 3 ), parameter :: irow = [ 1 , 1 , 2 ] fmin_tol = 1.0e-2_wp ! don't need a tight tol for this n_intervals = 2 alpha = 1.0_wp write ( * , * ) '' write ( * , * ) '***********************' write ( * , * ) '* sparse_test         *' write ( * , * ) '***********************' write ( * , * ) '' do i = 1 , 8 select case ( i ) case ( 1 ) step_mode = 1 use_broyden = . false . f_evals = 0 description = 'Constant alpha' case ( 2 ) cycle ! not yet supported step_mode = 1 use_broyden = . true . f_evals = 0 description = 'Constant alpha + broyden' case ( 3 ) step_mode = 2 use_broyden = . false . f_evals = 0 description = 'Backtracking line search' case ( 4 ) cycle ! not yet supported step_mode = 2 use_broyden = . true . f_evals = 0 description = 'Backtracking line search + broyden' case ( 5 ) step_mode = 3 use_broyden = . false . f_evals = 0 description = 'Exact line search' case ( 6 ) cycle ! not yet supported step_mode = 3 use_broyden = . true . f_evals = 0 description = 'Exact line search + broyden' case ( 7 ) step_mode = 4 use_broyden = . false . f_evals = 0 description = 'Fixed point search' case ( 8 ) cycle ! not yet supported step_mode = 4 use_broyden = . true . f_evals = 0 description = 'Fixed point search + broyden' case default error stop 'invalid case' end select write ( * , * ) '-------------------------------------------------------' write ( * , '(A,I3,A,A)' ) 'Case ' , i , ' : ' , description write ( * , * ) '' call solver % initialize ( n = n , & m = m , & max_iter = max_iter , & tol = tol , & func = func , & grad_sparse = grad_sparse , & step_mode = step_mode ,& use_broyden = use_broyden ,& export_iteration = export ,& n_intervals = n_intervals , & fmin_tol = fmin_tol , & verbose = verbose ,& sparsity_mode = 3 ,& irow = irow ,& icol = icol ,& damp = 1.0_wp ) call solver % status ( istat , message ) write ( * , '(I3,1X,A)' ) istat , message if ( istat /= 0 ) error stop x = [ 1.0_wp , 2.0_wp ] call solver % solve ( x ) call solver % status ( istat , message ) write ( * , '(I3,1X,A)' ) istat , message write ( * , * ) '' end do contains subroutine func ( me , x , f ) !! compute the function implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f f_evals = f_evals + 1 f ( 1 ) = x ( 1 ) ** 2 + x ( 2 ) - 0.1_wp f ( 2 ) = x ( 2 ) + 0.2_wp ! root is 5.477226E-01  -2.000000E-01 end subroutine func subroutine grad ( me , x , g ) !! compute the gradient of the function (Jacobian): implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:,:), intent ( out ) :: g f_evals = f_evals + 2 ! to approximate forward diff derivatives g ( 1 , 1 ) = 2.0_wp * x ( 1 ) !df(1)/dx g ( 2 , 1 ) = 0.0_wp !df(2)/dx g ( 1 , 2 ) = 1.0_wp !df(1)/dy g ( 2 , 2 ) = 1.0_wp !df(2)/dy end subroutine grad subroutine grad_sparse ( me , x , g ) !! compute the gradient of the function (Jacobian): implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: g real ( wp ), dimension ( m , n ) :: g_dense ! for this example, just convert the dense ! jacobian to the sparse representation call grad ( me , x , g_dense ) g ( 1 ) = g_dense ( 1 , 1 ) g ( 2 ) = g_dense ( 1 , 2 ) g ( 3 ) = g_dense ( 2 , 2 ) f_evals = f_evals + 2 ! to approximate forward diff derivatives end subroutine grad_sparse subroutine export ( me , x , f , iter ) !! export an iteration: implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: f integer , intent ( in ) :: iter !! iteration number write ( * , '(1P,I3,1X,A,I3,A,*(E15.6))' ) iter , '(' , f_evals , ')' , x , norm2 ( f ) end subroutine export !****************************************************************************************************** end program sparse_test","tags":"","loc":"program/sparse_test.html"},{"title":"dag_example – AoC-2023","text":"Uses dag_module program~~dag_example~~UsesGraph program~dag_example dag_example module~dag_module dag_module program~dag_example->module~dag_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. DAG module test program. Calls program~~dag_example~~CallsGraph program~dag_example dag_example proc~dag_destroy dag_module::dag%dag_destroy program~dag_example->proc~dag_destroy proc~dag_generate_dependency_matrix dag_module::dag%dag_generate_dependency_matrix program~dag_example->proc~dag_generate_dependency_matrix proc~dag_save_digraph dag_module::dag%dag_save_digraph program~dag_example->proc~dag_save_digraph proc~dag_set_edges dag_module::dag%dag_set_edges program~dag_example->proc~dag_set_edges proc~dag_set_vertex_info dag_module::dag%dag_set_vertex_info program~dag_example->proc~dag_set_vertex_info proc~dag_set_vertices dag_module::dag%dag_set_vertices program~dag_example->proc~dag_set_vertices proc~dag_toposort dag_module::dag%dag_toposort program~dag_example->proc~dag_toposort proc~dag_generate_digraph dag_module::dag%dag_generate_digraph proc~dag_save_digraph->proc~dag_generate_digraph none~set_edges dag_module::vertex%set_edges proc~dag_set_edges->none~set_edges proc~integer_to_string dag_module::integer_to_string proc~dag_set_vertex_info->proc~integer_to_string proc~add_edge dag_module::vertex%add_edge none~set_edges->proc~add_edge proc~set_edge_vector dag_module::vertex%set_edge_vector none~set_edges->proc~set_edge_vector proc~dag_generate_digraph->proc~integer_to_string proc~set_edge_vector->proc~add_edge Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( dag ) :: d integer, dimension(:), allocatable :: order integer :: istat integer :: i integer :: r integer :: c logical, dimension(:,:), allocatable :: mat dependency matrix integer, parameter :: n_nodes = 6 character(len=*), parameter :: filetype = 'pdf' filetype for output plot ('pdf', png', etc.) Source Code program dag_example use dag_module implicit none type ( dag ) :: d integer , dimension (:), allocatable :: order integer :: istat integer :: i , r , c logical , dimension (:,:), allocatable :: mat !! dependency matrix integer , parameter :: n_nodes = 6 character ( len =* ), parameter :: filetype = 'pdf' !! filetype for output plot ('pdf', png', etc.) ! TODO combine set_edges and set_vertex_info into one routine maybe. call d % set_vertices ( n_nodes ) call d % set_edges ( 2 ,[ 1 ]) !2 depends on 1 call d % set_edges ( 3 ,[ 5 , 1 ]) !3 depends on 5 and 1 call d % set_edges ( 4 ,[ 5 ]) !4 depends on 5 call d % set_edges ( 5 ,[ 2 ]) !5 depends on 2 call d % set_edges ( 6 ,[ 2 , 4 ]) !6 depends on 2 and 4 call d % toposort ( order , istat ) write ( * , * ) '' write ( * , * ) 'istat=' , istat write ( * , * ) 'order=' , order ! prints 1,2,5,3,4 do i = 1 , n_nodes if ( i == 3 . or . i == 6 ) then call d % set_vertex_info ( i , attributes = 'shape=square,fillcolor=\"SlateGray1\",style=filled' ) else call d % set_vertex_info ( i , attributes = 'shape=circle,fillcolor=\"cornsilk\",style=filled' ) end if end do write ( * , * ) '' write ( * , * ) 'diagraph:' write ( * , * ) '' call d % save_digraph ( 'test.dot' , 'RL' , 300 ) call execute_command_line ( 'cat test.dot' ) call execute_command_line ( 'dot -T' // filetype // ' -o test.' // filetype // ' test.dot' ) write ( * , * ) '' write ( * , * ) 'dependency matrix:' write ( * , * ) '' call d % generate_dependency_matrix ( mat ) do r = 1 , n_nodes do c = 1 , n_nodes if ( mat ( r , c )) then write ( * , '(A)' , advance = 'NO' ) 'X' else write ( * , '(A)' , advance = 'NO' ) 'O' end if end do write ( * , '(A)' ) '' end do ! cleanup: call d % destroy () end program dag_example","tags":"","loc":"program/dag_example.html"},{"title":"problem_13 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_13~~UsesGraph program~problem_13 problem_13 iso_fortran_env iso_fortran_env program~problem_13->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_13->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_13~~CallsGraph program~problem_13 problem_13 proc~clock_end aoc_utilities::clock%clock_end program~problem_13->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_13->proc~clock_start proc~go problem_13::go program~problem_13->proc~go proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_13->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_13->proc~read_line proc~str_to_int_array_with_mapping aoc_utilities::str_to_int_array_with_mapping program~problem_13->proc~str_to_int_array_with_mapping Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: iunit integer :: iline integer :: n_lines integer :: ival integer :: isum integer :: ival2 integer :: isum2 integer :: m integer :: n integer :: nrows integer :: ncols integer :: ileft integer :: iabove integer :: ileft2 integer :: iabove2 type( string ), dimension(:), allocatable :: lines integer, dimension(:,:), allocatable :: puzzle integer, dimension(:,:), allocatable :: puzzle2 character(len=:), allocatable :: line integer, parameter :: ASH = 0 . integer, parameter :: ROCK = 1 Subroutines subroutine go (puzzle, ileft, iskip) compute the number of cols to left of mirror (0 if none)\ncall with transpose(puzzle) to get number of rows above. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: puzzle integer, intent(out) :: ileft integer, intent(in), optional :: iskip don't consider this column Source Code program problem_13 use iso_fortran_env use aoc_utilities implicit none integer :: i , iunit , iline , n_lines , ival , isum , ival2 , isum2 , & m , n , nrows , ncols , ileft , iabove , ileft2 , iabove2 type ( string ), dimension (:), allocatable :: lines integer , dimension (:,:), allocatable :: puzzle , puzzle2 character ( len = :), allocatable :: line integer , parameter :: ASH = 0 !! . integer , parameter :: ROCK = 1 !! # call clk % tic () ! open(newunit=iunit, file='inputs/day13_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day13.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 isum2 = 0 do iline = 1 , n_lines line = read_line ( iunit ) if ( line == '' . or . iline == n_lines ) then ! process this puzzle ! convert the puzzle to a numeric matrix: if ( allocated ( puzzle )) deallocate ( puzzle ) nrows = size ( lines ) ncols = len ( lines ( 1 )% str ) allocate ( puzzle ( nrows , ncols )) do i = 1 , nrows puzzle ( i ,:) = str_to_int_array_with_mapping ( lines ( i )% str , [ '.' , '#' ], [ ASH , ROCK ]) end do ! part 1 call go ( puzzle , ileft ) call go ( transpose ( puzzle ), iabove ) ival = ileft + 100 * iabove isum = isum + ival ! part 2 main : do m = 1 , nrows do n = 1 , ncols ! permute each with a smudge and find the different non-zero value puzzle2 = puzzle if ( puzzle ( m , n ) == ASH ) then puzzle2 ( m , n ) = ROCK else puzzle2 ( m , n ) = ASH end if ! don't consider the one from part a (since that one still may be valid) call go ( puzzle2 , ileft2 , iskip = ileft ) call go ( transpose ( puzzle2 ), iabove2 , iskip = iabove ) if (( ileft2 /= ileft . or . iabove2 /= iabove ) . and . ( ileft2 /= 0 . or . iabove2 /= 0 )) then ival = ileft2 + 100 * iabove2 ! found it exit main end if end do end do main isum2 = isum2 + ival deallocate ( lines ) else ! accumulate this line in the current puzzle if (. not . allocated ( lines )) allocate ( lines ( 0 )) lines = [ lines , string ( line )] end if end do write ( * , * ) '13a: ' , isum write ( * , * ) '13b: ' , isum2 call clk % toc ( '13' ) contains subroutine go ( puzzle , ileft , iskip ) !! compute the number of cols to left of mirror (0 if none) !! call with transpose(puzzle) to get number of rows above. integer , dimension (:,:), intent ( in ) :: puzzle integer , intent ( out ) :: ileft integer , intent ( in ), optional :: iskip !! don't consider this column integer :: nrows , ncols , i , j logical :: mirror nrows = size ( puzzle , 1 ) ncols = size ( puzzle , 2 ) ileft = 0 do i = 1 , ncols - 1 if ( present ( iskip )) then if ( i == iskip ) cycle end if mirror = . true . do j = 1 , min ( i , ncols - i ) if ( any ( puzzle (:, i - j + 1 ) /= puzzle (:, i + j )) ) then mirror = . false . ! no mirror on this line exit end if end do if ( mirror ) then ileft = i exit end if end do end subroutine go end program problem_13","tags":"","loc":"program/problem_13.html"},{"title":"problem_7 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_7~~UsesGraph program~problem_7 problem_7 iso_fortran_env iso_fortran_env program~problem_7->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_7->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_7~~CallsGraph program~problem_7 problem_7 interface~split aoc_utilities::split program~problem_7->interface~split proc~beats problem_7::beats program~problem_7->proc~beats proc~clock_end aoc_utilities::clock%clock_end program~problem_7->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_7->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_7->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_7->proc~read_line proc~str_to_array aoc_utilities::str_to_array program~problem_7->proc~str_to_array proc~swap_hands problem_7::swap_hands program~problem_7->proc~swap_hands proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~hand_type problem_7::hand_type proc~beats->proc~hand_type proc~index_in_cards problem_7::index_in_cards proc~beats->proc~index_in_cards interface~unique aoc_utilities::unique proc~hand_type->interface~unique proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: iunit integer :: n_lines integer :: icase character(len=:), allocatable :: line type( string ), dimension(:), allocatable :: vals logical :: done type( hand ), dimension(:), allocatable :: hands array of hands character(len=1), parameter,               dimension(2) :: cases = ['a', 'b'] character(len=1), parameter,               dimension(*) :: cards = ['A', 'K', 'Q', 'J', 'T', '9', '8', '7', '6', '5', '4', '3', '2'] character(len=1), parameter,               dimension(*) :: cards_with_joker = ['A', 'K', 'Q', 'T', '9', '8', '7', '6', '5', '4', '3', '2', 'J'] integer, parameter :: FIVE_OF_A_KIND = 1 integer, parameter :: FOUR_OF_A_KIND = 2 integer, parameter :: FULL_HOUSE = 3 integer, parameter :: THREE_OF_A_KIND = 4 integer, parameter :: TWO_PAIR = 5 integer, parameter :: ONE_PAIR = 6 integer, parameter :: HIGH_CARD = 7 Derived Types type :: hand Components Type Visibility Attributes Name Initial character(len=1), public, dimension(5) :: cards the cards in a hand integer(kind=ip), public :: bid = 0 integer, public :: type = 0 Functions function hand_type (me, with_jokers) returns the type of hand Arguments Type Intent Optional Attributes Name class( hand ), intent(in) :: me logical, intent(in) :: with_jokers if considering jokers Return Value integer function beats (hand1, hand2, with_jokers) return true if hand1 beats hand2 (has a higher score) Arguments Type Intent Optional Attributes Name class( hand ), intent(inout) :: hand1 class( hand ), intent(inout) :: hand2 logical, intent(in) :: with_jokers if considering jokers Return Value logical function index_in_cards (c, with_jokers) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c logical, intent(in) :: with_jokers if considering jokers Return Value integer Subroutines pure elemental subroutine swap_hands (i1, i2) swap function for hand type Arguments Type Intent Optional Attributes Name type( hand ), intent(inout) :: i1 type( hand ), intent(inout) :: i2 Source Code program problem_7 use iso_fortran_env use aoc_utilities implicit none integer :: i , iunit , n_lines , icase character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals logical :: done type :: hand character ( len = 1 ), dimension ( 5 ) :: cards !! the cards in a hand integer ( ip ) :: bid = 0 ! the bit for the hand integer :: type = 0 ! the hand type end type hand type ( hand ), dimension (:), allocatable :: hands !! array of hands character ( len = 1 ), dimension ( 2 ), parameter :: cases = [ 'a' , 'b' ] character ( len = 1 ), dimension ( * ), parameter :: cards = [ 'A' , 'K' , 'Q' , 'J' , 'T' , & '9' , '8' , '7' , '6' , '5' , & '4' , '3' , '2' ] character ( len = 1 ), dimension ( * ), parameter :: cards_with_joker = [ 'A' , 'K' , 'Q' , 'T' , & '9' , '8' , '7' , '6' , '5' , & '4' , '3' , '2' , 'J' ] integer , parameter :: FIVE_OF_A_KIND = 1 ! the hand types integer , parameter :: FOUR_OF_A_KIND = 2 integer , parameter :: FULL_HOUSE = 3 integer , parameter :: THREE_OF_A_KIND = 4 integer , parameter :: TWO_PAIR = 5 integer , parameter :: ONE_PAIR = 6 integer , parameter :: HIGH_CARD = 7 call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day7_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day7.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( hands ( n_lines )) do i = 1 , n_lines line = read_line ( iunit ); vals = split ( line , ' ' ) hands ( i )% cards = str_to_array ( vals ( 1 )% str ) hands ( i )% bid = int ( vals ( 2 )) end do close ( iunit ) do icase = 1 , 2 ! first time normally, second time processing the jokers ! sort the list from worst to best to determinte the rank of each hand hands % type = 0 ! reinitialize since they need to be recomputed do ! bubble sort ! done = . true . do i = 1 , n_lines - 1 if ( beats ( hands ( i ), hands ( i + 1 ), icase == 2 )) then call swap_hands ( hands ( i ), hands ( i + 1 )); done = . false . end if end do if ( done ) exit end do write ( * , * ) '7' // cases ( icase ) // ':' , sum ( hands % bid * [( i , i = 1 , n_lines )]) end do call clk % toc ( '7' ) contains integer function hand_type ( me , with_jokers ) !! returns the type of hand class ( hand ), intent ( in ) :: me logical , intent ( in ) :: with_jokers !! if considering jokers integer , dimension ( 5 ) :: i integer , dimension (:), allocatable :: u integer :: n_jokers , n_unique character ( len = 1 ), dimension ( 5 ) :: h h = me % cards i = ichar ( h ) ! convert to code u = unique ( i ) ! unique elements n_unique = size ( u ) if ( with_jokers . and . any ( h == 'J' )) then ! have to pick best hand for all jokers ! just do it by inspection n_jokers = count ( h == 'J' ) select case ( n_jokers ) case ( 5 ) hand_type = FIVE_OF_A_KIND !jjjjj case ( 4 ) hand_type = FIVE_OF_A_KIND !jjjja case ( 3 ) ! can always turn to 4 or 5 of a kind if ( n_unique == 2 ) then !jjjaa hand_type = FIVE_OF_A_KIND else ! jjjab hand_type = FOUR_OF_A_KIND end if case ( 2 ) if ( n_unique == 2 ) then !jjaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then !jjaab hand_type = FOUR_OF_A_KIND else !jjabc hand_type = THREE_OF_A_KIND end if case ( 1 ) if ( n_unique == 2 ) then !jaaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then if ( any ([ count ( i == u ( 1 )) == 3 , & count ( i == u ( 2 )) == 3 , & count ( i == u ( 3 )) == 3 ]) ) then !jaaab hand_type = FOUR_OF_A_KIND elseif ( ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 ) . or . & ( count ( i == u ( 2 )) == 2 . and . count ( i == u ( 2 )) == 2 ) ) then !jaabb hand_type = FULL_HOUSE end if else if ( n_unique == 4 ) then !jaabc hand_type = THREE_OF_A_KIND else if ( n_unique == 5 ) then !jabcd hand_type = ONE_PAIR end if end select else !Every hand is exactly one type. From strongest to weakest, they are: select case ( n_unique ) case ( 1 ) ! aaaaa hand_type = FIVE_OF_A_KIND case ( 2 ) ! aaaab, aaabb if (( count ( i == u ( 1 )) == 4 . and . count ( i == u ( 2 )) == 1 ) . or . & ( count ( i == u ( 1 )) == 1 . and . count ( i == u ( 2 )) == 4 ) ) then hand_type = FOUR_OF_A_KIND else if (( count ( i == u ( 1 )) == 3 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 3 ) ) then hand_type = FULL_HOUSE end if case ( 3 ) ! aaabc, aabcc if ( any ([ count ( i == u ( 1 )) == 3 , count ( i == u ( 2 )) == 3 , count ( i == u ( 3 )) == 3 ]) ) then hand_type = THREE_OF_A_KIND else if ( any ([ count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 , & count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 , & count ( i == u ( 2 )) == 2 . and . count ( i == u ( 3 )) == 2 ]) ) then hand_type = TWO_PAIR end if case ( 4 ) !aabcd hand_type = ONE_PAIR case ( 5 ) !abcde hand_type = HIGH_CARD ! High card, where all cards' labels are distinct: 23456 end select end if end function hand_type logical function beats ( hand1 , hand2 , with_jokers ) !! return true if hand1 beats hand2 (has a higher score) class ( hand ), intent ( inout ) :: hand1 , hand2 logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i associate ( h1 => hand1 % cards , h2 => hand2 % cards ) ! recompute type if it hasn't already been computed if ( hand1 % type == 0 ) hand1 % type = hand_type ( hand1 , with_jokers ) if ( hand2 % type == 0 ) hand2 % type = hand_type ( hand2 , with_jokers ) if ( hand1 % type == hand2 % type ) then ! lower index is stronger do i = 1 , 5 if ( h1 ( i ) /= h2 ( i )) then beats = index_in_cards ( h1 ( i ), with_jokers ) < & index_in_cards ( h2 ( i ), with_jokers ) ! lower is stronger return end if end do else ! one hand beat the other beats = hand1 % type < hand2 % type ! lower score is better (1-7) end if end associate end function beats integer function index_in_cards ( c , with_jokers ) character ( len = 1 ), intent ( in ) :: c logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i do i = 1 , size ( cards_with_joker ) if ( with_jokers ) then if ( c == cards_with_joker ( i )) then index_in_cards = i return end if else if ( c == cards ( i )) then index_in_cards = i return end if end if end do error stop 'card not found' end function index_in_cards pure elemental subroutine swap_hands ( i1 , i2 ) !! swap function for hand type type ( hand ), intent ( inout ) :: i1 type ( hand ), intent ( inout ) :: i2 type ( hand ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_hands end program problem_7","tags":"","loc":"program/problem_7.html"},{"title":"nlesolver_test_1 – AoC-2023","text":"Uses nlesolver_module program~~nlesolver_test_1~~UsesGraph program~nlesolver_test_1 nlesolver_test_1 module~nlesolver_module nlesolver_module program~nlesolver_test_1->module~nlesolver_module iso_fortran_env iso_fortran_env module~nlesolver_module->iso_fortran_env module~fmin_module fmin_module module~nlesolver_module->module~fmin_module module~fmin_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Test of a small, square ( n=m ) problem. Calls program~~nlesolver_test_1~~CallsGraph program~nlesolver_test_1 nlesolver_test_1 proc~get_status nlesolver_module::nlesolver_type%get_status program~nlesolver_test_1->proc~get_status proc~initialize_nlesolver_variables nlesolver_module::nlesolver_type%initialize_nlesolver_variables program~nlesolver_test_1->proc~initialize_nlesolver_variables proc~nlesolver_solver nlesolver_module::nlesolver_type%nlesolver_solver program~nlesolver_test_1->proc~nlesolver_solver proc~set_status nlesolver_module::nlesolver_type%set_status proc~initialize_nlesolver_variables->proc~set_status proc~initialize_ez lsqr_module::lsqr_solver_ez%initialize_ez proc~nlesolver_solver->proc~initialize_ez proc~linear_solver nlesolver_module::linear_solver proc~nlesolver_solver->proc~linear_solver proc~nlesolver_solver->proc~set_status proc~solve_ez lsqr_module::lsqr_solver_ez%solve_ez proc~nlesolver_solver->proc~solve_ez proc~lsqr lsqr_module::lsqr_solver%LSQR proc~solve_ez->proc~lsqr aprod aprod proc~lsqr->aprod proc~d2norm lsqr_module::d2norm proc~lsqr->proc~d2norm proc~dcopy lsqpblas_module::dcopy proc~lsqr->proc~dcopy proc~dnrm2 lsqpblas_module::dnrm2 proc~lsqr->proc~dnrm2 proc~dscal lsqpblas_module::dscal proc~lsqr->proc~dscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: n = 2 integer, parameter :: m = 2 integer, parameter :: max_iter = 100 real(kind=wp), parameter :: tol = 1.0e-8_wp logical, parameter :: verbose = .false. type( nlesolver_type ) :: solver real(kind=wp) :: alpha logical :: use_broyden integer :: step_mode integer :: n_intervals integer :: istat Integer status code. character(len=:), allocatable :: message Text status message real(kind=wp), dimension(n) :: x integer :: f_evals integer :: i character(len=:), allocatable :: description real(kind=wp) :: fmin_tol Subroutines subroutine func (me, x, f) compute the function Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: f subroutine grad (me, x, g) compute the gradient of the function (Jacobian): Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:,:) :: g subroutine export (me, x, f, iter) export an iteration: Arguments Type Intent Optional Attributes Name class( nlesolver_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: f integer, intent(in) :: iter iteration number Source Code program nlesolver_test_1 use nlesolver_module , wp => nlesolver_rk implicit none integer , parameter :: n = 2 integer , parameter :: m = 2 integer , parameter :: max_iter = 100 real ( wp ), parameter :: tol = 1.0e-8_wp logical , parameter :: verbose = . false . type ( nlesolver_type ) :: solver real ( wp ) :: alpha logical :: use_broyden integer :: step_mode integer :: n_intervals integer :: istat !! Integer status code. character ( len = :), allocatable :: message !! Text status message real ( wp ), dimension ( n ) :: x integer :: f_evals integer :: i character ( len = :), allocatable :: description real ( wp ) :: fmin_tol fmin_tol = 1.0e-2_wp ! don't need a tight tol for this n_intervals = 2 alpha = 1.0_wp write ( * , * ) '' write ( * , * ) '***********************' write ( * , * ) '* nlesolver_test_1    *' write ( * , * ) '***********************' write ( * , * ) '' do i = 1 , 8 select case ( i ) case ( 1 ) step_mode = 1 use_broyden = . false . f_evals = 0 description = 'Constant alpha' case ( 2 ) step_mode = 1 use_broyden = . true . f_evals = 0 description = 'Constant alpha + broyden' case ( 3 ) step_mode = 2 use_broyden = . false . f_evals = 0 description = 'Backtracking line search' case ( 4 ) step_mode = 2 use_broyden = . true . f_evals = 0 description = 'Backtracking line search + broyden' case ( 5 ) step_mode = 3 use_broyden = . false . f_evals = 0 description = 'Exact line search' case ( 6 ) step_mode = 3 use_broyden = . true . f_evals = 0 description = 'Exact line search + broyden' case ( 7 ) step_mode = 4 use_broyden = . false . f_evals = 0 description = 'Fixed point search' case ( 8 ) step_mode = 4 use_broyden = . true . f_evals = 0 description = 'Fixed point search + broyden' case default error stop 'invalid case' end select write ( * , * ) '-------------------------------------------------------' write ( * , '(A,I3,A,A)' ) 'Case ' , i , ' : ' , description write ( * , * ) '' call solver % initialize ( n = n , & m = m , & max_iter = max_iter , & tol = tol , & func = func , & grad = grad , & step_mode = step_mode ,& use_broyden = use_broyden ,& export_iteration = export ,& n_intervals = n_intervals , & fmin_tol = fmin_tol , & verbose = verbose ) call solver % status ( istat , message ) write ( * , '(I3,1X,A)' ) istat , message if ( istat /= 0 ) error stop x = [ 1.0_wp , 2.0_wp ] call solver % solve ( x ) call solver % status ( istat , message ) write ( * , '(I3,1X,A)' ) istat , message write ( * , * ) '' end do contains subroutine func ( me , x , f ) !! compute the function implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f f_evals = f_evals + 1 f ( 1 ) = x ( 1 ) ** 2 + x ( 2 ) - 0.1_wp f ( 2 ) = x ( 2 ) + 0.2_wp ! root is 5.477226E-01  -2.000000E-01 end subroutine func subroutine grad ( me , x , g ) !! compute the gradient of the function (Jacobian): implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:,:), intent ( out ) :: g f_evals = f_evals + 2 ! to approximate forward diff derivatives g ( 1 , 1 ) = 2.0_wp * x ( 1 ) !df(1)/dx g ( 2 , 1 ) = 0.0_wp !df(2)/dx g ( 1 , 2 ) = 1.0_wp !df(1)/dy g ( 2 , 2 ) = 1.0_wp !df(2)/dy end subroutine grad subroutine export ( me , x , f , iter ) !! export an iteration: implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: f integer , intent ( in ) :: iter !! iteration number write ( * , '(1P,I3,1X,A,I3,A,*(E15.6))' ) iter , '(' , f_evals , ')' , x , norm2 ( f ) end subroutine export !****************************************************************************************************** end program nlesolver_test_1","tags":"","loc":"program/nlesolver_test_1.html"},{"title":"main – AoC-2023","text":"Uses lusol_precision lusol_ez_module program~~main~~UsesGraph program~main main module~lusol_ez_module lusol_ez_module program~main->module~lusol_ez_module module~lusol_precision lusol_precision program~main->module~lusol_precision module~lusol_ez_module->module~lusol_precision module~lusol lusol module~lusol_ez_module->module~lusol iso_fortran_env iso_fortran_env module~lusol_precision->iso_fortran_env module~lusol->module~lusol_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Main program for EZ test. Calls program~~main~~CallsGraph program~main main proc~test_1 main::test_1 program~main->proc~test_1 proc~test_2 main::test_2 program~main->proc~test_2 proc~solve lusol_ez_module::solve proc~test_1->proc~solve proc~test_2->proc~solve proc~lu1fac lusol::lu1fac proc~solve->proc~lu1fac proc~lu6sol lusol::lu6sol proc~solve->proc~lu6sol proc~lu1fad lusol::lu1fad proc~lu1fac->proc~lu1fad proc~lu1or1 lusol::lu1or1 proc~lu1fac->proc~lu1or1 proc~lu1or2 lusol::lu1or2 proc~lu1fac->proc~lu1or2 proc~lu1or3 lusol::lu1or3 proc~lu1fac->proc~lu1or3 proc~lu1or4 lusol::lu1or4 proc~lu1fac->proc~lu1or4 proc~lu1pq1 lusol::lu1pq1 proc~lu1fac->proc~lu1pq1 proc~lu1slk lusol::lu1slk proc~lu1fac->proc~lu1slk proc~lu6chk lusol::lu6chk proc~lu1fac->proc~lu6chk proc~lu6l lusol::lu6L proc~lu6sol->proc~lu6l proc~lu6ld lusol::lu6LD proc~lu6sol->proc~lu6ld proc~lu6lt lusol::lu6Lt proc~lu6sol->proc~lu6lt proc~lu6u lusol::lu6U proc~lu6sol->proc~lu6u proc~lu6ut lusol::lu6Ut proc~lu6sol->proc~lu6ut proc~hbuild lusol::Hbuild proc~lu1fad->proc~hbuild proc~hchange lusol::Hchange proc~lu1fad->proc~hchange proc~hdelete lusol::Hdelete proc~lu1fad->proc~hdelete proc~lu1ful lusol::lu1ful proc~lu1fad->proc~lu1ful proc~lu1gau lusol::lu1gau proc~lu1fad->proc~lu1gau proc~lu1mar lusol::lu1mar proc~lu1fad->proc~lu1mar proc~lu1mrp lusol::lu1mRP proc~lu1fad->proc~lu1mrp proc~lu1msp lusol::lu1mSP proc~lu1fad->proc~lu1msp proc~lu1mxc lusol::lu1mxc proc~lu1fad->proc~lu1mxc proc~lu1mxr lusol::lu1mxr proc~lu1fad->proc~lu1mxr proc~lu1pen lusol::lu1pen proc~lu1fad->proc~lu1pen proc~lu1pq2 lusol::lu1pq2 proc~lu1fad->proc~lu1pq2 proc~lu1pq3 lusol::lu1pq3 proc~lu1fad->proc~lu1pq3 proc~lu1rec lusol::lu1rec proc~lu1fad->proc~lu1rec proc~hinsert lusol::Hinsert proc~hbuild->proc~hinsert proc~hdown lusol::Hdown proc~hchange->proc~hdown proc~hup lusol::Hup proc~hchange->proc~hup proc~hdelete->proc~hchange proc~lu1dcp lusol::lu1DCP proc~lu1ful->proc~lu1dcp proc~lu1dpp lusol::lu1DPP proc~lu1ful->proc~lu1dpp proc~hinsert->proc~hup proc~jdamax lusol::jdamax proc~lu1dcp->proc~jdamax proc~lu1dpp->proc~jdamax Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Subroutines subroutine test_1 () Arguments None subroutine test_2 () Read more… Arguments None Source Code program main use lusol_precision , wp => rp use lusol_ez_module , only : solve implicit none call test_1 () call test_2 () contains subroutine test_1 () ! define a 3x3 dense system to solve: integer , parameter :: m = 3 !! number of rows in `A` matrix integer , parameter :: n = 3 !! number of columns in `A` matrix real ( wp ), dimension ( m ), parameter :: b = real ([ 1 , 2 , 3 ], wp ) integer , dimension ( m * n ), parameter :: icol = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ] integer , dimension ( m * n ), parameter :: irow = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] real ( wp ), dimension ( m * n ), parameter :: a = real ([ 1 , 4 , 7 , 2 , 5 , 88 , 3 , 66 , 9 ], wp ) real ( wp ), dimension ( m , 1 ), parameter :: b_vec = reshape ( b ,[ m , 1 ]) real ( wp ), dimension ( m , n ), parameter :: a_mat = reshape ( a ,[ 3 , 3 ]) real ( wp ), dimension ( n ) :: x real ( wp ), dimension ( n , 1 ) :: x_vec integer :: istat write ( * , * ) '' write ( * , * ) '***** test 1' write ( * , * ) '' call solve ( n , m , m * n , irow , icol , a , b , x , istat ) x_vec ( 1 : 3 , 1 ) = x write ( * , * ) '' write ( * , * ) 'istop = ' , istat write ( * , * ) '' write ( * , '(1P,A,*(E16.6))' ) 'x       = ' , x write ( * , '(1P,A,*(E16.6))' ) 'A*x     = ' , matmul ( a_mat , x_vec ) write ( * , '(1P,A,*(E16.6))' ) 'A*x - b = ' , matmul ( a_mat , x_vec ) - b_vec if ( any ( abs ( matmul ( a_mat , x_vec ) - b_vec ) > 1.0e-12 )) error stop 'TEST FAILED' end subroutine test_1 subroutine test_2 () ! another test case (with n>m). compare to scipy. !!``` !! >>> a !! array([[  4. ,   5. ,  66. ,   0.1], !!        [  1. ,  -3. ,   8. ,  -9. ], !!        [ 11. ,   3. , -87. ,   2. ]]) !! >>> b !! array([1, 2, 3]) !! >>> scipy.sparse.linalg.lsqr(a, b) !! (array([ 0.26437473,  0.04901579, -0.00426183, -0.21297414]), 1, 3, 5.5785963493386424e-12, 5.5785963493386424e-12, 110.70234866523838, 15.316189089999897, 6.119548932941366e-10, 0.343034538979173, array([0., 0., 0., 0.])) !! >>> !!``` integer , parameter :: m = 3 !! number of rows in `A` matrix integer , parameter :: n = 4 !! number of columns in `A` matrix real ( wp ), dimension ( m ), parameter :: b = real ([ 1 , 2 , 3 ], wp ) integer , dimension ( m * n ), parameter :: icol = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 ] integer , dimension ( m * n ), parameter :: irow = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] real ( wp ), dimension ( m * n ), parameter :: a = [ 4.1_wp , 1.1_wp , 1 1.1_wp ,& 5.1_wp , - 3.1_wp , 3.1_wp ,& 6 6.1_wp , 8.1_wp , - 8 7.1_wp ,& 0.1_wp , - 9.1_wp , 2.1_wp ] real ( wp ), dimension ( m , 1 ), parameter :: b_vec = reshape ( b ,[ m , 1 ]) real ( wp ), dimension ( m , n ), parameter :: a_mat = reshape ( a ,[ 3 , 4 ]) real ( wp ), dimension ( n ) :: x real ( wp ), dimension ( n , 1 ) :: x_vec integer :: istat write ( * , * ) '' write ( * , * ) '***** test 2' write ( * , * ) '' call solve ( n , m , m * n , irow , icol , a , b , x , istat ) x_vec ( 1 : 4 , 1 ) = x write ( * , * ) '' write ( * , * ) 'istop = ' , istat write ( * , * ) '' write ( * , '(1P,A,*(E16.6))' ) 'x       = ' , x write ( * , '(1P,A,*(E16.6))' ) 'A*x     = ' , matmul ( a_mat , x_vec ) write ( * , '(1P,A,*(E16.6))' ) 'A*x - b = ' , matmul ( a_mat , x_vec ) - b_vec if ( any ( abs ( matmul ( a_mat , x_vec ) - b_vec ) > 1.0e-12 )) error stop 'TEST FAILED' end subroutine test_2 end program main","tags":"","loc":"program/main.html"},{"title":"problem_21 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_21~~UsesGraph program~problem_21 problem_21 iso_fortran_env iso_fortran_env program~problem_21->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_21->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_21~~CallsGraph program~problem_21 problem_21 proc~clock_end aoc_utilities::clock%clock_end program~problem_21->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_21->proc~clock_start proc~read_file_to_char_array aoc_utilities::read_file_to_char_array program~problem_21->proc~read_file_to_char_array proc~step problem_21::step program~problem_21->proc~step proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial character(len=1), dimension(:,:), allocatable :: array integer :: nrows integer :: ncols integer :: i integer :: j integer, dimension(2) :: iloc integer, dimension(:,:), allocatable :: icount Subroutines recursive subroutine step (array) take all valid steps from any # elements in array Arguments Type Intent Optional Attributes Name character(len=1), intent(inout), dimension(:,:), allocatable :: array Source Code program problem_21 use aoc_utilities use iso_fortran_env implicit none character ( len = 1 ), dimension (:,:), allocatable :: array integer :: nrows , ncols , i , j integer , dimension ( 2 ) :: iloc integer , dimension (:,:), allocatable :: icount call clk % tic () ! array = read_file_to_char_array('inputs/day21_test.txt', border='#') array = read_file_to_char_array ( 'inputs/day21.txt' , border = '.' ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) allocate ( icount ( nrows , ncols )); icount = 0 iloc = findloc ( array , 'S' ) ! find starting point i = iloc ( 1 ) j = iloc ( 2 ) array ( i , j ) = 'O' ! starting here do i = 1 , 64 call step ( array ) end do write ( * , * ) '21a: ' , count ( array == 'O' ) call clk % toc ( '21' ) contains recursive subroutine step ( array ) !! take all valid steps from any # elements in array character ( len = 1 ), dimension (:,:), intent ( inout ), allocatable :: array integer :: i , j logical :: steped character ( len = 1 ), dimension (:,:), allocatable :: tmp tmp = array do i = 1 , nrows do j = 1 , ncols if ( array ( i , j ) == 'O' ) then steped = . false . ! try a step in each direction: if ( array ( i - 1 , j ) == '.' ) then tmp ( i - 1 , j ) = 'O' ; steped = . true . end if if ( array ( i + 1 , j ) == '.' ) then tmp ( i + 1 , j ) = 'O' ; steped = . true . end if if ( array ( i , j - 1 ) == '.' ) then tmp ( i , j - 1 ) = 'O' ; steped = . true . end if if ( array ( i , j + 1 ) == '.' ) then tmp ( i , j + 1 ) = 'O' ; steped = . true . end if if ( steped ) tmp ( i , j ) = '.' end if end do end do call move_alloc ( tmp , array ) end subroutine step end program problem_21","tags":"","loc":"program/problem_21.html"},{"title":"problem_12 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_12~~UsesGraph program~problem_12 problem_12 iso_fortran_env iso_fortran_env program~problem_12->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_12->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_12~~CallsGraph program~problem_12 problem_12 proc~clock_end aoc_utilities::clock%clock_end program~problem_12->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_12->proc~clock_start proc~go~6 problem_12::go program~problem_12->proc~go~6 interface~split aoc_utilities::split proc~go~6->interface~split proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~go~6->proc~number_of_lines_in_file proc~parse_ints aoc_utilities::parse_ints proc~go~6->proc~parse_ints proc~read_line aoc_utilities::read_line proc~go~6->proc~read_line proc~str_to_int_array_with_mapping aoc_utilities::str_to_int_array_with_mapping proc~go~6->proc~str_to_int_array_with_mapping proc~test problem_12::test proc~go~6->proc~test proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~test->proc~test proc~match problem_12::match proc~test->proc~match proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: POINT = 0 integer, parameter :: NUMBER = 1 integer, parameter :: QUESTION = 2 integer, dimension(:), allocatable :: a integer, dimension(:), allocatable :: ints integer, dimension(:), allocatable :: ipattern integer, dimension(:), allocatable :: ipattern_tmp integer(kind=ip) :: n_valid integer(kind=ip) :: isum integer :: iline Functions function match (ipattern, ints) returns true if the pattern is valid for the int list. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: ipattern integer, intent(in), dimension(:) :: ints Return Value logical Subroutines subroutine go (expand, isum) Arguments Type Intent Optional Attributes Name logical, intent(in) :: expand integer(kind=ip), intent(out) :: isum recursive subroutine test (i, n) each ? can be either a . or a #\ncheck pattern to match the int list Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: n Source Code program problem_12 use iso_fortran_env use aoc_utilities implicit none integer , parameter :: POINT = 0 integer , parameter :: NUMBER = 1 integer , parameter :: QUESTION = 2 ! some global variables integer , dimension (:), allocatable :: a , ints , ipattern , ipattern_tmp integer ( ip ) :: n_valid integer ( ip ) :: isum integer :: iline call clk % tic () call go (. false ., isum ); write ( * , * ) '12a: ' , isum ! call go(.true., isum); write(*,*) '12b: ', isum call clk % toc ( '12' ) contains subroutine go ( expand , isum ) logical , intent ( in ) :: expand integer ( ip ), intent ( out ) :: isum integer :: iunit , n_lines , n_unknowns integer ( ip ) :: n_perms character ( len = :), allocatable :: line , pattern type ( string ), dimension (:), allocatable :: vals ! open(newunit=iunit, file='inputs/day12_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day12.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ints = parse_ints ( vals ( 2 )% str ) ! integer list  1,1,3 pattern = vals ( 1 )% str ! the pattern   #.#.### ! will convert the pattern to an array of numbers: ipattern = str_to_int_array_with_mapping ( pattern ,[ '.' , '#' , '?' ],& [ POINT , NUMBER , QUESTION ]) ! 1010111 if ( expand ) then ! brute force it ipattern = [ ipattern , QUESTION , ipattern , QUESTION , & ipattern , QUESTION , ipattern , QUESTION , & ipattern ] ints = [ ints , ints , ints , ints , ints ] end if n_unknowns = count ( ipattern == 2 ) n_valid = 0 ! number of valid permutations n_perms = 2 ** n_unknowns ! number of permutations ipattern_tmp = ipattern ! recursively test all the permutations if ( allocated ( a )) deallocate ( a ) allocate ( a ( n_unknowns )) call test ( 1 , n_unknowns ) isum = isum + n_valid ! write(*,*) iline, 'n_valid = ', n_valid end do end subroutine go recursive subroutine test ( i , n ) !! each ? can be either a . or a # !! check pattern to match the int list integer , intent ( in ) :: i , n integer :: ix integer , dimension ( * ), parameter :: icoeffs = [ POINT , NUMBER ] !! set of coefficients ['.', '#'] ! what we are not doing here is accounting for permutations ! that we know do not match, because the begin with a sequence ! that doesn't match. those need to be skipped... if ( i > n ) then ! so we have an array of 0s and 1s -> replace the 2s in the ipattern with these !     ipattern: 2220111  -> ???.### !            a: 011      -> .## !       result: 0110111  -> .##.### !write(*,'(a,1x,i5,1x, *(I1))') 'test:', iline, ipattern_tmp ipattern_tmp = unpack ( a , mask = ipattern == QUESTION , field = ipattern ) if ( match ( ipattern_tmp , ints )) n_valid = n_valid + 1 else do ix = 1 , 2 a ( i ) = icoeffs ( ix ) call test ( i + 1 , n ) end do end if end subroutine test logical function match ( ipattern , ints ) !! returns true if the pattern is valid for the int list. integer , dimension (:), intent ( in ) :: ipattern integer , dimension (:), intent ( in ) :: ints integer :: i , iacc , int_checked integer , dimension ( 1 ) :: ifirst , iend logical :: accumulating ! .##..###... -> 2,3 ! start and end indices (ignoring leading and trailing spaces) ifirst = findloc ( ipattern , 1 ) iend = findloc ( ipattern , 1 , back = . true .) if ( ifirst ( 1 ) == 0 . or . iend ( 1 ) == 0 ) then ! all blank match = . false .; return end if ! step through the pattern and stop once we find it invalid accumulating = . true . iacc = 0 int_checked = 0 ! the count of ints that have been checked match = . true . ! initialize do i = ifirst ( 1 ), iend ( 1 ) select case ( ipattern ( i )) case ( POINT ) if ( accumulating ) then int_checked = int_checked + 1 ! check the next one if ( int_checked > size ( ints )) then ! too many ints match = . false . return else if ( ints ( int_checked ) /= iacc ) then ! doesn't match match = . false . return end if accumulating = . false . iacc = 0 end if case ( NUMBER ) if ( accumulating ) then iacc = iacc + 1 else ! start of a new number accumulating = . true . iacc = 1 end if if ( i == iend ( 1 )) then ! last number int_checked = int_checked + 1 ! check the next one if ( int_checked /= size ( ints )) then ! not enough ints match = . false . return else if ( ints ( int_checked ) /= iacc ) then ! doesn't match match = . false . return end if end if end select end do end function match end program problem_12","tags":"","loc":"program/problem_12.html"},{"title":"problem_2 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_2~~UsesGraph program~problem_2 problem_2 iso_fortran_env iso_fortran_env program~problem_2->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_2->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_2~~CallsGraph program~problem_2 problem_2 interface~split aoc_utilities::split program~problem_2->interface~split proc~clock_end aoc_utilities::clock%clock_end program~problem_2->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_2->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_2->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_2->proc~read_line proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit logical :: status_ok logical :: game_possible character(len=:), allocatable :: line character(len=:), allocatable :: color integer :: n_lines integer :: id integer :: j integer :: k integer :: ipossible integer :: inum integer :: min_red integer :: min_green integer :: min_blue integer :: power type( string ), dimension(:), allocatable :: vals type( string ), dimension(:), allocatable :: trys type( string ), dimension(:), allocatable :: cubes type( string ), dimension(:), allocatable :: num_color integer, parameter :: n_red = 12 integer, parameter :: n_green = 13 integer, parameter :: n_blue = 14 Source Code program problem_2 use iso_fortran_env use aoc_utilities implicit none integer :: iunit logical :: status_ok , game_possible character ( len = :), allocatable :: line , color integer :: n_lines , id , j , k , ipossible , inum , min_red , min_green , min_blue , power type ( string ), dimension (:), allocatable :: vals , trys , cubes , num_color integer , parameter :: n_red = 12 integer , parameter :: n_green = 13 integer , parameter :: n_blue = 14 call clk % tic () !example: Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green open ( newunit = iunit , file = 'inputs/day2.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) ! will parse the line with successive splits ipossible = 0 power = 0 main : do id = 1 , n_lines game_possible = . true . min_red = 0 ; min_green = 0 ; min_blue = 0 line = read_line ( iunit , status_ok ) vals = split ( line , ': ' ) trys = split ( vals ( 2 ), '; ' ) do j = 1 , size ( trys ) cubes = split ( trys ( j ), ', ' ) do k = 1 , size ( cubes ) num_color = split ( cubes ( k ), ' ' ) inum = int ( num_color ( 1 )% str ) color = num_color ( 2 )% str select case ( color ) case ( 'red' ) if ( inum > n_red ) game_possible = . false . if ( inum > min_red ) min_red = inum case ( 'green' ) if ( inum > n_green ) game_possible = . false . if ( inum > min_green ) min_green = inum case ( 'blue' ) if ( inum > n_blue ) game_possible = . false . if ( inum > min_blue ) min_blue = inum end select end do end do power = power + ( min_red * min_green * min_blue ) if ( game_possible ) ipossible = ipossible + id end do main write ( * , * ) '2a: result   :' , ipossible write ( * , * ) '2b: power sum:' , power close ( iunit ) call clk % toc ( '2' ) end program problem_2","tags":"","loc":"program/problem_2.html"},{"title":"problem_17 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities aoc_cache_module program~~problem_17~~UsesGraph program~problem_17 problem_17 iso_fortran_env iso_fortran_env program~problem_17->iso_fortran_env module~aoc_cache_module aoc_cache_module program~problem_17->module~aoc_cache_module module~aoc_utilities aoc_utilities program~problem_17->module~aoc_utilities module~aoc_cache_module->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. part b Calls program~~problem_17~~CallsGraph program~problem_17 problem_17 proc~add_to_queue problem_17::add_to_queue program~problem_17->proc~add_to_queue proc~check problem_17::check program~problem_17->proc~check proc~clock_end aoc_utilities::clock%clock_end program~problem_17->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_17->proc~clock_start proc~initialize_cache~2 aoc_cache_module::function_cache%initialize_cache program~problem_17->proc~initialize_cache~2 proc~read_file_to_int_array aoc_utilities::read_file_to_int_array program~problem_17->proc~read_file_to_int_array proc~expand_queue problem_17::expand_queue proc~add_to_queue->proc~expand_queue proc~check->proc~add_to_queue proc~index_in_queue problem_17::index_in_queue proc~check->proc~index_in_queue proc~destroy_cache~2 aoc_cache_module::function_cache%destroy_cache proc~initialize_cache~2->proc~destroy_cache~2 proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_int_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_int_array->proc~read_line proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~index_in_queue->proc~get_from_cache~2 proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~index_in_queue->proc~put_in_cache~2 proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: NSTATE = 4 number of state dimensions [i,j,direction,moves_in_that_direction] integer, parameter :: N_DIRECTIONS = 4 integer(kind=ip), parameter :: UP = 1 integer(kind=ip), parameter :: DOWN = -1 integer(kind=ip), parameter :: LEFT = 2 integer(kind=ip), parameter :: RIGHT = -2 integer, parameter :: MAX_MOVES_IN_DIR = 10 type( function_cache ) :: cache to cache the queue access ... to try to speed things up !!! type( item ), dimension(:), allocatable :: queue will be expanding integer(kind=ip), dimension(1) :: iloc integer(kind=ip) :: idx integer :: i integer :: j integer :: n_rows integer :: n_cols integer, dimension(:,:), allocatable :: map heat map integer(kind=ip) :: queue_size Derived Types type :: item Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(NSTATE) :: state = 0 state: [i, j, direction, and # of moves] integer(kind=ip), public :: dist = huge(1) distance for this one logical, public :: visited = .false. if this one is done integer(kind=ip), public :: iprev = -1 index in the queue of the previous one Functions function index_in_queue (state) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state Return Value integer(kind=ip) index in the queue. -1 if not present Subroutines subroutine check (idx, idirection) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: idx integer(kind=ip), intent(in) :: idirection direction to move from current subroutine add_to_queue (state, idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state integer(kind=ip), intent(out) :: idx index of the element in the queue pure subroutine expand_queue (vec, n, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name type( item ), intent(inout), dimension(:), allocatable :: vec integer(kind=ip), intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call type( item ), intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) Source Code program problem_17 !! part b use aoc_utilities use iso_fortran_env use aoc_cache_module implicit none integer , parameter :: NSTATE = 4 !! number of state dimensions [i,j,direction,moves_in_that_direction] integer , parameter :: N_DIRECTIONS = 4 ! 1,2,3,4 integer ( ip ), parameter :: UP = 1 ! direction traveling integer ( ip ), parameter :: DOWN = - 1 integer ( ip ), parameter :: LEFT = 2 integer ( ip ), parameter :: RIGHT = - 2 integer , parameter :: MAX_MOVES_IN_DIR = 10 !3 type ( function_cache ) :: cache !! to cache the queue access ... to try to speed things up !!! ! queue for the states and distances... rather than constructing the 2d array... ! just create this as we go... type :: item integer ( ip ), dimension ( NSTATE ) :: state = 0 !! state: [i, j, direction, and # of moves] integer ( ip ) :: dist = huge ( 1 ) !! distance for this one logical :: visited = . false . !! if this one is done integer ( ip ) :: iprev = - 1 !! index in the queue of the previous one end type item type ( item ), dimension (:), allocatable :: queue !! will be expanding integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: idx integer :: i , j , n_rows , n_cols integer , dimension (:,:), allocatable :: map !! heat map integer ( ip ) :: queue_size ! for the CI ! need a faster version ... write ( * , * ) 'it works but takes a few minutes...' stop call clk % tic () call cache % initialize ( isize = 10000 , chunk_size = 1000 ) ! map = read_file_to_int_array('inputs/day17_test.txt') map = read_file_to_int_array ( 'inputs/day17.txt' ) n_rows = size ( map , 1 ) n_cols = size ( map , 2 ) queue_size = 0 call add_to_queue ([ 1_ip , 1_ip , 0_ip , 0_ip ], idx ) ! start queue ( idx )% dist = 0 do ! find min distance so far for ones not visited iloc = minloc ( queue ( 1 : queue_size )% dist , mask = . not . queue ( 1 : queue_size )% visited ) idx = iloc ( 1 ) ! index in the queue queue ( idx )% visited = . true . if ( queue ( idx )% state ( 1 ) == n_rows . and . queue ( idx )% state ( 2 ) == n_cols ) exit ! destination: we are done ! process ajacent ones: call check ( idx , UP ) call check ( idx , DOWN ) call check ( idx , LEFT ) call check ( idx , RIGHT ) end do write ( * , * ) '17b: ' , queue ( idx )% dist call clk % toc ( '17' ) contains subroutine check ( idx , idirection ) implicit none integer ( ip ), intent ( in ) :: idx ! current item in the queue to process integer ( ip ), intent ( in ) :: idirection !! direction to move from current integer ( ip ) :: alt integer ( ip ), dimension ( 2 ) :: v ! neighbor to move to integer ( ip ) :: imovesv , idxv , distv integer ( ip ), dimension ( NSTATE ) :: istate logical :: in_queue associate ( i => queue ( idx )% state ( 1 ), & j => queue ( idx )% state ( 2 ), & direction => queue ( idx )% state ( 3 ), & n_moves => queue ( idx )% state ( 4 )) if ( direction ==- idirection ) return ! can't reverse ! the one to go to: if ( direction == idirection ) then if ( n_moves == MAX_MOVES_IN_DIR ) return ! can't move in this direction anymore imovesv = n_moves + 1 else if ( n_moves /= 0 . and . n_moves < 4 ) return ! must move at last 4 before a turn! imovesv = 1 ! reset on change of direction end if select case ( idirection ) case ( UP ); v = [ i - 1 , j ] case ( DOWN ); v = [ i + 1 , j ] case ( LEFT ); v = [ i , j - 1 ] case ( RIGHT ); v = [ i , j + 1 ] end select if ( v ( 1 ) < 1 . or . v ( 2 ) < 1 . or . v ( 1 ) > n_rows . or . v ( 2 ) > n_cols ) return ! can't go off the board if ( v ( 1 ) == n_rows . and . v ( 2 ) == n_cols . and . imovesv < 4 ) return ! require at least 4 to end istate = [ v ( 1 ), v ( 2 ), idirection , imovesv ] ! new state idxv = index_in_queue ( istate ) ! is it already in the queue in_queue = idxv > 0 ! if this one is already part of another path if ( in_queue ) then if ( queue ( idxv )% visited ) return ! already visited this one distv = queue ( idxv )% dist ! distance in the queue else !call add_to_queue(istate, idxv) ! add this to the queue for processing ! always add it ?? distv = huge ( 1_ip ) ! not processed yet, so huge number end if !alt = queue(idx)%dist + map(queue(idxv)%state(1), queue(idxv)%state(2)) alt = queue ( idx )% dist + map ( v ( 1 ), v ( 2 )) ! new distance if ( alt < distv ) then ! the new one is better, so replace values in the queue if (. not . in_queue ) call add_to_queue ( istate , idxv ) ! only add it if we accept it ???? ! accept this step queue ( idxv )% dist = alt ! new best dist queue ( idxv )% iprev = idx ! previous end if end associate end subroutine check ! .. need a faster queue... function index_in_queue ( state ) result ( idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ) :: idx !! index in the queue. -1 if not present integer ( ip ) :: i logical :: found integer ( ip ) :: cache_idx integer ( ip ), dimension (:), allocatable :: cache_ival call cache % get ( state , cache_idx , cache_ival , found ) if ( found ) then idx = cache_ival ( 1 ) else idx = - 1 if (. not . allocated ( queue )) error stop 'error: queue not allocated' do i = 1 , queue_size if ( all ( state == queue ( i )% state )) then idx = i exit end if end do if ( idx /= - 1 ) call cache % put ( cache_idx , state ,[ idx ]) end if end function index_in_queue subroutine add_to_queue ( state , idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ), intent ( out ) :: idx !! index of the element in the queue if ( allocated ( queue )) then call expand_queue ( queue , queue_size , item ( state = state )) idx = queue_size else queue = [ item ( state = state )] queue_size = 1 idx = 1 end if end subroutine add_to_queue !**************************************************************** !> !  Add elements to the integer vector in chunks. pure subroutine expand_queue ( vec , n , val , finished ) integer ( ip ), parameter :: chunk_size = 1000 type ( item ), dimension (:), allocatable , intent ( inout ) :: vec integer ( ip ), intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call type ( item ), intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) type ( item ), dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_queue !**************************************************************** end program problem_17","tags":"","loc":"program/problem_17.html"},{"title":"problem_11 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_11~~UsesGraph program~problem_11 problem_11 iso_fortran_env iso_fortran_env program~problem_11->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_11->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_11~~CallsGraph program~problem_11 problem_11 proc~clock_end aoc_utilities::clock%clock_end program~problem_11->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_11->proc~clock_start proc~go~7 problem_11::go program~problem_11->proc~go~7 interface~manhatten_distance aoc_utilities::manhatten_distance proc~go~7->interface~manhatten_distance proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~go~7->proc~read_file_to_char_array proc~manhatten_distance_64 aoc_utilities::manhatten_distance_64 interface~manhatten_distance->proc~manhatten_distance_64 proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Functions function go (expansion_factor) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: expansion_factor Return Value integer(kind=ip) Source Code program problem_11 use iso_fortran_env use aoc_utilities implicit none call clk % tic () write ( * , * ) '11a: ' , go ( 2_ip ) write ( * , * ) '11b: ' , go ( 1000000_ip ) call clk % toc ( '11' ) contains integer ( ip ) function go ( expansion_factor ) integer ( ip ), intent ( in ) :: expansion_factor integer :: i , j , nrows , ncols , n_galaxies , n , k character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:,:), allocatable :: idists integer ( ip ), dimension (:), allocatable :: igal , jgal integer ( ip ), dimension (:,:), allocatable :: ix , iy ! array = read_file_to_char_array('inputs/day11_test.txt') array = read_file_to_char_array ( 'inputs/day11.txt' ) nrows = size ( array , 1 ); ncols = size ( array , 2 ) n_galaxies = count ( array == '#' ) ! track the real indices after expansion ix = transpose ( spread ([( i , i = 1 , ncols )], 1 , nrows )) ! row indices iy = spread ([( i , i = 1 , nrows )], 1 , ncols ) ! col indices igal = pack ( ix , array == '#' ) ! indices of galaxies jgal = pack ( iy , array == '#' ) ! expand the array, keeping track of the new row indices do i = 1 , nrows ! add rows if necessary if ( all ( array ( i ,:) == '.' )) ix ( i :,:) = ix ( i :,:) + expansion_factor - 1 ! new row end do do j = 1 , ncols ! add cols if necessary if ( all ( array (:, j ) == '.' )) iy (:, j :) = iy (:, j :) + expansion_factor - 1 ! new column end do ! now compute all the distances: allocate ( idists ( n_galaxies , n_galaxies )); idists = 0 do i = 1 , n_galaxies do j = 1 , n_galaxies if ( j <= i ) cycle ! only need the lower diagonal idists ( i , j ) = manhatten_distance ( ix ( igal ( i ), jgal ( i )), iy ( igal ( i ), jgal ( i )),& ix ( igal ( j ), jgal ( j )), iy ( igal ( j ), jgal ( j ))) end do end do go = sum ( idists ) end function go end program problem_11","tags":"","loc":"program/problem_11.html"},{"title":"problem_3 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_3~~UsesGraph program~problem_3 problem_3 iso_fortran_env iso_fortran_env program~problem_3->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_3->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_3~~CallsGraph program~problem_3 problem_3 proc~check~2 problem_3::check program~problem_3->proc~check~2 proc~clock_end aoc_utilities::clock%clock_end program~problem_3->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_3->proc~clock_start proc~get_number problem_3::get_number program~problem_3->proc~get_number proc~is_not_number aoc_utilities::is_not_number program~problem_3->proc~is_not_number proc~is_symbol problem_3::is_symbol program~problem_3->proc~is_symbol proc~read_file_to_char_array aoc_utilities::read_file_to_char_array program~problem_3->proc~read_file_to_char_array proc~check~2->proc~get_number proc~is_number aoc_utilities::is_number proc~check~2->proc~is_number proc~get_number->proc~is_symbol proc~is_not_number->proc~is_number proc~is_symbol->proc~is_not_number proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: n_lines integer :: i integer :: j integer :: n_cols integer :: jstart integer :: jend logical :: adjacent logical :: tmp integer(kind=ip) :: isum character(len=1), dimension(:,:), allocatable :: array integer(kind=ip), dimension(:), allocatable :: ivals Functions function check (i, j) if the char is part of a number, then get it and append to ivals Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Return Value logical function is_symbol (c) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical function get_number (i, j) get the full number contining the character at i,j Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Return Value integer(kind=ip) Source Code program problem_3 use iso_fortran_env use aoc_utilities implicit none integer :: n_lines , i , j , n_cols , jstart , jend logical :: adjacent , tmp integer ( ip ) :: isum character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:), allocatable :: ivals call clk % tic () ! read file: ! pad around with blanks to simplify logic below array = read_file_to_char_array ( 'inputs/day3.txt' , border = '.' ) n_lines = size ( array , 1 ) n_cols = size ( array , 2 ) !----------------- part 1 ----------------- isum = 0 do i = 1 , n_lines ! is this character adjacent to a symbol? jend = 0 do j = 1 , n_cols if ( is_not_number ( array ( i , j ))) cycle if ( j <= jend ) cycle ! skip the cols that we already have jend = 0 adjacent = is_symbol ( array ( i - 1 , j ) ) . or . & is_symbol ( array ( i - 1 , j - 1 )) . or . & is_symbol ( array ( i - 1 , j + 1 )) . or . & is_symbol ( array ( i , j - 1 ) ) . or . & is_symbol ( array ( i , j + 1 ) ) . or . & is_symbol ( array ( i + 1 , j ) ) . or . & is_symbol ( array ( i + 1 , j - 1 )) . or . & is_symbol ( array ( i + 1 , j + 1 )) if ( adjacent ) isum = isum + get_number ( i , j ) ! note: this sets jend end do end do write ( * , * ) '3a: sum :' , isum !----------------- part 2 ----------------- ! now look for '*' and find adjacent numbers .... isum = 0 do i = 1 , n_lines do j = 1 , n_cols if ( array ( i , j ) == '*' ) then ! look for 2 adjacent numbers. if ( allocated ( ivals )) deallocate ( ivals ); allocate ( ivals ( 0 )) ! above tmp = check ( i - 1 , j ) ! if only one on top if (. not . tmp ) then tmp = check ( i - 1 , j - 1 ) tmp = check ( i - 1 , j + 1 ) end if tmp = check ( i , j - 1 ) ! left and right tmp = check ( i , j + 1 ) ! below tmp = check ( i + 1 , j ) ! if only one below if (. not . tmp ) then tmp = check ( i + 1 , j - 1 ) tmp = check ( i + 1 , j + 1 ) end if if ( size ( ivals ) == 2 ) isum = isum + product ( ivals ) ! sum gear ratio end if end do end do write ( * , * ) '3b: result :' , isum call clk % toc ( '3' ) contains logical function check ( i , j ) !! if the char is part of a number, then get it and append to ivals integer , intent ( in ) :: i , j check = is_number ( array ( i , j )) if ( check ) ivals = [ ivals , get_number ( i , j )] end function check logical function is_symbol ( c ) character ( len = 1 ), intent ( in ) :: c is_symbol = is_not_number ( c ) . and . c /= '.' end function is_symbol integer ( ip ) function get_number ( i , j ) !! get the full number contining the character at i,j integer , intent ( in ) :: i , j jstart = j jend = j do if ( array ( i , jstart - 1 ) == '.' . or . is_symbol ( array ( i , jstart - 1 ))) exit jstart = jstart - 1 end do do if ( array ( i , jend + 1 ) == '.' . or . is_symbol ( array ( i , jend + 1 ))) exit jend = jend + 1 end do get_number = int ( array ( i , jstart : jend )) end function get_number end program problem_3","tags":"","loc":"program/problem_3.html"},{"title":"problem_1 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_1~~UsesGraph program~problem_1 problem_1 iso_fortran_env iso_fortran_env program~problem_1->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_1->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_1~~CallsGraph program~problem_1 problem_1 proc~clock_end aoc_utilities::clock%clock_end program~problem_1->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_1->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_1->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_1->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit logical :: status_ok character(len=:), allocatable :: line integer :: n_lines integer :: i integer :: j integer :: k integer :: n integer :: isum integer :: ifirst integer :: ilast integer :: idxfirst integer :: idxlast character(len=*), parameter,               dimension(9) :: ichars = ['one&nbsp;&nbsp;', 'two&nbsp;&nbsp;', 'three', 'four ', 'five ', 'six&nbsp;&nbsp;', 'seven', 'eight', 'nine '] Source Code program problem_1 use iso_fortran_env use aoc_utilities implicit none integer :: iunit logical :: status_ok character ( len = :), allocatable :: line integer :: n_lines integer :: i , j , k , n , isum , ifirst , ilast , idxfirst , idxlast character ( len =* ), dimension ( 9 ), parameter :: ichars = [ & 'one  ' , & 'two  ' , & 'three' , & 'four ' , & 'five ' , & 'six  ' , & 'seven' , & 'eight' , & 'nine ' ] call clk % tic () isum = 0 open ( newunit = iunit , file = 'inputs/day1.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) do i = 1 , n_lines ! remove all the chars before the first and after the last number line = read_line ( iunit , status_ok ) n = len ( line ) do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) exit ! done line ( j : j ) = ' ' end do do j = n , 1 , - 1 if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) exit ! done line ( j : j ) = ' ' end do line = trim ( adjustl ( line )) n = len ( line ) isum = isum + 10 * int ( line ( 1 : 1 )) + int ( line ( n : n )) end do write ( * , * ) '1a: sum:' , isum close ( iunit ) ! -------- part 2 ----------- open ( newunit = iunit , file = 'inputs/day1.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do i = 1 , n_lines line = read_line ( iunit , status_ok ) n = len ( line ) ! keep track of the index of the first and last number (digit or string) ifirst = huge ( 1 ) idxfirst = huge ( 1 ) do j = 1 , size ( ichars ) k = min ( index ( line , trim ( ichars ( j ))), index ( line , trim ( ichars ( j )), back = . true .) ) ! accounts for duplicates if ( k > 0 . and . k <= idxfirst ) then ifirst = j idxfirst = k end if end do do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) then if ( j <= idxfirst ) then ifirst = int ( line ( j : j )) idxfirst = j end if end if end do ilast = 0 idxlast = 0 do j = 1 , size ( ichars ) k = max ( index ( line , trim ( ichars ( j ))), index ( line , trim ( ichars ( j )), back = . true .) ) ! accounts for duplicates if ( k > 0 . and . k >= idxlast ) then ilast = j idxlast = k end if end do do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) then if ( j >= idxlast ) then ilast = int ( line ( j : j )) idxlast = j end if end if end do isum = isum + 10 * ifirst + ilast end do write ( * , * ) '1b: sum:' , isum call clk % toc ( '1' ) end program problem_1","tags":"","loc":"program/problem_1.html"},{"title":"main – AoC-2023","text":"Uses lsqrtest_module program~~main~2~~UsesGraph program~main~2 main module~lsqrtest_module lsqrtest_module program~main~2->module~lsqrtest_module module~lsqpblas_module lsqpblas_module module~lsqrtest_module->module~lsqpblas_module module~lsqr_kinds lsqr_kinds module~lsqrtest_module->module~lsqr_kinds module~lsqr_module lsqr_module module~lsqrtest_module->module~lsqr_module module~lsqpblas_module->module~lsqr_kinds iso_fortran_env iso_fortran_env module~lsqr_kinds->iso_fortran_env module~lsqr_module->module~lsqpblas_module module~lsqr_module->module~lsqr_kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Main program for tests. Calls program~~main~2~~CallsGraph program~main~2 main proc~lsqr_test lsqrtest_module::lsqr_test program~main~2->proc~lsqr_test proc~test~2 lsqrtest_module::test_solver%test proc~lsqr_test->proc~test~2 4 4 proc~test~2->4 proc~acheck lsqr_module::lsqr_solver%acheck proc~test~2->proc~acheck proc~dcopy lsqpblas_module::dcopy proc~test~2->proc~dcopy proc~dnrm2 lsqpblas_module::dnrm2 proc~test~2->proc~dnrm2 proc~lsqr lsqr_module::lsqr_solver%LSQR proc~test~2->proc~lsqr proc~lstp lsqrtest_module::test_solver%lstp proc~test~2->proc~lstp proc~xcheck lsqr_module::lsqr_solver%xcheck proc~test~2->proc~xcheck proc~acheck->proc~dcopy proc~acheck->proc~dnrm2 aprod aprod proc~acheck->aprod proc~ddot lsqpblas_module::ddot proc~acheck->proc~ddot proc~dscal lsqpblas_module::dscal proc~acheck->proc~dscal proc~lsqr->proc~dcopy proc~lsqr->proc~dnrm2 proc~lsqr->aprod proc~d2norm lsqr_module::d2norm proc~lsqr->proc~d2norm proc~lsqr->proc~dscal proc~lstp->proc~dcopy proc~lstp->proc~dnrm2 proc~aprod1 lsqrtest_module::test_solver%aprod1 proc~lstp->proc~aprod1 proc~lstp->proc~dscal proc~hprod lsqrtest_module::hprod proc~lstp->proc~hprod proc~xcheck->proc~dcopy proc~xcheck->proc~dnrm2 proc~xcheck->aprod proc~xcheck->proc~dscal proc~aprod1->proc~hprod Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code program main use lsqrtest_module , only : lsqr_test implicit none call lsqr_test () end program main","tags":"","loc":"program/main~2.html"},{"title":"problem_17 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_17~2~~UsesGraph program~problem_17~2 problem_17 iso_fortran_env iso_fortran_env program~problem_17~2->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_17~2->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Based on AOC 2021 Day 15: https://github.com/jacobwilliams/AoC-2021/blob/master/test/problem_15.f90\nsee: https://en.wikipedia.org/wiki/Dijkstra's_algorithm#Pseudocode only difference is the constraint that it can move at most three blocks in a single direction Calls program~~problem_17~2~~CallsGraph program~problem_17~2 problem_17 proc~add_to_queue~2 problem_17::add_to_queue program~problem_17~2->proc~add_to_queue~2 proc~check~3 problem_17::check program~problem_17~2->proc~check~3 proc~clock_end aoc_utilities::clock%clock_end program~problem_17~2->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_17~2->proc~clock_start proc~read_file_to_int_array aoc_utilities::read_file_to_int_array program~problem_17~2->proc~read_file_to_int_array proc~check~3->proc~add_to_queue~2 proc~index_in_queue~2 problem_17::index_in_queue proc~check~3->proc~index_in_queue~2 proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_int_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_int_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: NSTATE = 4 number of state dimensions [i,j,direction,moves_in_that_direction] integer, parameter :: N_DIRECTIONS = 4 integer(kind=ip), parameter :: UP = 1 integer(kind=ip), parameter :: DOWN = -1 integer(kind=ip), parameter :: LEFT = 2 integer(kind=ip), parameter :: RIGHT = -2 integer, parameter :: MAX_MOVES_IN_DIR = 3 type( item ), dimension(:), allocatable :: queue will be expanding integer(kind=ip), dimension(1) :: iloc integer(kind=ip) :: idx integer :: i integer :: j integer :: n_rows integer :: n_cols integer, dimension(:,:), allocatable :: map heat map Derived Types type :: item Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(NSTATE) :: state = 0 state: [i, j, direction, and # of moves] integer(kind=ip), public :: dist = huge(1) distance for this one logical, public :: visited = .false. if this one is done integer(kind=ip), public :: iprev = -1 index in the queue of the previous one Functions function index_in_queue (state) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state Return Value integer(kind=ip) index in the queue. -1 if not present Subroutines subroutine check (idx, idirection) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: idx integer(kind=ip), intent(in) :: idirection direction to move from current subroutine add_to_queue (state, idx) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(NSTATE) :: state integer(kind=ip), intent(out) :: idx index of the element in the queue Source Code program problem_17 use aoc_utilities use iso_fortran_env !! Based on AOC 2021 Day 15: https://github.com/jacobwilliams/AoC-2021/blob/master/test/problem_15.f90 !! see: https://en.wikipedia.org/wiki/Dijkstra's_algorithm#Pseudocode !! !! only difference is the constraint that it can move at most three blocks in a single direction implicit none integer , parameter :: NSTATE = 4 !! number of state dimensions [i,j,direction,moves_in_that_direction] integer , parameter :: N_DIRECTIONS = 4 ! 1,2,3,4 integer ( ip ), parameter :: UP = 1 ! direction traveling integer ( ip ), parameter :: DOWN = - 1 integer ( ip ), parameter :: LEFT = 2 integer ( ip ), parameter :: RIGHT = - 2 integer , parameter :: MAX_MOVES_IN_DIR = 3 ! queue for the states and distances... rather than constructing the 2d array... ! just create this as we go... type :: item integer ( ip ), dimension ( NSTATE ) :: state = 0 !! state: [i, j, direction, and # of moves] integer ( ip ) :: dist = huge ( 1 ) !! distance for this one logical :: visited = . false . !! if this one is done integer ( ip ) :: iprev = - 1 !! index in the queue of the previous one end type item type ( item ), dimension (:), allocatable :: queue !! will be expanding integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: idx integer :: i , j , n_rows , n_cols integer , dimension (:,:), allocatable :: map !! heat map ! for the CI ! need a faster version ... write ( * , * ) 'it works but takes a few minutes...' stop call clk % tic () ! map = read_file_to_int_array('inputs/day17_test.txt') map = read_file_to_int_array ( 'inputs/day17.txt' ) n_rows = size ( map , 1 ) n_cols = size ( map , 2 ) call add_to_queue ([ 1_ip , 1_ip , 0_ip , 0_ip ], idx ) ! start queue ( idx )% dist = 0 do ! find min distance so far for ones not visited iloc = minloc ( queue % dist , mask = . not . queue % visited ) idx = iloc ( 1 ) ! index in the queue queue ( idx )% visited = . true . !write(*,*) 'visited ', queue(idx)%state(1), queue(idx)%state(2), n_rows, n_cols if ( queue ( idx )% state ( 1 ) == n_rows . and . queue ( idx )% state ( 2 ) == n_cols ) exit ! destination: we are done ! process ajacent ones: call check ( idx , UP ) call check ( idx , DOWN ) call check ( idx , LEFT ) call check ( idx , RIGHT ) end do write ( * , * ) '15a: ' , queue ( idx )% dist ! ...draw the path ! block !     character(len=1),dimension(:,:),allocatable :: char_map !     char_map = int_array_to_char_array(map) !     do !         char_map(queue(idx)%state(1),queue(idx)%state(2)) = '#' !         if (queue(idx)%state(1)==1) then !             write(*,*) queue(idx)%state !         end if !         if (queue(idx)%state(1)==1 .and. queue(idx)%state(2)==1) exit !         idx = queue(idx)%iprev !     end do !     write(*,*) ' path: ' !     do i = 1, n_rows !         write(*,'(*(A1))') char_map(i,:) !     end do ! end block call clk % toc ( '17' ) contains subroutine check ( idx , idirection ) implicit none integer ( ip ), intent ( in ) :: idx ! current item in the queue to process integer ( ip ), intent ( in ) :: idirection !! direction to move from current integer ( ip ) :: alt integer ( ip ), dimension ( 2 ) :: v ! neighbor to move to integer ( ip ) :: imovesv , idxv , distv integer ( ip ), dimension ( NSTATE ) :: istate logical :: in_queue associate ( i => queue ( idx )% state ( 1 ), & j => queue ( idx )% state ( 2 ), & direction => queue ( idx )% state ( 3 ), & n_moves => queue ( idx )% state ( 4 )) if ( direction ==- idirection ) return ! can't reverse ! the one to go to: if ( direction == idirection ) then if ( n_moves == MAX_MOVES_IN_DIR ) return ! can't move in this direction anymore imovesv = n_moves + 1 else imovesv = 1 ! reset on change of direction end if select case ( idirection ) case ( UP ); v = [ i - 1 , j ] case ( DOWN ); v = [ i + 1 , j ] case ( LEFT ); v = [ i , j - 1 ] case ( RIGHT ); v = [ i , j + 1 ] end select if ( v ( 1 ) < 1 . or . v ( 2 ) < 1 . or . v ( 1 ) > n_rows . or . v ( 2 ) > n_cols ) return ! can't go off the board istate = [ v ( 1 ), v ( 2 ), idirection , imovesv ] ! new state idxv = index_in_queue ( istate ) ! is it already in the queue in_queue = idxv > 0 ! if this one is already part of another path if ( in_queue ) then if ( queue ( idxv )% visited ) return ! already visited this one distv = queue ( idxv )% dist ! distance in the queue else !call add_to_queue(istate, idxv) ! add this to the queue for processing ! always add it ?? distv = huge ( 1_ip ) ! not processed yet, so huge number end if !alt = queue(idx)%dist + map(queue(idxv)%state(1), queue(idxv)%state(2)) alt = queue ( idx )% dist + map ( v ( 1 ), v ( 2 )) ! new distance if ( alt < distv ) then ! the new one is better, so replace values in the queue if (. not . in_queue ) call add_to_queue ( istate , idxv ) ! only add it if we accept it ???? ! accept this step queue ( idxv )% dist = alt ! new best dist queue ( idxv )% iprev = idx ! previous end if end associate end subroutine check ! .. need a faster queue... function index_in_queue ( state ) result ( idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ) :: idx !! index in the queue. -1 if not present integer :: i idx = - 1 if (. not . allocated ( queue )) error stop 'error: queue not allocated' do i = 1 , size ( queue ) if ( all ( state == queue ( i )% state )) then idx = i return end if end do end function index_in_queue subroutine add_to_queue ( state , idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ), intent ( out ) :: idx !! index of the element in the queue if ( allocated ( queue )) then queue = [ queue , item ( state = state )] idx = size ( queue ) else queue = [ item ( state = state )] idx = 1 end if end subroutine add_to_queue end program problem_17","tags":"","loc":"program/problem_17~2.html"},{"title":"problem_25 – AoC-2023","text":"Uses dag_module aoc_utilities program~~problem_25~~UsesGraph program~problem_25 problem_25 module~aoc_utilities aoc_utilities program~problem_25->module~aoc_utilities module~dag_module dag_module program~problem_25->module~dag_module iso_fortran_env iso_fortran_env module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_25~~CallsGraph program~problem_25 problem_25 interface~split aoc_utilities::split program~problem_25->interface~split interface~unique aoc_utilities::unique program~problem_25->interface~unique proc~clock_end aoc_utilities::clock%clock_end program~problem_25->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_25->proc~clock_start proc~dag_destroy dag_module::dag%dag_destroy program~problem_25->proc~dag_destroy proc~dag_save_digraph dag_module::dag%dag_save_digraph program~problem_25->proc~dag_save_digraph proc~dag_set_edges dag_module::dag%dag_set_edges program~problem_25->proc~dag_set_edges proc~dag_set_vertex_info dag_module::dag%dag_set_vertex_info program~problem_25->proc~dag_set_vertex_info proc~dag_set_vertices dag_module::dag%dag_set_vertices program~problem_25->proc~dag_set_vertices proc~node_index problem_25::node_index program~problem_25->proc~node_index proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_25->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_25->proc~read_line proc~traverse problem_25::traverse program~problem_25->proc~traverse proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 proc~dag_generate_digraph dag_module::dag%dag_generate_digraph proc~dag_save_digraph->proc~dag_generate_digraph none~set_edges dag_module::vertex%set_edges proc~dag_set_edges->none~set_edges proc~integer_to_string dag_module::integer_to_string proc~dag_set_vertex_info->proc~integer_to_string proc~traverse->proc~traverse proc~add_edge dag_module::vertex%add_edge none~set_edges->proc~add_edge proc~set_edge_vector dag_module::vertex%set_edge_vector none~set_edges->proc~set_edge_vector proc~dag_generate_digraph->proc~integer_to_string proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 proc~set_edge_vector->proc~add_edge interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit integer :: n_lines integer :: i integer :: j integer :: n_nodes integer :: inode integer :: inode2 character(len=:), allocatable :: line type( string ), dimension(:), allocatable :: vals type( string ), dimension(:), allocatable :: vals2 character(len=3) :: node1 character(len=3) :: node2 character(len=3), dimension(:), allocatable :: nodes integer, dimension(:), allocatable :: inodedep integer, dimension(:), allocatable :: icounts character(len=*), parameter :: filetype = 'pdf' type( dag ) :: d type( node_t ), dimension(:), allocatable :: graph index is the node number logical, dimension(:), allocatable :: visited Derived Types type :: node_t Components Type Visibility Attributes Name Initial integer, public, dimension(:), allocatable :: connections the ones connected to this one Functions pure function node_index (node) find the node number for this name Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: node Return Value integer Subroutines recursive subroutine traverse (i) travere the graph and visit all the connected nodes Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Source Code program problem_25 use aoc_utilities use dag_module implicit none integer :: iunit , n_lines , i , j , n_nodes , inode , inode2 character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals , vals2 character ( len = 3 ) :: node1 , node2 character ( len = 3 ), dimension (:), allocatable :: nodes integer , dimension (:), allocatable :: inodedep , icounts character ( len =* ), parameter :: filetype = 'pdf' type ( dag ) :: d type :: node_t !character(len=3) :: name = '' integer , dimension (:), allocatable :: connections !! the ones connected to this one end type node_t type ( node_t ), dimension (:), allocatable :: graph !! index is the node number logical , dimension (:), allocatable :: visited call clk % tic () ! read the data: ! open(newunit=iunit, file='inputs/day25_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day25.txt' , status = 'OLD' ) allocate ( nodes ( 0 )) n_lines = number_of_lines_in_file ( iunit ) do i = 1 , n_lines line = read_line ( iunit ) ! for starters, get a list of all the nodes vals = split ( line , ': ' ) node1 = vals ( 1 )% str if (. not . any ( nodes == node1 )) nodes = [ nodes , node1 ] vals2 = split ( vals ( 2 )% str , ' ' ) do j = 1 , size ( vals2 ) node2 = vals2 ( j )% str if (. not . any ( nodes == node2 )) nodes = [ nodes , node2 ] end do end do rewind ( iunit ) n_nodes = size ( nodes ) ! create a dag: call d % set_vertices ( n_nodes ) allocate ( graph ( n_nodes )) !... do i = 1 , n_nodes allocate ( graph ( i )% connections ( 0 )) ! initialize end do do i = 1 , n_lines line = read_line ( iunit ) ! for starters, get a list of all the nodes vals = split ( line , ': ' ) node1 = vals ( 1 )% str inode = node_index ( node1 ) !inode = findloc(nodes,node1) if (. not . any ( nodes == node1 )) nodes = [ nodes , node1 ] vals2 = split ( vals ( 2 )% str , ' ' ) if ( allocated ( inodedep )) deallocate ( inodedep ) allocate ( inodedep ( 0 )) do j = 1 , size ( vals2 ) node2 = vals2 ( j )% str inode2 = node_index ( node2 ) !-------------------------------------------- ! prune the ones by inspection by looking at the graph, opening in Inkscape, ! coloring the 3 lines and finding the nodes that connect them if ( ( node1 == 'ljm' . and . node2 == 'sfd' ) . or . ( node2 == 'ljm' . and . node1 == 'sfd' ) ) cycle if ( ( node1 == 'gst' . and . node2 == 'rph' ) . or . ( node2 == 'gst' . and . node1 == 'rph' ) ) cycle if ( ( node1 == 'jkn' . and . node2 == 'cfn' ) . or . ( node2 == 'jkn' . and . node1 == 'cfn' ) ) cycle !-------------------------------------------- ! accumulate the graph: ! connection between inode <--> inodedep graph ( inode )% connections = [ graph ( inode )% connections , inode2 ] graph ( inode2 )% connections = [ graph ( inode2 )% connections , inode ] ! for the plot: inodedep = [ inodedep , inode2 ] end do call d % set_edges ( inode , inodedep ) end do ! define some styles for the GraphViz output: do i = 1 , n_nodes call d % set_vertex_info ( i , label = nodes ( i )) end do ! generate the GraphViz output: call d % save_digraph ( 'problem25.dot' , rankdir = 'TB' , dpi = 300 ) call d % destroy () call execute_command_line ( 'dot -Tpdf -o problem25.pdf problem25.dot' ) ! add to dot file:  !todo add this to daglib ... ! mindist=10 ! ranksep=20 ! count the ones connected to each node and get the unique two we need allocate ( visited ( n_nodes )) allocate ( icounts ( 0 )) do i = 1 , n_lines visited = . false . call traverse ( i ) icounts = unique ([ icounts , count ( visited )]) write ( * , * ) i , icounts end do write ( * , * ) '25a:' , product ( icounts ) call clk % toc ( '25' ) contains pure integer function node_index ( node ) !! find the node number for this name character ( len =* ), intent ( in ) :: node integer , dimension ( 1 ) :: idx idx = findloc ( nodes , node ) node_index = idx ( 1 ) end function node_index recursive subroutine traverse ( i ) !! travere the graph and visit all the connected nodes integer , intent ( in ) :: i integer :: j if ( visited ( i )) return visited ( i ) = . true . do j = 1 , size ( graph ( i )% connections ) call traverse ( graph ( i )% connections ( j )) end do end subroutine traverse end program problem_25","tags":"","loc":"program/problem_25.html"},{"title":"problem_16 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_16~~UsesGraph program~problem_16 problem_16 iso_fortran_env iso_fortran_env program~problem_16->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_16->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_16~~CallsGraph program~problem_16 problem_16 proc~clock_end aoc_utilities::clock%clock_end program~problem_16->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_16->proc~clock_start proc~go~2 problem_16::go program~problem_16->proc~go~2 proc~read_file_to_char_array aoc_utilities::read_file_to_char_array program~problem_16->proc~read_file_to_char_array proc~go~2->proc~go~2 proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: j integer :: nrows integer :: ncols integer :: max_count integer :: icount integer :: icase character(len=1), dimension(:,:), allocatable :: array logical, dimension(:,:,:), allocatable :: visited integer, parameter :: TOP = 1 integer, parameter :: BOTTOM = 2 integer, parameter :: LEFT = 3 integer, parameter :: RIGHT = 4 Subroutines recursive subroutine go (i, j, direction_from) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i grid coordinate integer, intent(in) :: j grid coordinate integer, intent(in) :: direction_from direction coming from (TOP,BOTTOM,LEFT,RIGHT Source Code program problem_16 use iso_fortran_env use aoc_utilities implicit none integer :: i , j , nrows , ncols , max_count , icount , icase character ( len = 1 ), dimension (:,:), allocatable :: array logical , dimension (:,:,:), allocatable :: visited ! top,bottom,left,right integer , parameter :: TOP = 1 ! direction traveling FROM integer , parameter :: BOTTOM = 2 integer , parameter :: LEFT = 3 integer , parameter :: RIGHT = 4 call clk % tic () ! read the data file: ! array = read_file_to_char_array('inputs/day16_test.txt') ! pad with wall around the array array = read_file_to_char_array ( 'inputs/day16.txt' ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) ! track if we have already done this case, to avoid unnecessary duplication, ! otherwise it may loop indefinitly? allocate ( visited ( 4 , nrows , ncols )) ! part 1: visited = . false . call go ( 1 , 1 , LEFT ) write ( * , * ) '16a: ' , count ( visited ( 1 ,:,:) . or . & visited ( 2 ,:,:) . or . & visited ( 3 ,:,:) . or . & visited ( 4 ,:,:)) ! part 2, just do all the cases: max_count = 0 do icase = 1 , 2 ! first and last col do i = 1 , nrows visited = . false . if ( icase == 1 ) then ; call go ( i , 1 , LEFT ) else ; call go ( i , ncols , RIGHT ) end if icount = count ( visited ( 1 ,:,:) . or . & visited ( 2 ,:,:) . or . & visited ( 3 ,:,:) . or . & visited ( 4 ,:,:)) if ( icount > max_count ) max_count = icount end do end do do icase = 1 , 2 ! first and last row do j = 1 , ncols visited = . false . if ( icase == 1 ) then ; call go ( 1 , j , TOP ) else ; call go ( nrows , j , BOTTOM ) end if icount = count ( visited ( 1 ,:,:) . or . & visited ( 2 ,:,:) . or . & visited ( 3 ,:,:) . or . & visited ( 4 ,:,:)) if ( icount > max_count ) max_count = icount end do end do write ( * , * ) '16b: ' , max_count call clk % toc ( '16' ) contains recursive subroutine go ( i , j , direction_from ) integer , intent ( in ) :: i , j !! grid coordinate integer , intent ( in ) :: direction_from !! direction coming from (TOP,BOTTOM,LEFT,RIGHT integer :: k if ( i > nrows . or . i < 1 . or . j > ncols . or . j < 1 ) return ! off the board if ( visited ( direction_from , i , j )) return ! this case has already been done visited ( direction_from , i , j ) = . true . ! mark this one as visited in this direction associate ( c => array ( i , j )) select case ( c ) case ( '.' ) ! continue in same direction k = 1 do ! loop until we hit something else ! (to avoid unnecessary recursion) select case ( direction_from ) case ( TOP ) ! V if (( i + k ) > nrows ) return if ( array ( i + k , j ) /= '.' ) then call go ( i + k , j , direction_from ) return end if visited ( direction_from , i + k , j ) = . true . case ( BOTTOM ) ! &#94; if (( i - k ) < 1 ) return if ( array ( i - k , j ) /= '.' ) then call go ( i - k , j , direction_from ) return end if visited ( direction_from , i - k , j ) = . true . case ( LEFT ) ! --> if (( j + k ) > ncols ) return if ( array ( i , j + k ) /= '.' ) then call go ( i , j + k , direction_from ) return end if visited ( direction_from , i , j + k ) = . true . case ( RIGHT ) ! <-- if (( j - k ) < 1 ) return if ( array ( i , j - k ) /= '.' ) then call go ( i , j - k , direction_from ) return end if visited ( direction_from , i , j - k ) = . true . end select k = k + 1 end do case ( '-' ) select case ( direction_from ) case ( TOP , BOTTOM ) ! V, &#94; call go ( i , j + 1 , LEFT ) ! split call go ( i , j - 1 , RIGHT ) case ( LEFT ) ! --> call go ( i , j + 1 , LEFT ) case ( RIGHT ) ! <-- call go ( i , j - 1 , RIGHT ) end select case ( '|' ) select case ( direction_from ) case ( TOP ) ! V call go ( i + 1 , j , TOP ) case ( BOTTOM ) ! &#94; call go ( i - 1 , j , BOTTOM ) case ( LEFT , RIGHT ) ! -->, <-- call go ( i + 1 , j , TOP ) call go ( i - 1 , j , BOTTOM ) end select case ( '/' ) select case ( direction_from ) case ( TOP ) ! V call go ( i , j - 1 , RIGHT ) case ( BOTTOM ) ! &#94; call go ( i , j + 1 , LEFT ) case ( LEFT ) ! --> call go ( i - 1 , j , BOTTOM ) case ( RIGHT ) ! <-- call go ( i + 1 , j , TOP ) end select case ( '\\' ) select case ( direction_from ) case ( TOP ) ! V call go ( i , j + 1 , LEFT ) case ( BOTTOM ) ! &#94; call go ( i , j - 1 , RIGHT ) case ( LEFT ) ! --> call go ( i + 1 , j , TOP ) case ( RIGHT ) ! <-- call go ( i - 1 , j , BOTTOM ) end select end select end associate end subroutine go end program problem_16","tags":"","loc":"program/problem_16.html"},{"title":"problem_19b – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_19b~~UsesGraph program~problem_19b problem_19b iso_fortran_env iso_fortran_env program~problem_19b->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_19b->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. reformulated to operate on ranges of the x,m,a,s ratings Calls program~~problem_19b~~CallsGraph program~problem_19b problem_19b interface~split aoc_utilities::split program~problem_19b->interface~split proc~clock_end aoc_utilities::clock%clock_end program~problem_19b->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_19b->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_19b->proc~number_of_lines_in_file proc~parse_rule problem_19b::parse_rule program~problem_19b->proc~parse_rule proc~process problem_19b::process program~problem_19b->proc~process proc~read_line aoc_utilities::read_line program~problem_19b->proc~read_line proc~workflow_name_to_index problem_19b::workflow_name_to_index program~problem_19b->proc~workflow_name_to_index proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~parse_rule->interface~split proc~process->proc~process proc~process->proc~workflow_name_to_index proc~get_accepted problem_19b::get_accepted proc~process->proc~get_accepted proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit integer :: n_lines integer :: iline integer :: i character(len=:), allocatable :: line type( string ), dimension(:), allocatable :: vals logical :: accepted integer(kind=ip) :: total_accepted type( part ) :: parts type( workflow ), dimension(:), allocatable :: workflows type( workflow ), allocatable :: w Derived Types type :: interval Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(2) :: v [start, end] of the interval type :: part Components Type Visibility Attributes Name Initial type( interval ), public, dimension(4) :: xmas type :: rule Components Type Visibility Attributes Name Initial logical, public :: accept = .false. logical, public :: reject = .false. integer, public :: operator = 0 integer, public :: operator_arg = 0 integer, public :: operator_val = 0 character(len=:), public, allocatable :: goto type :: workflow Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name type( rule ), public, dimension(:), allocatable :: rules Functions recursive function process (iworkflow, irule, p) result(iaccepted) process this part range starting with irule Arguments Type Intent Optional Attributes Name integer, intent(in) :: iworkflow integer, intent(in) :: irule type( part ), intent(in) :: p Return Value integer(kind=ip) function get_accepted (p) count of all the parts in the set Arguments Type Intent Optional Attributes Name type( part ), intent(in) :: p Return Value integer(kind=ip) function workflow_name_to_index (name) result(idx) get the index of this workflow in the array Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value integer function parse_rule (s) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value type( rule ) Source Code program problem_19b !! reformulated to operate on ranges of the x,m,a,s ratings use aoc_utilities use iso_fortran_env implicit none integer :: iunit , n_lines , iline , i character ( len = :), allocatable :: line !, name type ( string ), dimension (:), allocatable :: vals logical :: accepted integer ( ip ) :: total_accepted type :: interval integer ( ip ), dimension ( 2 ) :: v !! [start, end] of the interval end type interval type :: part type ( interval ), dimension ( 4 ) :: xmas ! [x,m,a,s] ranges end type part type ( part ) :: parts type :: rule logical :: accept = . false . logical :: reject = . false . integer :: operator = 0 ! 1:<, 2:> integer :: operator_arg = 0 ! 1:x, 2:m, 3:a, 4:s integer :: operator_val = 0 ! value to compare to character ( len = :), allocatable :: goto ! where to next (workflow name) end type rule type :: workflow character ( len = :), allocatable :: name type ( rule ), dimension (:), allocatable :: rules end type workflow type ( workflow ), dimension (:), allocatable :: workflows type ( workflow ), allocatable :: w call clk % tic () ! open(newunit=iunit, file='inputs/day19_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day19.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( workflows ( 0 )) do iline = 1 , n_lines line = read_line ( iunit ) if ( line == '' ) exit ! done - dont need the parts list for part b ! parsing workflows : qqz{s>2770:qs,m<1801:hdj,R} if ( allocated ( w )) deallocate ( w ); allocate ( w ) ! blank one vals = split ( line , '{' ) w % name = vals ( 1 )% str ! workflow name !write(*,*) '--->'//w%name//'<-----' vals ( 2 )% str = vals ( 2 )% str ( 1 : len ( vals ( 2 )% str ) - 1 ) ! remove last bracket vals = split ( vals ( 2 )% str , ',' ) ! workflow rules ! add each rule to the workflow allocate ( w % rules ( 0 )) do i = 1 , size ( vals ) w % rules = [ w % rules , parse_rule ( vals ( i )% str )] end do workflows = [ workflows , w ] end do parts = part ( xmas = [ interval ([ 1 , 4000 ]), & interval ([ 1 , 4000 ]), & interval ([ 1 , 4000 ]),& interval ([ 1 , 4000 ])]) i = workflow_name_to_index ( 'in' ) ! start at the first workflow total_accepted = process ( i , 1 , parts ) write ( * , * ) '19b: ' , total_accepted call clk % toc ( '19b' ) contains recursive function process ( iworkflow , irule , p ) result ( iaccepted ) !! process this part range starting with irule integer , intent ( in ) :: iworkflow integer , intent ( in ) :: irule type ( part ), intent ( in ) :: p integer ( ip ) :: iaccepted integer ( ip ), dimension (:), allocatable :: itmp , itmp_t , itmp_f integer ( ip ) :: i type ( part ) :: pt , pf iaccepted = 0 associate ( r => workflows ( iworkflow )% rules ( irule ) ) ! check if we are done if ( r % accept ) then iaccepted = get_accepted ( p ) return else if ( r % reject ) then iaccepted = 0 return end if ! process recursively, by splitting up the intervals when necessary if ( r % operator > 0 ) then ! process the operator select case ( r % operator ) case ( 1 ) ! < ! always create the two sets and process the two cases below ! [note that some sets maybe empty] ! ! example: ![1,200]   < 10   ==> [1,9]    TRUE !                     [10,200] FALSE itmp = [( i , i = p % xmas ( r % operator_arg )% v ( 1 ), p % xmas ( r % operator_arg )% v ( 2 ))] itmp_t = pack ( itmp , mask = itmp < r % operator_val ) !true itmp_f = pack ( itmp , mask = itmp >= r % operator_val ) !false if ( size ( itmp_t ) > 0 ) then ! some are true pt = p pt % xmas ( r % operator_arg )% v = [ itmp_t ( 1 ), itmp_t ( size ( itmp_t ))] if ( r % goto == 'A' ) then iaccepted = iaccepted + get_accepted ( pt ) else if ( r % goto /= 'R' ) then ! go to next workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , pt ) end if end if if ( size ( itmp_f ) > 0 ) then ! some are false pf = p pf % xmas ( r % operator_arg )% v = [ itmp_f ( 1 ), itmp_f ( size ( itmp_f ))] iaccepted = iaccepted + process ( iworkflow , irule + 1 , pf ) ! next rule end if case ( 2 ) ! > itmp = [( i , i = p % xmas ( r % operator_arg )% v ( 1 ), p % xmas ( r % operator_arg )% v ( 2 ))] itmp_t = pack ( itmp , mask = itmp > r % operator_val ) !true itmp_f = pack ( itmp , mask = itmp <= r % operator_val ) !false if ( size ( itmp_t ) > 0 ) then ! some are true pt = p pt % xmas ( r % operator_arg )% v = [ itmp_t ( 1 ), itmp_t ( size ( itmp_t ))] if ( r % goto == 'A' ) then iaccepted = iaccepted + get_accepted ( pt ) else if ( r % goto /= 'R' ) then ! go to next workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , pt ) end if end if if ( size ( itmp_f ) > 0 ) then ! some are false pf = p pf % xmas ( r % operator_arg )% v = [ itmp_f ( 1 ), itmp_f ( size ( itmp_f ))] iaccepted = iaccepted + process ( iworkflow , irule + 1 , pf ) ! next rule end if end select else ! goto another workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , p ) end if end associate !end do end function process integer ( ip ) function get_accepted ( p ) !! count of all the parts in the set type ( part ), intent ( in ) :: p get_accepted = ( 1 + ( p % xmas ( 1 )% v ( 2 ) - p % xmas ( 1 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 2 )% v ( 2 ) - p % xmas ( 2 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 3 )% v ( 2 ) - p % xmas ( 3 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 4 )% v ( 2 ) - p % xmas ( 4 )% v ( 1 ))) end function get_accepted function workflow_name_to_index ( name ) result ( idx ) !! get the index of this workflow in the array character ( len =* ), intent ( in ) :: name integer :: idx do idx = 1 , size ( workflows ) if ( name == workflows ( idx )% name ) return ! found it end do if ( idx > size ( workflows )) error stop 'workflow not found: ' // name end function workflow_name_to_index function parse_rule ( s ) result ( r ) character ( len =* ), intent ( in ) :: s type ( rule ) :: r type ( string ), dimension (:), allocatable :: v character ( len =* ), parameter :: xmas = 'xmas' ! 1,2,3,4 if ( s == 'A' ) then r % accept = . true . else if ( s == 'R' ) then r % reject = . true . else if ( index ( s , '>' ) > 0 ) then v = split ( s ( 3 :), ':' ) ! example: a<2006:qkq r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 2 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else if ( index ( s , '<' ) > 0 ) then v = split ( s ( 3 :), ':' ) r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 1 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else r % goto = s ! it's a workflow name end if end if end function parse_rule end program problem_19b","tags":"","loc":"program/problem_19b.html"},{"title":"test1 – AoC-2023","text":"Uses iso_fortran_env numdiff_kinds_module numerical_differentiation_module program~~test1~~UsesGraph program~test1 test1 iso_fortran_env iso_fortran_env program~test1->iso_fortran_env module~numdiff_kinds_module numdiff_kinds_module program~test1->module~numdiff_kinds_module module~numerical_differentiation_module numerical_differentiation_module program~test1->module~numerical_differentiation_module module~numdiff_kinds_module->iso_fortran_env module~numerical_differentiation_module->iso_fortran_env module~numerical_differentiation_module->module~numdiff_kinds_module module~diff_module diff_module module~numerical_differentiation_module->module~diff_module module~dsm_module dsm_module module~numerical_differentiation_module->module~dsm_module module~numdiff_cache_module numdiff_cache_module module~numerical_differentiation_module->module~numdiff_cache_module module~numdiff_utilities_module numdiff_utilities_module module~numerical_differentiation_module->module~numdiff_utilities_module module~diff_module->module~numdiff_kinds_module module~dsm_module->module~numdiff_kinds_module module~numdiff_cache_module->iso_fortran_env module~numdiff_cache_module->module~numdiff_kinds_module module~numdiff_cache_module->module~numdiff_utilities_module module~numdiff_utilities_module->module~numdiff_kinds_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Test1 for the numerical differentiation module. Calls program~~test1~~CallsGraph program~test1 test1 proc~compute_jacobian numerical_differentiation_module::numdiff_type%compute_jacobian program~test1->proc~compute_jacobian proc~destroy_numdiff_type numerical_differentiation_module::numdiff_type%destroy_numdiff_type program~test1->proc~destroy_numdiff_type proc~failed numerical_differentiation_module::numdiff_type%failed program~test1->proc~failed proc~get_all_methods_in_class numerical_differentiation_module::get_all_methods_in_class program~test1->proc~get_all_methods_in_class proc~get_error_status numerical_differentiation_module::numdiff_type%get_error_status program~test1->proc~get_error_status proc~get_finite_diff_formula numerical_differentiation_module::get_finite_diff_formula program~test1->proc~get_finite_diff_formula proc~get_formula numerical_differentiation_module::finite_diff_method%get_formula program~test1->proc~get_formula proc~initialize_numdiff numerical_differentiation_module::numdiff_type%initialize_numdiff program~test1->proc~initialize_numdiff proc~initialize_numdiff_for_diff numerical_differentiation_module::numdiff_type%initialize_numdiff_for_diff program~test1->proc~initialize_numdiff_for_diff proc~print_sparsity_matrix numerical_differentiation_module::numdiff_type%print_sparsity_matrix program~test1->proc~print_sparsity_matrix proc~print_sparsity_pattern numerical_differentiation_module::numdiff_type%print_sparsity_pattern program~test1->proc~print_sparsity_pattern proc~select_finite_diff_method numerical_differentiation_module::numdiff_type%select_finite_diff_method program~test1->proc~select_finite_diff_method proc~compute_perturbation_vector numerical_differentiation_module::numdiff_type%compute_perturbation_vector proc~compute_jacobian->proc~compute_perturbation_vector proc~raise_exception numerical_differentiation_module::numdiff_type%raise_exception proc~compute_jacobian->proc~raise_exception proc~get_finite_difference_method numerical_differentiation_module::get_finite_difference_method proc~get_all_methods_in_class->proc~get_finite_difference_method proc~get_finite_diff_formula->proc~get_formula proc~get_finite_diff_formula->proc~get_finite_difference_method proc~integer_to_string~2 numerical_differentiation_module::integer_to_string proc~get_formula->proc~integer_to_string~2 proc~initialize_numdiff->proc~get_all_methods_in_class proc~destroy_cache numdiff_cache_module::function_cache%destroy_cache proc~initialize_numdiff->proc~destroy_cache proc~initialize_numdiff->proc~get_finite_difference_method proc~initialize_cache numdiff_cache_module::function_cache%initialize_cache proc~initialize_numdiff->proc~initialize_cache proc~initialize_numdiff->proc~raise_exception proc~set_numdiff_bounds numerical_differentiation_module::numdiff_type%set_numdiff_bounds proc~initialize_numdiff->proc~set_numdiff_bounds proc~set_sparsity_mode numerical_differentiation_module::numdiff_type%set_sparsity_mode proc~initialize_numdiff->proc~set_sparsity_mode proc~initialize_numdiff_for_diff->proc~destroy_cache proc~initialize_numdiff_for_diff->proc~initialize_cache proc~initialize_numdiff_for_diff->proc~raise_exception proc~initialize_numdiff_for_diff->proc~set_numdiff_bounds proc~initialize_numdiff_for_diff->proc~set_sparsity_mode proc~compute_perturb_vector numerical_differentiation_module::numdiff_type%compute_perturb_vector proc~compute_perturbation_vector->proc~compute_perturb_vector proc~initialize_cache->proc~destroy_cache proc~set_numdiff_bounds->proc~integer_to_string~2 proc~set_numdiff_bounds->proc~raise_exception proc~set_sparsity_mode->proc~raise_exception proc~set_numdiff_sparsity_bounds numerical_differentiation_module::numdiff_type%set_numdiff_sparsity_bounds proc~set_sparsity_mode->proc~set_numdiff_sparsity_bounds proc~compute_perturb_vector->proc~raise_exception proc~set_numdiff_sparsity_bounds->proc~raise_exception Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: n = 10 integer, parameter :: m = 6 real(kind=wp), parameter,               dimension(n) :: x = 1.0_wp real(kind=wp), parameter,               dimension(n) :: xlow = -10.0_wp real(kind=wp), parameter,               dimension(n) :: xhigh = 10.0_wp real(kind=wp), parameter,               dimension(n) :: dpert = 1.0e-5_wp integer, parameter :: perturb_mode = 1 integer, parameter :: cache_size = 0 0 indicates not to use cache integer, parameter :: sparsity_mode = 4 type( numdiff_type ) :: my_prob integer :: i counter integer :: j counter real(kind=wp), dimension(:), allocatable :: jac character(len=:), allocatable :: formula type( finite_diff_method ) :: fd logical :: status_ok type( meth_array ) :: meths integer :: func_evals function evaluation counter integer, dimension(:), allocatable :: methods array of method IDs character(len=:), allocatable :: error_msg error message string Subroutines subroutine my_func (me, x, f, funcs_to_compute) Problem function Arguments Type Intent Optional Attributes Name class( numdiff_type ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out), dimension(:) :: f integer, intent(in), dimension(:) :: funcs_to_compute Source Code program test1 use iso_fortran_env , only : output_unit , error_unit use numerical_differentiation_module use numdiff_kinds_module , only : wp implicit none integer , parameter :: n = 10 integer , parameter :: m = 6 real ( wp ), dimension ( n ), parameter :: x = 1.0_wp real ( wp ), dimension ( n ), parameter :: xlow = - 1 0.0_wp real ( wp ), dimension ( n ), parameter :: xhigh = 1 0.0_wp real ( wp ), dimension ( n ), parameter :: dpert = 1.0e-5_wp integer , parameter :: perturb_mode = 1 integer , parameter :: cache_size = 0 !! `0` indicates not to use cache integer , parameter :: sparsity_mode = 4 type ( numdiff_type ) :: my_prob integer :: i !! counter integer :: j !! counter real ( wp ), dimension (:), allocatable :: jac character ( len = :), allocatable :: formula type ( finite_diff_method ) :: fd logical :: status_ok type ( meth_array ) :: meths integer :: func_evals !! function evaluation counter integer , dimension (:), allocatable :: methods !! array of method IDs character ( len = :), allocatable :: error_msg !! error message string methods = [( i , i = 1 , 44 )] methods = [ methods , 500 , 600 , 700 , 800 ] ! these only have central diffs do j = 1 , size ( methods ) ! try different finite diff methods i = methods ( j ) call get_finite_diff_formula ( i , formula ) if ( formula == '' ) then write ( output_unit , * ) 'id ' , i , 'not available' cycle end if func_evals = 0 call my_prob % destroy () call my_prob % initialize ( n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func = my_func ,& sparsity_mode = sparsity_mode ,& jacobian_method = i ,& partition_sparsity_pattern = . false .,& cache_size = cache_size ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if if ( i == 1 ) then write ( output_unit , '(A)' ) '' call my_prob % print_sparsity_pattern ( output_unit ) write ( output_unit , '(A)' ) '' call my_prob % print_sparsity_matrix ( output_unit ) write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '--------------------------------------' write ( output_unit , '(A,I4)' ) ' specify method [no partitioning] : ' , i write ( output_unit , '(A)' ) '--------------------------------------' write ( output_unit , '(A)' ) '' end if write ( output_unit , '(A)' ) formula write ( output_unit , '(A)' ) '' write ( output_unit , '(A,1X,*(F27.16,\",\"))' ) 'jac =' , jac write ( output_unit , '(A,1X,I5)' ) 'function evaluations:' , func_evals write ( output_unit , '(A)' ) '' end do do j = 1 , size ( methods ) ! try different finite diff methods i = methods ( j ) call get_finite_diff_formula ( i , formula ) if ( formula == '' ) then write ( output_unit , * ) 'id ' , i , 'not available' cycle end if func_evals = 0 call my_prob % destroy () call my_prob % initialize ( n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func = my_func ,& sparsity_mode = sparsity_mode ,& jacobian_method = i ,& partition_sparsity_pattern = . true .,& cache_size = 1000 ) ! use the cache for these cases if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if if ( i == 1 ) then write ( output_unit , '(A)' ) '' call my_prob % print_sparsity_pattern ( output_unit ) write ( output_unit , '(A)' ) '' call my_prob % print_sparsity_matrix ( output_unit ) write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '--------------------------------------' write ( output_unit , '(A,I4)' ) ' specify method [with partitioning] : ' , i write ( output_unit , '(A)' ) '--------------------------------------' write ( output_unit , '(A)' ) '' end if write ( output_unit , '(A)' ) formula write ( output_unit , '(A)' ) '' write ( output_unit , '(A,1X,*(F27.16,\",\"))' ) 'jac =' , jac write ( output_unit , '(A,1X,I5)' ) 'function evaluations:' , func_evals write ( output_unit , '(A)' ) '' end do meths = get_all_methods_in_class ( 3 ) write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) 'select_finite_diff_method' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) '' call my_prob % select_finite_diff_method ( 0.0_wp , 0.0_wp , 1.0_wp , 0.001_wp , meths , fd , status_ok ) call fd % get_formula ( formula ) write ( output_unit , '(A)' ) formula write ( output_unit , '(A)' ) '' call my_prob % select_finite_diff_method ( 0.9999_wp , 0.0_wp , 1.0_wp , 0.001_wp , meths , fd , status_ok ) call fd % get_formula ( formula ) write ( output_unit , '(A)' ) formula write ( output_unit , '(A)' ) '' do i = 2 , 9 write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A,I2)' ) ' specify class [no partitioning] : ' , i write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) '' func_evals = 0 call my_prob % destroy () call my_prob % initialize ( n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func = my_func ,& sparsity_mode = sparsity_mode ,& class = i ,& cache_size = cache_size ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if write ( output_unit , '(A,1X,*(F27.16,\",\"))' ) 'jac =' , jac write ( output_unit , '(A,1X,I5)' ) 'function evaluations:' , func_evals write ( output_unit , '(A)' ) '' end do do i = 2 , 9 write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A,I2)' ) ' specify class [with partitioning] : ' , i write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) '' func_evals = 0 call my_prob % destroy () call my_prob % initialize ( n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func = my_func ,& sparsity_mode = sparsity_mode ,& class = i , partition_sparsity_pattern = . true .,& cache_size = cache_size ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if write ( output_unit , '(A,1X,*(F27.16,\",\"))' ) 'jac =' , jac write ( output_unit , '(A,1X,I5)' ) 'function evaluations:' , func_evals write ( output_unit , '(A)' ) '' end do write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) ' diff algorithm' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) '' func_evals = 0 call my_prob % diff_initialize ( n , m , xlow , xhigh , my_func , sparsity_mode = 1 ,& ! use a dense method for this one cache_size = cache_size ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if write ( output_unit , '(A,1X,*(F27.16,\",\"))' ) 'jac =' , jac write ( output_unit , '(A,1X,I5)' ) 'function evaluations:' , func_evals write ( output_unit , '(A)' ) '' contains subroutine my_func ( me , x , f , funcs_to_compute ) !! Problem function implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f integer , dimension (:), intent ( in ) :: funcs_to_compute if ( any ( funcs_to_compute == 1 )) f ( 1 ) = x ( 1 ) * x ( 2 ) - x ( 3 ) ** 3 if ( any ( funcs_to_compute == 2 )) f ( 2 ) = x ( 3 ) - 1.0_wp if ( any ( funcs_to_compute == 3 )) f ( 3 ) = x ( 4 ) * x ( 5 ) if ( any ( funcs_to_compute == 4 )) f ( 4 ) = 2.0_wp * x ( 6 ) + sin ( x ( 7 )) if ( any ( funcs_to_compute == 5 )) f ( 5 ) = cos ( x ( 8 )) + sqrt ( abs ( x ( 9 ))) if ( any ( funcs_to_compute == 6 )) f ( 6 ) = 1.0_wp / ( 1.0_wp + exp ( x ( 10 ))) func_evals = func_evals + 1 end subroutine my_func !******************************************************************************* end program test1","tags":"","loc":"program/test1.html"},{"title":"problem_9 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_9~~UsesGraph program~problem_9 problem_9 iso_fortran_env iso_fortran_env program~problem_9->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_9->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_9~~CallsGraph program~problem_9 problem_9 interface~parse aoc_utilities::parse program~problem_9->interface~parse proc~clock_end aoc_utilities::clock%clock_end program~problem_9->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_9->proc~clock_start proc~extrapolate problem_9::extrapolate program~problem_9->proc~extrapolate proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_9->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_9->proc~read_line proc~reverse aoc_utilities::reverse program~problem_9->proc~reverse proc~parse_nums64 aoc_utilities::parse_nums64 interface~parse->proc~parse_nums64 proc~diff aoc_utilities::diff proc~extrapolate->proc~diff interface~split aoc_utilities::split proc~parse_nums64->interface~split proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: iunit integer :: n_lines integer(kind=ip) :: isum Functions pure function extrapolate (ivals) result(iextrap) extrapolate the next value in the sequence using\na difference table. Straightfoward implemention:\ncreate the full table, and then evaluate it. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals Return Value integer(kind=ip) Source Code program problem_9 use iso_fortran_env use aoc_utilities implicit none integer :: i , iunit , n_lines integer ( ip ) :: isum call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day9_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day9.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = sum ([( extrapolate ( parse ( read_line ( iunit ))), i = 1 , n_lines )]) close ( iunit ) write ( * , * ) '9a: sum: ' , isum open ( newunit = iunit , file = 'inputs/day9.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = sum ([( extrapolate ( reverse ( parse ( read_line ( iunit )))), i = 1 , n_lines )]) close ( iunit ) write ( * , * ) '9b: sum: ' , isum call clk % toc ( '9' ) contains pure function extrapolate ( ivals ) result ( iextrap ) !! extrapolate the next value in the sequence using !! a difference table. Straightfoward implemention: !! create the full table, and then evaluate it. integer ( ip ), dimension (:), intent ( in ) :: ivals integer ( ip ) :: iextrap integer :: i , n type ( int64_vec ), dimension (:), allocatable :: diff_table !! difference table (vector of vectors) ! create the difference table: diff_table = [ int64_vec ( ivals )]; n = 1 do n = n + 1 diff_table = [ diff_table , int64_vec ( diff ( diff_table ( n - 1 )% vals ))] ! next line is diff of previous line if ( all ( diff_table ( n )% vals == 0 )) exit end do ! extrapolate iextrap = 0 do i = n - 1 , 1 , - 1 associate ( ilast => diff_table ( i )% vals ( size ( diff_table ( i )% vals )) ) iextrap = iextrap + ilast end associate end do end function extrapolate end program problem_9","tags":"","loc":"program/problem_9.html"},{"title":"dsm_test – AoC-2023","text":"Uses dsm_module iso_fortran_env numdiff_kinds_module program~~dsm_test~~UsesGraph program~dsm_test dsm_test iso_fortran_env iso_fortran_env program~dsm_test->iso_fortran_env module~dsm_module dsm_module program~dsm_test->module~dsm_module module~numdiff_kinds_module numdiff_kinds_module program~dsm_test->module~numdiff_kinds_module module~dsm_module->module~numdiff_kinds_module module~numdiff_kinds_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. This is a test program for subroutines dsm and fdjs .\n the test data represents a neutron kinetics problem. Reference Argonne National Laboratory. MINPACK Project. July 1983.\n    Thomas F. Coleman, Burton S. Garbow, Jorge J. More Thomas F. Coleman, Burton S. Garbow, Jorge J. More, \"Algorithm 618:\n    FORTRAN subroutines for estimating sparse Jacobian Matrices\",\n    ACM Transactions on Mathematical Software (TOMS),\n    Volume 10 Issue 3, Sept. 1984, Pages 346-347 Calls program~~dsm_test~~CallsGraph program~dsm_test dsm_test proc~dsm dsm_module::dsm program~dsm_test->proc~dsm proc~fcn dsm_test::fcn program~dsm_test->proc~fcn proc~fdjs dsm_module::fdjs program~dsm_test->proc~fdjs proc~degr dsm_module::degr proc~dsm->proc~degr proc~ido dsm_module::ido proc~dsm->proc~ido proc~numsrt dsm_module::numsrt proc~dsm->proc~numsrt proc~seq dsm_module::seq proc~dsm->proc~seq proc~setr dsm_module::setr proc~dsm->proc~setr proc~slo dsm_module::slo proc~dsm->proc~slo proc~srtdat dsm_module::srtdat proc~dsm->proc~srtdat proc~ido->proc~numsrt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: nwrite = output_unit unit for printing integer :: i integer :: info integer :: ip integer :: j integer :: jp integer :: l integer :: m integer :: maxgrp integer :: maxrow integer :: mingrp integer :: minrow integer :: n integer :: nnz integer :: numgrp integer :: indcol (6000) integer :: indrow (6000) integer :: ipntr (1201) integer :: jpntr (1201) integer :: ngrp (1200) logical :: col real(kind=wp) :: dnsm real(kind=wp) :: errij real(kind=wp) :: errmax real(kind=wp) :: fjact real(kind=wp) :: fjactr real(kind=wp) :: sum real(kind=wp) :: d (1200) real(kind=wp) :: fjac (6000) real(kind=wp) :: fjacd (1200) real(kind=wp) :: fvec (1200) real(kind=wp) :: x (1200) real(kind=wp) :: xd (1200) Subroutines subroutine fcn (n, x, Indcol, Ipntr, Fvec) Function subroutine for testing fdjs . Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: x (n) integer :: Indcol (*) integer :: Ipntr (n+1) real(kind=wp) :: Fvec (n) Source Code program dsm_test !! This is a test program for subroutines [[dsm]] and [[fdjs]]. !! the test data represents a neutron kinetics problem. !! !!### Reference !!  * Argonne National Laboratory. MINPACK Project. July 1983. !!    Thomas F. Coleman, Burton S. Garbow, Jorge J. More !!  * Thomas F. Coleman, Burton S. Garbow, Jorge J. More, \"Algorithm 618: !!    FORTRAN subroutines for estimating sparse Jacobian Matrices\", !!    ACM Transactions on Mathematical Software (TOMS), !!    Volume 10 Issue 3, Sept. 1984, Pages 346-347 use dsm_module use iso_fortran_env , only : output_unit use numdiff_kinds_module , only : wp implicit none integer , parameter :: nwrite = output_unit !! unit for printing integer i , info , ip , j , jp , l , m , maxgrp , maxrow , & mingrp , minrow , n , nnz , numgrp integer indcol ( 6000 ) , indrow ( 6000 ) , ipntr ( 1201 ) , jpntr ( 1201 ) , & ngrp ( 1200 ) logical col real ( wp ) :: dnsm , errij , errmax , fjact , fjactr , sum real ( wp ) :: d ( 1200 ) , fjac ( 6000 ) , fjacd ( 1200 ) , fvec ( 1200 ) , x ( 1200 ) , & xd ( 1200 ) col = . true . ! !     TEST FOR DSM AND FDJS. ! write ( nwrite , 99001 ) ! !     FORMAT STATEMENTS. ! 99001 format ( // ' TESTS FOR DSM AND FDJS - NEUTRON KINETICS PROBLEM' // & & ' STATISTICS GENERATED ' // '       N - NUMBER OF COLUMNS ' / & & '     NNZ - NUMBER OF NON-ZERO ELEMENTS' / & & '    DNSM - MATRIX DENSITY (PERCENTAGE)' / & & '  MINROW - MINIMUM NUMBER OF NON-ZEROS IN ANY ROW' / & & '  MAXROW - MAXIMUM NUMBER OF NON-ZEROS IN ANY ROW' / & & '  MINGRP - LOWER BOUND ON NUMBER OF GROUPS' / & & '  MAXGRP - NUMBER OF GROUPS DETERMINED BY DSM' // ) do n = 300 , 1200 , 300 write ( nwrite , 99002 ) 99002 format ( // 3 x , 'N' , 6 x , 'NNZ' , 5 x , 'DNSM' , 5 x , 'MINROW' , 4 x , 'MAXROW' , 4 x ,& & 'MINGRP' , 4 x , 'MAXGRP' // ) ! !        DEFINITION OF SPARSITY PATTERN. ! m = n l = n / 3 nnz = 0 do j = 1 , n nnz = nnz + 1 indrow ( nnz ) = j indcol ( nnz ) = j if ( mod ( j , l ) /= 0 ) then nnz = nnz + 1 indrow ( nnz ) = j + 1 indcol ( nnz ) = j endif if ( j <= 2 * l ) then nnz = nnz + 1 indrow ( nnz ) = j + l indcol ( nnz ) = j if ( mod ( j , l ) /= 1 ) then nnz = nnz + 1 indrow ( nnz ) = j - 1 indcol ( nnz ) = j endif endif nnz = nnz + 1 if ( j > l ) then indrow ( nnz ) = j - l else indrow ( nnz ) = j + 2 * l endif indcol ( nnz ) = j enddo ! !        CALL DSM. ! call dsm ( m , n , nnz , indrow , indcol , ngrp , maxgrp , mingrp , info , ipntr , jpntr ) if ( info <= 0 ) write ( nwrite , 99003 ) info 99003 format ( // ' *** MISTAKE IN INPUT DATA, INFO IS ***' , i6 ) ! !        STATISTICS FOR THE MATRIX. ! maxrow = 0 minrow = n do i = 1 , m maxrow = max ( maxrow , ipntr ( i + 1 ) - ipntr ( i )) minrow = min ( minrow , ipntr ( i + 1 ) - ipntr ( i )) enddo dnsm = real ( 100 * nnz , wp ) / real ( m * n , wp ) write ( nwrite , 99004 ) n , nnz , dnsm , minrow , maxrow , & & mingrp , maxgrp 99004 format ( 2 ( i5 , 3 x ), f6 . 2 , 4 x , 4 ( i5 , 5 x )) ! !        TEST FOR FDJS. ! do j = 1 , n x ( j ) = real ( j , wp ) / real ( n , wp ) enddo call fcn ( n , x , indcol , ipntr , fvec ) ! !        APPROXIMATE THE JACOBIAN MATRIX. ! do numgrp = 1 , maxgrp do j = 1 , n d ( j ) = 0.0_wp if ( ngrp ( j ) == numgrp ) d ( j ) = 1.0e-6_wp !d(j) = 0.001_wp xd ( j ) = x ( j ) + d ( j ) enddo call fcn ( n , xd , indcol , ipntr , fjacd ) do i = 1 , m fjacd ( i ) = fjacd ( i ) - fvec ( i ) enddo if ( col ) then call fdjs ( m , n , col , indrow , jpntr , ngrp , numgrp , d , fjacd , fjac ) else call fdjs ( m , n , col , indcol , ipntr , ngrp , numgrp , d , fjacd , fjac ) endif enddo ! !        TEST THE APPROXIMATION TO THE JACOBIAN. ! errmax = 0.0_wp if ( col ) then ! !           TEST FOR THE COLUMN-ORIENTED DEFINITION OF !           THE SPARSITY PATTERN. ! do j = 1 , n do jp = jpntr ( j ) , jpntr ( j + 1 ) - 1 i = indrow ( jp ) sum = 0.0_wp do ip = ipntr ( i ) , ipntr ( i + 1 ) - 1 sum = sum + x ( indcol ( ip )) enddo sum = sum + x ( i ) fjact = 1.0_wp + 2.0_wp * sum if ( i == j ) fjact = 2.0_wp * fjact errij = fjac ( jp ) - fjact if ( fjact /= 0.0_wp ) errij = errij / fjact errmax = max ( errmax , abs ( errij )) enddo enddo else ! !           TEST FOR THE ROW-ORIENTED DEFINITION OF !           THE SPARSITY PATTERN. ! do i = 1 , m sum = 0.0_wp do ip = ipntr ( i ) , ipntr ( i + 1 ) - 1 sum = sum + x ( indcol ( ip )) enddo sum = sum + x ( i ) fjactr = 1.0_wp + 2.0_wp * sum do ip = ipntr ( i ) , ipntr ( i + 1 ) - 1 j = indcol ( ip ) fjact = fjactr if ( i == j ) fjact = 2.0_wp * fjact errij = fjac ( ip ) - fjact if ( fjact /= 0.0_wp ) errij = errij / fjact errmax = max ( errmax , abs ( errij )) enddo enddo endif write ( nwrite , 99005 ) errmax 99005 format ( // ' LARGEST RELATIVE ERROR OF APPROXIMATION IS' , e10 . 2 ) col = . not . col enddo stop contains subroutine fcn ( n , x , Indcol , Ipntr , Fvec ) !! Function subroutine for testing [[fdjs]]. implicit none integer n integer Indcol ( * ) , Ipntr ( n + 1 ) real ( wp ) :: x ( n ) , Fvec ( n ) integer i , ip real ( wp ) :: sum do i = 1 , n sum = 0.0_wp do ip = Ipntr ( i ) , Ipntr ( i + 1 ) - 1 sum = sum + x ( Indcol ( ip )) enddo sum = sum + x ( i ) Fvec ( i ) = sum * ( 1.0_wp + sum ) + 1.0_wp enddo end subroutine fcn end program dsm_test","tags":"","loc":"program/dsm_test.html"},{"title":"problem_15 – AoC-2023","text":"Uses problem_15_module iso_fortran_env aoc_utilities program~~problem_15~~UsesGraph program~problem_15 problem_15 iso_fortran_env iso_fortran_env program~problem_15->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_15->module~aoc_utilities module~problem_15_module problem_15_module program~problem_15->module~problem_15_module module~aoc_utilities->iso_fortran_env module~problem_15_module->iso_fortran_env module~problem_15_module->module~aoc_utilities Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_15~~CallsGraph program~problem_15 problem_15 interface~split aoc_utilities::split program~problem_15->interface~split proc~add_lens problem_15_module::box%add_lens program~problem_15->proc~add_lens proc~clock_end aoc_utilities::clock%clock_end program~problem_15->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_15->proc~clock_start proc~hash problem_15::hash program~problem_15->proc~hash proc~read_line aoc_utilities::read_line program~problem_15->proc~read_line proc~remove_lens problem_15_module::box%remove_lens program~problem_15->proc~remove_lens proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: iunit integer :: j type( string ), dimension(:), allocatable :: vals type( string ), dimension(:), allocatable :: vals2 integer(kind=ip), dimension(:), allocatable :: ivals type( box ), dimension(0:255) :: boxes integer(kind=ip) :: ibox character(len=:), allocatable :: label integer(kind=ip) :: ival integer(kind=ip) :: focusing_power integer(kind=ip) :: lens_focusing_power Functions pure elemental function hash (s) Determine the ASCII code for the current character of the string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value integer(kind=ip) Source Code program problem_15 use iso_fortran_env use aoc_utilities use problem_15_module implicit none integer :: i , iunit , j type ( string ), dimension (:), allocatable :: vals , vals2 integer ( ip ), dimension (:), allocatable :: ivals type ( box ), dimension ( 0 : 255 ) :: boxes ! for part 2 integer ( ip ) :: ibox ! 0-255 character ( len = :), allocatable :: label integer ( ip ) :: ival , focusing_power , lens_focusing_power call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day15_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day15.txt' , status = 'OLD' ) vals = split ( read_line ( iunit ), ',' ) close ( iunit ) allocate ( ivals ( size ( vals ))) do i = 1 , size ( vals ) ! part 1: ivals ( i ) = hash ( vals ( i )% str ) ! part 2: if ( index ( vals ( i )% str , '=' ) > 0 ) then vals2 = split ( vals ( i )% str , '=' ) label = vals2 ( 1 )% str ibox = hash ( label ) ival = int ( vals2 ( 2 )% str ) ! focal length call boxes ( ibox )% add_lens ( lens ( label , ival )) else if ( index ( vals ( i )% str , '-' ) > 0 ) then vals2 = split ( vals ( i )% str , '-' ) label = vals2 ( 1 )% str ibox = hash ( label ) call boxes ( ibox )% remove_lens ( label ) end if end do write ( * , * ) '15a: ' , sum ( ivals ) focusing_power = 0 do i = 0 , 255 ! all the boxes if ( allocated ( boxes ( i )% lenses )) then do j = 1 , size ( boxes ( i )% lenses ) ! all the lenses in the box lens_focusing_power = ( i + 1 ) * ( j ) * ( boxes ( i )% lenses ( j )% focal_length ) focusing_power = focusing_power + lens_focusing_power end do end if end do write ( * , * ) '15b: ' , focusing_power call clk % toc ( '15' ) contains pure elemental integer ( ip ) function hash ( s ) !! Determine the ASCII code for the current character of the string. character ( len =* ), intent ( in ) :: s integer :: i hash = 0 do i = 1 , len ( s ) hash = modulo ( 17_ip * ( hash + iachar ( s ( i : i ))), 256_ip ) end do end function hash end program problem_15","tags":"","loc":"program/problem_15.html"},{"title":"problem_8 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_8~~UsesGraph program~problem_8 problem_8 iso_fortran_env iso_fortran_env program~problem_8->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_8->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_8~~CallsGraph program~problem_8 problem_8 proc~clock_end aoc_utilities::clock%clock_end program~problem_8->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_8->proc~clock_start proc~find_node problem_8::find_node program~problem_8->proc~find_node proc~lcm aoc_utilities::lcm program~problem_8->proc~lcm proc~moves problem_8::moves program~problem_8->proc~moves proc~moves_any_z problem_8::moves_any_z program~problem_8->proc~moves_any_z proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_8->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line program~problem_8->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit integer :: n_lines character(len=:), allocatable :: line character(len=:), allocatable :: instructions type( string ), dimension(:), allocatable :: vals integer(kind=ip) :: i integer(kind=ip) :: j integer(kind=ip) :: idx integer(kind=ip) :: idx_zzz integer(kind=ip) :: imoves integer(kind=ip) :: ias integer(kind=ip) :: izs integer(kind=ip), dimension(:), allocatable :: instructions_ints integer(kind=ip), dimension(:), allocatable :: idx_vec integer(kind=ip), dimension(:), allocatable :: idx_zzz_vec integer(kind=ip), dimension(:), allocatable :: imoves_vec type( node ), dimension(:), allocatable :: nodes Derived Types type :: node Components Type Visibility Attributes Name Initial character(len=3), public :: name = '' character(len=3), public, dimension(2) :: lr integer, public, dimension(2) :: lr_idx Functions pure function moves (istart, iend) result(imoves) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: istart indices for start and end nodes integer(kind=ip), intent(in) :: iend indices for start and end nodes Return Value integer(kind=ip) pure function moves_any_z (istart, iend) result(imoves) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: istart indices for start and end nodes integer(kind=ip), intent(in), dimension(:) :: iend Return Value integer(kind=ip) pure function all_in_set (ivals, iset) returns true if all the elements of ivals are in the set iset Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ivals integer(kind=ip), intent(in), dimension(:) :: iset Return Value logical pure function find_node (name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value integer(kind=ip) Source Code program problem_8 use iso_fortran_env use aoc_utilities implicit none integer :: iunit , n_lines character ( len = :), allocatable :: line , instructions type ( string ), dimension (:), allocatable :: vals integer ( ip ) :: i , j , idx , idx_zzz , imoves , ias , izs integer ( ip ), dimension (:), allocatable :: instructions_ints integer ( ip ), dimension (:), allocatable :: idx_vec , idx_zzz_vec integer ( ip ), dimension (:), allocatable :: imoves_vec type :: node character ( len = 3 ) :: name = '' character ( len = 3 ), dimension ( 2 ) :: lr integer , dimension ( 2 ) :: lr_idx ! the indices in the nodes array of the l,r nodes end type node type ( node ), dimension (:), allocatable :: nodes call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day8_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day8.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( nodes ( n_lines - 2 )) instructions = read_line ( iunit ) allocate ( instructions_ints ( len ( instructions ))) do i = 1 , len ( instructions ) select case ( instructions ( i : i )) ! make an int array for easier access case ( 'L' ); instructions_ints ( i ) = 1 case ( 'R' ); instructions_ints ( i ) = 2 end select end do do i = 0 , n_lines - 1 line = read_line ( iunit ) if ( line == '' ) cycle read ( line , \"(A3,1X,1X,1X,1X,A3,1X,1X,A3,1X)\" ) nodes ( i )% name , nodes ( i )% lr ( 1 ), nodes ( i )% lr ( 2 ) end do close ( iunit ) ! compute all the lr indices: do i = 1 , size ( nodes ) nodes ( i )% lr_idx ( 1 ) = find_node ( nodes ( i )% lr ( 1 )) nodes ( i )% lr_idx ( 2 ) = find_node ( nodes ( i )% lr ( 2 )) end do !******************************************** imoves = moves ( find_node ( 'AAA' ), find_node ( 'ZZZ' )) write ( * , * ) '8a : number of moves:' , imoves !******************************************** ! get indices of the ones that end in A and Z: allocate ( idx_vec ( 0 ), idx_zzz_vec ( 0 )) do i = 1 , size ( nodes ) if ( nodes ( i )% name ( 3 : 3 ) == 'A' ) idx_vec = [ idx_vec , i ] if ( nodes ( i )% name ( 3 : 3 ) == 'Z' ) idx_zzz_vec = [ idx_zzz_vec , i ] end do if ( size ( idx_vec ) /= size ( idx_zzz_vec )) error stop 'error: they need to be the same size?' allocate ( imoves_vec ( size ( idx_vec ))) ! for EACH start, find the number of moves that it takes to get to ONE of the ends. do i = 1 , size ( idx_vec ) imoves_vec ( i ) = moves_any_z ( idx_vec ( i ), idx_zzz_vec ) end do ! don't know why this works ¯\\_(ツ)_/¯ ! I think it's a feature of the specific data given ! (it's a repeating cycle once it gets to the end) write ( * , * ) '8b : number of moves: ' , lcm ( lcm ( lcm ( lcm ( lcm ( imoves_vec ( 1 ),& imoves_vec ( 2 )),& imoves_vec ( 3 )),& imoves_vec ( 4 )),& imoves_vec ( 5 )),& imoves_vec ( 6 )) ! ! ! ! brute force. run all the moves in parallel until they are all done. ! ! ! i = 0 ! imoves = 0 ! do !     if (all_in_set(idx_vec, idx_zzz_vec)) exit !     imoves = imoves + 1 ! another move !     i = i + 1 !     if (i>len(instructions)) i = 1 !     do concurrent (j = 1 : size(idx_vec)) !         idx_vec(j) = nodes(idx_vec(j))%lr_idx(instructions_ints(i)) !     end do ! end do ! write(*,*) '8b : number of moves:', imoves call clk % toc ( '8' ) contains pure function moves ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart , iend !! indices for start and end nodes integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( idx == iend ) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves pure function moves_any_z ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart !! indices for start and end nodes integer ( ip ), dimension (:), intent ( in ) :: iend integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( any ( idx == iend )) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves_any_z pure logical function all_in_set ( ivals , iset ) !! returns true if all the elements of ivals are in the set iset integer ( ip ), dimension (:), intent ( in ) :: ivals , iset integer :: i all_in_set = . true . do i = 1 , size ( ivals ) if (. not . any ( ivals ( i ) == iset )) then all_in_set = . false . exit end if end do end function all_in_set pure integer ( ip ) function find_node ( name ) character ( len =* ), intent ( in ) :: name integer ( ip ) :: i do i = 1 , size ( nodes ) if ( name == nodes ( i )% name ) then find_node = i return end if end do error stop 'could not find node' end function find_node end program problem_8","tags":"","loc":"program/problem_8.html"},{"title":"test – AoC-2023","text":"Uses fmin_module program~~test~~UsesGraph program~test test module~fmin_module fmin_module program~test->module~fmin_module iso_fortran_env iso_fortran_env module~fmin_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Tests for fmin_module . Calls program~~test~~CallsGraph program~test test proc~fmin fmin_module::fmin program~test->proc~fmin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial real(kind=wp) :: ax real(kind=wp) :: bx real(kind=wp) :: xmin real(kind=wp) :: xerr real(kind=wp) :: x real(kind=wp), parameter :: pi = acos(-1.0_wp) real(kind=wp), parameter :: tol = 1.0e-8_wp Functions function func (x) result(f) Test function to minimize. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x indep. variable Return Value real(kind=wp) function value f(x) Source Code program test use fmin_module , wp => fmin_rk real ( wp ) :: ax , bx , xmin , xerr , x real ( wp ), parameter :: pi = acos ( - 1.0_wp ) real ( wp ), parameter :: tol = 1.0e-8_wp ax = - 4.0_wp bx = 0.0_wp x = - pi / 2.0_wp ! actual answer xmin = fmin ( func , ax , bx , tol ) xerr = xmin - x ! difference from try value write ( * , * ) 'xmin       = ' , xmin write ( * , * ) 'xmin exact = ' , x write ( * , * ) 'xmin error = ' , xerr if ( abs ( xerr ) > 1 0.0_wp * tol ) then error stop 'test failed' end if contains !***************************************************************************************** !***************************************************************************************** !> !  Test function to minimize. function func ( x ) result ( f ) implicit none real ( wp ), intent ( in ) :: x !! indep. variable real ( wp ) :: f !! function value `f(x)` f = sin ( x ) end function func !***************************************************************************************** !***************************************************************************************** end program test","tags":"","loc":"program/test.html"},{"title":"problem_18 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_18~~UsesGraph program~problem_18 problem_18 iso_fortran_env iso_fortran_env program~problem_18->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_18->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_18~~CallsGraph program~problem_18 problem_18 proc~clock_end aoc_utilities::clock%clock_end program~problem_18->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_18->proc~clock_start proc~go~3 problem_18::go program~problem_18->proc~go~3 interface~split aoc_utilities::split proc~go~3->interface~split proc~destination problem_18::destination proc~go~3->proc~destination proc~hex2int aoc_utilities::hex2int proc~go~3->proc~hex2int proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~go~3->proc~number_of_lines_in_file proc~parea aoc_utilities::parea proc~go~3->proc~parea proc~read_line aoc_utilities::read_line proc~go~3->proc~read_line proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer(kind=ip) :: iresult Functions pure function destination (initial, direction, steps) result(final) get destination point Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(2) :: initial character(len=1), intent(in) :: direction integer(kind=ip), intent(in) :: steps Return Value integer(kind=ip), dimension(2) x,y of desination point Subroutines subroutine go (partb, iresult) Arguments Type Intent Optional Attributes Name logical, intent(in) :: partb if solving part b integer(kind=ip), intent(out) :: iresult Source Code program problem_18 use aoc_utilities use iso_fortran_env implicit none integer ( ip ) :: iresult call clk % tic () call go (. false ., iresult ); write ( * , * ) '18a:' , iresult call go (. true ., iresult ); write ( * , * ) '18b:' , iresult call clk % toc ( '18' ) contains subroutine go ( partb , iresult ) logical , intent ( in ) :: partb !! if solving part b integer ( ip ), intent ( out ) :: iresult integer :: iunit , iline , n_lines , n character ( len = :), allocatable :: line , hex type ( string ), dimension (:), allocatable :: vals character ( len = 1 ) :: direction integer ( ip ), dimension ( 2 ) :: iloc , iloc2 integer ( ip ) :: ival , isteps real ( wp ), dimension (:), allocatable :: xvec , yvec character ( len = 1 ), dimension ( 0 : 3 ) :: direction_str = [ 'R' , 'D' , 'L' , 'U' ] ! directions for part b : 0,1,2,3 ! open(newunit=iunit, file='inputs/day18_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day18.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) iloc = [ 0 , 0 ] ! where to start isteps = 0 xvec = [ 0 ]; yvec = [ 0 ] do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ! direction, number, (hex) if ( partb ) then ! values encoded in hex hex = vals ( 3 )% str ival = hex2int ( hex ( 3 : 7 )) direction = direction_str ( int ( hex ( 8 : 8 ))) else direction = vals ( 1 )% str ival = int ( vals ( 2 )% str ) end if isteps = isteps + ival ! keep track of the total perimeter size iloc2 = destination ( iloc , direction , ival ) ! destination oint xvec = [ xvec , real ( iloc2 ( 1 ), wp )] ! save the points of the polygon yvec = [ yvec , real ( iloc2 ( 2 ), wp )] ! iloc = iloc2 ! update for next move end do close ( iunit ) ! the area including the boundary = area + 1/2 the perimeter + 1 ! using NSWC parea function! n = size ( xvec ) iresult = int ( abs ( parea ( yvec , xvec , n )) + real ( isteps , wp ) / 2_ip + 1_ip , ip ) end subroutine go pure function destination ( initial , direction , steps ) result ( final ) !! get destination point integer ( ip ), dimension ( 2 ), intent ( in ) :: initial character ( len = 1 ), intent ( in ) :: direction integer ( ip ), intent ( in ) :: steps integer ( ip ), dimension ( 2 ) :: final !! x,y of desination point select case ( direction ) case ( 'R' ); final = [ initial ( 1 ), initial ( 2 ) + steps ] case ( 'L' ); final = [ initial ( 1 ), initial ( 2 ) - steps ] case ( 'D' ); final = [ initial ( 1 ) + steps , initial ( 2 )] case ( 'U' ); final = [ initial ( 1 ) - steps , initial ( 2 )] end select end function destination end program problem_18","tags":"","loc":"program/problem_18.html"},{"title":"problem_23 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_23~~UsesGraph program~problem_23 problem_23 iso_fortran_env iso_fortran_env program~problem_23->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_23->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. alternate one... collapse the maze into a graph Calls program~~problem_23~~CallsGraph program~problem_23 problem_23 proc~clock_end aoc_utilities::clock%clock_end program~problem_23->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_23->proc~clock_start proc~go~4 problem_23::go program~problem_23->proc~go~4 proc~build_graph problem_23::build_graph proc~go~4->proc~build_graph proc~count_adjacent problem_23::count_adjacent proc~go~4->proc~count_adjacent proc~dijkstra problem_23::dijkstra proc~go~4->proc~dijkstra proc~read_file_to_char_array aoc_utilities::read_file_to_char_array proc~go~4->proc~read_file_to_char_array proc~traverse~2 problem_23::traverse proc~go~4->proc~traverse~2 proc~build_graph->proc~build_graph proc~add_edge~2 problem_23::add_edge proc~build_graph->proc~add_edge~2 proc~get_cell problem_23::get_cell proc~build_graph->proc~get_cell proc~node_number problem_23::node_number proc~build_graph->proc~node_number proc~not_tree problem_23::not_tree proc~count_adjacent->proc~not_tree proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line proc~traverse~2->proc~traverse~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( node ), dimension(:), allocatable :: nodes the list of nodes logical :: slopes a=true, b=false logical, dimension(:,:), allocatable :: visited logical, dimension(:), allocatable :: nodes_visited integer(kind=ip), dimension(:), allocatable :: inodes node coordinates integer(kind=ip), dimension(:), allocatable :: jnodes node coordinates integer(kind=ip) :: max_dist integer(kind=ip) :: total_nodes integer(kind=ip) :: nrows integer(kind=ip) :: ncols character(len=1), dimension(:,:), allocatable :: array integer(kind=ip), dimension(:), allocatable :: node_dist integer(kind=ip), dimension(:), allocatable :: node_prev Derived Types type :: node Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(:), allocatable :: inext the node connected to this one integer(kind=ip), public, dimension(:), allocatable :: idist distance to inext nodes Functions pure function is_node (i, j) returns true if a node is at these coordinates Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value logical pure function node_number (i, j) returns the index of these coordinates in\nthe list of nodes (0 if it is not a node) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value integer(kind=ip) pure function count_adjacent (i, j) result(icount) count the number of adjacent cells not a tree Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: j Return Value integer(kind=ip) pure function get_cell (i, j) result(a) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i coordinates integer(kind=ip), intent(in) :: j coordinates Return Value character(len=1) pure function not_tree (i, j) returns true if the cell isn't a tree Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i coordinates integer(kind=ip), intent(in) :: j coordinates Return Value logical Subroutines subroutine go (case, filename, parta) solve the case Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: case case name for printing character(len=*), intent(in) :: filename input file to read logical, intent(in) :: parta if this is part a, then consider the slopes subroutine dijkstra (u, inext) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: u integer(kind=ip), intent(in) :: inext recursive subroutine build_graph (node_num, i, j, idist, visited) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: node_num current node number integer(kind=ip), intent(in) :: i current position integer(kind=ip), intent(in) :: j current position integer(kind=ip), intent(in) :: idist current distance (number of steps) logical, intent(in), dimension(:,:) :: visited elements visited in this path (not counting this one) recursive subroutine traverse (node_num, idist, nodes_visited) traverse the graph until we get to the end and check the max distance Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: node_num current node integer(kind=ip), intent(in) :: idist distance to get here logical, intent(in), dimension(:) :: nodes_visited subroutine add_edge (inode, ichild, idist) add an edge to this node (path to another node with the specified distance) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: inode integer(kind=ip), intent(in) :: ichild integer(kind=ip), intent(in) :: idist Source Code program problem_23 !! alternate one... collapse the maze into a graph ! Process: !   1. locate the start and end nodes (top and bottom) !   2. find all the cells that have 3 or 4 adjacent cells: ! !      1    2    3    4 !     ###  #.#  ###  #.# !-->  #.#  #.#  ...  ... !     #.#  #.#  #.#  #.# ! !     those are the nodes, and the paths between them are the edges !   3. compute the edges between each node combination and construct the graph !   4. DFS all paths to find the longest. use iso_fortran_env use aoc_utilities implicit none type :: node integer ( ip ), dimension (:), allocatable :: inext !! the node connected to this one integer ( ip ), dimension (:), allocatable :: idist !! distance to inext nodes end type node type ( node ), dimension (:), allocatable :: nodes !! the list of nodes logical :: slopes !! a=true, b=false logical , dimension (:,:), allocatable :: visited logical , dimension (:), allocatable :: nodes_visited integer ( ip ), dimension (:), allocatable :: inodes , jnodes !! node coordinates integer ( ip ) :: max_dist , total_nodes , nrows , ncols character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:), allocatable :: node_dist integer ( ip ), dimension (:), allocatable :: node_prev call clk % tic () ! call go('23a', 'inputs/day23_test.txt', .true. ) ! call go('23b', 'inputs/day23_test.txt', .false.) call go ( '23a' , 'inputs/day23.txt' , . true . ) call go ( '23b' , 'inputs/day23.txt' , . false .) call clk % toc ( '23' ) contains subroutine go ( case , filename , parta ) !! solve the case character ( len =* ), intent ( in ) :: case !! case name for printing character ( len =* ), intent ( in ) :: filename !! input file to read logical , intent ( in ) :: parta !! if this is part a, then consider the slopes integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: istart , iend , idist , i , j logical , parameter :: use_dijkstra = . false . !.... doesn't work yet .... don't know why ....... ! initialize: max_dist = 0 slopes = parta if ( allocated ( nodes )) deallocate ( nodes ) if ( allocated ( visited )) deallocate ( visited ) if ( allocated ( nodes_visited )) deallocate ( nodes_visited ) if ( allocated ( inodes )) deallocate ( inodes ) if ( allocated ( jnodes )) deallocate ( jnodes ) if ( allocated ( node_dist )) deallocate ( node_dist ) if ( allocated ( node_prev )) deallocate ( node_prev ) ! read the data file: array = read_file_to_char_array ( filename ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) iloc = findloc ( array ( 1 ,:), '.' ); istart = iloc ( 1 ) ! get start and end columns iloc = findloc ( array ( nrows ,:), '.' ); iend = iloc ( 1 ) ! ! identify the coordinates of all the nodes: inodes = [ 1 ] ! start node jnodes = [ istart ] do i = 1 , nrows do j = 1 , ncols if ( count_adjacent ( i , j ) >= 3 ) then inodes = [ inodes , i ] jnodes = [ jnodes , j ] end if end do end do inodes = [ inodes , nrows ] ! end node jnodes = [ jnodes , iend ] total_nodes = size ( inodes ) ! for each node, find the other nodes they are ! connected to and the distances between them (the edges) allocate ( nodes ( total_nodes )) allocate ( visited ( nrows , ncols )) do i = 1 , total_nodes visited = . false . idist = 0 call build_graph ( i , inodes ( i ), jnodes ( i ), idist , visited ) end do if ( use_dijkstra ) then !write(*,*) 'hello use_dijkstra'         ! ... something wrong here... don't get the right answer ! based on AOC 2021, Problem 15 allocate ( node_dist ( total_nodes )); node_dist = - 1 ; node_dist ( 1 ) = 0 allocate ( node_prev ( total_nodes )); node_prev = - 1 allocate ( nodes_visited ( total_nodes )); nodes_visited = . false . do iloc = maxloc ( node_dist , mask = . not . nodes_visited ) i = iloc ( 1 ) nodes_visited ( i ) = . true . if ( i == total_nodes ) exit ! we are done! !write(*,*) 'visited ', i if ( allocated ( nodes ( i )% inext )) then do j = 1 , size ( nodes ( i )% inext ) ! adjacent nodes to this one call dijkstra ( i , j ) end do end if !if (all(nodes_visited)) exit ! done end do !write(*,*) case, node_dist(size(node_dist)) ! result for this case (last node) !write(*,*) nodes_visited !write(*,*) node_dist else ! start at first, and find the longest that gets to the last. ! recursively traverse the graph. visited = . false . allocate ( nodes_visited ( total_nodes )); nodes_visited = . false . call traverse ( 1_ip , 0_ip , nodes_visited ) write ( * , * ) case , max_dist ! result for this case end if end subroutine go subroutine dijkstra ( u , inext ) integer ( ip ), intent ( in ) :: u ! current integer ( ip ), intent ( in ) :: inext ! index in inext array of the next node integer ( ip ) :: idist associate ( next_node => nodes ( u )% inext ( inext ), & distance_to_next_node => nodes ( u )% idist ( inext )) if ( nodes_visited ( next_node )) return ! already visited this one idist = node_dist ( u ) + distance_to_next_node ! add distance from u to v if ( idist > node_dist ( next_node )) then !write(*,*) 'highest so far: ', idist node_dist ( next_node ) = idist node_prev ( next_node ) = u end if end associate end subroutine dijkstra recursive subroutine build_graph ( node_num , i , j , idist , visited ) integer ( ip ), intent ( in ) :: node_num !! current node number integer ( ip ), intent ( in ) :: i , j !! current position integer ( ip ), intent ( in ) :: idist !! current distance (number of steps) logical , dimension (:,:), intent ( in ) :: visited !! elements visited in this path (not counting this one) logical , dimension (:,:), allocatable :: tmp_visited integer ( ip ) :: child_node_num if ( i < 1 . or . i > nrows . or . j < 1 . or . j > ncols ) return if ( visited ( i , j )) return if ( array ( i , j ) == '#' ) return ! can't continue from here ! go until we hit another node child_node_num = node_number ( i , j ) if ( child_node_num > 0 . and . child_node_num /= node_num ) then ! we have reached another node call add_edge ( node_num , child_node_num , idist ) else ! continue processing this edge tmp_visited = visited !make a copy and mark this one tmp_visited ( i , j ) = . true . ! we are here now associate ( a => get_cell ( i , j )) ! paths (.), forest (#), and steep slopes (&#94;, >, v, and <). select case ( a ) case ( '.' ) ! path call build_graph ( node_num , i - 1 , j , idist + 1 , tmp_visited ) call build_graph ( node_num , i + 1 , j , idist + 1 , tmp_visited ) call build_graph ( node_num , i , j + 1 , idist + 1 , tmp_visited ) call build_graph ( node_num , i , j - 1 , idist + 1 , tmp_visited ) ! these don't have a choice, must go in these directions: case ( '&#94;' ); call build_graph ( node_num , i - 1 , j , idist + 1 , tmp_visited ) case ( 'v' ); call build_graph ( node_num , i + 1 , j , idist + 1 , tmp_visited ) case ( '>' ); call build_graph ( node_num , i , j + 1 , idist + 1 , tmp_visited ) case ( '<' ); call build_graph ( node_num , i , j - 1 , idist + 1 , tmp_visited ) end select end associate end if end subroutine build_graph recursive subroutine traverse ( node_num , idist , nodes_visited ) !! traverse the graph until we get to the end and check the max distance integer ( ip ), intent ( in ) :: node_num !! current node integer ( ip ), intent ( in ) :: idist !! distance to get here logical , dimension (:), intent ( in ) :: nodes_visited logical , dimension (:), allocatable :: tmp_nodes_visited integer :: i if ( nodes_visited ( node_num )) return ! already visited this node if ( node_num == total_nodes ) then ! reached the destination if ( idist > max_dist ) max_dist = idist ! best so far else ! are their child nodes? if ( allocated ( nodes ( node_num )% inext )) then tmp_nodes_visited = nodes_visited tmp_nodes_visited ( node_num ) = . true . ! mark this node do i = 1 , size ( nodes ( node_num )% inext ) call traverse ( nodes ( node_num )% inext ( i ), idist + nodes ( node_num )% idist ( i ), tmp_nodes_visited ) end do end if end if end subroutine traverse pure logical function is_node ( i , j ) !! returns true if a node is at these coordinates integer ( ip ), intent ( in ) :: i , j is_node = any ( inodes == i . and . jnodes == j ) end function is_node subroutine add_edge ( inode , ichild , idist ) !! add an edge to this node (path to another node with the specified distance) integer ( ip ), intent ( in ) :: inode , ichild , idist if (. not . allocated ( nodes ( inode )% inext )) then allocate ( nodes ( inode )% inext ( 0 )) allocate ( nodes ( inode )% idist ( 0 )) end if nodes ( inode )% inext = [ nodes ( inode )% inext , ichild ] nodes ( inode )% idist = [ nodes ( inode )% idist , idist ] end subroutine add_edge pure integer ( ip ) function node_number ( i , j ) !! returns the index of these coordinates in !! the list of nodes (0 if it is not a node) integer ( ip ), intent ( in ) :: i , j integer ( ip ), dimension ( 1 ) :: iloc iloc = findloc ( inodes == i . and . jnodes == j , . true .) node_number = iloc ( 1 ) end function node_number pure function count_adjacent ( i , j ) result ( icount ) !! count the number of adjacent cells not a tree integer ( ip ), intent ( in ) :: i , j integer ( ip ) :: icount icount = 0 if ( i >= 1 ) icount = icount + count ([ not_tree ( i - 1 , j )]) if ( i <= nrows ) icount = icount + count ([ not_tree ( i + 1 , j )]) if ( j <= ncols ) icount = icount + count ([ not_tree ( i , j + 1 )]) if ( j >= 1 ) icount = icount + count ([ not_tree ( i , j - 1 )]) end function count_adjacent pure function get_cell ( i , j ) result ( a ) integer ( ip ), intent ( in ) :: i , j !! coordinates character ( len = 1 ) :: a if ( slopes ) then a = array ( i , j ) else a = '.' ! ignore the slopes for part b end if end function get_cell pure logical function not_tree ( i , j ) !! returns true if the cell isn't a tree integer ( ip ), intent ( in ) :: i , j !! coordinates if ( i < 1 . or . i > nrows . or . j < 1 . or . j > ncols ) then not_tree = . false . ! off the board, call it a tree else not_tree = array ( i , j ) /= '#' end if end function not_tree end program problem_23","tags":"","loc":"program/problem_23.html"},{"title":"problem_12b – AoC-2023","text":"Uses aoc_cache_module iso_fortran_env aoc_utilities program~~problem_12b~~UsesGraph program~problem_12b problem_12b iso_fortran_env iso_fortran_env program~problem_12b->iso_fortran_env module~aoc_cache_module aoc_cache_module program~problem_12b->module~aoc_cache_module module~aoc_utilities aoc_utilities program~problem_12b->module~aoc_utilities module~aoc_cache_module->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. completely reworked solution from part a\nthis one starts with the int list and checks it against the pattern.\nit also employs a function cache to speed it up. Calls program~~problem_12b~~CallsGraph program~problem_12b problem_12b interface~split aoc_utilities::split program~problem_12b->interface~split proc~clock_end aoc_utilities::clock%clock_end program~problem_12b->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_12b->proc~clock_start proc~go~5 problem_12b::go program~problem_12b->proc~go~5 proc~initialize_cache~2 aoc_cache_module::function_cache%initialize_cache program~problem_12b->proc~initialize_cache~2 proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_12b->proc~number_of_lines_in_file proc~parse_ints aoc_utilities::parse_ints program~problem_12b->proc~parse_ints proc~read_line aoc_utilities::read_line program~problem_12b->proc~read_line proc~str_to_int64_array_with_mapping aoc_utilities::str_to_int64_array_with_mapping program~problem_12b->proc~str_to_int64_array_with_mapping proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~go~5->proc~get_from_cache~2 proc~ipoint problem_12b::ipoint proc~go~5->proc~ipoint proc~ipound problem_12b::ipound proc~go~5->proc~ipound proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~go~5->proc~put_in_cache~2 proc~destroy_cache~2 aoc_cache_module::function_cache%destroy_cache proc~initialize_cache~2->proc~destroy_cache~2 proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 proc~ipoint->proc~go~5 proc~ipound->proc~go~5 ints_tmp ints_tmp proc~ipound->ints_tmp ipattern_tmp ipattern_tmp proc~ipound->ipattern_tmp proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer(kind=ip), parameter :: POINT = -1 integer(kind=ip), parameter :: NUMBER = -2 integer(kind=ip), parameter :: QUESTION = -3 integer :: iunit integer :: n_lines integer :: iline character(len=:), allocatable :: line character(len=:), allocatable :: pattern type( string ), dimension(:), allocatable :: vals integer(kind=ip), dimension(:), allocatable :: ints integer(kind=ip), dimension(:), allocatable :: ipattern integer(kind=ip) :: isum integer(kind=ip) :: ival type( function_cache ) :: cache to cache the go function values Functions recursive function go (ipattern, ints) result(ival) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ipattern integer(kind=ip), intent(in), dimension(:) :: ints Return Value integer(kind=ip) recursive function ipound (ipattern, ints) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ipattern first char is a # integer(kind=ip), intent(in), dimension(:) :: ints Return Value integer(kind=ip) recursive function ipoint (ipattern, ints) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: ipattern first char is a . integer(kind=ip), intent(in), dimension(:) :: ints Return Value integer(kind=ip) Source Code program problem_12b !! completely reworked solution from part a !! this one starts with the int list and checks it against the pattern. !! it also employs a function cache to speed it up. use iso_fortran_env use aoc_utilities use aoc_cache_module implicit none ! note: these are negative because we are appending ! them to the pattern for the cache integer ( ip ), parameter :: POINT = - 1 ! . integer ( ip ), parameter :: NUMBER = - 2 ! # integer ( ip ), parameter :: QUESTION = - 3 ! ? ! some global variables integer :: iunit , n_lines , iline character ( len = :), allocatable :: line , pattern type ( string ), dimension (:), allocatable :: vals integer ( ip ), dimension (:), allocatable :: ints , ipattern integer ( ip ) :: isum , ival type ( function_cache ) :: cache !! to cache the [[go]] function values call clk % tic () call cache % initialize ( isize = 10000 , chunk_size = 1000 ) ! open(newunit=iunit, file='inputs/day12_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day12.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ints = parse_ints ( vals ( 2 )% str ) ! integer list pattern = vals ( 1 )% str ! the pattern ! will convert the pattern to an array of numbers: ipattern = str_to_int64_array_with_mapping ( pattern ,[ '.' , '#' , '?' ],& [ POINT , NUMBER , QUESTION ]) ! expand the input ipattern = [ ipattern , QUESTION , ipattern , QUESTION , & ipattern , QUESTION , ipattern , QUESTION , & ipattern ] ints = [ ints , ints , ints , ints , ints ] ival = go ( ipattern , ints ) isum = isum + ival end do write ( * , * ) '12b: ' , isum call clk % toc ( '12b' ) contains recursive function go ( ipattern , ints ) result ( ival ) integer ( ip ), dimension (:), intent ( in ) :: ipattern integer ( ip ), dimension (:), intent ( in ) :: ints integer ( ip ) :: ival integer ( ip ), dimension (:), allocatable :: ival_vec integer ( ip ) :: idx logical :: found ! first check the cache: call cache % get ([ ipattern , ints ], idx , ival_vec , found ) if ( found ) then ival = ival_vec ( 1 ) else if ( size ( ints ) == 0 ) then ! no more ints ival = merge ( 0 , 1 , any ( ipattern == NUMBER )) ! if any more numbers, invalid else if ( size ( ipattern ) == 0 ) then ival = 0 ! too many ints else ! process next element in pattern select case ( ipattern ( 1 )) case ( NUMBER ); ival = ipound ( ipattern , ints ) case ( POINT ); ival = ipoint ( ipattern , ints ) case ( QUESTION ); ival = ipoint ( ipattern , ints ) + ipound ( ipattern , ints ) end select end if ! cache this function call: ival_vec = [ ival ] call cache % put ( idx ,[ ipattern , ints ], ival_vec ) end if end function go recursive integer ( ip ) function ipound ( ipattern , ints ) integer ( ip ), dimension (:), intent ( in ) :: ipattern !! first char is a # integer ( ip ), dimension (:), intent ( in ) :: ints integer ( ip ), dimension (:), allocatable :: this_group ! check for the number of # that correspond to the first group if ( size ( ipattern ) >= ints ( 1 )) then this_group = ipattern ( 1 : ints ( 1 )) where ( this_group == QUESTION ) this_group = NUMBER ! replace ? with # if ( any ( this_group /= NUMBER )) then ! can't fit all the #'s so not valid ipound = 0 return else ! so far so good end if else ! not enough room to hold all the #'s ipound = 0 return end if if ( size ( ipattern ) == ints ( 1 )) then ! if this is the last group, then we are done ipound = merge ( 1 , 0 , size ( ints ) == 1 ) else ! the next character after this number must be a ? or . if ( size ( ipattern ) >= ints ( 1 ) + 1 ) then if ( any ( ipattern ( ints ( 1 ) + 1 ) == [ QUESTION , POINT ])) then block integer ( ip ), dimension (:), allocatable :: ipattern_tmp , ints_tmp ! to handle edge cases ! skip it and process the next group if ( size ( ipattern ) >= ints ( 1 ) + 2 ) then ipattern_tmp = ipattern ( ints ( 1 ) + 2 :) else allocate ( ipattern_tmp ( 0 )) end if if ( size ( ints ) >= 2 ) then ints_tmp = ints ( 2 :) else allocate ( ints_tmp ( 0 )) end if ipound = go ( ipattern_tmp , ints_tmp ) return end block end if end if ! not valid at this point ipound = 0 end if end function ipound recursive integer ( ip ) function ipoint ( ipattern , ints ) integer ( ip ), dimension (:), intent ( in ) :: ipattern !! first char is a . integer ( ip ), dimension (:), intent ( in ) :: ints if ( size ( ipattern ) <= 1 ) then ipoint = go ([ integer ( ip ) :: ], ints ) ! done, pass in empty array else ipoint = go ( ipattern ( 2 :), ints ) ! skip it and go to next one end if end function ipoint end program problem_12b","tags":"","loc":"program/problem_12b.html"},{"title":"main – AoC-2023","text":"Uses lsqr_kinds iso_fortran_env lsqr_module program~~main~3~~UsesGraph program~main~3 main iso_fortran_env iso_fortran_env program~main~3->iso_fortran_env module~lsqr_kinds lsqr_kinds program~main~3->module~lsqr_kinds module~lsqr_module lsqr_module program~main~3->module~lsqr_module module~lsqr_kinds->iso_fortran_env module~lsqr_module->module~lsqr_kinds module~lsqpblas_module lsqpblas_module module~lsqr_module->module~lsqpblas_module module~lsqpblas_module->module~lsqr_kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Main program for EZ test. Calls program~~main~3~~CallsGraph program~main~3 main proc~initialize_ez lsqr_module::lsqr_solver_ez%initialize_ez program~main~3->proc~initialize_ez proc~solve_ez lsqr_module::lsqr_solver_ez%solve_ez program~main~3->proc~solve_ez proc~lsqr lsqr_module::lsqr_solver%LSQR proc~solve_ez->proc~lsqr aprod aprod proc~lsqr->aprod proc~d2norm lsqr_module::d2norm proc~lsqr->proc~d2norm proc~dcopy lsqpblas_module::dcopy proc~lsqr->proc~dcopy proc~dnrm2 lsqpblas_module::dnrm2 proc~lsqr->proc~dnrm2 proc~dscal lsqpblas_module::dscal proc~lsqr->proc~dscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: m = 3 number of rows in A matrix integer, parameter :: n = 3 number of columns in A matrix real(kind=wp), parameter,               dimension(m) :: b = real([1, 2, 3], wp) integer, parameter,               dimension(m*n) :: icol = [1, 1, 1, 2, 2, 2, 3, 3, 3] integer, parameter,               dimension(m*n) :: irow = [1, 2, 3, 1, 2, 3, 1, 2, 3] real(kind=wp), parameter,               dimension(m*n) :: a = real([1, 4, 7, 2, 5, 88, 3, 66, 9], wp) real(kind=wp), parameter :: damp = zero real(kind=wp), parameter,               dimension(m,1) :: b_vec = reshape(b, [m, 1]) real(kind=wp), parameter,               dimension(m,n) :: a_mat = reshape(a, [3, 3]) type( lsqr_solver_ez ) :: solver real(kind=wp), dimension(n) :: x real(kind=wp), dimension(1) :: se not used real(kind=wp), dimension(n,1) :: x_vec integer :: istop Source Code program main use lsqr_kinds use lsqr_module , only : lsqr_solver_ez use iso_fortran_env , only : output_unit implicit none ! define a 3x3 dense system to solve: integer , parameter :: m = 3 !! number of rows in `A` matrix integer , parameter :: n = 3 !! number of columns in `A` matrix real ( wp ), dimension ( m ), parameter :: b = real ([ 1 , 2 , 3 ], wp ) integer , dimension ( m * n ), parameter :: icol = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ] integer , dimension ( m * n ), parameter :: irow = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] real ( wp ), dimension ( m * n ), parameter :: a = real ([ 1 , 4 , 7 , 2 , 5 , 88 , 3 , 66 , 9 ], wp ) real ( wp ), parameter :: damp = zero real ( wp ), dimension ( m , 1 ), parameter :: b_vec = reshape ( b ,[ m , 1 ]) real ( wp ), dimension ( m , n ), parameter :: a_mat = reshape ( a ,[ 3 , 3 ]) type ( lsqr_solver_ez ) :: solver real ( wp ), dimension ( n ) :: x real ( wp ), dimension ( 1 ) :: se !! not used real ( wp ), dimension ( n , 1 ) :: x_vec integer :: istop call solver % initialize ( m , n , a , irow , icol ,& itnlim = 100 ,& nout = output_unit ) call solver % solve ( b , damp , x , istop ) x_vec ( 1 : 3 , 1 ) = x write ( * , * ) '' write ( * , * ) 'istop = ' , istop write ( * , * ) '' write ( * , '(1P,A,*(E16.6))' ) 'x       = ' , x write ( * , '(1P,A,*(E16.6))' ) 'A*x     = ' , matmul ( a_mat , x_vec ) write ( * , '(1P,A,*(E16.6))' ) 'A*x - b = ' , matmul ( a_mat , x_vec ) - b_vec if ( any ( abs ( matmul ( a_mat , x_vec ) - b_vec ) > 1.0e-12 )) error stop 'TEST FAILED' end program main","tags":"","loc":"program/main~3.html"},{"title":"problem_4 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_4~~UsesGraph program~problem_4 problem_4 iso_fortran_env iso_fortran_env program~problem_4->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_4->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_4~~CallsGraph program~problem_4 problem_4 interface~split aoc_utilities::split program~problem_4->interface~split proc~clock_end aoc_utilities::clock%clock_end program~problem_4->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_4->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_4->proc~number_of_lines_in_file proc~parse_ints aoc_utilities::parse_ints program~problem_4->proc~parse_ints proc~read_line aoc_utilities::read_line program~problem_4->proc~read_line proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit integer :: n_lines integer :: i integer :: points integer :: j integer :: iwin type( string ), dimension(:), allocatable :: vals type( string ), dimension(:), allocatable :: vals2 integer, dimension(:), allocatable :: iwinning integer, dimension(:), allocatable :: ihave integer, dimension(:), allocatable :: n_matches character(len=:), allocatable :: line integer, dimension(:,:), allocatable :: card_matrix Source Code program problem_4 use iso_fortran_env use aoc_utilities implicit none integer :: iunit , n_lines , i , points , j , iwin type ( string ), dimension (:), allocatable :: vals , vals2 integer , dimension (:), allocatable :: iwinning , ihave , n_matches character ( len = :), allocatable :: line integer , dimension (:,:), allocatable :: card_matrix call clk % tic () ! open(newunit=iunit, file='inputs/day4_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day4.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( n_matches ( n_lines )) ! for part 2 allocate ( card_matrix ( 0 : n_lines , n_lines )) ! for part 2 ! Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53 points = 0 do i = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ': ' ) vals2 = split ( vals ( 2 ), ' | ' ) iwinning = parse_ints ( vals2 ( 1 )% str ) ! winning list ihave = parse_ints ( vals2 ( 2 )% str ) ! ones you have ! count the number of ones you have in the winning set: iwin = 0 do j = 1 , size ( ihave ) iwin = iwin + count ( ihave ( j ) == iwinning ) end do n_matches ( i ) = iwin points = points + 2 ** ( iwin - 1 ) end do close ( iunit ) write ( * , * ) '4a : points : ' , points card_matrix = 0 card_matrix ( 0 ,:) = 1 ! start with one card each do i = 1 , n_lines associate ( n => n_matches ( i )) if ( n > 0 ) card_matrix ( i , i + 1 : i + n ) = sum ( card_matrix (:, i )) end associate end do write ( * , * ) '4b : scratchcards :' , sum ( card_matrix ) call clk % toc ( '4' ) end program problem_4","tags":"","loc":"program/problem_4.html"},{"title":"problem_6 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_6~~UsesGraph program~problem_6 problem_6 iso_fortran_env iso_fortran_env program~problem_6->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_6->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_6~~CallsGraph program~problem_6 problem_6 proc~clock_end aoc_utilities::clock%clock_end program~problem_6->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_6->proc~clock_start proc~go~8 problem_6::go program~problem_6->proc~go~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer(kind=ip), parameter,               dimension(*) :: time_a = [60, 94, 78, 82] integer(kind=ip), parameter,               dimension(*) :: distance_a = [475, 2138, 1015, 1650] integer(kind=ip), parameter,               dimension(*) :: time_b = [60947882_ip] integer(kind=ip), parameter,               dimension(*) :: distance_b = [475213810151650_ip] Functions function go (time, distance) result(iproduct) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(:) :: time integer(kind=ip), intent(in), dimension(:) :: distance Return Value integer(kind=ip) Source Code program problem_6 use iso_fortran_env use aoc_utilities implicit none ! just copy and paste the inputs here: ! a integer ( ip ), dimension ( * ), parameter :: time_a = [ 60 , 94 , 78 , 82 ] integer ( ip ), dimension ( * ), parameter :: distance_a = [ 475 , 2138 , 1015 , 1650 ] ! b integer ( ip ), dimension ( * ), parameter :: time_b = [ 60947882_ip ] integer ( ip ), dimension ( * ), parameter :: distance_b = [ 475213810151650_ip ] call clk % tic () print * , '6a: ways to win:' , go ( time_a , distance_a ) print * , '6b: ways to win:' , go ( time_b , distance_b ) call clk % toc ( '6' ) contains function go ( time , distance ) result ( iproduct ) integer ( ip ), dimension (:), intent ( in ) :: time integer ( ip ), dimension (:), intent ( in ) :: distance integer ( ip ) :: iproduct integer ( ip ) :: i , ihold , iways , idistance iproduct = 1 do i = 1 , size ( time ) iways = 0 do ihold = 1 , time ( i ) ! time to hold the button idistance = ihold * ( time ( i ) - ihold ) if ( idistance > distance ( i )) iways = iways + 1 end do iproduct = iproduct * iways end do end function go end program problem_6","tags":"","loc":"program/problem_6.html"},{"title":"problem_22 – AoC-2023","text":"Uses aoc_cache_module iso_fortran_env aoc_utilities program~~problem_22~~UsesGraph program~problem_22 problem_22 iso_fortran_env iso_fortran_env program~problem_22->iso_fortran_env module~aoc_cache_module aoc_cache_module program~problem_22->module~aoc_cache_module module~aoc_utilities aoc_utilities program~problem_22->module~aoc_utilities module~aoc_cache_module->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_22~~CallsGraph program~problem_22 problem_22 proc~clock_end aoc_utilities::clock%clock_end program~problem_22->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_22->proc~clock_start proc~get_all_pieces_above problem_22::get_all_pieces_above program~problem_22->proc~get_all_pieces_above proc~get_all_pieces_below problem_22::get_all_pieces_below program~problem_22->proc~get_all_pieces_below proc~get_pieces_above problem_22::get_pieces_above program~problem_22->proc~get_pieces_above proc~get_pieces_below problem_22::get_pieces_below program~problem_22->proc~get_pieces_below proc~initialize problem_22::initialize program~problem_22->proc~initialize proc~get_all_pieces_above->proc~get_all_pieces_above proc~get_all_pieces_above->proc~get_pieces_above interface~unique aoc_utilities::unique proc~get_all_pieces_above->interface~unique proc~get_from_cache~2 aoc_cache_module::function_cache%get_from_cache proc~get_all_pieces_above->proc~get_from_cache~2 proc~put_in_cache~2 aoc_cache_module::function_cache%put_in_cache proc~get_all_pieces_above->proc~put_in_cache~2 proc~get_all_pieces_below->proc~get_all_pieces_below proc~get_all_pieces_below->proc~get_pieces_below proc~get_all_pieces_below->interface~unique proc~get_all_pieces_below->proc~get_from_cache~2 proc~get_all_pieces_below->proc~put_in_cache~2 proc~get_pieces_above->interface~unique proc~get_pieces_below->interface~unique interface~split aoc_utilities::split proc~initialize->interface~split proc~drop problem_22::drop proc~initialize->proc~drop proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~initialize->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~initialize->proc~read_line proc~update_array problem_22::update_array proc~initialize->proc~update_array proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~unique32 aoc_utilities::unique32 interface~unique->proc~unique32 proc~unique64 aoc_utilities::unique64 interface~unique->proc~unique64 proc~move_piece_down problem_22::move_piece_down proc~drop->proc~move_piece_down proc~vector_djb_hash~2 aoc_cache_module::vector_djb_hash proc~get_from_cache~2->proc~vector_djb_hash~2 proc~move_piece_down->proc~get_pieces_below proc~move_piece_down->proc~update_array proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 interface~sort aoc_utilities::sort proc~unique32->interface~sort proc~unique64->interface~sort proc~sort_ascending aoc_utilities::sort_ascending interface~sort->proc~sort_ascending proc~sort_ascending_64 aoc_utilities::sort_ascending_64 interface~sort->proc~sort_ascending_64 interface~swap aoc_utilities::swap proc~sort_ascending->interface~swap proc~swap64 aoc_utilities::swap64 proc~sort_ascending_64->proc~swap64 interface~swap->proc~swap64 proc~swap32 aoc_utilities::swap32 interface~swap->proc~swap32 proc~swap_str aoc_utilities::swap_str interface~swap->proc~swap_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit integer :: n_lines integer(kind=ip) :: i integer(kind=ip) :: j integer(kind=ip) :: k character(len=:), allocatable :: line type( string ), dimension(:), allocatable :: start_end type( string ), dimension(:), allocatable :: starts type( string ), dimension(:), allocatable :: ends integer(kind=ip), dimension(:,:), allocatable :: istart_array integer(kind=ip), dimension(:,:), allocatable :: iend_array integer(kind=ip), dimension(:,:,:), allocatable :: array integer(kind=ip), dimension(:), allocatable :: ipieces_above integer(kind=ip), dimension(:), allocatable :: ipieces_below integer(kind=ip) :: ok_to_disintegrate integer(kind=ip) :: isum integer(kind=ip) :: isum_total logical :: ok_tmp type( function_cache ) :: above_cache type( function_cache ) :: below_cache Functions recursive function get_all_pieces_above (i) result(ipieces) reursively get a list of all pieces above piece i Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i Return Value integer(kind=ip), dimension(:), allocatable recursive function get_all_pieces_below (i, iskip) result(ipieces) reursively get a list of all pieces below piece i Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i integer(kind=ip), intent(in) :: iskip skip this one and it's children Return Value integer(kind=ip), dimension(:), allocatable function get_pieces_above (i) result(ipieces) get set of pieces directly above piece i Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i Return Value integer(kind=ip), dimension(:), allocatable function get_pieces_below (i) result(ipieces) get set of pieces directly below piece i Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i Return Value integer(kind=ip), dimension(:), allocatable Subroutines subroutine initialize () read the data Arguments None subroutine drop () continue forward in time until all the bricks settle. Arguments None subroutine update_array () populate the array using the start/end indices Arguments None subroutine move_piece_down (i, moved) move a piece down (fall one square) if it can be moved Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i piece number logical, intent(out) :: moved if it was actually movec Source Code program problem_22 use iso_fortran_env use aoc_utilities use aoc_cache_module implicit none integer :: iunit , n_lines integer ( ip ) :: i , j , k character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: start_end , starts , ends integer ( ip ), dimension (:,:), allocatable :: istart_array integer ( ip ), dimension (:,:), allocatable :: iend_array integer ( ip ), dimension (:,:,:), allocatable :: array integer ( ip ), dimension (:), allocatable :: ipieces_above , ipieces_below integer ( ip ) :: ok_to_disintegrate , isum , isum_total logical :: ok_tmp type ( function_cache ) :: above_cache , below_cache call clk % tic () !find the ones we can remove without any other falling: !  to do that, look to see if any above it are not otherwise held up by another piece call initialize () ok_to_disintegrate = 0 do i = 1 , n_lines ipieces_above = get_pieces_above ( i ) if ( size ( ipieces_above ) == 0 ) then ! nothing above, it so ok to remove ok_to_disintegrate = ok_to_disintegrate + 1 else ok_tmp = . true . do j = 1 , size ( ipieces_above ) ! check all the pieces above. if ALL have other supporters then OK to remove ipieces_below = get_pieces_below ( ipieces_above ( j )) if ( all ( ipieces_below == i )) then ! only supported by i , so can't remove i ok_tmp = . false . exit end if end do if ( ok_tmp ) ok_to_disintegrate = ok_to_disintegrate + 1 end if end do write ( * , * ) '22a: ' , ok_to_disintegrate ! for part 2, we need to find all the nodes in the tree ! that are only supportd by ones below that in the tree ! !  777  44444 ! 66111222  9 !88 333333333   <--- deleting 3 will cause 1, 2, 4, 9 to fall, but not 6,7,8 ! just use a cache to save the ones above/below a given piece ! since there is a lot of duplication in that calculation call above_cache % initialize ( isize = 1000 , chunk_size = 1000 ) call below_cache % initialize ( isize = 1000 , chunk_size = 1000 ) call initialize () isum_total = 0 do i = 1 , n_lines ! try remove piece i ipieces_above = get_all_pieces_above ( i ) isum = size ( ipieces_above ) ! start out assuming they will all fall if ( isum > 0 ) then main : do j = 1 , size ( ipieces_above ) ! for all the ones, see if there are any below that are not in the above set. ! is so, then it will not fall. ipieces_below = get_all_pieces_below ( ipieces_above ( j ), iskip = i ) ipieces_below = pack ( ipieces_below , ipieces_below /= i ) ! remove i if present (the one being removed) do k = 1 , size ( ipieces_below ) if (. not . any ( ipieces_below ( k ) == [ ipieces_above ])) then isum = isum - 1 ! this one will not fall, so remove it from total cycle main end if end do end do main end if isum_total = isum_total + isum end do write ( * , * ) '22b: ' , isum_total call clk % toc ( '22' ) contains subroutine initialize () !! read the data ! open(newunit=iunit, file='inputs/day22_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day22.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) if ( allocated ( istart_array )) deallocate ( istart_array ); allocate ( istart_array ( n_lines , 3 )) if ( allocated ( iend_array )) deallocate ( iend_array ); allocate ( iend_array ( n_lines , 3 )) do i = 1 , n_lines line = read_line ( iunit ); start_end = split ( line , '~' ) starts = split ( start_end ( 1 )% str , ',' ) ends = split ( start_end ( 2 )% str , ',' ) istart_array ( i ,:) = [( int ( starts ( j )% str ), j = 1 , 3 )] iend_array ( i ,:) = [( int ( ends ( j )% str ), j = 1 , 3 )] end do close ( iunit ) ! create the array to hold all the pieces: if ( allocated ( array )) deallocate ( array ) allocate ( array ( 0 : maxval ([ istart_array (:, 1 ), iend_array (:, 1 )]),& 0 : maxval ([ istart_array (:, 2 ), iend_array (:, 2 )]),& 0 : maxval ([ istart_array (:, 3 ), iend_array (:, 3 )]))) call update_array () ! set array values from the start/end arrays call drop () ! continue forward in time until all the bricks settle. end subroutine initialize subroutine drop () !! continue forward in time until all the bricks settle. logical :: moved , tmp_moved integer ( ip ) :: i do moved = . false . do i = 1 , n_lines call move_piece_down ( i , tmp_moved ) if ( tmp_moved ) moved = . true . ! at least one was moved end do if (. not . moved ) exit ! done moving all the pieces end do end subroutine drop recursive function get_all_pieces_above ( i ) result ( ipieces ) !! reursively get a list of all pieces above piece i integer ( ip ), intent ( in ) :: i integer ( ip ), dimension (:), allocatable :: ipieces integer :: j !! counter logical :: found integer ( ip ) :: idx call above_cache % get ([ i ], idx , ipieces , found ) if (. not . found ) then allocate ( ipieces ( 0 )) associate ( tmp => get_pieces_above ( i )) if ( size ( tmp ) > 0 ) then ipieces = [ ipieces , tmp ] ! ones directly above do j = 1 , size ( tmp ) ! go up the tree ipieces = [ ipieces , get_all_pieces_above ( tmp ( j ))] end do ipieces = unique ( ipieces ) end if end associate call above_cache % put ( idx ,[ i ], ipieces ) end if end function get_all_pieces_above recursive function get_all_pieces_below ( i , iskip ) result ( ipieces ) !! reursively get a list of all pieces below piece i integer ( ip ), intent ( in ) :: i integer ( ip ), intent ( in ) :: iskip !! skip this one and it's children integer ( ip ), dimension (:), allocatable :: ipieces integer :: j !! counter logical :: found integer ( ip ) :: idx integer ( ip ), dimension (:), allocatable :: tmp call below_cache % get ([ i , iskip ], idx , ipieces , found ) if (. not . found ) then allocate ( ipieces ( 0 )) if ( i == iskip ) return tmp = get_pieces_below ( i ) if ( size ( tmp ) > 0 ) then tmp = pack ( tmp , tmp /= iskip ) ! remove the skipped one ipieces = [ ipieces , tmp ] ! ones directly below do j = 1 , size ( tmp ) ! go down the tree ipieces = [ ipieces , get_all_pieces_below ( tmp ( j ), iskip = iskip )] end do ipieces = unique ( ipieces ) end if call below_cache % put ( idx ,[ i , iskip ], ipieces ) end if end function get_all_pieces_below subroutine update_array () !! populate the array using the start/end indices integer :: i array = 0 do i = 1 , n_lines array ( istart_array ( i , 1 ): iend_array ( i , 1 ),& istart_array ( i , 2 ): iend_array ( i , 2 ),& istart_array ( i , 3 ): iend_array ( i , 3 )) = i end do end subroutine update_array function get_pieces_above ( i ) result ( ipieces ) !! get set of pieces directly above piece i integer ( ip ), intent ( in ) :: i integer ( ip ), dimension (:), allocatable :: ipieces integer ( ip ) :: x , y , z !! counter allocate ( ipieces ( 0 )) do x = istart_array ( i , 1 ), iend_array ( i , 1 ) do y = istart_array ( i , 2 ), iend_array ( i , 2 ) do z = istart_array ( i , 3 ), iend_array ( i , 3 ) if ( z + 1 <= ubound ( array , 3 )) then if ( array ( x , y , z + 1 ) /= 0 ) ipieces = [ ipieces , array ( x , y , z + 1 )] ! above this one end if end do end do end do ipieces = unique ( pack ( ipieces , ipieces /= i )) ! exclude the ones in this piece end function get_pieces_above function get_pieces_below ( i ) result ( ipieces ) !! get set of pieces directly below piece i integer ( ip ), intent ( in ) :: i integer ( ip ), dimension (:), allocatable :: ipieces integer ( ip ) :: x , y , z !! counter allocate ( ipieces ( 0 )) do x = istart_array ( i , 1 ), iend_array ( i , 1 ) do y = istart_array ( i , 2 ), iend_array ( i , 2 ) do z = istart_array ( i , 3 ), iend_array ( i , 3 ) if ( z - 1 > 0 ) then ! 0 is the floor if ( array ( x , y , z - 1 ) /= 0 ) ipieces = [ ipieces , array ( x , y , z - 1 )] ! below this one end if end do end do end do ipieces = unique ( pack ( ipieces , ipieces /= i )) ! exclude the ones in this piece end function get_pieces_below subroutine move_piece_down ( i , moved ) !! move a piece down (fall one square) if it can be moved integer ( ip ), intent ( in ) :: i !! piece number logical , intent ( out ) :: moved !! if it was actually movec moved = . false . if ( size ( get_pieces_below ( i )) == 0 ) then ! can only move if nothing below if ( istart_array ( i , 3 ) > 1 . and . iend_array ( i , 3 ) > 1 ) then istart_array ( i , 3 ) = istart_array ( i , 3 ) - 1 iend_array ( i , 3 ) = iend_array ( i , 3 ) - 1 moved = . true . call update_array () end if end if end subroutine move_piece_down end program problem_22","tags":"","loc":"program/problem_22.html"},{"title":"problem_5 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_5~~UsesGraph program~problem_5 problem_5 iso_fortran_env iso_fortran_env program~problem_5->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_5->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_5~~CallsGraph program~problem_5 problem_5 interface~startswith aoc_utilities::startswith program~problem_5->interface~startswith proc~clock_end aoc_utilities::clock%clock_end program~problem_5->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_5->proc~clock_start proc~in_seed_list problem_5::in_seed_list program~problem_5->proc~in_seed_list proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_5->proc~number_of_lines_in_file proc~parse_ints64 aoc_utilities::parse_ints64 program~problem_5->proc~parse_ints64 proc~populate problem_5::populate program~problem_5->proc~populate proc~read_line aoc_utilities::read_line program~problem_5->proc~read_line proc~traverse~3 problem_5::traverse program~problem_5->proc~traverse~3 proc~startswith_cc aoc_utilities::startswith_cc interface~startswith->proc~startswith_cc proc~startswith_cs aoc_utilities::startswith_cs interface~startswith->proc~startswith_cs proc~startswith_sc aoc_utilities::startswith_sc interface~startswith->proc~startswith_sc proc~startswith_ss aoc_utilities::startswith_ss interface~startswith->proc~startswith_ss proc~map problem_5::map proc~traverse~3->proc~map proc~startswith_cs->interface~startswith proc~startswith_sc->interface~startswith proc~startswith_ss->interface~startswith Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: iunit integer :: n_lines character(len=:), allocatable :: line type( string ), dimension(:), allocatable :: vals integer(kind=ip), dimension(:), allocatable :: seeds_list integer(kind=ip) :: ilocation_min integer(kind=ip) :: ilocation integer(kind=ip) :: iseed integer(kind=ip), dimension(:), allocatable :: ilocation_min_parallel integer, parameter :: NSTAGES = 7 type( mapping ), dimension(NSTAGES) :: mappings integer :: parsing_state Derived Types type :: mapping Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(:), allocatable :: dest_start integer(kind=ip), public, dimension(:), allocatable :: dest_end integer(kind=ip), public, dimension(:), allocatable :: src_start integer(kind=ip), public, dimension(:), allocatable :: src_end Functions function in_seed_list (iseed) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: iseed Return Value logical pure function map (ival, m, reverse) result(idest) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: ival type( mapping ), intent(in) :: m logical, intent(in) :: reverse Return Value integer(kind=ip) pure function traverse (iseed, reverse) result(ilocation) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: iseed logical, intent(in) :: reverse if reverse, then ilocation -> iseed Return Value integer(kind=ip) Subroutines subroutine populate (nums, m) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), dimension(3) :: nums type( mapping ), intent(inout) :: m Source Code program problem_5 use iso_fortran_env use aoc_utilities implicit none integer :: i , iunit , n_lines character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals integer ( ip ), dimension (:), allocatable :: seeds_list integer ( ip ) :: ilocation_min , ilocation , iseed integer ( ip ), dimension (:), allocatable :: ilocation_min_parallel type :: mapping ! save the source and destination start and end values integer ( ip ), dimension (:), allocatable :: dest_start , dest_end , src_start , src_end end type mapping integer , parameter :: NSTAGES = 7 type ( mapping ), dimension ( NSTAGES ) :: mappings ! seed_to_soil, soil_to_fertilizer, fertilizer_to_water, water_to_light, ! light_to_temperature, temperature_to_humidity, humidity_to_location integer :: parsing_state ! index in mappings (1 to NSTAGES) call clk % tic () do i = 1 , NSTAGES allocate ( mappings ( i )% dest_start ( 0 ), mappings ( i )% dest_end ( 0 ),& mappings ( i )% src_start ( 0 ), mappings ( i )% src_end ( 0 )) end do ! open(newunit=iunit, file='inputs/day5_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day5.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) parsing_state = 0 do i = 1 , n_lines line = read_line ( iunit ) if ( line == '' ) cycle ! blank line if ( startswith ( line , 'seeds:' )) then ; seeds_list = parse_ints64 ( line ( 7 :)) else if ( index ( line , 'map:' ) > 0 ) then ; parsing_state = parsing_state + 1 ! one of the 7 stages else ! parse the numbers for the given state: call populate ( parse_ints64 ( line ), mappings ( parsing_state )) end if end do close ( iunit ) ! ------------ part 1 ----------------- ilocation_min = huge ( 1 ) do i = 1 , size ( seeds_list ) ilocation = traverse ( seeds_list ( i ),. false .) if ( ilocation < ilocation_min ) ilocation_min = ilocation end do print * , '5a: ' , ilocation_min ! ------------ part 2 ----------------- !  so it doesn't run in the CI !! if (. false .) then ! brute force, openMP version. just run the part a algorithm for all the seeds. ! takes a minute or so on my computer. allocate ( ilocation_min_parallel ( size ( seeds_list ) / 2 )) ilocation_min_parallel = huge ( 1 ) !$OMP PARALLEL DO SHARED(ilocation_min_parallel) PRIVATE(i,iseed,ilocation) do i = 1 , size ( seeds_list ), 2 do iseed = seeds_list ( i ), seeds_list ( i ) + seeds_list ( i + 1 ) - 1 ilocation = traverse ( iseed , . false .) if ( ilocation < ilocation_min_parallel (( i + 1 ) / 2 )) ilocation_min_parallel (( i + 1 ) / 2 ) = ilocation end do end do !$OMP END PARALLEL DO print * , '5b: ' , minval ( ilocation_min_parallel ) end if ! ------------ part 2 ----------------- ! Alternate version, go backwards from the location to the seed ! and see if it is contained in the seed set. ! this one is pretty fast (< 1 sec) do ilocation = minval ( mappings ( 7 )% dest_start ), maxval ( mappings ( 7 )% dest_end ) ! up to the max ilocation value iseed = traverse ( ilocation , reverse = . true .) ! from ilocation to iseed if ( in_seed_list ( iseed )) exit ! found the min end do print * , '5b: ' , ilocation call clk % toc ( '5' ) contains logical function in_seed_list ( iseed ) ! for part b, is the seed in the initial list integer ( ip ), intent ( in ) :: iseed integer :: i do i = 1 , size ( seeds_list ), 2 if ( iseed >= seeds_list ( i ) . and . iseed <= seeds_list ( i ) + seeds_list ( i + 1 ) - 1 ) then in_seed_list = . true . return end if end do in_seed_list = . false . end function in_seed_list subroutine populate ( nums , m ) integer ( ip ), dimension ( 3 ), intent ( in ) :: nums ! the three numbers from the line: ! [dest range start, src range start, range length type ( mapping ), intent ( inout ) :: m ! structure to add this data to associate ( dest => nums ( 1 ), source => nums ( 2 ), range => nums ( 3 ) ) m % dest_start = [ m % dest_start , dest ] m % dest_end = [ m % dest_end , dest + range - 1 ] m % src_start = [ m % src_start , source ] m % src_end = [ m % src_end , source + range - 1 ] end associate end subroutine populate pure function map ( ival , m , reverse ) result ( idest ) integer ( ip ), intent ( in ) :: ival type ( mapping ), intent ( in ) :: m logical , intent ( in ) :: reverse ! if reversed, go from: dest -> src integer ( ip ) :: idest integer :: i if ( reverse ) then do i = 1 , size ( m % src_start ) ! locate ival (dest) in the dest start:end range if ( ival >= m % dest_start ( i ) . and . ival <= m % dest_end ( i )) then ! found it, map to dest idest = m % src_start ( i ) + ( ival - m % dest_start ( i )) ! this is the resultant isource return end if end do else do i = 1 , size ( m % src_start ) ! locate ival (source) in the source start:end range if ( ival >= m % src_start ( i ) . and . ival <= m % src_end ( i )) then ! found it, map to dest idest = m % dest_start ( i ) + ( ival - m % src_start ( i )) return end if end do end if idest = ival ! if not found in any of the sets end function map pure function traverse ( iseed , reverse ) result ( ilocation ) integer ( ip ), intent ( in ) :: iseed logical , intent ( in ) :: reverse !! if reverse, then ilocation -> iseed integer ( ip ) :: ilocation integer :: i ilocation = iseed ! initialize if ( reverse ) then do i = NSTAGES , 1 , - 1 ilocation = map ( ilocation , mappings ( i ), reverse ) ! this is really iseed end do else do i = 1 , NSTAGES ilocation = map ( ilocation , mappings ( i ), reverse ) end do end if end function traverse end program problem_5","tags":"","loc":"program/problem_5.html"},{"title":"problem_10 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_10~~UsesGraph program~problem_10 problem_10 iso_fortran_env iso_fortran_env program~problem_10->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_10->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_10~~CallsGraph program~problem_10 problem_10 proc~clock_end aoc_utilities::clock%clock_end program~problem_10->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_10->proc~clock_start proc~locpt aoc_utilities::locpt program~problem_10->proc~locpt proc~move problem_10::move program~problem_10->proc~move proc~read_file_to_char_array aoc_utilities::read_file_to_char_array program~problem_10->proc~read_file_to_char_array proc~move->proc~move proc~pipe_info problem_10::pipe_info proc~move->proc~pipe_info proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file proc~read_file_to_char_array->proc~number_of_lines_in_file proc~read_line aoc_utilities::read_line proc~read_file_to_char_array->proc~read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: j integer :: nrows integer :: ncols integer :: imove integer :: l integer :: m logical, dimension(:,:), allocatable :: icounts character(len=1), dimension(:,:), allocatable :: array integer, dimension(:,:), allocatable :: distance integer, dimension(:,:), allocatable :: distance_reverse logical, dimension(:,:), allocatable :: visited real(kind=wp), dimension(:), allocatable :: x path cooidinates real(kind=wp), dimension(:), allocatable :: y path cooidinates integer, dimension(2) :: Sij i,j of the S char in array Functions pure function pipe_info (p) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: p Return Value character(len=2) Subroutines recursive subroutine move (i, j, direction, distance, save_path) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: direction integer, intent(inout), dimension(:,:) :: distance logical, intent(in) :: save_path to save the path coordinates Source Code program problem_10 use iso_fortran_env use aoc_utilities implicit none integer :: i , j , nrows , ncols , imove , l , m logical , dimension (:,:), allocatable :: icounts character ( len = 1 ), dimension (:,:), allocatable :: array integer , dimension (:,:), allocatable :: distance , distance_reverse logical , dimension (:,:), allocatable :: visited real ( wp ), dimension (:), allocatable :: x , y !! path cooidinates integer , dimension ( 2 ) :: Sij !! i,j of the S char in array call clk % tic () array = read_file_to_char_array ( 'inputs/day10.txt' , '.' ) ! pad with . to simplify edge logic nrows = size ( array , 1 ) ncols = size ( array , 2 ) allocate ( distance ( nrows , ncols )); distance = - 1 allocate ( distance_reverse ( nrows , ncols )); distance_reverse = - 1 allocate ( visited ( nrows , ncols )) ! start at the S coordinate: Sij = findloc ( array , 'S' ) x = [ Sij ( 1 )] ! to store the path for part b y = [ Sij ( 2 )] ! traverse the maze: visited = . false .; visited ( Sij ( 1 ), Sij ( 2 )) = . true .; distance ( Sij ( 1 ), Sij ( 2 )) = 0 do imove = 1 , 4 call move ( Sij ( 1 ), Sij ( 2 ), imove , distance , . true .) end do ! traverse the maze again in reverse: visited = . false .; visited ( Sij ( 1 ), Sij ( 2 )) = . true .; distance_reverse ( Sij ( 1 ), Sij ( 2 )) = 0 do imove = 4 , 1 , - 1 call move ( Sij ( 1 ), Sij ( 2 ), imove , distance_reverse , . false .) end do ! where they match is the distance furthest away from the start write ( * , * ) '10a: ' , pack ( distance , mask = ( distance == distance_reverse . and . distance > 0 )) ! for part b, use locpt to test all the points ! allow openmp to be used here to do each row in parallel allocate ( icounts ( nrows , ncols )); icounts = . false . !$OMP PARALLEL DO SHARED(icounts,x,y) PRIVATE(i,j,l,m) do i = 2 , nrows - 1 ! we can skip the padding do j = 2 , ncols - 1 if ( any ( i == x . and . j == y )) cycle ! skip if on path call locpt ( real ( i , wp ), real ( j , wp ), x , y , size ( x ), l , m ) if ( l == 1 ) icounts ( i , j ) = . true . ! if (i,j) is inside the polygonal path end do end do !$OMP END PARALLEL DO write ( * , * ) '10b: ' , count ( icounts ) call clk % toc ( '10' ) contains recursive subroutine move ( i , j , direction , distance , save_path ) integer , intent ( in ) :: i , j , direction integer , dimension (:,:), intent ( inout ) :: distance logical , intent ( in ) :: save_path !! to save the path coordinates integer :: inew , jnew , imove logical :: valid_move select case ( direction ) case ( 1 ); inew = i - 1 ; jnew = j ! north case ( 2 ); inew = i + 1 ; jnew = j ! south case ( 3 ); inew = i ; jnew = j + 1 ! east case ( 4 ); inew = i ; jnew = j - 1 ! west end select if ( visited ( inew , jnew ) . or . array ( inew , jnew ) == '.' ) return ! can we move in this direction? valid_move = . false . associate ( current_pipe => array ( i , j ), & current_distance => distance ( i , j ), & move_to => array ( inew , jnew ) ) select case ( current_pipe ) case ( 'S' ) ! don't know what the first pip is, so have to try them all select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '|' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south end select case ( '-' ) select case ( direction ) case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'L' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select case ( 'J' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '7' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'F' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select end select if ( valid_move ) then distance ( inew , jnew ) = current_distance + 1 visited ( inew , jnew ) = . true . do imove = 1 , 4 call move ( inew , jnew , imove , distance , save_path ) end do if ( save_path ) then x = [ x , real ( inew , wp )] ! save cordinates of point on the path y = [ y , real ( jnew , wp )] end if end if end associate end subroutine move pure character ( len = 2 ) function pipe_info ( p ) character ( len = 1 ), intent ( in ) :: p select case ( p ) case ( '|' ); pipe_info = 'NS' ! | is a vertical pipe connecting north and south. case ( '-' ); pipe_info = 'EW' ! - is a horizontal pipe connecting east and west. case ( 'L' ); pipe_info = 'NE' ! L is a 90-degree bend connecting north and east. case ( 'J' ); pipe_info = 'NW' ! J is a 90-degree bend connecting north and west. case ( '7' ); pipe_info = 'SW' ! 7 is a 90-degree bend connecting south and west. case ( 'F' ); pipe_info = 'SE' ! F is a 90-degree bend connecting south and east. end select end function pipe_info end program problem_10","tags":"","loc":"program/problem_10.html"},{"title":"problem_19 – AoC-2023","text":"Uses iso_fortran_env aoc_utilities program~~problem_19~~UsesGraph program~problem_19 problem_19 iso_fortran_env iso_fortran_env program~problem_19->iso_fortran_env module~aoc_utilities aoc_utilities program~problem_19->module~aoc_utilities module~aoc_utilities->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~problem_19~~CallsGraph program~problem_19 problem_19 interface~split aoc_utilities::split program~problem_19->interface~split proc~clock_end aoc_utilities::clock%clock_end program~problem_19->proc~clock_end proc~clock_start aoc_utilities::clock%clock_start program~problem_19->proc~clock_start proc~number_of_lines_in_file aoc_utilities::number_of_lines_in_file program~problem_19->proc~number_of_lines_in_file proc~parse_rule~2 problem_19::parse_rule program~problem_19->proc~parse_rule~2 proc~process~2 problem_19::process program~problem_19->proc~process~2 proc~rating problem_19::rating program~problem_19->proc~rating proc~read_line aoc_utilities::read_line program~problem_19->proc~read_line proc~split1 aoc_utilities::split1 interface~split->proc~split1 proc~split2 aoc_utilities::split2 interface~split->proc~split2 proc~parse_rule~2->interface~split proc~workflow_name_to_index~2 problem_19::workflow_name_to_index proc~process~2->proc~workflow_name_to_index~2 proc~expand_vector aoc_utilities::expand_vector proc~split1->proc~expand_vector proc~split2->proc~split1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: iunit integer :: n_lines integer :: iline integer :: i character(len=:), allocatable :: line type( string ), dimension(:), allocatable :: vals logical :: accepted integer(kind=ip) :: total_accepted type( part ), dimension(:), allocatable :: parts type( workflow ), dimension(:), allocatable :: workflows type( workflow ), allocatable :: w Derived Types type :: part Components Type Visibility Attributes Name Initial integer(kind=ip), public, dimension(4) :: xmas type :: rule Components Type Visibility Attributes Name Initial logical, public :: accept = .false. logical, public :: reject = .false. integer, public :: operator = 0 integer, public :: operator_arg = 0 integer, public :: operator_val = 0 character(len=:), public, allocatable :: goto type :: workflow Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name type( rule ), public, dimension(:), allocatable :: rules Functions pure function rating (p) Arguments Type Intent Optional Attributes Name type( part ), intent(in) :: p Return Value integer(kind=ip) function process (p) result(accepted) process this part through all the workflows. Arguments Type Intent Optional Attributes Name type( part ), intent(in) :: p Return Value logical function workflow_name_to_index (name) result(idx) get the index of this workflow in the array Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value integer function parse_rule (s) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value type( rule ) Source Code program problem_19 use aoc_utilities use iso_fortran_env implicit none integer :: iunit , n_lines , iline , i character ( len = :), allocatable :: line !, name type ( string ), dimension (:), allocatable :: vals logical :: accepted integer ( ip ) :: total_accepted type :: part integer ( ip ), dimension ( 4 ) :: xmas ! [x,m,a,s] end type part type ( part ), dimension (:), allocatable :: parts type :: rule logical :: accept = . false . logical :: reject = . false . integer :: operator = 0 ! 1:<, 2:> integer :: operator_arg = 0 ! 1:x, 2:m, 3:a, 4:s integer :: operator_val = 0 ! value to compare to character ( len = :), allocatable :: goto ! where to next (workflow name) end type rule type :: workflow character ( len = :), allocatable :: name type ( rule ), dimension (:), allocatable :: rules end type workflow type ( workflow ), dimension (:), allocatable :: workflows type ( workflow ), allocatable :: w call clk % tic () ! open(newunit=iunit, file='inputs/day19_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day19.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( workflows ( 0 )) do iline = 1 , n_lines line = read_line ( iunit ) if ( line == '' ) then !now parse part ratings allocate ( parts ( 0 )) end if if ( allocated ( parts )) then ! parsing parts if ( line == '' ) cycle ! {x=787,m=2655,a=1222,s=2876} vals = split ( line , ',' ) parts = [ parts , part ( xmas = [ int ( vals ( 1 )% str ( 4 :)), & int ( vals ( 2 )% str ( 3 :)), & int ( vals ( 3 )% str ( 3 :)), & int ( vals ( 4 )% str ( 3 : len ( vals ( 4 )% str ) - 1 ))])] else ! parsing workflows : qqz{s>2770:qs,m<1801:hdj,R} if ( allocated ( w )) deallocate ( w ); allocate ( w ) ! blank one vals = split ( line , '{' ) w % name = vals ( 1 )% str ! workflow name !write(*,*) '--->'//w%name//'<-----' vals ( 2 )% str = vals ( 2 )% str ( 1 : len ( vals ( 2 )% str ) - 1 ) ! remove last bracket vals = split ( vals ( 2 )% str , ',' ) ! workflow rules ! add each rule to the workflow allocate ( w % rules ( 0 )) do i = 1 , size ( vals ) w % rules = [ w % rules , parse_rule ( vals ( i )% str )] end do workflows = [ workflows , w ] end if end do total_accepted = 0 do i = 1 , size ( parts ) accepted = process ( parts ( i )) !write(*,*) parts(i), accepted if ( accepted ) then total_accepted = total_accepted + rating ( parts ( i )) end if end do write ( * , * ) '19a: ' , total_accepted call clk % toc ( '19' ) contains pure integer ( ip ) function rating ( p ) type ( part ), intent ( in ) :: p rating = sum ( p % xmas ) end function rating function process ( p ) result ( accepted ) !! process this part through all the workflows. type ( part ), intent ( in ) :: p logical :: accepted integer :: i , irule i = workflow_name_to_index ( 'in' ) ! start at the first workflow irule = 1 ! first rule do associate ( r => workflows ( i )% rules ( irule ) ) ! check if we are done if ( r % accept ) then ; accepted = . true .; return ; end if if ( r % reject ) then ; accepted = . false .; return ; end if if ( r % operator > 0 ) then ! process the operator select case ( r % operator ) case ( 1 ) ! < if ( p % xmas ( r % operator_arg ) < r % operator_val ) then ! check if done if ( r % goto == 'A' ) then ; accepted = . true .; return ; end if if ( r % goto == 'R' ) then ; accepted = . false .; return ; end if ! go to next workflow: i = workflow_name_to_index ( r % goto ) !write(*,*) 'goto '//r%goto irule = 1 ! start at first rule of new workflow else irule = irule + 1 ! next rule end if case ( 2 ) ! > if ( p % xmas ( r % operator_arg ) > r % operator_val ) then ! check if done if ( r % goto == 'A' ) then ; accepted = . true .; return ; end if if ( r % goto == 'R' ) then ; accepted = . false .; return ; end if ! go to next workflow: i = workflow_name_to_index ( r % goto ) irule = 1 ! start at first rule of new workflow else irule = irule + 1 ! next rule end if end select else ! goto another workflow i = workflow_name_to_index ( r % goto ) irule = 1 ! start at first rule of new workflow end if end associate end do end function process function workflow_name_to_index ( name ) result ( idx ) !! get the index of this workflow in the array character ( len =* ), intent ( in ) :: name integer :: idx do idx = 1 , size ( workflows ) if ( name == workflows ( idx )% name ) return ! found it end do if ( idx > size ( workflows )) error stop 'workflow not found: ' // name end function workflow_name_to_index function parse_rule ( s ) result ( r ) character ( len =* ), intent ( in ) :: s type ( rule ) :: r type ( string ), dimension (:), allocatable :: v character ( len =* ), parameter :: xmas = 'xmas' ! 1,2,3,4 if ( s == 'A' ) then r % accept = . true . else if ( s == 'R' ) then r % reject = . true . else if ( index ( s , '>' ) > 0 ) then v = split ( s ( 3 :), ':' ) ! example: a<2006:qkq r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 2 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else if ( index ( s , '<' ) > 0 ) then v = split ( s ( 3 :), ':' ) r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 1 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else r % goto = s ! it's a workflow name end if end if end function parse_rule end program problem_19","tags":"","loc":"program/problem_19.html"},{"title":"aoc_utilities.F90 – AoC-2023","text":"Files dependent on this one sourcefile~~aoc_utilities.f90~~AfferentGraph sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~cache_module.f90~2 cache_module.f90 sourcefile~cache_module.f90~2->sourcefile~aoc_utilities.f90 sourcefile~problem_01.f90 problem_01.f90 sourcefile~problem_01.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_02.f90 problem_02.f90 sourcefile~problem_02.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_03.f90 problem_03.f90 sourcefile~problem_03.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_04.f90 problem_04.f90 sourcefile~problem_04.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_05.f90 problem_05.f90 sourcefile~problem_05.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_06.f90 problem_06.f90 sourcefile~problem_06.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_07.f90 problem_07.f90 sourcefile~problem_07.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_08.f90 problem_08.f90 sourcefile~problem_08.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_09.f90 problem_09.f90 sourcefile~problem_09.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_10.f90 problem_10.f90 sourcefile~problem_10.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_11.f90 problem_11.f90 sourcefile~problem_11.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_12.f90 problem_12.f90 sourcefile~problem_12.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_12b.f90 problem_12b.f90 sourcefile~problem_12b.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_12b.f90->sourcefile~cache_module.f90~2 sourcefile~problem_13.f90 problem_13.f90 sourcefile~problem_13.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_15.f90 problem_15.f90 sourcefile~problem_15.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_16.f90 problem_16.f90 sourcefile~problem_16.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_17.f90 problem_17.f90 sourcefile~problem_17.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_17b.f90 problem_17b.f90 sourcefile~problem_17b.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_17b.f90->sourcefile~cache_module.f90~2 sourcefile~problem_18.f90 problem_18.f90 sourcefile~problem_18.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_19.f90 problem_19.f90 sourcefile~problem_19.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_19b.f90 problem_19b.f90 sourcefile~problem_19b.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_21.f90 problem_21.f90 sourcefile~problem_21.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_22.f90 problem_22.f90 sourcefile~problem_22.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_22.f90->sourcefile~cache_module.f90~2 sourcefile~problem_23.f90 problem_23.f90 sourcefile~problem_23.f90->sourcefile~aoc_utilities.f90 sourcefile~problem_25.f90 problem_25.f90 sourcefile~problem_25.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !************************************************************************************************ !> !  Helper classes and routines for Advent of Code ! !### Author !  * Jacob Williams module aoc_utilities use iso_fortran_env implicit none private #ifdef REAL32 integer , parameter , public :: wp = real32 !! default real kind [4 bytes] #elif REAL64 integer , parameter , public :: wp = real64 !! default real kind [8 bytes] #elif REAL128 integer , parameter , public :: wp = real128 !! default real kind [16 bytes] #else integer , parameter , public :: wp = real64 !! default real kind [8 bytes] #endif integer , parameter , public :: ip = int64 !! default int kind integer , parameter :: chunk_size = 100 !! for dynamic allocations type , public :: clock private integer ( ip ) :: begin , end , rate contains procedure , public :: tic => clock_start procedure , public :: toc => clock_end end type clock type ( clock ), public :: clk !! a public clock to use for timing in the problems type , public :: string !! a type containing an allocatable character string. !! so we can have an array of strings of different lengths. character ( len = :), allocatable :: str contains procedure , public :: to_int => string_to_int !! convert to integer procedure , public :: to_int_64 => string_to_int_64 end type string type , public :: int64_vec !! an type that contains an allocatable ip array. !! so we can have an array of these. integer ( ip ), dimension (:), allocatable :: vals end type int64_vec public :: read_file_to_integer_array , & read_file_to_integer64_array , & read_file_to_char_array , & read_file_to_int_array public :: number_of_lines_in_file public :: read_line public :: parse_ints , parse_ints64 public :: is_number , is_not_number public :: str_to_array public :: lcm public :: reverse public :: diff public :: locpt , parea public :: str_to_int_array_with_mapping , str_to_int64_array_with_mapping public :: int_array_to_char_array public :: hex2int public :: inverse public :: cross interface sort procedure :: sort_ascending , sort_ascending_64 end interface sort public :: sort interface parse procedure :: parse_nums64 end interface parse public :: parse interface split procedure :: split1 , split2 end interface split public :: split interface int procedure :: string_to_int , & char_to_int , char_to_int64 , & char_array_to_int end interface int public :: int interface unique procedure :: unique32 , unique64 end interface unique public :: unique interface startswith !! test if a string starts with a specified substring procedure :: startswith_cc , startswith_ss , startswith_sc , startswith_cs end interface startswith public :: startswith interface swap procedure :: swap32 , swap64 , swap_str end interface swap public :: swap interface manhatten_distance procedure :: manhatten_distance_64 end interface manhatten_distance public :: manhatten_distance contains !************************************************************************************************ !**************************************************************** !> !  Start the clock subroutine clock_start ( me ) class ( clock ), intent ( inout ) :: me call system_clock ( me % begin , me % rate ) end subroutine clock_start !**************************************************************** !**************************************************************** !> !  Print runtime in milliseconds form the start of the clock. subroutine clock_end ( me , case_str ) class ( clock ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: case_str !! description of the case integer :: itime !! time in integer milliseconds call system_clock ( me % end ) itime = int ( 1000 * ( me % end - me % begin ) / real ( me % rate , wp )) write ( * , '(a,I4,a)' ) trim ( case_str ) // ' runtime: ' , itime , ' ms' write ( * , '(a)' ) '---------------------------' write ( * , * ) '' end subroutine clock_end !**************************************************************** !**************************************************************** !> !  Basic string to integer routine pure function char_to_int ( str ) result ( i ) character ( len =* ), intent ( in ) :: str integer :: i read ( str , * ) i end function char_to_int !**************************************************************** !**************************************************************** !> !  Basic string to integer routine pure elemental function string_to_int ( me ) result ( i ) class ( string ), intent ( in ) :: me integer :: i i = int ( me % str ) end function string_to_int !**************************************************************** !**************************************************************** !> !  Basic string to integer routine pure elemental function string_to_int_64 ( me ) result ( i ) class ( string ), intent ( in ) :: me integer ( ip ) :: i i = int ( me % str , ip ) end function string_to_int_64 !**************************************************************** !**************************************************************** !> !  Basic string to integer(ip) routine. !  Hacky hack just so we can overload as int() pure function char_to_int64 ( str , kind ) result ( i ) character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: kind integer ( ip ) :: i if ( kind /= ip ) error stop 'error' read ( str , * ) i end function char_to_int64 !**************************************************************** !**************************************************************** !> !  Character array to integer routine pure function char_array_to_int ( str_array ) result ( i ) character ( len = 1 ), dimension (:), intent ( in ) :: str_array !! example ['1','3'] --> 13 integer :: i character ( len = :), allocatable :: str integer :: k str = '' do k = 1 , size ( str_array ) str = str // str_array ( k ) end do i = char_to_int ( str ) end function char_array_to_int !**************************************************************** !**************************************************************** !> !  integer array to Character array pure function int_array_to_char_array ( iarray ) result ( carray ) integer , dimension (:,:), intent ( in ) :: iarray character ( len = 1 ), dimension (:,:), allocatable :: carray integer :: i , j allocate ( carray ( size ( iarray , 1 ), size ( iarray , 2 ))) do i = 1 , size ( iarray , 1 ) do j = 1 , size ( iarray , 2 ) write ( carray ( i , j ), '(I1)' ) iarray ( i , j ) end do end do end function int_array_to_char_array !**************************************************************** !**************************************************************** !> !  Read a file into a 2d character array. function read_file_to_char_array ( filename , border ) result ( array ) character ( len =* ), intent ( in ) :: filename character ( len = 1 ), intent ( in ), optional :: border !! if true, extra border is added with this char character ( len = 1 ), dimension (:,:), allocatable :: array integer :: i , j , iunit , n_lines , n_cols character ( len = :), allocatable :: line open ( newunit = iunit , file = filename , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) line = read_line ( iunit ); n_cols = len ( line ) rewind ( iunit ) if ( present ( border )) then allocate ( array ( 0 : n_lines + 1 , 0 : n_cols + 1 )) ! padding with border array = border else allocate ( array ( n_lines , n_cols )) end if do i = 1 , n_lines line = read_line ( iunit ) do j = 1 , n_cols array ( i , j ) = line ( j : j ) end do end do close ( iunit ) end function read_file_to_char_array !**************************************************************** !**************************************************************** !> !  Read a file into a 2d character array. function read_file_to_int_array ( filename ) result ( array ) character ( len =* ), intent ( in ) :: filename integer , dimension (:,:), allocatable :: array integer :: i , iunit , n_lines , n_cols character ( len = :), allocatable :: line open ( newunit = iunit , file = filename , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) line = read_line ( iunit ) n_cols = len ( line ) rewind ( iunit ) allocate ( array ( n_lines , n_cols )) do i = 1 , n_lines line = read_line ( iunit ) read ( line , '(*(I1))' ) array ( i , 1 : n_cols ) end do close ( iunit ) end function read_file_to_int_array !**************************************************************** !**************************************************************** !> !  Read a file into an integer array (one element per line) function read_file_to_integer_array ( filename ) result ( iarray ) character ( len =* ), intent ( in ) :: filename integer , dimension (:), allocatable :: iarray integer :: i , iunit , n_lines , istat open ( newunit = iunit , file = filename , iostat = istat ) if ( istat /= 0 ) error stop ' error reading file' n_lines = number_of_lines_in_file ( iunit ) allocate ( iarray ( n_lines )) do i = 1 , n_lines read ( iunit , '(I10)' ) iarray ( i ) end do close ( iunit ) end function read_file_to_integer_array !**************************************************************** !**************************************************************** !> !  Read a file into an ip integer array (one element per line) function read_file_to_integer64_array ( filename ) result ( iarray ) character ( len =* ), intent ( in ) :: filename integer ( ip ), dimension (:), allocatable :: iarray integer :: i , iunit , n_lines , istat open ( newunit = iunit , file = filename , iostat = istat ) if ( istat /= 0 ) error stop ' error reading file' n_lines = number_of_lines_in_file ( iunit ) allocate ( iarray ( n_lines )) do i = 1 , n_lines read ( iunit , * ) iarray ( i ) end do close ( iunit ) end function read_file_to_integer64_array !**************************************************************** !**************************************************************** !> !  Returns the number of lines in a file (assumed to be open) function number_of_lines_in_file ( iunit ) result ( n_lines ) integer , intent ( in ) :: iunit !! the file unit number !! (assumed to be open) integer :: n_lines !! the number of lines in the file character ( len = 1 ) :: tmp integer :: istat rewind ( iunit ) n_lines = 0 do read ( iunit , fmt = '(A1)' , iostat = istat ) tmp if ( is_iostat_end ( istat )) exit n_lines = n_lines + 1 end do rewind ( iunit ) end function number_of_lines_in_file !**************************************************************** !**************************************************************** !> !  Sorts an integer array `ivec` in increasing order. !  Uses a basic recursive quicksort !  (with insertion sort for partitions with \\le 20 elements). subroutine sort_ascending ( ivec ) integer , dimension (:), intent ( inout ) :: ivec integer , parameter :: max_size_for_insertion_sort = 20 !! max size for using insertion sort. call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending !**************************************************************** !**************************************************************** !> subroutine sort_ascending_64 ( ivec ) integer ( ip ), dimension (:), intent ( inout ) :: ivec integer ( ip ), parameter :: max_size_for_insertion_sort = 20 !! max size for using insertion sort. call quicksort ( 1_ip , size ( ivec , kind = ip )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array integer ( ip ), intent ( in ) :: ilow integer ( ip ), intent ( in ) :: ihigh integer ( ip ) :: ipivot !! pivot element integer ( ip ) :: i !! counter integer ( ip ) :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap64 ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer ( ip ), intent ( in ) :: ilow integer ( ip ), intent ( in ) :: ihigh integer ( ip ), intent ( out ) :: ipivot integer ( ip ) :: i , ip call swap64 ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap64 ( ivec ( ip ), ivec ( i )) end if end do call swap64 ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending_64 !**************************************************************** !**************************************************************** !> !  Swap two integer values. pure elemental subroutine swap32 ( i1 , i2 ) integer , intent ( inout ) :: i1 integer , intent ( inout ) :: i2 integer :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap32 !**************************************************************** !**************************************************************** !> !  Swap two integer values. pure elemental subroutine swap64 ( i1 , i2 ) integer ( ip ), intent ( inout ) :: i1 integer ( ip ), intent ( inout ) :: i2 integer ( ip ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap64 !**************************************************************** !**************************************************************** !> !  Swap two character string values pure elemental subroutine swap_str ( i1 , i2 ) character ( len =* ), intent ( inout ) :: i1 character ( len =* ), intent ( inout ) :: i2 character ( len = len ( i1 )) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_str !**************************************************************** !**************************************************************** !> !  Split a `string`, given a token. pure function split2 ( s , token ) result ( vals ) implicit none type ( string ), intent ( in ) :: s character ( len =* ), intent ( in ) :: token type ( string ), dimension (:), allocatable :: vals if ( allocated ( s % str )) then vals = split1 ( s % str , token ) else error stop 'error: string not allocated' end if end function split2 !**************************************************************** !**************************************************************** !> !  Split a character string using a token. !  This routine is inspired by the Python split function. ! !### Example !````Fortran !   character(len=:),allocatable :: s !   type(string),dimension(:),allocatable :: vals !   s = '1,2,3,4,5' !   call split(s,',',vals) !```` pure function split1 ( str , token ) result ( vals ) implicit none character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ) :: token type ( string ), dimension (:), allocatable :: vals integer :: i !! counter integer :: len_str !! significant length of `str` integer :: len_token !! length of the token integer :: n_tokens !! number of tokens integer :: i1 !! index integer :: i2 !! index integer :: j !! counters integer , dimension (:), allocatable :: itokens !! start indices of the !! token locations in `str` len_token = len ( token ) ! length of the token n_tokens = 0 ! initialize the token counter j = 0 ! index to start looking for the next token ! first, count the number of times the token ! appears in the string, and get the token indices. ! ! Examples: !  ',         '    --> 1 !  '1234,67,90'    --> 5,8 !  '123,      '    --> 4 ! length of the string if ( token == ' ' ) then ! in this case, we can't ignore trailing space len_str = len ( str ) else ! safe to ignore trailing space when looking for tokens len_str = len_trim ( str ) end if j = 1 n_tokens = 0 do if ( j > len_str ) exit ! end of string, finished i = index ( str ( j :), token ) ! index of next token in remaining string if ( i <= 0 ) exit ! no more tokens found call expand_vector ( itokens , n_tokens , i + j - 1 ) ! save the token location j = j + i + ( len_token - 1 ) end do call expand_vector ( itokens , n_tokens , finished = . true .) ! resize the vector allocate ( vals ( n_tokens + 1 )) if ( n_tokens > 0 ) then len_str = len ( str ) i1 = 1 i2 = itokens ( 1 ) - 1 if ( i2 >= i1 ) then vals ( 1 )% str = str ( i1 : i2 ) else vals ( 1 )% str = '' !the first character is a token end if !      1 2 3 !    'a,b,c,d' do i = 2 , n_tokens i1 = itokens ( i - 1 ) + len_token i2 = itokens ( i ) - 1 if ( i2 >= i1 ) then vals ( i )% str = str ( i1 : i2 ) else vals ( i )% str = '' !empty element (e.g., 'abc,,def') end if end do i1 = itokens ( n_tokens ) + len_token i2 = len_str if ( itokens ( n_tokens ) + len_token <= len_str ) then vals ( n_tokens + 1 )% str = str ( i1 : i2 ) else vals ( n_tokens + 1 )% str = '' !the last character was a token end if else !no tokens present, so just return the original string: vals ( 1 )% str = str end if end function split1 !**************************************************************** !**************************************************************** !> !  Add elements to the integer vector in chunks. pure subroutine expand_vector ( vec , n , val , finished ) integer , dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) integer , dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector !**************************************************************** !**************************************************************** !> !  Reads the next line from a file. function read_line ( iunit , status_ok ) result ( line ) integer , intent ( in ) :: iunit character ( len = :), allocatable :: line logical , intent ( out ), optional :: status_ok !! true if no problems integer :: nread !! character count specifier for read statement integer :: istat !! file read io status flag character ( len = chunk_size ) :: buffer !! the file read buffer nread = 0 buffer = '' line = '' if ( present ( status_ok )) status_ok = . true . do ! read in the next block of text from the line: read ( iunit , fmt = '(A)' , advance = 'NO' , size = nread , iostat = istat ) buffer if ( IS_IOSTAT_END ( istat ) . or . IS_IOSTAT_EOR ( istat )) then ! add the last block of text before the end of record if ( nread > 0 ) line = line // buffer ( 1 : nread ) exit else if ( istat == 0 ) then ! all the characters were read line = line // buffer ! add this block of text to the string else ! some kind of error if ( present ( status_ok )) then status_ok = . false . exit else error stop 'Read error' end if end if end do end function read_line !**************************************************************** !**************************************************************** !> !  Return only the unique values from vec. function unique32 ( vec ) result ( vec_unique ) integer , dimension (:), intent ( in ) :: vec integer , dimension (:), allocatable :: vec_unique integer :: i , num logical , dimension ( size ( vec )) :: mask mask = . false . do i = 1 , size ( vec ) !count the number of occurrences of this element: num = count ( vec ( i ) == vec ) if ( num == 1 ) then !there is only one, flag it: mask ( i ) = . true . else !flag this value only if it hasn't already been flagged: if (. not . any ( vec ( i ) == vec . and . mask ) ) mask ( i ) = . true . end if end do !return only flagged elements: allocate ( vec_unique ( count ( mask )) ) vec_unique = pack ( vec , mask ) ! also sort it: call sort ( vec_unique ) end function unique32 !**************************************************************** !**************************************************************** !> !  Return only the unique values from vec. function unique64 ( vec ) result ( vec_unique ) integer ( ip ), dimension (:), intent ( in ) :: vec integer ( ip ), dimension (:), allocatable :: vec_unique integer ( ip ) :: i , num logical , dimension ( size ( vec )) :: mask mask = . false . do i = 1 , size ( vec ) !count the number of occurrences of this element: num = count ( vec ( i ) == vec ) if ( num == 1 ) then !there is only one, flag it: mask ( i ) = . true . else !flag this value only if it hasn't already been flagged: if (. not . any ( vec ( i ) == vec . and . mask ) ) mask ( i ) = . true . end if end do !return only flagged elements: allocate ( vec_unique ( count ( mask )) ) vec_unique = pack ( vec , mask ) ! also sort it: call sort ( vec_unique ) end function unique64 !**************************************************************** !**************************************************************** !> !  parse positive ints from a string that also includes text function parse_ints ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer , dimension (:), allocatable :: ints ! array of integers integer :: i , j , n integer :: istart character ( len =* ), parameter :: tokens = '0123456789' n = len ( line ) istart = 0 allocate ( ints ( 0 )) do i = 1 , n if ( index ( tokens , line ( i : i )) > 0 ) then if ( istart == 0 ) istart = i else if ( istart /= 0 ) ints = [ ints , int ( line ( istart : i - 1 ))] ! get previous int istart = 0 end if end do if ( istart /= 0 ) ints = [ ints , int ( line ( istart : n ))] ! get last int end function parse_ints !**************************************************************** !**************************************************************** !> !  Parse positive ints from a string that also includes text function parse_ints64 ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer ( ip ), dimension (:), allocatable :: ints ! array of integers integer ( ip ) :: i , j , n integer ( ip ) :: istart character ( len =* ), parameter :: tokens = '0123456789' n = len ( line ) istart = 0 allocate ( ints ( 0 )) do i = 1 , n if ( index ( tokens , line ( i : i )) > 0 ) then if ( istart == 0 ) istart = i else if ( istart /= 0 ) ints = [ ints , int ( line ( istart : i - 1 ), kind = ip )] ! get previous int istart = 0 end if end do if ( istart /= 0 ) ints = [ ints , int ( line ( istart : n ), kind = ip )] ! get last int end function parse_ints64 !**************************************************************** !**************************************************************** !> !  parse space-deliminated ip sequence (positive or negative) function parse_nums64 ( line ) result ( ints ) character ( len =* ), intent ( in ) :: line integer ( ip ), dimension (:), allocatable :: ints ! array of integers ints = int ( split ( line , ' ' )) end function parse_nums64 !**************************************************************** !> !  starts with function for strings pure logical function startswith_cc ( str , substring ) character ( len =* ), intent ( in ) :: str , substring startswith_cc = index ( str , substring ) == 1 end function startswith_cc pure logical function startswith_ss ( str , substring ) type ( string ), intent ( in ) :: str , substring startswith_ss = startswith ( str % str , substring % str ) end function startswith_ss pure logical function startswith_sc ( str , substring ) type ( string ), intent ( in ) :: str character ( len =* ), intent ( in ) :: substring startswith_sc = startswith ( str % str , substring ) end function startswith_sc pure logical function startswith_cs ( str , substring ) character ( len =* ), intent ( in ) :: str type ( string ), intent ( in ) :: substring startswith_cs = startswith ( str , substring % str ) end function startswith_cs !**************************************************************** !**************************************************************** !> !  returns true if the character is a number from 0 to 9. logical function is_number ( c ) character ( len = 1 ), intent ( in ) :: c is_number = c >= '0' . and . c <= '9' end function is_number !**************************************************************** !**************************************************************** !> !  returns true if the character is not a number. logical function is_not_number ( c ) character ( len = 1 ), intent ( in ) :: c is_not_number = . not . is_number ( c ) end function is_not_number !**************************************************************** !**************************************************************** !> !  convert the character string to an array of characters function str_to_array ( s ) result ( a ) character ( len =* ), intent ( in ) :: s character ( len = 1 ), dimension ( len ( s )) :: a integer :: i do i = 1 , len ( s ) ! transfer a ( i ) = s ( i : i ) end do end function str_to_array !**************************************************************** !**************************************************************** !> !  LCM. based on code from NCAR Command Language pure integer ( ip ) function lcm ( i , j ) integer ( ip ), intent ( in ) :: i , j integer ( ip ) :: rem , m , n m = abs ( i ) n = abs ( j ) lcm = 0 if ( m <= 0 . or . n <= 0 ) return do rem = mod ( m , n ) if ( rem <= 0 ) exit m = n n = rem end do lcm = abs ( i * j / n ) end function lcm !**************************************************************** !**************************************************************** !> !  Reverse an ip vector pure function reverse ( ivals ) result ( ireverse ) integer ( ip ), dimension (:), intent ( in ) :: ivals integer ( ip ), dimension ( size ( ivals )) :: ireverse integer :: i ireverse = [( ivals ( i ), i = size ( ivals ), 1 , - 1 )] end function reverse !**************************************************************** !**************************************************************** !> !  Difference ip vector pure function diff ( ivals ) result ( idiff ) integer ( ip ), dimension (:), intent ( in ) :: ivals integer ( ip ), dimension (:), allocatable :: idiff integer :: i !! counter idiff = [( ivals ( i + 1 ) - ivals ( i ), i = 1 , size ( ivals ) - 1 )] end function diff !**************************************************************** ! the following routine is from the Fortran Astrodynamics Toolkit !***************************************************************************************** !> !  given a polygonal line connecting the vertices (x(i),y(i)) !  (i = 1,...,n) taken in this order. it is assumed that the !  polygonal path is a loop, where (x(n),y(n)) = (x(1),y(1)) !  or there is an arc from (x(n),y(n)) to (x(1),y(1)). ! !  (x0,y0) is an arbitrary point and l and m are variables. !  l and m are assigned the following values: ! !     l = -1   if (x0,y0) is outside the polygonal path !     l =  0   if (x0,y0) lies on the polygonal path !     l =  1   if (x0,y0) is inside the polygonal path ! !  m = 0 if (x0,y0) is on or outside the path. if (x0,y0) !  is inside the path then m is the winding number of the !  path around the point (x0,y0). ! !# History !  * Original version from the NSWC Library !  * Modified by J. Williams : 08/04/2012 : refactored to modern Fortran pure subroutine locpt ( x0 , y0 , x , y , n , l , m ) implicit none !arguments: integer , intent ( in ) :: n real ( wp ), intent ( in ) :: x0 real ( wp ), intent ( in ) :: y0 real ( wp ), dimension ( n ), intent ( in ) :: x real ( wp ), dimension ( n ), intent ( in ) :: y integer , intent ( out ) :: l integer , intent ( out ) :: m !constants: real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) real ( wp ), parameter :: pi = atan2 ( 0.0_wp , - 1.0_wp ) real ( wp ), parameter :: pi2 = 2.0_wp * pi real ( wp ), parameter :: tol = 4.0_wp * eps * pi !local variables: integer :: i , n0 real ( wp ) :: u , v , theta1 , sum , theta , angle , thetai n0 = n if ( x ( 1 ) == x ( n ) . and . y ( 1 ) == y ( n )) n0 = n - 1 l = - 1 m = 0 u = x ( 1 ) - x0 v = y ( 1 ) - y0 if ( u == 0.0_wp . and . v == 0.0_wp ) then l = 0 !(x0, y0) is on the boundary of the path else if ( n0 >= 2 ) then theta1 = atan2 ( v , u ) sum = 0.0_wp theta = theta1 do i = 2 , n0 u = x ( i ) - x0 v = y ( i ) - y0 if ( u == 0.0_wp . and . v == 0.0_wp ) then l = 0 !(x0, y0) is on the boundary of the path exit end if thetai = atan2 ( v , u ) angle = abs ( thetai - theta ) if ( abs ( angle - pi ) < tol ) then l = 0 !(x0, y0) is on the boundary of the path exit end if if ( angle > pi ) angle = angle - pi2 if ( theta > thetai ) angle = - angle sum = sum + angle theta = thetai end do if ( l /= 0 ) then angle = abs ( theta1 - theta ) if ( abs ( angle - pi ) < tol ) then l = 0 !(x0, y0) is on the boundary of the path else if ( angle > pi ) angle = angle - pi2 if ( theta > theta1 ) angle = - angle sum = sum + angle !sum = 2*pi*m where m is the winding number m = abs ( sum ) / pi2 + 0.2_wp if ( m /= 0 ) then l = 1 if ( sum < 0.0_wp ) m = - m end if end if end if end if end if end subroutine locpt !***************************************************************************************** !***************************************************************************************** !> !  given a sequence of nb points (x(i),y(i)). parea computes !  the area bounded by the closed polygonal curve which passes !  through the points in the order that they are indexed. the !  final point of the curve is assumed to be the first point !  given. therefore, it need not be listed at the end of x and !  y. the curve is not required to be simple. ! !  * Original version from the NSWC Library real ( wp ) function parea ( x , y , nb ) real ( wp ), intent ( in ) :: x ( nb ), y ( nb ) integer , intent ( in ) :: nb real ( wp ) :: a integer :: n , nm1 , i n = nb if ( x ( 1 ) == x ( n ) . and . y ( 1 ) == y ( n )) n = n - 1 if ( n - 3 < 0 ) then parea = 0.0_wp else if ( n - 3 == 0 ) then parea = 0.5_wp * (( x ( 2 ) - x ( 1 )) * ( y ( 3 ) - y ( 1 )) - ( x ( 3 ) - x ( 1 )) * ( y ( 2 ) - y ( 1 ))) else nm1 = n - 1 a = x ( 1 ) * ( y ( 2 ) - y ( n )) + x ( n ) * ( y ( 1 ) - y ( nm1 )) do i = 2 , nm1 a = a + x ( i ) * ( y ( i + 1 ) - y ( i - 1 )) end do parea = 0.5_wp * a end if end function parea !***************************************************************************************** !***************************************************************************************** !> !  Manhattan distance between two `ip` points. pure integer ( ip ) function manhatten_distance_64 ( x1 , y1 , x2 , y2 ) integer ( ip ), intent ( in ) :: x1 , y1 , x2 , y2 manhatten_distance_64 = abs ( x1 - x2 ) + abs ( y1 - y2 ) end function manhatten_distance_64 !***************************************************************************************** !***************************************************************************************** !> !  Convert a string to a numeric array by mapping characters to integers (user-specified) pure function str_to_int_array_with_mapping ( str , ichars , iints ) result ( array ) character ( len =* ), intent ( in ) :: str character ( len = 1 ), dimension (:), intent ( in ) :: ichars !! characters to process integer , dimension (:), intent ( in ) :: iints !! int values of the chars integer , dimension (:), allocatable :: array integer :: i integer , dimension ( 1 ) :: iloc allocate ( array ( len ( str ))) do i = 1 , len ( str ) iloc = findloc ( ichars , str ( i : i )) if ( iloc ( 1 ) > 0 ) then array ( i ) = iints ( iloc ( 1 )) else error stop 'error: could not map character: ' // str ( i : i ) end if end do end function str_to_int_array_with_mapping !***************************************************************************************** !***************************************************************************************** !> !  Convert a string to a numeric array by mapping characters to integers (user-specified) pure function str_to_int64_array_with_mapping ( str , ichars , iints ) result ( array ) character ( len =* ), intent ( in ) :: str character ( len = 1 ), dimension (:), intent ( in ) :: ichars !! characters to process integer ( ip ), dimension (:), intent ( in ) :: iints !! int values of the chars integer ( ip ), dimension (:), allocatable :: array integer :: i integer , dimension ( 1 ) :: iloc allocate ( array ( len ( str ))) do i = 1 , len ( str ) iloc = findloc ( ichars , str ( i : i )) if ( iloc ( 1 ) > 0 ) then array ( i ) = iints ( iloc ( 1 )) else error stop 'error: could not map character: ' // str ( i : i ) end if end do end function str_to_int64_array_with_mapping !***************************************************************************************** !***************************************************************************************** !> !!  hex string to int value. lowercase letters assumed! !!  no error checking here! pure integer function hex2int ( hex ) character ( len =* ), intent ( in ) :: hex integer :: i , n , ipower ! 70c71 -> 461937 n = len ( hex ) hex2int = 0 !base 16 (0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f) ipower = - 1 do i = n , 1 , - 1 ipower = ipower + 1 associate ( c => hex ( i : i )) if ( c >= 'a' . and . c <= 'f' ) then hex2int = hex2int + ( 10 + iachar ( c ) - iachar ( 'a' )) * ( 16 ** ipower ) else hex2int = hex2int + ( iachar ( c ) - iachar ( '0' )) * ( 16 ** ipower ) end if end associate end do end function hex2int !***************************************************************************************** !***************************************************************************************** !> !  inverse of a 2x2 matrix. ! !  See: https://caps.gsfc.nasa.gov/simpson/software/m22inv_f90.txt subroutine inverse ( a , ainv , status_ok ) real ( wp ), dimension ( 2 , 2 ), intent ( in ) :: a real ( wp ), dimension ( 2 , 2 ), intent ( out ) :: ainv logical , intent ( out ) :: status_ok real ( wp ), parameter :: eps = 1.0e-10_wp real ( wp ), dimension ( 2 , 2 ) :: cofactor associate ( det => a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 2 , 1 ) ) if ( abs ( det ) <= eps ) then ainv = 0.0_wp status_ok = . false . else cofactor ( 1 , 1 ) = + a ( 2 , 2 ) cofactor ( 1 , 2 ) = - a ( 2 , 1 ) cofactor ( 2 , 1 ) = - a ( 1 , 2 ) cofactor ( 2 , 2 ) = + a ( 1 , 1 ) ainv = transpose ( cofactor ) / det status_ok = . true . end if end associate end subroutine inverse !************************************************************************************************ !************************************************************************************************ !> !   Cross product of two real 3x1 vectors pure function cross ( r , v ) result ( c ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r real ( wp ), dimension ( 3 ), intent ( in ) :: v real ( wp ), dimension ( 3 ) :: c c ( 1 ) = r ( 2 ) * v ( 3 ) - v ( 2 ) * r ( 3 ) c ( 2 ) = r ( 3 ) * v ( 1 ) - v ( 3 ) * r ( 1 ) c ( 3 ) = r ( 1 ) * v ( 2 ) - v ( 1 ) * r ( 2 ) end function cross !************************************************************************************************ !************************************************************************************************ end module aoc_utilities !************************************************************************************************","tags":"","loc":"sourcefile/aoc_utilities.f90.html"},{"title":"fmin_module.F90 – AoC-2023","text":"Files dependent on this one sourcefile~~fmin_module.f90~~AfferentGraph sourcefile~fmin_module.f90 fmin_module.F90 sourcefile~nlesolver_module.f90 nlesolver_module.F90 sourcefile~nlesolver_module.f90->sourcefile~fmin_module.f90 sourcefile~test.f90 test.f90 sourcefile~test.f90->sourcefile~fmin_module.f90 sourcefile~nlesolver_test_1.f90 nlesolver_test_1.f90 sourcefile~nlesolver_test_1.f90->sourcefile~nlesolver_module.f90 sourcefile~sparse_test.f90 sparse_test.f90 sourcefile~sparse_test.f90->sourcefile~nlesolver_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  Module for [[fmin]] 1D derative-free function minimizer. ! !### License !  * [BSD-3](https://github.com/jacobwilliams/fmin/blob/master/LICENSE) ! !@note The default real kind (`wp`) can be !      changed using optional preprocessor flags. !      This library was built with real kind: #ifdef REAL32 !      `real(kind=real32)` [4 bytes] #elif REAL64 !      `real(kind=real64)` [8 bytes] #elif REAL128 !      `real(kind=real128)` [16 bytes] #else !      `real(kind=real64)` [8 bytes] #endif module fmin_module use iso_fortran_env implicit none private #ifdef REAL32 integer , parameter , public :: fmin_rk = real32 !! real kind used by this module [4 bytes] #elif REAL64 integer , parameter , public :: fmin_rk = real64 !! real kind used by this module [8 bytes] #elif REAL128 integer , parameter , public :: fmin_rk = real128 !! real kind used by this module [16 bytes] #else integer , parameter , public :: fmin_rk = real64 !! real kind used by this module [8 bytes] #endif integer , parameter :: wp = fmin_rk !! local copy of `fmin_rk` with a shorter name abstract interface function func ( x ) result ( f ) !! interface for user function import :: wp implicit none real ( wp ), intent ( in ) :: x !! indep. variable real ( wp ) :: f !! function value `f(x)` end function func end interface public :: fmin contains !***************************************************************************************** !***************************************************************************************** !> !  An approximation x to the point where `f` attains a minimum on !  the interval `(ax,bx)` is determined. ! !  the method used is a combination of golden section search and !  successive parabolic interpolation. convergence is never much slower !  than that for a fibonacci search. if `f` has a continuous second !  derivative which is positive at the minimum (which is not at `ax` or !  `bx`), then convergence is superlinear, and usually of the order of !  about 1.324. ! !  the function `f` is never evaluated at two points closer together !  than `eps*abs(fmin) + (tol/3)`, where `eps` is approximately the square !  root of the relative machine precision. if `f` is a unimodal !  function and the computed values of `f` are always unimodal when !  separated by at least `eps*abs(x) + (tol/3)`, then fmin approximates !  the abcissa of the global minimum of `f` on the interval `ax,bx` with !  an error less than `3*eps*abs(fmin) + tol`. if `f` is not unimodal, !  then `fmin` may approximate a local, but perhaps non-global, minimum to !  the same accuracy. ! !### Reference !  * Richard brent, \"algorithms for minimization without derivatives\", !    prentice - hall, inc. (1973). ! !### See also !  * [fmin from Netlib](http://www.netlib.org/fmm/fmin.f) function fmin ( f , ax , bx , tol ) result ( xmin ) implicit none procedure ( func ) :: f !! the function to minimize real ( wp ), intent ( in ) :: ax !! left endpoint of initial interval real ( wp ), intent ( in ) :: bx !! right endpoint of initial interval real ( wp ), intent ( in ) :: tol !! desired length of the interval of !! uncertainty of the final result (>=0) real ( wp ) :: xmin !! abcissa approximating the point where !! f attains a minimum real ( wp ) :: a , b , d , e , xm , p , q , r , tol1 , tol2 , u , v , w real ( wp ) :: fu , fv , fw , fx , x real ( wp ) :: abs , sqrt , sign real ( wp ), parameter :: c = ( 3.0_wp - sqrt ( 5.0_wp )) / 2.0_wp !! squared inverse of golden ratio real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: sqrteps = sqrt ( epsilon ( 1.0_wp )) ! initialization a = ax b = bx v = a + c * ( b - a ) w = v x = v e = 0.0_wp fx = f ( x ) fv = fx fw = fx do !  main loop starts here xm = half * ( a + b ) tol1 = sqrteps * abs ( x ) + tol / 3.0_wp tol2 = 2.0_wp * tol1 !  check stopping criterion if ( abs ( x - xm ) <= ( tol2 - half * ( b - a ))) then ! write(*,*) 'x             = ', x ! write(*,*) 'xm            = ', xm ! write(*,*) 'abs(x - xm)   = ', abs(x - xm) ! write(*,*) 'tol2          = ', tol2 ! write(*,*) 'half*(b - a)  = ', half*(b - a) exit end if ! is golden-section necessary if ( abs ( e ) <= tol1 ) then !  a golden-section step if ( x >= xm ) then e = a - x else e = b - x end if d = c * e else !  fit parabola r = ( x - w ) * ( fx - fv ) q = ( x - v ) * ( fx - fw ) p = ( x - v ) * q - ( x - w ) * r q = 2.0_wp * ( q - r ) if ( q > 0.0_wp ) p = - p q = abs ( q ) r = e e = d !  is parabola acceptable if (( abs ( p ) >= abs ( half * q * r )) . or . ( p <= q * ( a - x )) . or . ( p >= q * ( b - x ))) then !  a golden-section step if ( x >= xm ) then e = a - x else e = b - x end if d = c * e else !  a parabolic interpolation step d = p / q u = x + d !  f must not be evaluated too close to ax or bx if ((( u - a ) < tol2 ) . or . (( b - u ) < tol2 )) d = sign ( tol1 , xm - x ) end if end if !  f must not be evaluated too close to x if ( abs ( d ) >= tol1 ) then u = x + d else u = x + sign ( tol1 , d ) end if fu = f ( u ) !  update a, b, v, w, and x if ( fu <= fx ) then if ( u >= x ) a = x if ( u < x ) b = x v = w fv = fw w = x fw = fx x = u fx = fu else if ( u < x ) a = u if ( u >= x ) b = u if ( fu <= fw . or . w == x ) then v = w fv = fw w = u fw = fu else if ( fu <= fv . or . v == x . or . v == w ) then v = u fv = fu end if end if end do !  end of main loop xmin = x end function fmin !***************************************************************************************** !***************************************************************************************** end module fmin_module !*****************************************************************************************","tags":"","loc":"sourcefile/fmin_module.f90.html"},{"title":"test2.f90 – AoC-2023","text":"This file depends on sourcefile~~test2.f90~~EfferentGraph sourcefile~test2.f90 test2.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~test2.f90->sourcefile~kinds_module.f90 sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~test2.f90->sourcefile~numerical_differentiation_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~kinds_module.f90 sourcefile~cache_module.f90 cache_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~cache_module.f90 sourcefile~diff_module.f90 diff_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~diff_module.f90 sourcefile~dsm_module.f90 dsm_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~dsm_module.f90 sourcefile~utilities_module.f90 utilities_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~utilities_module.f90 sourcefile~cache_module.f90->sourcefile~kinds_module.f90 sourcefile~cache_module.f90->sourcefile~utilities_module.f90 sourcefile~diff_module.f90->sourcefile~kinds_module.f90 sourcefile~dsm_module.f90->sourcefile~kinds_module.f90 sourcefile~utilities_module.f90->sourcefile~kinds_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> author: Jacob Williams !  date: October 1, 2022 ! !  Test2 for the numerical differentiation module. !  Makes a plot of the errors using different methods and step sizes. program test2 use iso_fortran_env use numerical_differentiation_module use numdiff_kinds_module , only : wp use pyplot_module implicit none integer , parameter :: n = 1 !! number of variables integer , parameter :: m = 1 !! number of functions real ( wp ), dimension ( n ), parameter :: x = 1.0_wp !! point at which to compute the derivative real ( wp ), dimension ( n ), parameter :: xlow = - 10000 0.0_wp !! bounds not really needed real ( wp ), dimension ( n ), parameter :: xhigh = 10000 0.0_wp !! integer , parameter :: perturb_mode = 1 !! absolute step integer , parameter :: cache_size = 0 !! `0` indicates not to use cache integer , parameter :: sparsity_mode = 1 !! assume dense integer , dimension ( * ), parameter :: methods = [ 1 , 3 , 10 , 21 , 36 , 500 , 600 , 700 , 800 ] !! array of method IDs: !! [1,3,10,21,36,500,600,700,800] !! forward + all the central diff ones integer , parameter :: exp_star = - ceiling ( log10 ( epsilon ( 1.0_wp ))) !! exponent to start with integer , parameter :: exp_stop = - 2 !! exponent to end with integer , parameter :: exp_step = - 1 !! ecponent step integer , parameter :: exp_scale = 5 !! number of substeps from one to the next type ( numdiff_type ) :: my_prob !! main class to compute the derivatives integer :: i !! method counter integer :: j !! counter real ( wp ), dimension (:), allocatable :: jac !! jacobian integer :: func_evals !! function evaluation counter character ( len = :), allocatable :: error_msg !! error message string real ( wp ), dimension ( n ) :: dpert !! perturbation step size integer :: ipert !! perturbation step size counter real ( wp ) :: error !! diff from true derivative integer :: num_dperts !! number of dperts to test integer :: num_methods !! number of methods to test real ( wp ), dimension (:), allocatable :: results_dpert !! results array - dpert real ( wp ), dimension (:), allocatable :: results_errors !! results array - errors type ( pyplot ) :: plt !! for plotting the results character ( len = :), allocatable :: formula !! finite diff formula for the plot legend character ( len = :), allocatable :: name !! finite diff name for the plot legend integer :: idx !! index in results arrays character ( len = :), allocatable :: real_kind_str !! real kind for the plot title real ( wp ), dimension ( 3 ) :: color !! line color array real ( wp ), dimension ( 2 ) :: ylim !! plot y limit array ! size the arrays: num_methods = size ( methods ) num_dperts = size ([( i , i = exp_star * exp_scale , exp_stop * exp_scale , exp_step )]) allocate ( results_errors ( num_dperts )); results_errors = - huge ( 1.0_wp ) ! for plot title: select case ( wp ) case ( REAL32 ); real_kind_str = '[Single Precision]' case ( REAL64 ); real_kind_str = '[Double Precision]' case ( REAL128 ); real_kind_str = '[Quad Precision]' case default ; error stop 'Invalid real kind' end select ! initialize the plot: call plt % initialize ( grid = . true .,& figsize = [ 20 , 10 ],& axes_labelsize = 30 , & xtick_labelsize = 30 , & ytick_labelsize = 30 , & font_size = 30 , & xlabel = 'Finite Difference Perturbation Step Size $h$' ,& ylabel = 'Finite Difference Derivative Error' ,& title = 'Derivative of $x + \\sin(x)$ at $x=1$ ' // real_kind_str ,& legend = . true ., & legend_fontsize = 10 ,& usetex = . true .) ! try different finite diff methods do j = 1 , size ( methods ) idx = 0 i = methods ( j ) ! method id call get_finite_diff_formula ( i , formula , name ) ! cycle through perturbation step sizes: do ipert = exp_star * exp_scale , exp_stop * exp_scale , exp_step idx = idx + 1 ! index for arrays dpert = 1 0.0_wp ** ( - ipert / real ( exp_scale , wp )) ! compute perturbation step size if ( j == 1 ) then if (. not . allocated ( results_dpert )) allocate ( results_dpert ( 0 )) results_dpert = [ results_dpert , dpert ( 1 )] ! save dpert end if func_evals = 0 call my_prob % destroy () call my_prob % initialize ( n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func = my_func ,& sparsity_mode = sparsity_mode ,& jacobian_method = i ,& partition_sparsity_pattern = . false .,& cache_size = cache_size ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) error stop error_msg end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) error stop error_msg end if error = abs ( deriv ( x ( 1 )) - jac ( 1 )) !write(output_unit,'(I5,1X,*(F27.16))') i , dpert, error if ( error <= epsilon ( 1.0_wp )) error = 0.0_wp results_errors ( idx ) = error ! save result end do ! line color for the plot: select case ( j ) case ( 1 ); color = [ 1.0_wp , 0.0_wp , 0.0_wp ] ! red case ( 2 ); color = [ 0.0_wp , 1.0_wp , 0.0_wp ] ! green case default ! blue gradient for the others color = [ real ( j - 2 , wp ) / num_methods , & real ( j - 2 , wp ) / num_methods , & 0.9_wp ] end select ylim = [ 1 0.0_wp ** ( ceiling ( log10 ( epsilon ( 1.0_wp )))), 1.0_wp ] ! plot for this method: call plt % add_plot ( results_dpert , results_errors ,& xscale = 'log' , yscale = 'log' ,& label = formula , linestyle = '.-' , markersize = 5 , linewidth = 2 , & color = color ,& xlim = ylim ,& ylim = ylim ) end do ! save plot: call plt % savefig ( 'results ' // real_kind_str // '.pdf' , pyfile = 'results.py' ) contains function func ( x ) !! Problem function real ( wp ), intent ( in ) :: x real ( wp ) :: func func = x + sin ( x ) end function func function deriv ( x ) !! Problem function true derivative real ( wp ), intent ( in ) :: x real ( wp ) :: deriv deriv = 1.0_wp + cos ( x ) end function deriv subroutine my_func ( me , x , f , funcs_to_compute ) !! Problem function interface for numdiff class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f integer , dimension (:), intent ( in ) :: funcs_to_compute if ( any ( funcs_to_compute == 1 )) f ( 1 ) = func ( x ( 1 )) func_evals = func_evals + 1 end subroutine my_func !******************************************************************************* end program test2 !*******************************************************************************","tags":"","loc":"sourcefile/test2.f90.html"},{"title":"cache_module.f90 – AoC-2023","text":"This file depends on sourcefile~~cache_module.f90~~EfferentGraph sourcefile~cache_module.f90 cache_module.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~cache_module.f90->sourcefile~kinds_module.f90 sourcefile~utilities_module.f90 utilities_module.f90 sourcefile~cache_module.f90->sourcefile~utilities_module.f90 sourcefile~utilities_module.f90->sourcefile~kinds_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~cache_module.f90~~AfferentGraph sourcefile~cache_module.f90 cache_module.f90 sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~cache_module.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~numerical_differentiation_module.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~numerical_differentiation_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> author: Jacob Williams ! !  For caching function evaluations. module numdiff_cache_module use iso_fortran_env , only : ip => int64 ! same number of bits as real(wp) use numdiff_kinds_module use numdiff_utilities_module , only : unique implicit none private type :: fx !! an [x,f(x)] cached pair. private real ( wp ), dimension (:), allocatable :: x !! vector of input values real ( wp ), dimension (:), allocatable :: f !! vector of output functions `f(x)` !! note: only the elements indicated by `ifs` !! will have valid values. The others will !! be dummy values. integer , dimension (:), allocatable :: ifs !! elements of `f` present in the cache !! (this is just an array of the indices !! present in `f`) end type fx type , public :: function_cache !! a vector function cache. private integer :: n = 0 !! size of `x` integer :: m = 0 !! size of `f` type ( fx ), dimension (:), allocatable :: c !! the cache of `f(x)` integer :: chunk_size = 100 !! for resizing vectors !! in the [[unique]] function contains private procedure , public :: initialize => initialize_cache procedure , public :: get => get_from_cache procedure , public :: put => put_in_cache procedure , public :: destroy => destroy_cache procedure , public :: print => print_cache end type function_cache contains !******************************************************************************* !******************************************************************************* !> !  Initialize the cache. Must be called first before use. subroutine initialize_cache ( me , isize , n , m , chunk_size ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: isize !! the size of the hash table integer , intent ( in ) :: n !! number of independant variables (x) integer , intent ( in ) :: m !! number of functions (f) integer , intent ( in ), optional :: chunk_size !! chunk size to speed up reallocation !! of arrays. A good value is a guess for !! the actual number of elements of `f` that !! will be saved per value of `x` [default is 100] call me % destroy () allocate ( me % c ( 0 : isize - 1 )) me % n = n me % m = m if ( present ( chunk_size )) then me % chunk_size = chunk_size else me % chunk_size = 100 end if end subroutine initialize_cache !******************************************************************************* !******************************************************************************* !> !  Print the contents of the cache. Used for debugging. subroutine print_cache ( me , iunit ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: iunit !! file unit for writing !! (assumed to be opened) integer :: i !! counter write ( iunit , '(A)' ) '' write ( iunit , '(A)' ) '------------------------' if ( allocated ( me % c )) then do i = 1 , size ( me % c ) if ( allocated ( me % c ( i )% x )) then write ( iunit , '(A)' ) '' write ( iunit , '(A,1X,I10)' ) 'Entry ' , i write ( iunit , '(A,1X,*(F27.16,1X))' ) 'x  :' , me % c ( i )% x if ( allocated ( me % c ( i )% f )) then write ( iunit , '(A,1X,*(I27,1X))' ) 'ifs:' , me % c ( i )% ifs write ( iunit , '(A,1X,*(F27.16,1X))' ) 'f  :' , me % c ( i )% f ( me % c ( i )% ifs ) end if write ( iunit , '(A)' ) '------------------------' end if end do else write ( iunit , '(A)' ) 'Cache is not initialized' write ( iunit , '(A)' ) '------------------------' end if write ( iunit , '(A)' ) '' end subroutine print_cache !******************************************************************************* !******************************************************************************* !> !  Check if the `x` vector is in the cache, if so return `f`. !  Note that only some of the elements may be present, so it will return !  the ones there are there, and indicate which ones were found. subroutine get_from_cache ( me , x , ifs , i , f , xfound , ffound ) implicit none class ( function_cache ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! independant variable vector integer , dimension (:), intent ( in ) :: ifs !! elements of `f` needed integer , intent ( out ) :: i !! index in the hash table real ( wp ), dimension (:), intent ( out ) :: f !! `f(x)` from the cache (if it was found) logical , intent ( out ) :: xfound !! if `x` was found in the cache logical , dimension ( size ( ifs )), intent ( out ) :: ffound !! which `ifs` were found in the cache integer :: j !! counter ! initialize: xfound = . false . ffound = . false . if ( allocated ( me % c )) then ! get index in the hash table: i = mod ( abs ( vector_djb_hash ( x )), int ( size ( me % c ), ip ) ) ! check the table: if ( allocated ( me % c ( i )% x ) . and . allocated ( me % c ( i )% f )) then if ( size ( me % c ( i )% x ) == size ( x ) . and . & size ( me % c ( i )% f ) == size ( f )) then if ( all ( me % c ( i )% x == x )) then xfound = . true . ! return the elements that were found in the cache: f ( me % c ( i )% ifs ) = me % c ( i )% f ( me % c ( i )% ifs ) ! what indices are in the cache? do j = 1 , size ( ifs ) ffound ( j ) = any ( ifs ( j ) == me % c ( i )% ifs ) end do end if end if end if else error stop 'Error: the cache has not been initialized.' end if end subroutine get_from_cache !******************************************************************************* !******************************************************************************* !> !  Put a value into the cache. subroutine put_in_cache ( me , i , x , f , ifs ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: i !! index in the hash table real ( wp ), dimension (:), intent ( in ) :: x !! independant variable vector (dimension `n`) real ( wp ), dimension (:), intent ( in ) :: f !! function vector `f(x)` (dimension `m`) integer , dimension (:), intent ( in ) :: ifs !! elements of `f` to add (should all be `>0, <=m`) real ( wp ), parameter :: null = huge ( 1.0_wp ) !! an unusual value to initialize arrays if ( allocated ( me % c )) then if ( i <= size ( me % c )) then if ( allocated ( me % c ( i )% x )) then ! we need to check if there is an x already there, ! which may already have some function indices present. ! if same x, then add the new indices to them. ! if a different x, then replace indices. if ( all ( me % c ( i )% x == x )) then ! this x is already present in this location. ! so merge the new f,ifs into what is already there. if ( allocated ( me % c ( i )% f )) then me % c ( i )% ifs = unique ([ me % c ( i )% ifs , ifs ],& chunk_size = me % chunk_size ) else allocate ( me % c ( i )% f ( me % m )) me % c ( i )% f = null ! initialize to an unusual value me % c ( i )% ifs = ifs end if me % c ( i )% f ( ifs ) = f ( ifs ) else ! replace existing x and f. me % c ( i )% x = x me % c ( i )% ifs = ifs if ( allocated ( me % c ( i )% f )) deallocate ( me % c ( i )% f ) allocate ( me % c ( i )% f ( me % m )) me % c ( i )% f = null ! initialize to an unusual value me % c ( i )% f ( ifs ) = f ( ifs ) end if else ! new entry in the cache: me % c ( i )% x = x allocate ( me % c ( i )% f ( me % m )) me % c ( i )% f = null ! initialize to an unusual value me % c ( i )% ifs = ifs me % c ( i )% f ( ifs ) = f ( ifs ) end if else error stop 'Error: invalid index in hash table.' end if else error stop 'Error: the cache has not been initialized.' end if end subroutine put_in_cache !******************************************************************************* !******************************************************************************* !> !  Destroy a cache. subroutine destroy_cache ( me ) implicit none class ( function_cache ), intent ( out ) :: me end subroutine destroy_cache !******************************************************************************* !******************************************************************************* !> !  DJB hash algorithm for a `real(wp)` vector. ! !### See also !  * J. Shahbazian, Fortran hashing algorithm, July 6, 2013 !   [Fortran Dev](https://fortrandev.wordpress.com/2013/07/06/fortran-hashing-algorithm/) pure function vector_djb_hash ( r ) result ( hash ) real ( wp ), dimension (:), intent ( in ) :: r !! the vector integer ( ip ) :: hash !! the hash value integer :: i !! counter hash = 5381_ip do i = 1 , size ( r ) hash = ishft ( hash , 5_ip ) + hash + transfer ( r ( i ), 1_ip ) end do end function vector_djb_hash !******************************************************************************* !******************************************************************************* end module numdiff_cache_module !*******************************************************************************","tags":"","loc":"sourcefile/cache_module.f90.html"},{"title":"sparse_test.f90 – AoC-2023","text":"This file depends on sourcefile~~sparse_test.f90~~EfferentGraph sourcefile~sparse_test.f90 sparse_test.f90 sourcefile~nlesolver_module.f90 nlesolver_module.F90 sourcefile~sparse_test.f90->sourcefile~nlesolver_module.f90 sourcefile~fmin_module.f90 fmin_module.F90 sourcefile~nlesolver_module.f90->sourcefile~fmin_module.f90 sourcefile~lsqr.f90 lsqr.f90 sourcefile~nlesolver_module.f90->sourcefile~lsqr.f90 sourcefile~lusol_ez.f90 lusol_ez.f90 sourcefile~nlesolver_module.f90->sourcefile~lusol_ez.f90 sourcefile~lsqr_kinds.f90 lsqr_kinds.F90 sourcefile~lsqr.f90->sourcefile~lsqr_kinds.f90 sourcefile~lsqrblas.f90 lsqrblas.f90 sourcefile~lsqr.f90->sourcefile~lsqrblas.f90 sourcefile~lusol.f90 lusol.f90 sourcefile~lusol_ez.f90->sourcefile~lusol.f90 sourcefile~lusol_precision.f90 lusol_precision.F90 sourcefile~lusol_ez.f90->sourcefile~lusol_precision.f90 sourcefile~lsqrblas.f90->sourcefile~lsqr_kinds.f90 sourcefile~lusol.f90->sourcefile~lusol_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !****************************************************************************************************** !> !  Test of a sparse problem. program sparse_test use nlesolver_module , wp => nlesolver_rk implicit none integer , parameter :: n = 2 integer , parameter :: m = 2 integer , parameter :: max_iter = 100 real ( wp ), parameter :: tol = 1.0e-8_wp logical , parameter :: verbose = . false . type ( nlesolver_type ) :: solver real ( wp ) :: alpha logical :: use_broyden integer :: step_mode integer :: n_intervals integer :: istat !! Integer status code. character ( len = :), allocatable :: message !! Text status message real ( wp ), dimension ( n ) :: x integer :: f_evals integer :: i character ( len = :), allocatable :: description real ( wp ) :: fmin_tol integer , dimension ( 3 ), parameter :: icol = [ 1 , 2 , 2 ] integer , dimension ( 3 ), parameter :: irow = [ 1 , 1 , 2 ] fmin_tol = 1.0e-2_wp ! don't need a tight tol for this n_intervals = 2 alpha = 1.0_wp write ( * , * ) '' write ( * , * ) '***********************' write ( * , * ) '* sparse_test         *' write ( * , * ) '***********************' write ( * , * ) '' do i = 1 , 8 select case ( i ) case ( 1 ) step_mode = 1 use_broyden = . false . f_evals = 0 description = 'Constant alpha' case ( 2 ) cycle ! not yet supported step_mode = 1 use_broyden = . true . f_evals = 0 description = 'Constant alpha + broyden' case ( 3 ) step_mode = 2 use_broyden = . false . f_evals = 0 description = 'Backtracking line search' case ( 4 ) cycle ! not yet supported step_mode = 2 use_broyden = . true . f_evals = 0 description = 'Backtracking line search + broyden' case ( 5 ) step_mode = 3 use_broyden = . false . f_evals = 0 description = 'Exact line search' case ( 6 ) cycle ! not yet supported step_mode = 3 use_broyden = . true . f_evals = 0 description = 'Exact line search + broyden' case ( 7 ) step_mode = 4 use_broyden = . false . f_evals = 0 description = 'Fixed point search' case ( 8 ) cycle ! not yet supported step_mode = 4 use_broyden = . true . f_evals = 0 description = 'Fixed point search + broyden' case default error stop 'invalid case' end select write ( * , * ) '-------------------------------------------------------' write ( * , '(A,I3,A,A)' ) 'Case ' , i , ' : ' , description write ( * , * ) '' call solver % initialize ( n = n , & m = m , & max_iter = max_iter , & tol = tol , & func = func , & grad_sparse = grad_sparse , & step_mode = step_mode ,& use_broyden = use_broyden ,& export_iteration = export ,& n_intervals = n_intervals , & fmin_tol = fmin_tol , & verbose = verbose ,& sparsity_mode = 3 ,& irow = irow ,& icol = icol ,& damp = 1.0_wp ) call solver % status ( istat , message ) write ( * , '(I3,1X,A)' ) istat , message if ( istat /= 0 ) error stop x = [ 1.0_wp , 2.0_wp ] call solver % solve ( x ) call solver % status ( istat , message ) write ( * , '(I3,1X,A)' ) istat , message write ( * , * ) '' end do contains subroutine func ( me , x , f ) !! compute the function implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f f_evals = f_evals + 1 f ( 1 ) = x ( 1 ) ** 2 + x ( 2 ) - 0.1_wp f ( 2 ) = x ( 2 ) + 0.2_wp ! root is 5.477226E-01  -2.000000E-01 end subroutine func subroutine grad ( me , x , g ) !! compute the gradient of the function (Jacobian): implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:,:), intent ( out ) :: g f_evals = f_evals + 2 ! to approximate forward diff derivatives g ( 1 , 1 ) = 2.0_wp * x ( 1 ) !df(1)/dx g ( 2 , 1 ) = 0.0_wp !df(2)/dx g ( 1 , 2 ) = 1.0_wp !df(1)/dy g ( 2 , 2 ) = 1.0_wp !df(2)/dy end subroutine grad subroutine grad_sparse ( me , x , g ) !! compute the gradient of the function (Jacobian): implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: g real ( wp ), dimension ( m , n ) :: g_dense ! for this example, just convert the dense ! jacobian to the sparse representation call grad ( me , x , g_dense ) g ( 1 ) = g_dense ( 1 , 1 ) g ( 2 ) = g_dense ( 1 , 2 ) g ( 3 ) = g_dense ( 2 , 2 ) f_evals = f_evals + 2 ! to approximate forward diff derivatives end subroutine grad_sparse subroutine export ( me , x , f , iter ) !! export an iteration: implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: f integer , intent ( in ) :: iter !! iteration number write ( * , '(1P,I3,1X,A,I3,A,*(E15.6))' ) iter , '(' , f_evals , ')' , x , norm2 ( f ) end subroutine export !****************************************************************************************************** end program sparse_test !******************************************************************************************************","tags":"","loc":"sourcefile/sparse_test.f90.html"},{"title":"dag_example.f90 – AoC-2023","text":"This file depends on sourcefile~~dag_example.f90~~EfferentGraph sourcefile~dag_example.f90 dag_example.f90 sourcefile~dag_module.f90 dag_module.f90 sourcefile~dag_example.f90->sourcefile~dag_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> !  DAG module test program. program dag_example use dag_module implicit none type ( dag ) :: d integer , dimension (:), allocatable :: order integer :: istat integer :: i , r , c logical , dimension (:,:), allocatable :: mat !! dependency matrix integer , parameter :: n_nodes = 6 character ( len =* ), parameter :: filetype = 'pdf' !! filetype for output plot ('pdf', png', etc.) ! TODO combine set_edges and set_vertex_info into one routine maybe. call d % set_vertices ( n_nodes ) call d % set_edges ( 2 ,[ 1 ]) !2 depends on 1 call d % set_edges ( 3 ,[ 5 , 1 ]) !3 depends on 5 and 1 call d % set_edges ( 4 ,[ 5 ]) !4 depends on 5 call d % set_edges ( 5 ,[ 2 ]) !5 depends on 2 call d % set_edges ( 6 ,[ 2 , 4 ]) !6 depends on 2 and 4 call d % toposort ( order , istat ) write ( * , * ) '' write ( * , * ) 'istat=' , istat write ( * , * ) 'order=' , order ! prints 1,2,5,3,4 do i = 1 , n_nodes if ( i == 3 . or . i == 6 ) then call d % set_vertex_info ( i , attributes = 'shape=square,fillcolor=\"SlateGray1\",style=filled' ) else call d % set_vertex_info ( i , attributes = 'shape=circle,fillcolor=\"cornsilk\",style=filled' ) end if end do write ( * , * ) '' write ( * , * ) 'diagraph:' write ( * , * ) '' call d % save_digraph ( 'test.dot' , 'RL' , 300 ) call execute_command_line ( 'cat test.dot' ) call execute_command_line ( 'dot -T' // filetype // ' -o test.' // filetype // ' test.dot' ) write ( * , * ) '' write ( * , * ) 'dependency matrix:' write ( * , * ) '' call d % generate_dependency_matrix ( mat ) do r = 1 , n_nodes do c = 1 , n_nodes if ( mat ( r , c )) then write ( * , '(A)' , advance = 'NO' ) 'X' else write ( * , '(A)' , advance = 'NO' ) 'O' end if end do write ( * , '(A)' ) '' end do ! cleanup: call d % destroy () end program dag_example !*******************************************************************************","tags":"","loc":"sourcefile/dag_example.f90.html"},{"title":"problem_13.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_13.f90~~EfferentGraph sourcefile~problem_13.f90 problem_13.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_13.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_13 use iso_fortran_env use aoc_utilities implicit none integer :: i , iunit , iline , n_lines , ival , isum , ival2 , isum2 , & m , n , nrows , ncols , ileft , iabove , ileft2 , iabove2 type ( string ), dimension (:), allocatable :: lines integer , dimension (:,:), allocatable :: puzzle , puzzle2 character ( len = :), allocatable :: line integer , parameter :: ASH = 0 !! . integer , parameter :: ROCK = 1 !! # call clk % tic () ! open(newunit=iunit, file='inputs/day13_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day13.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 isum2 = 0 do iline = 1 , n_lines line = read_line ( iunit ) if ( line == '' . or . iline == n_lines ) then ! process this puzzle ! convert the puzzle to a numeric matrix: if ( allocated ( puzzle )) deallocate ( puzzle ) nrows = size ( lines ) ncols = len ( lines ( 1 )% str ) allocate ( puzzle ( nrows , ncols )) do i = 1 , nrows puzzle ( i ,:) = str_to_int_array_with_mapping ( lines ( i )% str , [ '.' , '#' ], [ ASH , ROCK ]) end do ! part 1 call go ( puzzle , ileft ) call go ( transpose ( puzzle ), iabove ) ival = ileft + 100 * iabove isum = isum + ival ! part 2 main : do m = 1 , nrows do n = 1 , ncols ! permute each with a smudge and find the different non-zero value puzzle2 = puzzle if ( puzzle ( m , n ) == ASH ) then puzzle2 ( m , n ) = ROCK else puzzle2 ( m , n ) = ASH end if ! don't consider the one from part a (since that one still may be valid) call go ( puzzle2 , ileft2 , iskip = ileft ) call go ( transpose ( puzzle2 ), iabove2 , iskip = iabove ) if (( ileft2 /= ileft . or . iabove2 /= iabove ) . and . ( ileft2 /= 0 . or . iabove2 /= 0 )) then ival = ileft2 + 100 * iabove2 ! found it exit main end if end do end do main isum2 = isum2 + ival deallocate ( lines ) else ! accumulate this line in the current puzzle if (. not . allocated ( lines )) allocate ( lines ( 0 )) lines = [ lines , string ( line )] end if end do write ( * , * ) '13a: ' , isum write ( * , * ) '13b: ' , isum2 call clk % toc ( '13' ) contains subroutine go ( puzzle , ileft , iskip ) !! compute the number of cols to left of mirror (0 if none) !! call with transpose(puzzle) to get number of rows above. integer , dimension (:,:), intent ( in ) :: puzzle integer , intent ( out ) :: ileft integer , intent ( in ), optional :: iskip !! don't consider this column integer :: nrows , ncols , i , j logical :: mirror nrows = size ( puzzle , 1 ) ncols = size ( puzzle , 2 ) ileft = 0 do i = 1 , ncols - 1 if ( present ( iskip )) then if ( i == iskip ) cycle end if mirror = . true . do j = 1 , min ( i , ncols - i ) if ( any ( puzzle (:, i - j + 1 ) /= puzzle (:, i + j )) ) then mirror = . false . ! no mirror on this line exit end if end do if ( mirror ) then ileft = i exit end if end do end subroutine go end program problem_13","tags":"","loc":"sourcefile/problem_13.f90.html"},{"title":"problem_07.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_07.f90~~EfferentGraph sourcefile~problem_07.f90 problem_07.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_07.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_7 use iso_fortran_env use aoc_utilities implicit none integer :: i , iunit , n_lines , icase character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals logical :: done type :: hand character ( len = 1 ), dimension ( 5 ) :: cards !! the cards in a hand integer ( ip ) :: bid = 0 ! the bit for the hand integer :: type = 0 ! the hand type end type hand type ( hand ), dimension (:), allocatable :: hands !! array of hands character ( len = 1 ), dimension ( 2 ), parameter :: cases = [ 'a' , 'b' ] character ( len = 1 ), dimension ( * ), parameter :: cards = [ 'A' , 'K' , 'Q' , 'J' , 'T' , & '9' , '8' , '7' , '6' , '5' , & '4' , '3' , '2' ] character ( len = 1 ), dimension ( * ), parameter :: cards_with_joker = [ 'A' , 'K' , 'Q' , 'T' , & '9' , '8' , '7' , '6' , '5' , & '4' , '3' , '2' , 'J' ] integer , parameter :: FIVE_OF_A_KIND = 1 ! the hand types integer , parameter :: FOUR_OF_A_KIND = 2 integer , parameter :: FULL_HOUSE = 3 integer , parameter :: THREE_OF_A_KIND = 4 integer , parameter :: TWO_PAIR = 5 integer , parameter :: ONE_PAIR = 6 integer , parameter :: HIGH_CARD = 7 call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day7_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day7.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( hands ( n_lines )) do i = 1 , n_lines line = read_line ( iunit ); vals = split ( line , ' ' ) hands ( i )% cards = str_to_array ( vals ( 1 )% str ) hands ( i )% bid = int ( vals ( 2 )) end do close ( iunit ) do icase = 1 , 2 ! first time normally, second time processing the jokers ! sort the list from worst to best to determinte the rank of each hand hands % type = 0 ! reinitialize since they need to be recomputed do ! bubble sort ! done = . true . do i = 1 , n_lines - 1 if ( beats ( hands ( i ), hands ( i + 1 ), icase == 2 )) then call swap_hands ( hands ( i ), hands ( i + 1 )); done = . false . end if end do if ( done ) exit end do write ( * , * ) '7' // cases ( icase ) // ':' , sum ( hands % bid * [( i , i = 1 , n_lines )]) end do call clk % toc ( '7' ) contains integer function hand_type ( me , with_jokers ) !! returns the type of hand class ( hand ), intent ( in ) :: me logical , intent ( in ) :: with_jokers !! if considering jokers integer , dimension ( 5 ) :: i integer , dimension (:), allocatable :: u integer :: n_jokers , n_unique character ( len = 1 ), dimension ( 5 ) :: h h = me % cards i = ichar ( h ) ! convert to code u = unique ( i ) ! unique elements n_unique = size ( u ) if ( with_jokers . and . any ( h == 'J' )) then ! have to pick best hand for all jokers ! just do it by inspection n_jokers = count ( h == 'J' ) select case ( n_jokers ) case ( 5 ) hand_type = FIVE_OF_A_KIND !jjjjj case ( 4 ) hand_type = FIVE_OF_A_KIND !jjjja case ( 3 ) ! can always turn to 4 or 5 of a kind if ( n_unique == 2 ) then !jjjaa hand_type = FIVE_OF_A_KIND else ! jjjab hand_type = FOUR_OF_A_KIND end if case ( 2 ) if ( n_unique == 2 ) then !jjaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then !jjaab hand_type = FOUR_OF_A_KIND else !jjabc hand_type = THREE_OF_A_KIND end if case ( 1 ) if ( n_unique == 2 ) then !jaaaa hand_type = FIVE_OF_A_KIND else if ( n_unique == 3 ) then if ( any ([ count ( i == u ( 1 )) == 3 , & count ( i == u ( 2 )) == 3 , & count ( i == u ( 3 )) == 3 ]) ) then !jaaab hand_type = FOUR_OF_A_KIND elseif ( ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 ) . or . & ( count ( i == u ( 2 )) == 2 . and . count ( i == u ( 2 )) == 2 ) ) then !jaabb hand_type = FULL_HOUSE end if else if ( n_unique == 4 ) then !jaabc hand_type = THREE_OF_A_KIND else if ( n_unique == 5 ) then !jabcd hand_type = ONE_PAIR end if end select else !Every hand is exactly one type. From strongest to weakest, they are: select case ( n_unique ) case ( 1 ) ! aaaaa hand_type = FIVE_OF_A_KIND case ( 2 ) ! aaaab, aaabb if (( count ( i == u ( 1 )) == 4 . and . count ( i == u ( 2 )) == 1 ) . or . & ( count ( i == u ( 1 )) == 1 . and . count ( i == u ( 2 )) == 4 ) ) then hand_type = FOUR_OF_A_KIND else if (( count ( i == u ( 1 )) == 3 . and . count ( i == u ( 2 )) == 2 ) . or . & ( count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 3 ) ) then hand_type = FULL_HOUSE end if case ( 3 ) ! aaabc, aabcc if ( any ([ count ( i == u ( 1 )) == 3 , count ( i == u ( 2 )) == 3 , count ( i == u ( 3 )) == 3 ]) ) then hand_type = THREE_OF_A_KIND else if ( any ([ count ( i == u ( 1 )) == 2 . and . count ( i == u ( 2 )) == 2 , & count ( i == u ( 1 )) == 2 . and . count ( i == u ( 3 )) == 2 , & count ( i == u ( 2 )) == 2 . and . count ( i == u ( 3 )) == 2 ]) ) then hand_type = TWO_PAIR end if case ( 4 ) !aabcd hand_type = ONE_PAIR case ( 5 ) !abcde hand_type = HIGH_CARD ! High card, where all cards' labels are distinct: 23456 end select end if end function hand_type logical function beats ( hand1 , hand2 , with_jokers ) !! return true if hand1 beats hand2 (has a higher score) class ( hand ), intent ( inout ) :: hand1 , hand2 logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i associate ( h1 => hand1 % cards , h2 => hand2 % cards ) ! recompute type if it hasn't already been computed if ( hand1 % type == 0 ) hand1 % type = hand_type ( hand1 , with_jokers ) if ( hand2 % type == 0 ) hand2 % type = hand_type ( hand2 , with_jokers ) if ( hand1 % type == hand2 % type ) then ! lower index is stronger do i = 1 , 5 if ( h1 ( i ) /= h2 ( i )) then beats = index_in_cards ( h1 ( i ), with_jokers ) < & index_in_cards ( h2 ( i ), with_jokers ) ! lower is stronger return end if end do else ! one hand beat the other beats = hand1 % type < hand2 % type ! lower score is better (1-7) end if end associate end function beats integer function index_in_cards ( c , with_jokers ) character ( len = 1 ), intent ( in ) :: c logical , intent ( in ) :: with_jokers !! if considering jokers integer :: i do i = 1 , size ( cards_with_joker ) if ( with_jokers ) then if ( c == cards_with_joker ( i )) then index_in_cards = i return end if else if ( c == cards ( i )) then index_in_cards = i return end if end if end do error stop 'card not found' end function index_in_cards pure elemental subroutine swap_hands ( i1 , i2 ) !! swap function for hand type type ( hand ), intent ( inout ) :: i1 type ( hand ), intent ( inout ) :: i2 type ( hand ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_hands end program problem_7","tags":"","loc":"sourcefile/problem_07.f90.html"},{"title":"nlesolver_test_1.f90 – AoC-2023","text":"This file depends on sourcefile~~nlesolver_test_1.f90~~EfferentGraph sourcefile~nlesolver_test_1.f90 nlesolver_test_1.f90 sourcefile~nlesolver_module.f90 nlesolver_module.F90 sourcefile~nlesolver_test_1.f90->sourcefile~nlesolver_module.f90 sourcefile~fmin_module.f90 fmin_module.F90 sourcefile~nlesolver_module.f90->sourcefile~fmin_module.f90 sourcefile~lsqr.f90 lsqr.f90 sourcefile~nlesolver_module.f90->sourcefile~lsqr.f90 sourcefile~lusol_ez.f90 lusol_ez.f90 sourcefile~nlesolver_module.f90->sourcefile~lusol_ez.f90 sourcefile~lsqr_kinds.f90 lsqr_kinds.F90 sourcefile~lsqr.f90->sourcefile~lsqr_kinds.f90 sourcefile~lsqrblas.f90 lsqrblas.f90 sourcefile~lsqr.f90->sourcefile~lsqrblas.f90 sourcefile~lusol.f90 lusol.f90 sourcefile~lusol_ez.f90->sourcefile~lusol.f90 sourcefile~lusol_precision.f90 lusol_precision.F90 sourcefile~lusol_ez.f90->sourcefile~lusol_precision.f90 sourcefile~lsqrblas.f90->sourcefile~lsqr_kinds.f90 sourcefile~lusol.f90->sourcefile~lusol_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !****************************************************************************************************** !> !  Test of a small, square (`n=m`) problem. program nlesolver_test_1 use nlesolver_module , wp => nlesolver_rk implicit none integer , parameter :: n = 2 integer , parameter :: m = 2 integer , parameter :: max_iter = 100 real ( wp ), parameter :: tol = 1.0e-8_wp logical , parameter :: verbose = . false . type ( nlesolver_type ) :: solver real ( wp ) :: alpha logical :: use_broyden integer :: step_mode integer :: n_intervals integer :: istat !! Integer status code. character ( len = :), allocatable :: message !! Text status message real ( wp ), dimension ( n ) :: x integer :: f_evals integer :: i character ( len = :), allocatable :: description real ( wp ) :: fmin_tol fmin_tol = 1.0e-2_wp ! don't need a tight tol for this n_intervals = 2 alpha = 1.0_wp write ( * , * ) '' write ( * , * ) '***********************' write ( * , * ) '* nlesolver_test_1    *' write ( * , * ) '***********************' write ( * , * ) '' do i = 1 , 8 select case ( i ) case ( 1 ) step_mode = 1 use_broyden = . false . f_evals = 0 description = 'Constant alpha' case ( 2 ) step_mode = 1 use_broyden = . true . f_evals = 0 description = 'Constant alpha + broyden' case ( 3 ) step_mode = 2 use_broyden = . false . f_evals = 0 description = 'Backtracking line search' case ( 4 ) step_mode = 2 use_broyden = . true . f_evals = 0 description = 'Backtracking line search + broyden' case ( 5 ) step_mode = 3 use_broyden = . false . f_evals = 0 description = 'Exact line search' case ( 6 ) step_mode = 3 use_broyden = . true . f_evals = 0 description = 'Exact line search + broyden' case ( 7 ) step_mode = 4 use_broyden = . false . f_evals = 0 description = 'Fixed point search' case ( 8 ) step_mode = 4 use_broyden = . true . f_evals = 0 description = 'Fixed point search + broyden' case default error stop 'invalid case' end select write ( * , * ) '-------------------------------------------------------' write ( * , '(A,I3,A,A)' ) 'Case ' , i , ' : ' , description write ( * , * ) '' call solver % initialize ( n = n , & m = m , & max_iter = max_iter , & tol = tol , & func = func , & grad = grad , & step_mode = step_mode ,& use_broyden = use_broyden ,& export_iteration = export ,& n_intervals = n_intervals , & fmin_tol = fmin_tol , & verbose = verbose ) call solver % status ( istat , message ) write ( * , '(I3,1X,A)' ) istat , message if ( istat /= 0 ) error stop x = [ 1.0_wp , 2.0_wp ] call solver % solve ( x ) call solver % status ( istat , message ) write ( * , '(I3,1X,A)' ) istat , message write ( * , * ) '' end do contains subroutine func ( me , x , f ) !! compute the function implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f f_evals = f_evals + 1 f ( 1 ) = x ( 1 ) ** 2 + x ( 2 ) - 0.1_wp f ( 2 ) = x ( 2 ) + 0.2_wp ! root is 5.477226E-01  -2.000000E-01 end subroutine func subroutine grad ( me , x , g ) !! compute the gradient of the function (Jacobian): implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:,:), intent ( out ) :: g f_evals = f_evals + 2 ! to approximate forward diff derivatives g ( 1 , 1 ) = 2.0_wp * x ( 1 ) !df(1)/dx g ( 2 , 1 ) = 0.0_wp !df(2)/dx g ( 1 , 2 ) = 1.0_wp !df(1)/dy g ( 2 , 2 ) = 1.0_wp !df(2)/dy end subroutine grad subroutine export ( me , x , f , iter ) !! export an iteration: implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: f integer , intent ( in ) :: iter !! iteration number write ( * , '(1P,I3,1X,A,I3,A,*(E15.6))' ) iter , '(' , f_evals , ')' , x , norm2 ( f ) end subroutine export !****************************************************************************************************** end program nlesolver_test_1 !******************************************************************************************************","tags":"","loc":"sourcefile/nlesolver_test_1.f90.html"},{"title":"lusol_test.f90 – AoC-2023","text":"This file depends on sourcefile~~lusol_test.f90~~EfferentGraph sourcefile~lusol_test.f90 lusol_test.f90 sourcefile~lusol_ez.f90 lusol_ez.f90 sourcefile~lusol_test.f90->sourcefile~lusol_ez.f90 sourcefile~lusol_precision.f90 lusol_precision.F90 sourcefile~lusol_test.f90->sourcefile~lusol_precision.f90 sourcefile~lusol_ez.f90->sourcefile~lusol_precision.f90 sourcefile~lusol.f90 lusol.f90 sourcefile~lusol_ez.f90->sourcefile~lusol.f90 sourcefile~lusol.f90->sourcefile~lusol_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !*************************************************************************************************** !> !  Main program for EZ test. program main use lusol_precision , wp => rp use lusol_ez_module , only : solve implicit none call test_1 () call test_2 () contains subroutine test_1 () ! define a 3x3 dense system to solve: integer , parameter :: m = 3 !! number of rows in `A` matrix integer , parameter :: n = 3 !! number of columns in `A` matrix real ( wp ), dimension ( m ), parameter :: b = real ([ 1 , 2 , 3 ], wp ) integer , dimension ( m * n ), parameter :: icol = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ] integer , dimension ( m * n ), parameter :: irow = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] real ( wp ), dimension ( m * n ), parameter :: a = real ([ 1 , 4 , 7 , 2 , 5 , 88 , 3 , 66 , 9 ], wp ) real ( wp ), dimension ( m , 1 ), parameter :: b_vec = reshape ( b ,[ m , 1 ]) real ( wp ), dimension ( m , n ), parameter :: a_mat = reshape ( a ,[ 3 , 3 ]) real ( wp ), dimension ( n ) :: x real ( wp ), dimension ( n , 1 ) :: x_vec integer :: istat write ( * , * ) '' write ( * , * ) '***** test 1' write ( * , * ) '' call solve ( n , m , m * n , irow , icol , a , b , x , istat ) x_vec ( 1 : 3 , 1 ) = x write ( * , * ) '' write ( * , * ) 'istop = ' , istat write ( * , * ) '' write ( * , '(1P,A,*(E16.6))' ) 'x       = ' , x write ( * , '(1P,A,*(E16.6))' ) 'A*x     = ' , matmul ( a_mat , x_vec ) write ( * , '(1P,A,*(E16.6))' ) 'A*x - b = ' , matmul ( a_mat , x_vec ) - b_vec if ( any ( abs ( matmul ( a_mat , x_vec ) - b_vec ) > 1.0e-12 )) error stop 'TEST FAILED' end subroutine test_1 subroutine test_2 () ! another test case (with n>m). compare to scipy. !!``` !! >>> a !! array([[  4. ,   5. ,  66. ,   0.1], !!        [  1. ,  -3. ,   8. ,  -9. ], !!        [ 11. ,   3. , -87. ,   2. ]]) !! >>> b !! array([1, 2, 3]) !! >>> scipy.sparse.linalg.lsqr(a, b) !! (array([ 0.26437473,  0.04901579, -0.00426183, -0.21297414]), 1, 3, 5.5785963493386424e-12, 5.5785963493386424e-12, 110.70234866523838, 15.316189089999897, 6.119548932941366e-10, 0.343034538979173, array([0., 0., 0., 0.])) !! >>> !!``` integer , parameter :: m = 3 !! number of rows in `A` matrix integer , parameter :: n = 4 !! number of columns in `A` matrix real ( wp ), dimension ( m ), parameter :: b = real ([ 1 , 2 , 3 ], wp ) integer , dimension ( m * n ), parameter :: icol = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 ] integer , dimension ( m * n ), parameter :: irow = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] real ( wp ), dimension ( m * n ), parameter :: a = [ 4.1_wp , 1.1_wp , 1 1.1_wp ,& 5.1_wp , - 3.1_wp , 3.1_wp ,& 6 6.1_wp , 8.1_wp , - 8 7.1_wp ,& 0.1_wp , - 9.1_wp , 2.1_wp ] real ( wp ), dimension ( m , 1 ), parameter :: b_vec = reshape ( b ,[ m , 1 ]) real ( wp ), dimension ( m , n ), parameter :: a_mat = reshape ( a ,[ 3 , 4 ]) real ( wp ), dimension ( n ) :: x real ( wp ), dimension ( n , 1 ) :: x_vec integer :: istat write ( * , * ) '' write ( * , * ) '***** test 2' write ( * , * ) '' call solve ( n , m , m * n , irow , icol , a , b , x , istat ) x_vec ( 1 : 4 , 1 ) = x write ( * , * ) '' write ( * , * ) 'istop = ' , istat write ( * , * ) '' write ( * , '(1P,A,*(E16.6))' ) 'x       = ' , x write ( * , '(1P,A,*(E16.6))' ) 'A*x     = ' , matmul ( a_mat , x_vec ) write ( * , '(1P,A,*(E16.6))' ) 'A*x - b = ' , matmul ( a_mat , x_vec ) - b_vec if ( any ( abs ( matmul ( a_mat , x_vec ) - b_vec ) > 1.0e-12 )) error stop 'TEST FAILED' end subroutine test_2 end program main !***************************************************************************************************","tags":"","loc":"sourcefile/lusol_test.f90.html"},{"title":"dag_module.f90 – AoC-2023","text":"Files dependent on this one sourcefile~~dag_module.f90~~AfferentGraph sourcefile~dag_module.f90 dag_module.f90 sourcefile~dag_example.f90 dag_example.f90 sourcefile~dag_example.f90->sourcefile~dag_module.f90 sourcefile~problem_25.f90 problem_25.f90 sourcefile~problem_25.f90->sourcefile~dag_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> !  DAG Module. module dag_module implicit none private type :: vertex !! a vertex of a directed acyclic graph (DAG) private integer , dimension (:), allocatable :: edges !! these are the vertices that this vertex depends on integer :: ivertex = 0 !! vertex number logical :: checking = . false . !! used for toposort logical :: marked = . false . !! used for toposort character ( len = :), allocatable :: label !! used for diagraph character ( len = :), allocatable :: attributes !! used for diagraph contains generic :: set_edges => set_edge_vector , add_edge procedure :: set_edge_vector procedure :: add_edge end type vertex type , public :: dag !! a directed acyclic graph (DAG) private integer :: n = 0 !! number of `vertices` type ( vertex ), dimension (:), allocatable :: vertices !! the vertices in the DAG. contains procedure , public :: set_vertices => dag_set_vertices procedure , public :: set_edges => dag_set_edges procedure , public :: set_vertex_info => dag_set_vertex_info procedure , public :: toposort => dag_toposort procedure , public :: generate_digraph => dag_generate_digraph procedure , public :: generate_dependency_matrix => dag_generate_dependency_matrix procedure , public :: save_digraph => dag_save_digraph procedure , public :: get_edges => dag_get_edges procedure , public :: get_dependencies => dag_get_dependencies procedure , public :: destroy => dag_destroy end type dag contains !******************************************************************************* !******************************************************************************* !> !  Destroy the `dag`. subroutine dag_destroy ( me ) class ( dag ), intent ( inout ) :: me me % n = 0 if ( allocated ( me % vertices )) deallocate ( me % vertices ) end subroutine dag_destroy !******************************************************************************* !******************************************************************************* !> !  specify the edge indices for this vertex subroutine set_edge_vector ( me , edges ) class ( vertex ), intent ( inout ) :: me integer , dimension (:), intent ( in ) :: edges integer :: i !! counter if ( allocated ( me % edges )) then do i = 1 , size ( edges ) call me % add_edge ( edges ( i )) end do else allocate ( me % edges ( size ( edges ))) ! note: not checking for uniqueness here. me % edges = edges end if end subroutine set_edge_vector !******************************************************************************* !******************************************************************************* !> !  add an edge index for this vertex subroutine add_edge ( me , edge ) class ( vertex ), intent ( inout ) :: me integer , intent ( in ) :: edge if ( allocated ( me % edges )) then if (. not . any ( edge == me % edges )) then me % edges = [ me % edges , edge ] ! auto lhs reallocation end if else allocate ( me % edges ( 1 )) me % edges = [ edge ] end if end subroutine add_edge !******************************************************************************* !******************************************************************************* !> !  get the edges for the vertex (all the the vertices !  that this vertex depends on). pure function dag_get_edges ( me , ivertex ) result ( edges ) implicit none class ( dag ), intent ( in ) :: me integer , intent ( in ) :: ivertex integer , dimension (:), allocatable :: edges if ( ivertex > 0 . and . ivertex <= me % n ) then edges = me % vertices ( ivertex )% edges ! auto LHS allocation end if end function dag_get_edges !******************************************************************************* !******************************************************************************* !> !  get all the vertices that depend on this vertex. pure function dag_get_dependencies ( me , ivertex ) result ( dep ) implicit none class ( dag ), intent ( in ) :: me integer , intent ( in ) :: ivertex integer , dimension (:), allocatable :: dep !! the set of all vertices !! than depend on `ivertex` integer :: i !! vertex counter if ( ivertex > 0 . and . ivertex <= me % n ) then ! have to check all the vertices: do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then if ( any ( me % vertices ( i )% edges == ivertex )) then if ( allocated ( dep )) then dep = [ dep , i ] ! auto LHS allocation else dep = [ i ] ! auto LHS allocation end if end if end if end do end if end function dag_get_dependencies !******************************************************************************* !******************************************************************************* !> !  set the number of vertices in the dag subroutine dag_set_vertices ( me , nvertices ) class ( dag ), intent ( inout ) :: me integer , intent ( in ) :: nvertices !! number of vertices integer :: i me % n = nvertices allocate ( me % vertices ( nvertices )) me % vertices % ivertex = [( i , i = 1 , nvertices )] end subroutine dag_set_vertices !******************************************************************************* !******************************************************************************* !> !  set info about a vertex in a dag. subroutine dag_set_vertex_info ( me , ivertex , label , attributes ) class ( dag ), intent ( inout ) :: me integer , intent ( in ) :: ivertex !! vertex number character ( len =* ), intent ( in ), optional :: label !! if a label is not set, !! then the integer vertex !! number is used. character ( len =* ), intent ( in ), optional :: attributes !! other attributes when !! saving as a diagraph. if ( present ( label )) then me % vertices ( ivertex )% label = label else ! just use the vertex number me % vertices ( ivertex )% label = integer_to_string ( ivertex ) end if if ( present ( attributes )) then me % vertices ( ivertex )% attributes = attributes end if end subroutine dag_set_vertex_info !******************************************************************************* !******************************************************************************* !> !  set the edges for a vertex in a dag subroutine dag_set_edges ( me , ivertex , edges ) class ( dag ), intent ( inout ) :: me integer , intent ( in ) :: ivertex !! vertex number integer , dimension (:), intent ( in ) :: edges call me % vertices ( ivertex )% set_edges ( edges ) end subroutine dag_set_edges !******************************************************************************* !******************************************************************************* !> !  Main toposort routine subroutine dag_toposort ( me , order , istat ) class ( dag ), intent ( inout ) :: me integer , dimension (:), allocatable , intent ( out ) :: order !! the toposort order integer , intent ( out ) :: istat !! Status flag: !! !! * 0 if no errors !! * -1 if circular dependency !!  (in this case, `order` will not be allocated) integer :: i , iorder if ( me % n == 0 ) return allocate ( order ( me % n )) iorder = 0 ! index in order array istat = 0 ! no errors so far do i = 1 , me % n if (. not . me % vertices ( i )% marked ) call dfs ( me % vertices ( i )) if ( istat ==- 1 ) exit end do if ( istat ==- 1 ) deallocate ( order ) contains recursive subroutine dfs ( v ) !! depth-first graph traversal type ( vertex ), intent ( inout ) :: v integer :: j if ( istat ==- 1 ) return if ( v % checking ) then ! error: circular dependency istat = - 1 else if (. not . v % marked ) then v % checking = . true . if ( allocated ( v % edges )) then do j = 1 , size ( v % edges ) call dfs ( me % vertices ( v % edges ( j ))) if ( istat ==- 1 ) return end do end if v % checking = . false . v % marked = . true . iorder = iorder + 1 order ( iorder ) = v % ivertex end if end if end subroutine dfs end subroutine dag_toposort !******************************************************************************* !******************************************************************************* !> !  Generate a Graphviz digraph structure for the DAG. ! !### Example !  * To convert this to a PDF using `dot`: `dot -Tpdf -o test.pdf test.dot`, !    where `test.dot` is `str` written to a file. function dag_generate_digraph ( me , rankdir , dpi ) result ( str ) implicit none class ( dag ), intent ( in ) :: me character ( len = :), allocatable :: str character ( len =* ), intent ( in ), optional :: rankdir !! right to left orientation (e.g. 'RL') integer , intent ( in ), optional :: dpi !! resolution (e.g. 300) integer :: i , j !! counter integer :: n_edges !! number of edges character ( len = :), allocatable :: attributes , label logical :: has_label , has_attributes character ( len =* ), parameter :: tab = '  ' !! for indenting character ( len =* ), parameter :: newline = new_line ( ' ' ) !! line break character if ( me % n == 0 ) return str = 'digraph G {' // newline // newline if ( present ( rankdir )) & str = str // tab // 'rankdir=' // rankdir // newline // newline if ( present ( dpi )) & str = str // tab // 'graph [ dpi = ' // integer_to_string ( dpi ) // ' ]' // newline // newline ! define the vertices: do i = 1 , me % n has_label = allocated ( me % vertices ( i )% label ) has_attributes = allocated ( me % vertices ( i )% attributes ) if ( has_label ) label = 'label=\"' // trim ( adjustl ( me % vertices ( i )% label )) // '\"' if ( has_label . and . has_attributes ) then attributes = '[' // trim ( adjustl ( me % vertices ( i )% attributes )) // ',' // label // ']' elseif ( has_label . and . . not . has_attributes ) then attributes = '[' // label // ']' elseif (. not . has_label . and . has_attributes ) then attributes = '[' // trim ( adjustl ( me % vertices ( i )% attributes )) // ']' else ! neither attributes = '' end if str = str // tab // integer_to_string ( i ) // ' ' // attributes // newline if ( i == me % n ) str = str // newline end do ! define the dependencies: do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then n_edges = size ( me % vertices ( i )% edges ) str = str // tab // integer_to_string ( i ) // merge ( ' -> ' , '    ' , n_edges /= 0 ) do j = 1 , n_edges ! comma-separated list: str = str // integer_to_string ( me % vertices ( i )% edges ( j )) if ( n_edges > 1 . and . j < n_edges ) str = str // ',' end do str = str // ';' // newline end if end do str = str // newline // '}' end function dag_generate_digraph !******************************************************************************* !******************************************************************************* !> !  Generate the dependency matrix for the DAG. ! !  This is an n \\times n  matrix with elements A_{ij}, !  such that A_{ij} is true if vertex i depends on vertex j. subroutine dag_generate_dependency_matrix ( me , mat ) implicit none class ( dag ), intent ( in ) :: me logical , dimension (:,:), intent ( out ), allocatable :: mat !! dependency matrix integer :: i !! vertex counter if ( me % n > 0 ) then allocate ( mat ( me % n , me % n )) mat = . false . do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then mat ( i , me % vertices ( i )% edges ) = . true . end if end do end if end subroutine dag_generate_dependency_matrix !******************************************************************************* !******************************************************************************* !> !  Generate a Graphviz digraph structure for the DAG and write it to a file. subroutine dag_save_digraph ( me , filename , rankdir , dpi ) implicit none class ( dag ), intent ( in ) :: me character ( len =* ), intent ( in ), optional :: filename !! file name for diagraph character ( len =* ), intent ( in ), optional :: rankdir !! right to left orientation (e.g. 'RL') integer , intent ( in ), optional :: dpi !! resolution (e.g. 300) integer :: iunit , istat character ( len = :), allocatable :: diagraph diagraph = me % generate_digraph ( rankdir , dpi ) open ( newunit = iunit , file = filename , status = 'REPLACE' , iostat = istat ) if ( istat == 0 ) then write ( iunit , fmt = '(A)' , iostat = istat ) diagraph else write ( * , * ) 'error opening ' // trim ( filename ) end if close ( iunit , iostat = istat ) end subroutine dag_save_digraph !******************************************************************************* !******************************************************************************* !> !  Integer to allocatable string. pure function integer_to_string ( i ) result ( s ) implicit none integer , intent ( in ) :: i character ( len = :), allocatable :: s integer :: istat allocate ( character ( len = 64 ) :: s ) ! should be big enough write ( s , fmt = '(ss,I0)' , iostat = istat ) i if ( istat == 0 ) then s = trim ( adjustl ( s )) else s = '***' end if end function integer_to_string !******************************************************************************* !******************************************************************************* end module dag_module !*******************************************************************************","tags":"","loc":"sourcefile/dag_module.f90.html"},{"title":"kinds_module.F90 – AoC-2023","text":"Files dependent on this one sourcefile~~kinds_module.f90~~AfferentGraph sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~cache_module.f90 cache_module.f90 sourcefile~cache_module.f90->sourcefile~kinds_module.f90 sourcefile~utilities_module.f90 utilities_module.f90 sourcefile~cache_module.f90->sourcefile~utilities_module.f90 sourcefile~diff_module.f90 diff_module.f90 sourcefile~diff_module.f90->sourcefile~kinds_module.f90 sourcefile~dsm_module.f90 dsm_module.f90 sourcefile~dsm_module.f90->sourcefile~kinds_module.f90 sourcefile~dsm_test.f90 dsm_test.f90 sourcefile~dsm_test.f90->sourcefile~kinds_module.f90 sourcefile~dsm_test.f90->sourcefile~dsm_module.f90 sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~kinds_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~cache_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~diff_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~dsm_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~utilities_module.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~kinds_module.f90 sourcefile~test1.f90->sourcefile~numerical_differentiation_module.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~kinds_module.f90 sourcefile~test2.f90->sourcefile~numerical_differentiation_module.f90 sourcefile~utilities_module.f90->sourcefile~kinds_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> !  Numeric kinds for NumDiff. ! !@note The default real kind (`wp`) can be !      changed using optional preprocessor flags. !      This library was built with real kind: #ifdef REAL32 !      `real(kind=real32)` [4 bytes] #elif REAL64 !      `real(kind=real64)` [8 bytes] #elif REAL128 !      `real(kind=real128)` [16 bytes] #else !      `real(kind=real64)` [8 bytes] #endif module numdiff_kinds_module use iso_fortran_env private #ifdef REAL32 integer , parameter , public :: wp = real32 !! default real kind [4 bytes] #elif REAL64 integer , parameter , public :: wp = real64 !! default real kind [8 bytes] #elif REAL128 integer , parameter , public :: wp = real128 !! default real kind [16 bytes] #else integer , parameter , public :: wp = real64 !! default real kind [8 bytes] #endif end module numdiff_kinds_module !*******************************************************************************","tags":"","loc":"sourcefile/kinds_module.f90.html"},{"title":"problem_21.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_21.f90~~EfferentGraph sourcefile~problem_21.f90 problem_21.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_21.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_21 use aoc_utilities use iso_fortran_env implicit none character ( len = 1 ), dimension (:,:), allocatable :: array integer :: nrows , ncols , i , j integer , dimension ( 2 ) :: iloc integer , dimension (:,:), allocatable :: icount call clk % tic () ! array = read_file_to_char_array('inputs/day21_test.txt', border='#') array = read_file_to_char_array ( 'inputs/day21.txt' , border = '.' ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) allocate ( icount ( nrows , ncols )); icount = 0 iloc = findloc ( array , 'S' ) ! find starting point i = iloc ( 1 ) j = iloc ( 2 ) array ( i , j ) = 'O' ! starting here do i = 1 , 64 call step ( array ) end do write ( * , * ) '21a: ' , count ( array == 'O' ) call clk % toc ( '21' ) contains recursive subroutine step ( array ) !! take all valid steps from any # elements in array character ( len = 1 ), dimension (:,:), intent ( inout ), allocatable :: array integer :: i , j logical :: steped character ( len = 1 ), dimension (:,:), allocatable :: tmp tmp = array do i = 1 , nrows do j = 1 , ncols if ( array ( i , j ) == 'O' ) then steped = . false . ! try a step in each direction: if ( array ( i - 1 , j ) == '.' ) then tmp ( i - 1 , j ) = 'O' ; steped = . true . end if if ( array ( i + 1 , j ) == '.' ) then tmp ( i + 1 , j ) = 'O' ; steped = . true . end if if ( array ( i , j - 1 ) == '.' ) then tmp ( i , j - 1 ) = 'O' ; steped = . true . end if if ( array ( i , j + 1 ) == '.' ) then tmp ( i , j + 1 ) = 'O' ; steped = . true . end if if ( steped ) tmp ( i , j ) = '.' end if end do end do call move_alloc ( tmp , array ) end subroutine step end program problem_21","tags":"","loc":"sourcefile/problem_21.f90.html"},{"title":"nlesolver_module.F90 – AoC-2023","text":"This file depends on sourcefile~~nlesolver_module.f90~~EfferentGraph sourcefile~nlesolver_module.f90 nlesolver_module.F90 sourcefile~fmin_module.f90 fmin_module.F90 sourcefile~nlesolver_module.f90->sourcefile~fmin_module.f90 sourcefile~lsqr.f90 lsqr.f90 sourcefile~nlesolver_module.f90->sourcefile~lsqr.f90 sourcefile~lusol_ez.f90 lusol_ez.f90 sourcefile~nlesolver_module.f90->sourcefile~lusol_ez.f90 sourcefile~lsqr_kinds.f90 lsqr_kinds.F90 sourcefile~lsqr.f90->sourcefile~lsqr_kinds.f90 sourcefile~lsqrblas.f90 lsqrblas.f90 sourcefile~lsqr.f90->sourcefile~lsqrblas.f90 sourcefile~lusol.f90 lusol.f90 sourcefile~lusol_ez.f90->sourcefile~lusol.f90 sourcefile~lusol_precision.f90 lusol_precision.F90 sourcefile~lusol_ez.f90->sourcefile~lusol_precision.f90 sourcefile~lsqrblas.f90->sourcefile~lsqr_kinds.f90 sourcefile~lusol.f90->sourcefile~lusol_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~nlesolver_module.f90~~AfferentGraph sourcefile~nlesolver_module.f90 nlesolver_module.F90 sourcefile~nlesolver_test_1.f90 nlesolver_test_1.f90 sourcefile~nlesolver_test_1.f90->sourcefile~nlesolver_module.f90 sourcefile~sparse_test.f90 sparse_test.f90 sourcefile~sparse_test.f90->sourcefile~nlesolver_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !****************************************************************************************************** !> !  A basic multidimensional nonlinear equation solver, using a Newton-Raphson type direct method. ! !### Features !  * Works with square, under-determined, or over-determined systems. !  * Uses LAPACK routines (`dgesv` or `dgels`) to solve the linear system. !  * Has a Broyden update option. !  * Has various line search options. ! !### References !  * https://en.wikipedia.org/wiki/Backtracking_line_search !  * http://projecteuclid.org/download/pdf_1/euclid.pjm/1102995080 !  * http://help.agi.com/stk/index.htm#gator/eq-diffcorr.htm !  * http://gmat.sourceforge.net/doc/R2015a/html/DifferentialCorrector.html ! !### Author !  * Jacob Williams ! !### License !  * BSD-3 ! !@todo add an `istat` output to func and grad, for user stopping !      or to take a smaller stop (if istat>0 take a smaller step, if istat<0 abort) ! !@note The default real kind (`wp`) can be !      changed using optional preprocessor flags. !      This library was built with real kind: #ifdef REAL32 !      `real(kind=real32)` [4 bytes] #elif REAL64 !      `real(kind=real64)` [8 bytes] #elif REAL128 !      `real(kind=real128)` [16 bytes] #else !      `real(kind=real64)` [8 bytes] #endif module nlesolver_module use iso_fortran_env use fmin_module , only : fmin implicit none private #ifdef REAL32 integer , parameter , public :: nlesolver_rk = real32 !! real kind used by this module [4 bytes] #elif REAL64 integer , parameter , public :: nlesolver_rk = real64 !! real kind used by this module [8 bytes] #elif REAL128 integer , parameter , public :: nlesolver_rk = real128 !! real kind used by this module [16 bytes] #else integer , parameter , public :: nlesolver_rk = real64 !! real kind used by this module [8 bytes] #endif integer , parameter :: wp = nlesolver_rk !! local copy of `nlesolver_rk` with a shorter name real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: two = 2.0_wp real ( wp ), parameter :: eps = epsilon ( one ) !! machine  \\epsilon  real ( wp ), parameter :: big = huge ( one ) !********************************************************* type , public :: nlesolver_type !! Nonlinear equations solver class. private integer :: n = 0 !! number of opt vars integer :: m = 0 !! number of constraints integer :: max_iter = 100 !! maximum number of iterations real ( wp ) :: tol = 1.0e-6_wp !! convergence tolerance for function values real ( wp ) :: alpha = 1.0_wp !! step length (when specified constant) real ( wp ) :: alpha_min = 0.1_wp !! minimum step length (when allowed to vary) real ( wp ) :: alpha_max = 1.0_wp !! maximum step length (when allowed to vary) real ( wp ) :: tolx = 1.0e-8_wp !! convergence tolerance for `x` real ( wp ) :: c = 0.5_wp !! backtracking linesearch parameter (0,1) real ( wp ) :: tau = 0.5_wp !! backtracking linesearch parameter (0,1) real ( wp ) :: fmin_tol = 1.0e-5_wp !! tolerance for \"exact\" linesearch integer :: n_intervals = 2 !! number of intervals for fixed point linesearch logical :: use_broyden = . false . !! if true, a Broyden update is used !! rather than computing the Jacobian !! at every step. The `grad` function is !! only called for the initial evaluation. integer :: broyden_update_n = 4 !! if this value is `>0`, the Broyden update !! is computed at most this many times before !! the full Jacobian is recomputed. integer :: n_uphill_max = 5 !! maximum number of consecutive steps !! to allow where the value of `f` increases logical :: verbose = . false . !! verbose output printing integer :: iunit = output_unit !! output unit for printing (assumed to be open). character ( len = :), allocatable :: message !! latest status message integer :: istat = - 999 !! latest status message procedure ( func_func ), pointer :: func => null () !! user-supplied routine to compute the function procedure ( export_func ), pointer :: export_iteration => null () !! user-supplied routine to export iterations procedure ( wait_func ), pointer :: user_input_check => null () !! user-supplied routine to enable user to stop iterations procedure ( linesearch_func ), pointer :: linesearch => null () !! line search method (determined by `step_mode` user input in [[nlesolver_type:initialize]]) ! sparsity options: integer :: sparsity_mode = 1 !! sparsity mode: !! !! * 1 - assume dense (use dense solver) !! * 2 - assume sparse (use LSQR sparse solver). !! * 3 - assume sparse (use LUSOL sparse solver). integer :: n_nonzeros = - 1 !! number of nonzero Jacobian elements (used for `sparsity_mode > 1`) integer , dimension (:), allocatable :: irow !! sparsity pattern nonzero elements row indices. integer , dimension (:), allocatable :: icol !! sparsity pattern nonzero elements column indices ! LSQR parameters: real ( wp ) :: atol = zero !! relative error in definition of `A` real ( wp ) :: btol = zero !! relative error in definition of `b` real ( wp ) :: conlim = zero !! An upper limit on `cond(Abar)`, the apparent !! condition number of the matrix `Abar`. integer :: itnlim = 100 !! max iterations integer :: nout = 0 !! output unit for printing real ( wp ) :: damp = zero !! damp parameter for LSQR ! LUSOL parameters: integer :: lusol_method = 0 ! dense version: procedure ( grad_func ), pointer :: grad => null () !! user-supplied routine to compute the gradient of the function (dense version) ! sparse version: procedure ( grad_func_sparse ), pointer :: grad_sparse => null () !! user-supplied routine to compute the gradient of the function (sparse version) contains private procedure , public :: initialize => initialize_nlesolver_variables procedure , public :: solve => nlesolver_solver procedure , public :: destroy => destroy_nlesolver_variables procedure , public :: status => get_status procedure :: set_status end type nlesolver_type !********************************************************* abstract interface subroutine func_func ( me , x , f ) !! compute the function import :: wp , nlesolver_type implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f end subroutine func_func subroutine grad_func ( me , x , g ) !! compute the gradient of the function (Jacobian). Dense version. import :: wp , nlesolver_type implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:,:), intent ( out ) :: g end subroutine grad_func subroutine grad_func_sparse ( me , x , g ) !! compute the gradient of the function (Jacobian). Sparse version. import :: wp , nlesolver_type implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: g !! sparse jacobian. length is `n_nonzeros` end subroutine grad_func_sparse subroutine export_func ( me , x , f , iter ) !! export an iteration: import :: wp , nlesolver_type implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: f integer , intent ( in ) :: iter !! iteration number end subroutine export_func subroutine wait_func ( me , user_stop ) !! enable a user-triggered stop of the iterations: import :: wp , nlesolver_type implicit none class ( nlesolver_type ), intent ( inout ) :: me logical , intent ( out ) :: user_stop end subroutine wait_func subroutine linesearch_func ( me , xold , p , x , f , fvec , fjac , fjac_sparse ) !! line search method. Note that not all inputs/outputs are !! used by all methods. import :: wp , nlesolver_type implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: xold !! previous value of `x` real ( wp ), dimension ( me % n ), intent ( in ) :: p !! search direction real ( wp ), dimension ( me % n ), intent ( out ) :: x !! new `x` real ( wp ), intent ( inout ) :: f !! input: current magnitude of `fvec`, !! output: new value of `f` real ( wp ), dimension ( me % m ), intent ( inout ) :: fvec !! input: current function vector, !! output: new function vector real ( wp ), dimension (:,:), intent ( in ), optional :: fjac !! jacobian matrix [dense] real ( wp ), dimension (:), intent ( in ), optional :: fjac_sparse !! jacobian matrix [sparse] end subroutine linesearch_func end interface contains !******************************************************************************************************* !***************************************************************************************** !> !  Set status flag and message. subroutine set_status ( me , istat , string , i , r ) implicit none class ( nlesolver_type ), intent ( inout ) :: me integer , intent ( in ) :: istat !! status code character ( len =* ), intent ( in ) :: string !! status message integer , intent ( in ), optional :: i !! an integer value to append real ( wp ), intent ( in ), optional :: r !! a real value to append character ( len = 256 ) :: numstr !! for number fo string conversion character ( len = :), allocatable :: message !! the full message to log integer :: iostat !! write `iostat` code message = trim ( string ) if ( present ( i )) then numstr = '' write ( numstr , fmt =* , iostat = iostat ) i if ( iostat /= 0 ) numstr = '****' message = message // ' ' // trim ( adjustl ( numstr )) end if if ( present ( r )) then numstr = '' write ( numstr , fmt =* , iostat = iostat ) r if ( iostat /= 0 ) numstr = '****' message = message // ' ' // trim ( adjustl ( numstr )) end if if ( me % verbose ) then write ( me % iunit , '(A)' , iostat = iostat ) message end if ! store in the class: me % istat = istat me % message = message end subroutine set_status !***************************************************************************************** !***************************************************************************************** !> !  Return the status code and message from the [[nlesolver_type]] class. ! !### Status codes ! !  * -1   -- Error: Invalid alpha !  * -2   -- Error: Invalid alpha_min !  * -3   -- Error: Invalid alpha_max !  * -4   -- Error: Alpha_min must be < alpha_max !  * -5   -- Error: Invalid step_mode !  * -6   -- Error solving linear system !  * -7   -- Error: More than 5 steps in the uphill direction !  * -8   -- Error: Divide by zero when computing Broyden update !  * -9   -- Error: Out of memory !  * -10  -- Error: function routine is not associated !  * -11  -- Error: gradient routine is not associated !  * -12  -- Error: backtracking linesearch c must be in range (0, 1) !  * -13  -- Error: backtracking linesearch tau must be in range (0, 1) !  * -14  -- Error: must specify grad_sparse, irow, and icol for sparsity_mode > 1 !  * -15  -- Error: irow and icol must be the same length !  * -999 -- Error: class has not been initialized !  * 0    -- Class successfully initialized in [[nlesolver_type:initialize]] !  * 1    -- Required accuracy achieved !  * 2    -- Solution cannot be improved !  * 3    -- Maximum number of iterations reached !  * 4    -- Stopped by the user subroutine get_status ( me , istat , message ) implicit none class ( nlesolver_type ), intent ( inout ) :: me integer , intent ( out ), optional :: istat !! Integer status code. character ( len = :), allocatable , intent ( out ), optional :: message !! Text status message if ( present ( istat )) istat = me % istat if ( present ( message )) then if ( allocated ( me % message )) then message = trim ( me % message ) else message = 'Error: class has not been initialized' end if end if end subroutine get_status !***************************************************************************************** !***************************************************************************************** !> !  Constructor for the class. subroutine initialize_nlesolver_variables ( me ,& n , m , max_iter , tol , alpha , alpha_min , alpha_max , tolx , fmin_tol ,& backtrack_c , backtrack_tau ,& use_broyden , broyden_update_n , step_mode ,& func , grad , grad_sparse ,& export_iteration , user_input_check ,& verbose , iunit , n_uphill_max , n_intervals ,& sparsity_mode , irow , icol ,& atol , btol , conlim , damp , itnlim , nout ,& lusol_method ) implicit none class ( nlesolver_type ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of optimization variables integer , intent ( in ) :: m !! number of constraints integer , intent ( in ) :: max_iter !! maximum number of iterations real ( wp ), intent ( in ) :: tol !! function convergence tolerance procedure ( func_func ) :: func !! computes the function vector procedure ( grad_func ), optional :: grad !! computes the jacobian [required for dense mode: `sparsity_mode=1`] procedure ( grad_func_sparse ), optional :: grad_sparse !! computes the jacobian [required for sparse mode: `sparsity_mode>1`] integer , intent ( in ), optional :: step_mode !! step mode: !! !!  * 1 = use the specified `alpha` (0,1] !!  * 2 = backtracking linesearch (between `alpha_min` and `alpha_max`) !!  * 3 = exact linesearch (between `alpha_min` and `alpha_max`) !!  * 4 = evaluate function at specified fixed points  (between `alpha_min` and `alpha_max`) real ( wp ), intent ( in ), optional :: alpha !! constant step length for `step_mode=1` (0,1] real ( wp ), intent ( in ), optional :: alpha_min !! minimum step length (0,1] real ( wp ), intent ( in ), optional :: alpha_max !! maximum step length (0,1] real ( wp ), intent ( in ), optional :: tolx !! convergence tolerance for changes in `x` real ( wp ), intent ( in ), optional :: fmin_tol !! convergence tolerance for [[fmin]] (used when `step_mode=3`) real ( wp ), intent ( in ), optional :: backtrack_c !! backtracking linesearch parameter (0,1) real ( wp ), intent ( in ), optional :: backtrack_tau !! backtracking linesearch parameter (0,1) logical , intent ( in ), optional :: use_broyden !! use a Broyden update (default is False) integer , intent ( in ), optional :: broyden_update_n !! For Broyden mode, update the full Jacobian !! at most every this many iterations (must be >1) !! If <=1 then Jacobian is only computed on the !! first iteration. procedure ( export_func ), optional :: export_iteration !! function to export each iteration procedure ( wait_func ), optional :: user_input_check !! check for user input (to stop solver if necessary) logical , intent ( in ), optional :: verbose !! for verbose status printing integer , intent ( in ), optional :: iunit !! unit for verbose printing (assumed to be open). !! by default this is `output_unit`. integer , intent ( in ), optional :: n_uphill_max !! maximum number of consecutive steps !! to allow where the value of `f` increases integer , intent ( in ), optional :: n_intervals !! number of intervals for fixed point linesearch integer , intent ( in ), optional :: sparsity_mode !! sparsity mode: !! !! * 1 - assume dense (use dense solver) !!   Must specify `grad` for this mode. !! * 2 - assume sparse (use LSQR sparse solver). !! * 3 - assume sparse (use LUSOL sparse solver). !! Must also specify `grad_sparse` and the `irow` and `icol` !! sparsity pattern for `mode>1`. integer , dimension (:), intent ( in ), optional :: irow !! sparsity pattern nonzero elements row indices. !! must be specified with `icol` and be the same length (`n_nonzeros`). integer , dimension (:), intent ( in ), optional :: icol !! sparsity pattern nonzero elements column indices !! must be specified with `icol` and be the same length (`n_nonzeros`). real ( wp ), intent ( in ), optional :: atol !! LSQR: relative error in definition of `A` real ( wp ), intent ( in ), optional :: btol !! LSQR: relative error in definition of `b` real ( wp ), intent ( in ), optional :: conlim !! LSQR: An upper limit on `cond(Abar)`, the apparent !! condition number of the matrix `Abar`. real ( wp ), intent ( in ), optional :: damp !! LSQR: damp factor integer , intent ( in ), optional :: itnlim !! LSQR: max iterations integer , intent ( in ), optional :: nout !! LSQR: output unit for printing integer , intent ( in ), optional :: lusol_method logical :: status_ok !! true if there were no errors status_ok = . true . !required: me % n = abs ( n ) me % m = abs ( m ) me % max_iter = abs ( max_iter ) me % tol = abs ( tol ) me % func => func if ( present ( grad )) me % grad => grad if ( present ( grad_sparse )) me % grad_sparse => grad_sparse !optional: if ( present ( step_mode )) then select case ( step_mode ) case ( 1 ) ! = use the specified `alpha` (0,1] me % linesearch => simple_step case ( 2 ) ! = backtracking linesearch (between `alpha_min` and `alpha_max`) me % linesearch => backtracking_linesearch case ( 3 ) ! = exact linesearch (between `alpha_min` and `alpha_max`) me % linesearch => exact_linesearch case ( 4 ) ! = evaluate function at specified fixed points (between `alpha_min` and `alpha_max`) me % linesearch => fixed_point_linesearch case default status_ok = . false . call me % set_status ( istat = - 5 , string = 'Error: invalid step_mode:' , i = step_mode ) return end select else me % linesearch => simple_step end if if ( present ( alpha )) me % alpha = abs ( alpha ) if ( present ( alpha_min )) me % alpha_min = abs ( alpha_min ) if ( present ( alpha_max )) me % alpha_max = abs ( alpha_max ) if ( present ( tolx )) me % tolx = abs ( tolx ) if ( present ( backtrack_c )) me % c = abs ( backtrack_c ) if ( present ( backtrack_tau )) me % tau = abs ( backtrack_tau ) if ( present ( use_broyden )) me % use_broyden = use_broyden if ( present ( broyden_update_n )) me % broyden_update_n = abs ( broyden_update_n ) if ( present ( verbose )) me % verbose = verbose if ( present ( iunit )) me % iunit = iunit if ( present ( n_uphill_max )) me % n_uphill_max = abs ( n_uphill_max ) if ( present ( n_intervals )) me % n_intervals = max ( abs ( n_intervals ), 1 ) if ( present ( fmin_tol )) me % fmin_tol = abs ( fmin_tol ) if ( present ( export_iteration )) me % export_iteration => export_iteration if ( present ( user_input_check )) me % user_input_check => user_input_check ! error checks: if ( me % alpha < zero . or . me % alpha > one ) then status_ok = . false . call me % set_status ( istat = - 1 , string = 'Error: invalid alpha:' , r = me % alpha ) return end if if ( me % alpha_min < zero . or . me % alpha_min > one ) then status_ok = . false . call me % set_status ( istat = - 2 , string = 'Error: invalid alpha_min:' , r = me % alpha_min ) return end if if ( me % alpha_max < zero . or . me % alpha_max > one ) then status_ok = . false . call me % set_status ( istat = - 3 , string = 'Error: invalid alpha_max:' , r = me % alpha_max ) return end if if ( me % alpha_max <= me % alpha_min ) then status_ok = . false . call me % set_status ( istat = - 4 , string = 'Error: alpha_min must be < alpha_max' ) return end if if ( me % c < zero . or . me % c > one ) then status_ok = . false . call me % set_status ( istat = - 12 , string = 'Error: backtracking linesearch c must be in range (0, 1):' , r = me % c ) return end if if ( me % tau < zero . or . me % tau > one ) then status_ok = . false . call me % set_status ( istat = - 13 , string = 'Error: backtracking linesearch tau must be in range (0, 1):' , r = me % tau ) return end if ! initialize: me % n_nonzeros = - 1 ! not used if ( allocated ( me % irow )) deallocate ( me % irow ) if ( allocated ( me % icol )) deallocate ( me % icol ) if ( present ( sparsity_mode )) then me % sparsity_mode = sparsity_mode if ( sparsity_mode > 1 ) then ! sparse solver method if ( present ( irow ) . and . present ( icol ) . and . present ( grad_sparse )) then if ( size ( irow ) == size ( icol )) then me % n_nonzeros = size ( irow ) me % irow = irow me % icol = icol else call me % set_status ( istat = - 15 , string = 'Error: irow and icol must be the same length' ) return end if else call me % set_status ( istat = - 14 , string = 'Error: must specify grad_sparse, irow, and icol for sparsity_mode > 1' ) return end if ! LSQR optional inputs: if ( present ( atol )) me % atol = atol if ( present ( btol )) me % btol = btol if ( present ( conlim )) me % conlim = conlim if ( present ( damp )) me % damp = damp if ( present ( itnlim )) me % itnlim = itnlim if ( present ( nout )) me % nout = nout ! LUSOL method if ( present ( nout )) me % lusol_method = lusol_method ! now now, some options are not available for sparse mode !...see if this is possible in sparse mode... TODO if ( me % use_broyden ) then call me % set_status ( istat = - 16 , string = 'Error: broyden method not available for sparse solver' ) return end if end if end if if ( status_ok ) then call me % set_status ( istat = 0 , string = 'Class successfully initialized' ) end if end subroutine initialize_nlesolver_variables !***************************************************************************************** !***************************************************************************************** !> !  Main solver. subroutine nlesolver_solver ( me , x ) use lsqr_module , only : lsqr_solver_ez use lusol_ez_module , only : solve , lusol_settings implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( inout ) :: x real ( wp ), dimension (:) , allocatable :: fvec !! function vector real ( wp ), dimension (:,:), allocatable :: fjac !! jacobian matrix [dense] real ( wp ), dimension (:), allocatable :: fjac_sparse !! jacobian matrix [sparse] real ( wp ), dimension (:) , allocatable :: rhs !! linear system right-hand side real ( wp ), dimension (:) , allocatable :: p !! search direction real ( wp ), dimension (:) , allocatable :: xold !! previous value of `x` real ( wp ), dimension (:) , allocatable :: prev_fvec !! previous function vector real ( wp ), dimension (:,:), allocatable :: prev_fjac !! previous jacobian matrix real ( wp ), dimension (:,:), allocatable :: delf !! used for Broyden (rank 2 for `matmul`) real ( wp ), dimension (:,:), allocatable :: delx !! used for Broyden (rank 2 for `matmul`) logical :: user_stop !! user stop button flag integer :: info !! status flag from the [[linear_solver]] integer :: iter !! iteration counter real ( wp ) :: f !! magnitude of `fvec` real ( wp ) :: fold !! previous value of `f` integer :: n_uphill !! number of steps taken in the \"uphill\" direction !! (where `f` is increasing) real ( wp ) :: delxmag2 !! used for Broyden logical :: recompute_jac !! if using Broyden, and we want to call the user !! jacobian routine instead integer :: broyden_counter !! number of times the broyden update has been used integer :: alloc_stat !! allocation status flag type ( lsqr_solver_ez ) :: sparse_solver !! sparse LSQR solver class type ( lusol_settings ) :: lusol_options if ( me % istat < 0 ) return ! class was not initialized properly if (. not . associated ( me % func )) then call me % set_status ( istat = - 10 , string = 'Error: function routine is not associated' ) return end if if ( me % sparsity_mode == 1 . and . . not . associated ( me % grad )) then call me % set_status ( istat = - 11 , string = 'Error: gradient routine is not associated' ) return end if if ( me % sparsity_mode > 1 . and . . not . associated ( me % grad_sparse )) then call me % set_status ( istat = - 11 , string = 'Error: gradient routine is not associated' ) return end if ! initialize: iter = 0 n_uphill = 0 recompute_jac = . false . broyden_counter = 0 ! allocate the arrays: alloc_stat = 0 if ( alloc_stat == 0 ) allocate ( fvec ( me % m ) , stat = alloc_stat ) if ( me % sparsity_mode == 1 ) then ! dense if ( alloc_stat == 0 ) allocate ( fjac ( me % m , me % n ) , stat = alloc_stat ) else ! sparse if ( alloc_stat == 0 ) allocate ( fjac_sparse ( me % n_nonzeros ) , stat = alloc_stat ) end if if ( alloc_stat == 0 ) allocate ( rhs ( me % m ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( p ( me % n ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( xold ( me % n ) , stat = alloc_stat ) if ( me % use_broyden ) then ! only need these for broyden: if ( alloc_stat == 0 ) allocate ( prev_fvec ( me % m ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( prev_fjac ( me % m , me % n ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( delf ( me % m , 1 ) , stat = alloc_stat ) if ( alloc_stat == 0 ) allocate ( delx ( me % n , 1 ) , stat = alloc_stat ) end if if ( alloc_stat /= 0 ) then call me % set_status ( istat = - 9 , string = 'Error: Out of memory' ) return else me % istat = - 998 me % message = 'Unknown error' end if ! evaluate the function: call me % func ( x , fvec ) f = norm2 ( fvec ) ! check to see if initial guess is a root: if ( f <= me % tol ) then call me % set_status ( istat = 1 , string = 'Required accuracy achieved' ) else ! main iteration loop: do iter = 1 , me % max_iter ! Export the current iteration: if ( associated ( me % export_iteration )) call me % export_iteration ( x , fvec , iter ) ! Check for user stop: if ( associated ( me % user_input_check )) then call me % user_input_check ( user_stop ) if ( user_stop ) then call me % set_status ( istat = 4 , string = 'Stopped by the user' ) exit end if end if if ( me % use_broyden . and . . not . recompute_jac ) then if ( iter == 1 ) then ! always compute Jacobian on the first iteration call me % grad ( x , fjac ) broyden_counter = 0 else ! and use Broyden update to estimate Jacobian ! for subsequent iterations. ! note: fvec was computed the last iteration delx (:, 1 ) = x - xold delf (:, 1 ) = fvec - prev_fvec delxmag2 = dot_product ( delx (:, 1 ), delx (:, 1 )) if ( delxmag2 < eps ) then call me % set_status ( istat = - 8 , & string = 'Error: Divide by zero when computing Broyden update' ) exit end if ! Jacobian estimate: fjac = prev_fjac + & matmul (( delf - matmul ( prev_fjac , delx )),& transpose ( delx )) / delxmag2 broyden_counter = broyden_counter + 1 end if prev_fjac = fjac prev_fvec = fvec else ! compute the jacobian: select case ( me % sparsity_mode ) case ( 1 ) call me % grad ( x , fjac ) case ( 2 :) call me % grad_sparse ( x , fjac_sparse ) end select recompute_jac = . false . ! for broyden broyden_counter = 0 end if xold = x fold = f ! compute the search direction p by solving linear system: rhs = - fvec ! RHS of the linear system select case ( me % sparsity_mode ) case ( 1 ) ! use dense solver call linear_solver ( me % m , me % n , fjac , rhs , p , info ) case ( 2 ) ! initialize the LSQR sparse solver call sparse_solver % initialize ( me % m , me % n , fjac_sparse , me % irow , me % icol ,& atol = me % atol , & btol = me % btol , & conlim = me % conlim , & itnlim = me % itnlim , & nout = me % nout ) call sparse_solver % solve ( rhs , me % damp , p , info ) ! solve the linear system ! check convergence: select case ( info ) case ( 4 ) call me % set_status ( istat = - 1004 , & string = 'LSQR Error: The system appears to be ill-conditioned. istop =' , i = info ) exit case ( 5 ) call me % set_status ( istat = - 1005 , & string = 'LSQR Error: The iteration limit was reached. istop =' , i = info ) exit case default info = 0 end select case ( 3 ) ! use lusol solver lusol_options % method = me % lusol_method ! 0    =>  TPP: Threshold Partial   Pivoting. ! 1    =>  TRP: Threshold Rook      Pivoting. ! 2    =>  TCP: Threshold Complete  Pivoting. call solve ( me % n , me % m , me % n_nonzeros , me % irow , me % icol , fjac_sparse , rhs , p , info ,& settings = lusol_options ) end select ! check for errors: if ( info /= 0 ) then call me % set_status ( istat = - 6 , string = 'Error solving linear system. info =' , i = info ) exit else ! next step, using the specified method: call me % linesearch ( xold , p , x , f , fvec , fjac , fjac_sparse ) ! keep track of the number of steps in the \"uphill\" direction: if ( f > fold ) then n_uphill = n_uphill + 1 else n_uphill = 0 end if ! check for stopping conditions if ( f <= me % tol ) then call me % set_status ( istat = 1 , string = 'Required accuracy achieved' ) exit elseif ( maxval ( abs ( x - xold )) <= me % tolx ) then call me % set_status ( istat = 2 , string = 'Solution cannot be improved' ) exit elseif ( iter == me % max_iter ) then call me % set_status ( istat = 3 , string = 'Maximum number of iterations reached' ) exit elseif ( n_uphill > me % n_uphill_max ) then call me % set_status ( istat = 5 , string = 'Too many steps in the uphill direction' ) exit elseif ( me % use_broyden ) then ! If delxmag2 is too small when using broyden, just ! call the user-supplied jacobian function to avoid ! a divide by zero on the next step. This should ! normally only happen when the solution is almost converged. if ( norm2 ( x - xold ) ** 2 <= eps ) then recompute_jac = . true . else if ( me % broyden_update_n > 0 ) then ! Note that we also recompute if we have taken an uphill step if ( broyden_counter == me % broyden_update_n . or . n_uphill > 0 ) then ! time to recompute the full jacobian recompute_jac = . true . end if end if end if endif end if end do !end of iterations loop end if !Export the last iteration: iter = iter + 1 if ( associated ( me % export_iteration )) call me % export_iteration ( x , fvec , iter ) end subroutine nlesolver_solver !***************************************************************************************** !***************************************************************************************** !> !   Destructor subroutine destroy_nlesolver_variables ( me ) implicit none class ( nlesolver_type ), intent ( out ) :: me me % message = 'Error: class has not been initialized' me % istat = - 999 end subroutine destroy_nlesolver_variables !***************************************************************************************** !***************************************************************************************** !> !  Solve the linear system:  Ax = b , using a dense, direct method. ! !  * if `n=m` : use LAPACK `dgesv` (LU decomposition) !  * if `n/=m` : use LAPACK `dgels` (if m>n uses QR factorization, !    if m<n uses LQ factorization) subroutine linear_solver ( m , n , a , b , x , info ) implicit none integer , intent ( in ) :: n !! number of columns in `a` integer , intent ( in ) :: m !! number of rows in `a` real ( wp ), dimension ( m , n ), intent ( in ) :: a !! `A` matrix of the linear system real ( wp ), dimension ( m ), intent ( in ) :: b !! RHS of the linear system real ( wp ), dimension ( n ), intent ( out ) :: x !! the solution of the linear system. integer , intent ( out ) :: info !! output status flag (`=0` if success) ! LAPACK routine interfaces: interface subroutine dgesv ( n , nrhs , a , lda , ipiv , b , ldb , info ) !! See: [?gesv](https://www.intel.com/content/www/us/en/develop/documentation/onemkl-developer-reference-fortran/top/lapack-routines/lapack-linear-equation-routines/lapack-linear-equation-driver-routines/gesv.html) import :: wp implicit none integer :: info integer :: lda integer :: ldb integer :: n integer :: nrhs integer :: ipiv ( * ) real ( wp ) :: a ( lda , * ) real ( wp ) :: b ( ldb , * ) end subroutine dgesv subroutine dgels ( trans , m , n , nrhs , a , lda , b , ldb , work , lwork , info ) !! See: [?gels](https://www.intel.com/content/www/us/en/develop/documentation/onemkl-developer-reference-fortran/top/lapack-routines/lapack-least-squares-and-eigenvalue-problem/lapack-least-squares-eigenvalue-problem-driver/linear-least-squares-lls-problems-lapack-driver/gels.html) import :: wp implicit none character :: trans integer :: info integer :: lda integer :: ldb integer :: lwork integer :: m integer :: n integer :: nrhs real ( wp ) :: a ( lda , * ) real ( wp ) :: b ( ldb , * ) real ( wp ) :: work ( * ) end subroutine dgels end interface integer , dimension (:), allocatable :: ipiv !! pivot indices array real ( wp ), dimension (:,:), allocatable :: bmat !! copy of `b` so it won't be overwritten real ( wp ), dimension (:), allocatable :: work !! work array for `dgels` real ( wp ), dimension (:,:), allocatable :: amat !! copy of `a` so it won't be overwritten integer :: lwork !! size of `work` allocate ( amat ( m , n )) allocate ( bmat ( max ( 1 , m , n ), 1 )) if ( n == m ) then !normal inverse allocate ( ipiv ( n )) amat = a bmat ( 1 : n , 1 ) = b call dgesv ( n , 1 , amat , n , ipiv , bmat , n , info ) x = bmat ( 1 : n , 1 ) else amat = a bmat = zero bmat ( 1 : m , 1 ) = b lwork = min ( m , n ) + max ( 1 , m , n ) allocate ( work ( lwork )) call dgels ( 'N' , m , n , 1 , amat , m , bmat , max ( 1 , m , n ), work , lwork , info ) x = bmat ( 1 : n , 1 ) end if end subroutine linear_solver !***************************************************************************************** !***************************************************************************************** !> !  Take a simple step in the search direction of `p * alpha`. subroutine simple_step ( me , xold , p , x , f , fvec , fjac , fjac_sparse ) implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: xold !! previous value of `x` real ( wp ), dimension ( me % n ), intent ( in ) :: p !! search direction real ( wp ), dimension ( me % n ), intent ( out ) :: x !! new `x` real ( wp ), intent ( inout ) :: f !! magnitude of `fvec` real ( wp ), dimension ( me % m ), intent ( inout ) :: fvec !! function vector real ( wp ), dimension (:,:), intent ( in ), optional :: fjac !! jacobian matrix [dense] real ( wp ), dimension (:), intent ( in ), optional :: fjac_sparse !! jacobian matrix [sparse] x = xold + p * me % alpha !evaluate the function at the new point: call me % func ( x , fvec ) f = norm2 ( fvec ) end subroutine simple_step !***************************************************************************************** !***************************************************************************************** !> !  Backtracking line search. ! !### See also !  * [Backtracking line search](https://en.wikipedia.org/wiki/Backtracking_line_search) ! !@note Either `fjac` or `fjac_sparse` should be present. subroutine backtracking_linesearch ( me , xold , p , x , f , fvec , fjac , fjac_sparse ) implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: xold !! previous value of `x` real ( wp ), dimension ( me % n ), intent ( in ) :: p !! search direction real ( wp ), dimension ( me % n ), intent ( out ) :: x !! new `x` real ( wp ), intent ( inout ) :: f !! magnitude of `fvec` real ( wp ), dimension ( me % m ), intent ( inout ) :: fvec !! function vector real ( wp ), dimension (:,:), intent ( in ), optional :: fjac !! jacobian matrix [dense] real ( wp ), dimension (:), intent ( in ), optional :: fjac_sparse !! jacobian matrix [sparse] integer :: i !! counter real ( wp ) :: slope !! local slope of the function of `alpha` along the search direction used for line search logical :: min_alpha_reached !! if the minimum step size is reached during the line search real ( wp ) :: alpha !! `alpha` for the line search real ( wp ) :: ftmp !! `f` value for linesearch real ( wp ) :: t !! used for line search real ( wp ), dimension (:), allocatable :: gradf !! line search objective function gradient vector real ( wp ), dimension (:), allocatable :: xtmp !! `x` value for linesearch real ( wp ), dimension (:), allocatable :: fvectmp !! `fvec` value for linesearch ! allocate arrays: allocate ( gradf ( me % n )) allocate ( xtmp ( me % n )) allocate ( fvectmp ( me % m )) ! compute the gradient of the function to be minimized ! (which in this case is 1/2 the norm of fvec). Use the chain ! rule and the Jacobian matrix already computed. if ( present ( fjac )) then ! dense do i = 1 , me % n gradf ( i ) = dot_product ( fvec , fjac (:, i )) end do else ! sparse do i = 1 , me % n gradf ( i ) = dot_product ( fvec , pack ( fjac_sparse , mask = me % icol == i )) end do end if slope = dot_product ( p , gradf ) t = - me % c * slope if ( me % verbose ) then write ( me % iunit , '(1P,*(A,1X,E16.6))' ) '        slope    = ' , slope write ( me % iunit , '(1P,*(A,1X,E16.6))' ) '        t        = ' , t end if ! perform the line search: min_alpha_reached = . false . alpha = me % alpha_max ! start with the largest step do xtmp = xold + p * alpha call me % func ( xtmp , fvectmp ) ftmp = norm2 ( fvectmp ) if ( me % verbose ) then write ( me % iunit , '(1P,*(A,1X,E16.6))' ) '        alpha    = ' , alpha , ' f       = ' , ftmp if ( f - ftmp >= alpha * t ) then write ( me % iunit , '(1P,2(A,1X,E16.6),1X,A)' ) '        f - ftmp = ' , f - ftmp , ' alpha*t = ' , alpha * t , ' [ACCEPTED]' else write ( me % iunit , '(1P,*(A,1X,E16.6))' ) '        f - ftmp = ' , f - ftmp , ' alpha*t = ' , alpha * t end if end if if ((( f - ftmp ) / 2.0_wp >= alpha * t ) . or . min_alpha_reached ) then if ( min_alpha_reached ) then write ( me % iunit , '(A)' ) '        Minimum alpha reached' end if ! Armijo-Goldstein condition is satisfied ! (or the min step has been reached) x = xtmp fvec = fvectmp f = ftmp exit end if alpha = alpha * me % tau ! reduce step size if ( alpha <= me % alpha_min ) then alpha = me % alpha_min min_alpha_reached = . true . ! will stop on the next step end if end do end subroutine backtracking_linesearch !***************************************************************************************** !***************************************************************************************** !> !  An exact linesearch that uses a derivative-free minimizer to !  find the minimum value of `f(x)` between !  `x = xold + p * alpha_min` and !  `x = xold + p * alpha_max`. ! !  Usually this is overkill and not necessary, but is here as an option for testing. subroutine exact_linesearch ( me , xold , p , x , f , fvec , fjac , fjac_sparse ) implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: xold !! previous value of `x` real ( wp ), dimension ( me % n ), intent ( in ) :: p !! search direction real ( wp ), dimension ( me % n ), intent ( out ) :: x !! new `x` real ( wp ), intent ( inout ) :: f !! magnitude of `fvec` real ( wp ), dimension ( me % m ), intent ( inout ) :: fvec !! function vector real ( wp ), dimension (:,:), intent ( in ), optional :: fjac !! jacobian matrix [dense] real ( wp ), dimension (:), intent ( in ), optional :: fjac_sparse !! jacobian matrix [sparse] real ( wp ), dimension (:), allocatable :: xnew !! used in [[func_for_fmin]] real ( wp ) :: alpha_min allocate ( xnew ( me % n )) ! find the minimum value of f in the range of alphas: alpha_min = fmin ( func_for_fmin , me % alpha_min , me % alpha_max , me % fmin_tol ) if ( me % verbose ) write ( me % iunit , '(1P,*(A,1X,E16.6))' ) '        alpha_min = ' , alpha_min x = xold + p * alpha_min if ( all ( x == xnew )) then ! already computed in the func else call me % func ( x , fvec ) f = norm2 ( fvec ) end if contains real ( wp ) function func_for_fmin ( alpha ) !! function for [[fmin]] implicit none real ( wp ), intent ( in ) :: alpha !! indep variable xnew = xold + p * alpha call me % func ( xnew , fvec ) func_for_fmin = norm2 ( fvec ) ! return result f = func_for_fmin ! just in case this is the solution end function func_for_fmin end subroutine exact_linesearch !***************************************************************************************** !***************************************************************************************** !> !  A simple search that just evaluates the function at a specified !  number of points and picks the one with the minimum function value. subroutine fixed_point_linesearch ( me , xold , p , x , f , fvec , fjac , fjac_sparse ) implicit none class ( nlesolver_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: xold !! previous value of `x` real ( wp ), dimension ( me % n ), intent ( in ) :: p !! search direction real ( wp ), dimension ( me % n ), intent ( out ) :: x !! new `x` real ( wp ), intent ( inout ) :: f !! magnitude of `fvec` real ( wp ), dimension ( me % m ), intent ( inout ) :: fvec !! function vector real ( wp ), dimension (:,:), intent ( in ), optional :: fjac !! jacobian matrix [dense] real ( wp ), dimension (:), intent ( in ), optional :: fjac_sparse !! jacobian matrix [sparse] integer :: i !! counter integer :: n_points !! number of points to compute real ( wp ), dimension (:), allocatable :: alphas_to_try !! set of `alpha` values to try real ( wp ), dimension (:), allocatable :: x_tmp !! temp `x` real ( wp ), dimension (:), allocatable :: fvec_tmp !! temp `fvec` real ( wp ) :: f_tmp !! temp `f` real ( wp ) :: step_size !! step size for `alpha` integer :: n !! number of steps to divide the interval ! 1 o-----------o ! 2 o-----o-----o ! 3 o---o---o---o n = me % n_intervals n_points = n + 1 allocate ( alphas_to_try ( n_points )) allocate ( x_tmp ( me % n )) allocate ( fvec_tmp ( me % m )) step_size = ( me % alpha_max - me % alpha_min ) / real ( n , wp ) ! compute the alphas: alphas_to_try ( 1 ) = me % alpha_min do i = 2 , n alphas_to_try ( i ) = alphas_to_try ( i - 1 ) + step_size end do alphas_to_try ( n_points ) = me % alpha_max ! now compute the functions at these alphas: f = big do i = 1 , n_points x_tmp = xold + p * alphas_to_try ( i ) ! evaluate the function at tthis point: call me % func ( x_tmp , fvec_tmp ) f_tmp = norm2 ( fvec_tmp ) if ( f_tmp <= f ) then ! new best point x = x_tmp f = f_tmp fvec = fvec_tmp end if end do end subroutine fixed_point_linesearch !***************************************************************************************** !****************************************************************************************************** end module nlesolver_module !******************************************************************************************************","tags":"","loc":"sourcefile/nlesolver_module.f90.html"},{"title":"problem_12.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_12.f90~~EfferentGraph sourcefile~problem_12.f90 problem_12.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_12.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_12 use iso_fortran_env use aoc_utilities implicit none integer , parameter :: POINT = 0 integer , parameter :: NUMBER = 1 integer , parameter :: QUESTION = 2 ! some global variables integer , dimension (:), allocatable :: a , ints , ipattern , ipattern_tmp integer ( ip ) :: n_valid integer ( ip ) :: isum integer :: iline call clk % tic () call go (. false ., isum ); write ( * , * ) '12a: ' , isum ! call go(.true., isum); write(*,*) '12b: ', isum call clk % toc ( '12' ) contains subroutine go ( expand , isum ) logical , intent ( in ) :: expand integer ( ip ), intent ( out ) :: isum integer :: iunit , n_lines , n_unknowns integer ( ip ) :: n_perms character ( len = :), allocatable :: line , pattern type ( string ), dimension (:), allocatable :: vals ! open(newunit=iunit, file='inputs/day12_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day12.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ints = parse_ints ( vals ( 2 )% str ) ! integer list  1,1,3 pattern = vals ( 1 )% str ! the pattern   #.#.### ! will convert the pattern to an array of numbers: ipattern = str_to_int_array_with_mapping ( pattern ,[ '.' , '#' , '?' ],& [ POINT , NUMBER , QUESTION ]) ! 1010111 if ( expand ) then ! brute force it ipattern = [ ipattern , QUESTION , ipattern , QUESTION , & ipattern , QUESTION , ipattern , QUESTION , & ipattern ] ints = [ ints , ints , ints , ints , ints ] end if n_unknowns = count ( ipattern == 2 ) n_valid = 0 ! number of valid permutations n_perms = 2 ** n_unknowns ! number of permutations ipattern_tmp = ipattern ! recursively test all the permutations if ( allocated ( a )) deallocate ( a ) allocate ( a ( n_unknowns )) call test ( 1 , n_unknowns ) isum = isum + n_valid ! write(*,*) iline, 'n_valid = ', n_valid end do end subroutine go recursive subroutine test ( i , n ) !! each ? can be either a . or a # !! check pattern to match the int list integer , intent ( in ) :: i , n integer :: ix integer , dimension ( * ), parameter :: icoeffs = [ POINT , NUMBER ] !! set of coefficients ['.', '#'] ! what we are not doing here is accounting for permutations ! that we know do not match, because the begin with a sequence ! that doesn't match. those need to be skipped... if ( i > n ) then ! so we have an array of 0s and 1s -> replace the 2s in the ipattern with these !     ipattern: 2220111  -> ???.### !            a: 011      -> .## !       result: 0110111  -> .##.### !write(*,'(a,1x,i5,1x, *(I1))') 'test:', iline, ipattern_tmp ipattern_tmp = unpack ( a , mask = ipattern == QUESTION , field = ipattern ) if ( match ( ipattern_tmp , ints )) n_valid = n_valid + 1 else do ix = 1 , 2 a ( i ) = icoeffs ( ix ) call test ( i + 1 , n ) end do end if end subroutine test logical function match ( ipattern , ints ) !! returns true if the pattern is valid for the int list. integer , dimension (:), intent ( in ) :: ipattern integer , dimension (:), intent ( in ) :: ints integer :: i , iacc , int_checked integer , dimension ( 1 ) :: ifirst , iend logical :: accumulating ! .##..###... -> 2,3 ! start and end indices (ignoring leading and trailing spaces) ifirst = findloc ( ipattern , 1 ) iend = findloc ( ipattern , 1 , back = . true .) if ( ifirst ( 1 ) == 0 . or . iend ( 1 ) == 0 ) then ! all blank match = . false .; return end if ! step through the pattern and stop once we find it invalid accumulating = . true . iacc = 0 int_checked = 0 ! the count of ints that have been checked match = . true . ! initialize do i = ifirst ( 1 ), iend ( 1 ) select case ( ipattern ( i )) case ( POINT ) if ( accumulating ) then int_checked = int_checked + 1 ! check the next one if ( int_checked > size ( ints )) then ! too many ints match = . false . return else if ( ints ( int_checked ) /= iacc ) then ! doesn't match match = . false . return end if accumulating = . false . iacc = 0 end if case ( NUMBER ) if ( accumulating ) then iacc = iacc + 1 else ! start of a new number accumulating = . true . iacc = 1 end if if ( i == iend ( 1 )) then ! last number int_checked = int_checked + 1 ! check the next one if ( int_checked /= size ( ints )) then ! not enough ints match = . false . return else if ( ints ( int_checked ) /= iacc ) then ! doesn't match match = . false . return end if end if end select end do end function match end program problem_12","tags":"","loc":"sourcefile/problem_12.f90.html"},{"title":"problem_02.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_02.f90~~EfferentGraph sourcefile~problem_02.f90 problem_02.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_02.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_2 use iso_fortran_env use aoc_utilities implicit none integer :: iunit logical :: status_ok , game_possible character ( len = :), allocatable :: line , color integer :: n_lines , id , j , k , ipossible , inum , min_red , min_green , min_blue , power type ( string ), dimension (:), allocatable :: vals , trys , cubes , num_color integer , parameter :: n_red = 12 integer , parameter :: n_green = 13 integer , parameter :: n_blue = 14 call clk % tic () !example: Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green open ( newunit = iunit , file = 'inputs/day2.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) ! will parse the line with successive splits ipossible = 0 power = 0 main : do id = 1 , n_lines game_possible = . true . min_red = 0 ; min_green = 0 ; min_blue = 0 line = read_line ( iunit , status_ok ) vals = split ( line , ': ' ) trys = split ( vals ( 2 ), '; ' ) do j = 1 , size ( trys ) cubes = split ( trys ( j ), ', ' ) do k = 1 , size ( cubes ) num_color = split ( cubes ( k ), ' ' ) inum = int ( num_color ( 1 )% str ) color = num_color ( 2 )% str select case ( color ) case ( 'red' ) if ( inum > n_red ) game_possible = . false . if ( inum > min_red ) min_red = inum case ( 'green' ) if ( inum > n_green ) game_possible = . false . if ( inum > min_green ) min_green = inum case ( 'blue' ) if ( inum > n_blue ) game_possible = . false . if ( inum > min_blue ) min_blue = inum end select end do end do power = power + ( min_red * min_green * min_blue ) if ( game_possible ) ipossible = ipossible + id end do main write ( * , * ) '2a: result   :' , ipossible write ( * , * ) '2b: power sum:' , power close ( iunit ) call clk % toc ( '2' ) end program problem_2","tags":"","loc":"sourcefile/problem_02.f90.html"},{"title":"problem_17b.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_17b.f90~~EfferentGraph sourcefile~problem_17b.f90 problem_17b.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_17b.f90->sourcefile~aoc_utilities.f90 sourcefile~cache_module.f90~2 cache_module.f90 sourcefile~problem_17b.f90->sourcefile~cache_module.f90~2 sourcefile~cache_module.f90~2->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_17 !! part b use aoc_utilities use iso_fortran_env use aoc_cache_module implicit none integer , parameter :: NSTATE = 4 !! number of state dimensions [i,j,direction,moves_in_that_direction] integer , parameter :: N_DIRECTIONS = 4 ! 1,2,3,4 integer ( ip ), parameter :: UP = 1 ! direction traveling integer ( ip ), parameter :: DOWN = - 1 integer ( ip ), parameter :: LEFT = 2 integer ( ip ), parameter :: RIGHT = - 2 integer , parameter :: MAX_MOVES_IN_DIR = 10 !3 type ( function_cache ) :: cache !! to cache the queue access ... to try to speed things up !!! ! queue for the states and distances... rather than constructing the 2d array... ! just create this as we go... type :: item integer ( ip ), dimension ( NSTATE ) :: state = 0 !! state: [i, j, direction, and # of moves] integer ( ip ) :: dist = huge ( 1 ) !! distance for this one logical :: visited = . false . !! if this one is done integer ( ip ) :: iprev = - 1 !! index in the queue of the previous one end type item type ( item ), dimension (:), allocatable :: queue !! will be expanding integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: idx integer :: i , j , n_rows , n_cols integer , dimension (:,:), allocatable :: map !! heat map integer ( ip ) :: queue_size ! for the CI ! need a faster version ... write ( * , * ) 'it works but takes a few minutes...' stop call clk % tic () call cache % initialize ( isize = 10000 , chunk_size = 1000 ) ! map = read_file_to_int_array('inputs/day17_test.txt') map = read_file_to_int_array ( 'inputs/day17.txt' ) n_rows = size ( map , 1 ) n_cols = size ( map , 2 ) queue_size = 0 call add_to_queue ([ 1_ip , 1_ip , 0_ip , 0_ip ], idx ) ! start queue ( idx )% dist = 0 do ! find min distance so far for ones not visited iloc = minloc ( queue ( 1 : queue_size )% dist , mask = . not . queue ( 1 : queue_size )% visited ) idx = iloc ( 1 ) ! index in the queue queue ( idx )% visited = . true . if ( queue ( idx )% state ( 1 ) == n_rows . and . queue ( idx )% state ( 2 ) == n_cols ) exit ! destination: we are done ! process ajacent ones: call check ( idx , UP ) call check ( idx , DOWN ) call check ( idx , LEFT ) call check ( idx , RIGHT ) end do write ( * , * ) '17b: ' , queue ( idx )% dist call clk % toc ( '17' ) contains subroutine check ( idx , idirection ) implicit none integer ( ip ), intent ( in ) :: idx ! current item in the queue to process integer ( ip ), intent ( in ) :: idirection !! direction to move from current integer ( ip ) :: alt integer ( ip ), dimension ( 2 ) :: v ! neighbor to move to integer ( ip ) :: imovesv , idxv , distv integer ( ip ), dimension ( NSTATE ) :: istate logical :: in_queue associate ( i => queue ( idx )% state ( 1 ), & j => queue ( idx )% state ( 2 ), & direction => queue ( idx )% state ( 3 ), & n_moves => queue ( idx )% state ( 4 )) if ( direction ==- idirection ) return ! can't reverse ! the one to go to: if ( direction == idirection ) then if ( n_moves == MAX_MOVES_IN_DIR ) return ! can't move in this direction anymore imovesv = n_moves + 1 else if ( n_moves /= 0 . and . n_moves < 4 ) return ! must move at last 4 before a turn! imovesv = 1 ! reset on change of direction end if select case ( idirection ) case ( UP ); v = [ i - 1 , j ] case ( DOWN ); v = [ i + 1 , j ] case ( LEFT ); v = [ i , j - 1 ] case ( RIGHT ); v = [ i , j + 1 ] end select if ( v ( 1 ) < 1 . or . v ( 2 ) < 1 . or . v ( 1 ) > n_rows . or . v ( 2 ) > n_cols ) return ! can't go off the board if ( v ( 1 ) == n_rows . and . v ( 2 ) == n_cols . and . imovesv < 4 ) return ! require at least 4 to end istate = [ v ( 1 ), v ( 2 ), idirection , imovesv ] ! new state idxv = index_in_queue ( istate ) ! is it already in the queue in_queue = idxv > 0 ! if this one is already part of another path if ( in_queue ) then if ( queue ( idxv )% visited ) return ! already visited this one distv = queue ( idxv )% dist ! distance in the queue else !call add_to_queue(istate, idxv) ! add this to the queue for processing ! always add it ?? distv = huge ( 1_ip ) ! not processed yet, so huge number end if !alt = queue(idx)%dist + map(queue(idxv)%state(1), queue(idxv)%state(2)) alt = queue ( idx )% dist + map ( v ( 1 ), v ( 2 )) ! new distance if ( alt < distv ) then ! the new one is better, so replace values in the queue if (. not . in_queue ) call add_to_queue ( istate , idxv ) ! only add it if we accept it ???? ! accept this step queue ( idxv )% dist = alt ! new best dist queue ( idxv )% iprev = idx ! previous end if end associate end subroutine check ! .. need a faster queue... function index_in_queue ( state ) result ( idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ) :: idx !! index in the queue. -1 if not present integer ( ip ) :: i logical :: found integer ( ip ) :: cache_idx integer ( ip ), dimension (:), allocatable :: cache_ival call cache % get ( state , cache_idx , cache_ival , found ) if ( found ) then idx = cache_ival ( 1 ) else idx = - 1 if (. not . allocated ( queue )) error stop 'error: queue not allocated' do i = 1 , queue_size if ( all ( state == queue ( i )% state )) then idx = i exit end if end do if ( idx /= - 1 ) call cache % put ( cache_idx , state ,[ idx ]) end if end function index_in_queue subroutine add_to_queue ( state , idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ), intent ( out ) :: idx !! index of the element in the queue if ( allocated ( queue )) then call expand_queue ( queue , queue_size , item ( state = state )) idx = queue_size else queue = [ item ( state = state )] queue_size = 1 idx = 1 end if end subroutine add_to_queue !**************************************************************** !> !  Add elements to the integer vector in chunks. pure subroutine expand_queue ( vec , n , val , finished ) integer ( ip ), parameter :: chunk_size = 1000 type ( item ), dimension (:), allocatable , intent ( inout ) :: vec integer ( ip ), intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call type ( item ), intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) type ( item ), dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_queue !**************************************************************** end program problem_17","tags":"","loc":"sourcefile/problem_17b.f90.html"},{"title":"problem_11.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_11.f90~~EfferentGraph sourcefile~problem_11.f90 problem_11.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_11.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_11 use iso_fortran_env use aoc_utilities implicit none call clk % tic () write ( * , * ) '11a: ' , go ( 2_ip ) write ( * , * ) '11b: ' , go ( 1000000_ip ) call clk % toc ( '11' ) contains integer ( ip ) function go ( expansion_factor ) integer ( ip ), intent ( in ) :: expansion_factor integer :: i , j , nrows , ncols , n_galaxies , n , k character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:,:), allocatable :: idists integer ( ip ), dimension (:), allocatable :: igal , jgal integer ( ip ), dimension (:,:), allocatable :: ix , iy ! array = read_file_to_char_array('inputs/day11_test.txt') array = read_file_to_char_array ( 'inputs/day11.txt' ) nrows = size ( array , 1 ); ncols = size ( array , 2 ) n_galaxies = count ( array == '#' ) ! track the real indices after expansion ix = transpose ( spread ([( i , i = 1 , ncols )], 1 , nrows )) ! row indices iy = spread ([( i , i = 1 , nrows )], 1 , ncols ) ! col indices igal = pack ( ix , array == '#' ) ! indices of galaxies jgal = pack ( iy , array == '#' ) ! expand the array, keeping track of the new row indices do i = 1 , nrows ! add rows if necessary if ( all ( array ( i ,:) == '.' )) ix ( i :,:) = ix ( i :,:) + expansion_factor - 1 ! new row end do do j = 1 , ncols ! add cols if necessary if ( all ( array (:, j ) == '.' )) iy (:, j :) = iy (:, j :) + expansion_factor - 1 ! new column end do ! now compute all the distances: allocate ( idists ( n_galaxies , n_galaxies )); idists = 0 do i = 1 , n_galaxies do j = 1 , n_galaxies if ( j <= i ) cycle ! only need the lower diagonal idists ( i , j ) = manhatten_distance ( ix ( igal ( i ), jgal ( i )), iy ( igal ( i ), jgal ( i )),& ix ( igal ( j ), jgal ( j )), iy ( igal ( j ), jgal ( j ))) end do end do go = sum ( idists ) end function go end program problem_11","tags":"","loc":"sourcefile/problem_11.f90.html"},{"title":"utilities_module.f90 – AoC-2023","text":"This file depends on sourcefile~~utilities_module.f90~~EfferentGraph sourcefile~utilities_module.f90 utilities_module.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~utilities_module.f90->sourcefile~kinds_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~utilities_module.f90~~AfferentGraph sourcefile~utilities_module.f90 utilities_module.f90 sourcefile~cache_module.f90 cache_module.f90 sourcefile~cache_module.f90->sourcefile~utilities_module.f90 sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~utilities_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~cache_module.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~numerical_differentiation_module.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~numerical_differentiation_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> author: Jacob Williams ! !  Utility routines. module numdiff_utilities_module use numdiff_kinds_module integer , parameter :: max_size_for_insertion_sort = 20 !! max size for using insertion sort. private interface expand_vector module procedure :: expand_vector_int , expand_vector_real end interface expand_vector public :: expand_vector interface unique module procedure :: unique_int , unique_real end interface unique public :: unique interface sort_ascending module procedure :: sort_ascending_int , sort_ascending_real end interface sort_ascending public :: sort_ascending interface swap module procedure :: swap_int , swap_real end interface swap public :: equal_within_tol public :: divide_interval contains !******************************************************************************* !******************************************************************************* !> !  Add elements to the integer vector in chunks. pure subroutine expand_vector_int ( vec , n , chunk_size , val , finished ) implicit none integer , dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ) :: chunk_size !! allocate `vec` in blocks of this size (>0) integer , intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) integer , dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector_int !******************************************************************************* !******************************************************************************* !> !  Add elements to the real vector in chunks. pure subroutine expand_vector_real ( vec , n , chunk_size , val , finished ) implicit none real ( wp ), dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ) :: chunk_size !! allocate `vec` in blocks of this size (>0) real ( wp ), intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) real ( wp ), dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector_real !******************************************************************************* !******************************************************************************* !> !  Returns only the unique elements of the vector (sorted in ascending order). function unique_int ( vec , chunk_size ) result ( ivec_unique ) implicit none integer , dimension (:), intent ( in ) :: vec !! a vector of integers integer , intent ( in ) :: chunk_size !! chunk size for adding to arrays integer , dimension (:), allocatable :: ivec_unique !! unique elements of `ivec` integer , dimension ( size ( vec )) :: ivec !! temp copy of vec integer :: i !! counter integer :: n !! number of unique elements ! first we sort it: ivec = vec ! make a copy call sort_ascending ( ivec ) ! add the first element: n = 1 ivec_unique = [ ivec ( 1 )] ! walk through array and get the unique ones: if ( size ( ivec ) > 1 ) then do i = 2 , size ( ivec ) if ( ivec ( i ) /= ivec ( i - 1 )) then call expand_vector ( ivec_unique , n , chunk_size , val = ivec ( i )) end if end do call expand_vector ( ivec_unique , n , chunk_size , finished = . true .) end if end function unique_int !******************************************************************************* !******************************************************************************* !> !  Returns only the unique elements of the vector (sorted in ascending order). function unique_real ( vec , chunk_size ) result ( ivec_unique ) implicit none real ( wp ), dimension (:), intent ( in ) :: vec !! a vector of integers integer , intent ( in ) :: chunk_size !! chunk size for adding to arrays real ( wp ), dimension (:), allocatable :: ivec_unique !! unique elements of `ivec` real ( wp ), dimension ( size ( vec )) :: ivec !! temp copy of vec integer :: i !! counter integer :: n !! number of unique elements ! first we sort it: ivec = vec ! make a copy call sort_ascending ( ivec ) ! add the first element: n = 1 ivec_unique = [ ivec ( 1 )] ! walk through array and get the unique ones: if ( size ( ivec ) > 1 ) then do i = 2 , size ( ivec ) if ( ivec ( i ) /= ivec ( i - 1 )) then call expand_vector ( ivec_unique , n , chunk_size , val = ivec ( i )) end if end do call expand_vector ( ivec_unique , n , chunk_size , finished = . true .) end if end function unique_real !******************************************************************************* !******************************************************************************* !> !  Sorts an integer array `ivec` in increasing order. !  Uses a basic recursive quicksort !  (with insertion sort for partitions with \\le 20 elements). subroutine sort_ascending_int ( ivec ) implicit none integer , dimension (:), intent ( inout ) :: ivec call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending_int !******************************************************************************* !******************************************************************************* !> !  Sorts a real array `ivec` in increasing order. !  Uses a basic recursive quicksort !  (with insertion sort for partitions with \\le 20 elements). subroutine sort_ascending_real ( ivec ) implicit none real ( wp ), dimension (:), intent ( inout ) :: ivec call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending_real !******************************************************************************* !******************************************************************************* !> !  Swap two integer values. pure elemental subroutine swap_int ( i1 , i2 ) implicit none integer , intent ( inout ) :: i1 integer , intent ( inout ) :: i2 integer :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_int !******************************************************************************* !******************************************************************************* !> !  Swap two integer values. pure elemental subroutine swap_real ( i1 , i2 ) implicit none real ( wp ), intent ( inout ) :: i1 real ( wp ), intent ( inout ) :: i2 real ( wp ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap_real !******************************************************************************* !******************************************************************************* !> !  Returns true if the values in the array are the same !  (to within the specified absolute tolerance). pure function equal_within_tol ( vals , tol ) result ( equal ) implicit none real ( wp ), dimension (:), intent ( in ) :: vals !! a set of values real ( wp ), intent ( in ) :: tol !! a positive tolerance value logical :: equal !! true if they are equal !! within the tolerance equal = all ( abs ( vals - vals ( 1 )) <= abs ( tol ) ) end function equal_within_tol !******************************************************************************* !******************************************************************************* !> !  Returns a set of slightly randomized equally-spaced !  points that divide an interval. ! !### Example: ! !  for `num_points` = 3: !``` !     o---|---|---|---o !         1   2   3 !``` !  returns: `[0.25308641972530865, 0.5061728394506173, 0.759259259175926]`. function divide_interval ( num_points ) result ( points ) implicit none integer , intent ( in ) :: num_points !! the number of points in the interval real ( wp ), dimension (:), allocatable :: points !! the resultant vector real ( wp ), parameter :: noise = 1.012345678901234567_wp !! a noise value. Not a round number !! so as to avoid freak zeros in the !! jacobian real ( wp ), parameter :: min_val = 1 0.0_wp * epsilon ( 1.0_wp ) !! the minimize distance from the lower bound real ( wp ), parameter :: max_val = 1.0_wp - min_val !! the minimize distance from the upper bound integer :: i !! counter real ( wp ) :: delta !! step size real ( wp ), dimension (:), allocatable :: tmp !! a temp array to hold the values delta = 1.0_wp / ( num_points + 1 ) allocate ( tmp ( num_points )) do i = 1 , num_points tmp ( i ) = min ( max ( min_val , delta * i * noise ), max_val ) end do ! this is to protect for the min/max case if there ! are enough points so that some are duplicated near ! the bounds: points = unique ( tmp , chunk_size = 10 ) end function divide_interval !******************************************************************************* !******************************************************************************* end module numdiff_utilities_module !*******************************************************************************","tags":"","loc":"sourcefile/utilities_module.f90.html"},{"title":"dsm_module.f90 – AoC-2023","text":"This file depends on sourcefile~~dsm_module.f90~~EfferentGraph sourcefile~dsm_module.f90 dsm_module.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~dsm_module.f90->sourcefile~kinds_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~dsm_module.f90~~AfferentGraph sourcefile~dsm_module.f90 dsm_module.f90 sourcefile~dsm_test.f90 dsm_test.f90 sourcefile~dsm_test.f90->sourcefile~dsm_module.f90 sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~dsm_module.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~numerical_differentiation_module.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~numerical_differentiation_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> !  Jacobian partitioning using the DSM algorithm. ! !### Reference !  * Argonne National Laboratory. MINPACK Project. July 1983. !    Thomas F. Coleman, Burton S. Garbow, Jorge J. More !  * Thomas F. Coleman, Burton S. Garbow, Jorge J. More, \"Algorithm 618: !    FORTRAN subroutines for estimating sparse Jacobian Matrices\", !    ACM Transactions on Mathematical Software (TOMS), !    Volume 10 Issue 3, Sept. 1984, Pages 346-347 ! !### History !  * Jacob Williams, Nov. 2016, extensive refactoring into modern Fortran. module dsm_module use numdiff_kinds_module implicit none private public :: dsm public :: fdjs contains !******************************************************************************* !******************************************************************************* !> !  The purpose of `dsm` is to determine an optimal or near- !  optimal consistent partition of the columns of a sparse !  `m` by `n` matrix `a`. ! !  the sparsity pattern of the matrix `a` is specified by !  the arrays `indrow` and `indcol`. on input the indices !  for the non-zero elements of `a` are ! !  `indrow(k),indcol(k), k = 1,2,...,npairs`. ! !  the (`indrow`,`indcol`) pairs may be specified in any order. !  duplicate input pairs are permitted, but the subroutine !  eliminates them. ! !  the subroutine partitions the columns of `a` into groups !  such that columns in the same group do not have a !  non-zero in the same row position. a partition of the !  columns of `a` with this property is consistent with the !  direct determination of `a`. subroutine dsm ( m , n , Npairs , Indrow , Indcol , Ngrp , Maxgrp , Mingrp , Info , Ipntr , Jpntr ) implicit none integer , intent ( in ) :: m !! number of rows of `a` (>0) integer , intent ( in ) :: n !! number of columns of `a` (>0) integer , intent ( in ) :: npairs !! number of (`indrow`,`indcol`) pairs used !! to describe the sparsity pattern of `a` (>0) integer , intent ( out ) :: maxgrp !! the number of groups in the partition !! of the columns of `a`. integer , intent ( out ) :: mingrp !! a lower bound for the number of groups !! in any consistent partition of the !! columns of `a`. integer , intent ( out ) :: info !! for normal termination `info = 1`. !! if `m`, `n`, or `npairs` is not positive, !! then `info = 0`. if the k-th element of !! `indrow` is not an integer between !! 1 and m or the k-th element of `indcol` !! is not an integer between 1 and n, !! then `info = -k`. integer , dimension ( npairs ), intent ( inout ) :: indrow !! an integer array of length `npairs`. on input `indrow` !! must contain the row indices of the non-zero elements of `a`. !! on output `indrow` is permuted so that the corresponding !! column indices are in non-decreasing order. the column !! indices can be recovered from the array `jpntr`. integer , dimension ( npairs ), intent ( inout ) :: indcol !! an integer array of length `npairs`. on input `indcol` !! must contain the column indices of the non-zero elements of !! `a`. on output `indcol` is permuted so that the corresponding !! row indices are in non-decreasing order. the row indices !! can be recovered from the array `ipntr`. integer , dimension ( n ), intent ( out ) :: ngrp !! specifies the partition of the columns of `a`. !! column `jcol` belongs to group `ngrp(jcol)`. integer , dimension ( m + 1 ), intent ( out ) :: ipntr !! an integer output array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! note that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n + 1 ), intent ( out ) :: jpntr !! jpntr is an integer output array of length n + 1 which !! specifies the locations of the row indices in indrow. !! the row indices for column j are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! note that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( max ( m , 6 * n )) :: iwa !! an integer work array integer :: i , ir , j , jp , k , maxclq , nnz , numgrp !  check the input data. Info = 0 if ( m < 1 . or . n < 1 . or . Npairs < 1 ) return do k = 1 , Npairs Info = - k if ( Indrow ( k ) < 1 . or . Indrow ( k ) > m . or . Indcol ( k ) < 1 . or . Indcol ( k ) > n ) return enddo Info = 1 !  sort the data structure by columns. call srtdat ( n , Npairs , Indrow , Indcol , Jpntr , Iwa ) !  compress the data and determine the number of !  non-zero elements of a. do i = 1 , m Iwa ( i ) = 0 enddo nnz = 1 do j = 1 , n k = nnz do jp = Jpntr ( j ) , Jpntr ( j + 1 ) - 1 ir = Indrow ( jp ) if ( Iwa ( ir ) /= j ) then Indrow ( nnz ) = ir nnz = nnz + 1 Iwa ( ir ) = j endif enddo Jpntr ( j ) = k enddo Jpntr ( n + 1 ) = nnz !  extend the data structure to rows. call setr ( m , n , Indrow , Jpntr , Indcol , Ipntr , Iwa ) !  determine a lower bound for the number of groups. Mingrp = 0 do i = 1 , m Mingrp = max ( Mingrp , Ipntr ( i + 1 ) - Ipntr ( i )) enddo !  determine the degree sequence for the intersection !  graph of the columns of a. call degr ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 5 * n + 1 ), Iwa ( n + 1 )) !  color the intersection graph of the columns of a !  with the smallest-last (sl) ordering. call slo ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 5 * n + 1 ), Iwa ( 4 * n + 1 ), maxclq ,& Iwa ( 1 ), Iwa ( n + 1 ), Iwa ( 2 * n + 1 ), Iwa ( 3 * n + 1 )) call seq ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 4 * n + 1 ), Ngrp , Maxgrp , & Iwa ( n + 1 )) Mingrp = max ( Mingrp , maxclq ) !  exit if the smallest-last ordering is optimal. if ( Maxgrp == Mingrp ) return !  color the intersection graph of the columns of a !  with the incidence-degree (id) ordering. call ido ( m , n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 5 * n + 1 ), Iwa ( 4 * n + 1 ), & maxclq , Iwa ( 1 ), Iwa ( n + 1 ), Iwa ( 2 * n + 1 ), Iwa ( 3 * n + 1 )) call seq ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 4 * n + 1 ), Iwa ( 1 ), numgrp , & Iwa ( n + 1 )) Mingrp = max ( Mingrp , maxclq ) !  retain the better of the two orderings so far. if ( numgrp < Maxgrp ) then Maxgrp = numgrp do j = 1 , n Ngrp ( j ) = Iwa ( j ) enddo !  exit if the incidence-degree ordering is optimal. if ( Maxgrp == Mingrp ) return endif !  color the intersection graph of the columns of a !  with the largest-first (lf) ordering. call numsrt ( n , n - 1 , Iwa ( 5 * n + 1 ), - 1 , Iwa ( 4 * n + 1 ), Iwa ( 2 * n + 1 ), Iwa ( n + 1 )) call seq ( n , Indrow , Jpntr , Indcol , Ipntr , Iwa ( 4 * n + 1 ), Iwa ( 1 ), numgrp , & Iwa ( n + 1 )) !  retain the best of the three orderings and exit. if ( numgrp < Maxgrp ) then Maxgrp = numgrp do j = 1 , n Ngrp ( j ) = Iwa ( j ) enddo endif end subroutine dsm !******************************************************************************* !******************************************************************************* !> !  Given the sparsity pattern of an `m` by `n` matrix `a`, !  this subroutine determines the degree sequence for !  the intersection graph of the columns of `a`. ! !  In graph-theory terminology, the intersection graph of !  the columns of `a` is the loopless graph `g` with vertices !  `a(j), j = 1,2,...,n` where `a(j)` is the `j`-th column of `a` !  and with edge `(a(i),a(j))` if and only if columns `i` and `j` !  have a non-zero in the same row position. ! !@note The value of `m` is not needed by `degr` and is !      therefore not present in the subroutine statement. subroutine degr ( n , Indrow , Jpntr , Indcol , Ipntr , Ndeg , Iwa ) implicit none integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of `a`. integer , dimension ( * ), intent ( in ) :: indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ), intent ( in ) :: jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ), intent ( in ) :: indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( * ), intent ( in ) :: ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ), intent ( out ) :: ndeg !! an integer output array of length `n` which !! specifies the degree sequence. the degree of the !! `j`-th column of `a` is `ndeg(j)`. integer , dimension ( n ) :: iwa !! an integer work array of length `n` integer :: ic , ip , ir , jcol , jp ! initialization block. do jp = 1 , n Ndeg ( jp ) = 0 Iwa ( jp ) = 0 enddo ! compute the degree sequence by determining the contributions ! to the degrees from the current(jcol) column and further ! columns which have not yet been considered. do jcol = 2 , n Iwa ( jcol ) = n ! determine all positions (ir,jcol) which correspond ! to non-zeroes in the matrix. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! for each row ir, determine all positions (ir,ic) ! which correspond to non-zeroes in the matrix. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! array iwa marks columns which have contributed to ! the degree count of column jcol. update the degree ! counts of these columns as well as column jcol. if ( Iwa ( ic ) < jcol ) then Iwa ( ic ) = jcol Ndeg ( ic ) = Ndeg ( ic ) + 1 Ndeg ( jcol ) = Ndeg ( jcol ) + 1 endif enddo enddo enddo end subroutine degr !******************************************************************************* !******************************************************************************* !> !  given the sparsity pattern of an `m` by `n` matrix `a`, this !  subroutine determines an incidence-degree ordering of the !  columns of `a`. ! !  the incidence-degree ordering is defined for the loopless !  graph `g` with vertices `a(j), j = 1,2,...,n` where `a(j)` is the !  `j`-th column of `a` and with edge `(a(i),a(j))` if and only if !  columns `i` and `j` have a non-zero in the same row position. ! !  the incidence-degree ordering is determined recursively by !  letting `list(k), k = 1,...,n` be a column with maximal !  incidence to the subgraph spanned by the ordered columns. !  among all the columns of maximal incidence, `ido` chooses a !  column of maximal degree. subroutine ido ( m , n , Indrow , Jpntr , Indcol , Ipntr , Ndeg , List , Maxclq , & Iwa1 , Iwa2 , Iwa3 , Iwa4 ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of `a`. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of `a`. integer , intent ( out ) :: Maxclq !! an integer output variable set to the size !! of the largest clique found during the ordering. integer , dimension ( * ), intent ( in ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ), intent ( in ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ), intent ( in ) :: Indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( m + 1 ), intent ( in ) :: Ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ), intent ( in ) :: Ndeg !! an integer input array of length `n` which specifies !! the degree sequence. the degree of the `j`-th column !! of `a` is `ndeg(j)`. integer , dimension ( n ), intent ( out ) :: List !! an integer output array of length `n` which specifies !! the incidence-degree ordering of the columns of `a`. the `j`-th !! column in this order is `list(j)`. integer , dimension ( 0 : n - 1 ) :: Iwa1 !! integer work array of length `n`. integer , dimension ( n ) :: Iwa2 !! integer work array of length `n`. integer , dimension ( n ) :: Iwa3 !! integer work array of length `n`. integer , dimension ( n ) :: Iwa4 !! integer work array of length `n`. integer :: ic , ip , ir , jcol , jp , maxinc , maxlst , ncomp , & numinc , numlst , numord , numwgt ! sort the degree sequence. call numsrt ( n , n - 1 , Ndeg , - 1 , Iwa4 , Iwa2 , Iwa3 ) ! initialization block. ! ! create a doubly-linked list to access the incidences of the ! columns. the pointers for the linked list are as follows. ! ! each un-ordered column ic is in a list (the incidence list) ! of columns with the same incidence. ! ! iwa1(numinc) is the first column in the numinc list ! unless iwa1(numinc) = 0. in this case there are ! no columns in the numinc list. ! ! iwa2(ic) is the column before ic in the incidence list ! unless iwa2(ic) = 0. in this case ic is the first ! column in this incidence list. ! ! iwa3(ic) is the column after ic in the incidence list ! unless iwa3(ic) = 0. in this case ic is the last ! column in this incidence list. ! ! if ic is an un-ordered column, then list(ic) is the ! incidence of ic to the graph induced by the ordered ! columns. if jcol is an ordered column, then list(jcol) ! is the incidence-degree order of column jcol. maxinc = 0 do jp = n , 1 , - 1 ic = Iwa4 ( jp ) Iwa1 ( n - jp ) = 0 Iwa2 ( ic ) = 0 Iwa3 ( ic ) = Iwa1 ( 0 ) if ( Iwa1 ( 0 ) > 0 ) Iwa2 ( Iwa1 ( 0 )) = ic Iwa1 ( 0 ) = ic Iwa4 ( jp ) = 0 List ( jp ) = 0 enddo ! DETERMINE THE MAXIMAL SEARCH LENGTH FOR THE LIST ! OF COLUMNS OF MAXIMAL INCIDENCE. maxlst = 0 do ir = 1 , m maxlst = maxlst + ( Ipntr ( ir + 1 ) - Ipntr ( ir )) ** 2 enddo maxlst = maxlst / n Maxclq = 0 numord = 1 ! BEGINNING OF ITERATION LOOP. ! UPDATE THE SIZE OF THE LARGEST CLIQUE ! FOUND DURING THE ORDERING. 100 if ( maxinc == 0 ) ncomp = 0 ncomp = ncomp + 1 if ( maxinc + 1 == ncomp ) Maxclq = max ( Maxclq , ncomp ) ! CHOOSE A COLUMN JCOL OF MAXIMAL DEGREE AMONG THE ! COLUMNS OF MAXIMAL INCIDENCE MAXINC. 200 jp = Iwa1 ( maxinc ) if ( jp > 0 ) then numwgt = - 1 do numlst = 1 , maxlst if ( Ndeg ( jp ) > numwgt ) then numwgt = Ndeg ( jp ) jcol = jp endif jp = Iwa3 ( jp ) if ( jp <= 0 ) exit enddo List ( jcol ) = numord numord = numord + 1 ! TERMINATION TEST. if ( numord > n ) then ! INVERT THE ARRAY LIST. do jcol = 1 , n Iwa2 ( List ( jcol )) = jcol enddo do jp = 1 , n List ( jp ) = Iwa2 ( jp ) enddo else ! DELETE COLUMN JCOL FROM THE MAXINC LIST. if ( Iwa2 ( jcol ) == 0 ) then Iwa1 ( maxinc ) = Iwa3 ( jcol ) else Iwa3 ( Iwa2 ( jcol )) = Iwa3 ( jcol ) endif if ( Iwa3 ( jcol ) > 0 ) Iwa2 ( Iwa3 ( jcol )) = Iwa2 ( jcol ) ! FIND ALL COLUMNS ADJACENT TO COLUMN JCOL. Iwa4 ( jcol ) = n ! DETERMINE ALL POSITIONS (IR,JCOL) WHICH CORRESPOND ! TO NON-ZEROES IN THE MATRIX. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! FOR EACH ROW IR, DETERMINE ALL POSITIONS (IR,IC) ! WHICH CORRESPOND TO NON-ZEROES IN THE MATRIX. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! ARRAY IWA4 MARKS COLUMNS WHICH ARE ADJACENT TO ! COLUMN JCOL. if ( Iwa4 ( ic ) < numord ) then Iwa4 ( ic ) = numord ! UPDATE THE POINTERS TO THE CURRENT INCIDENCE LISTS. numinc = List ( ic ) List ( ic ) = List ( ic ) + 1 maxinc = max ( maxinc , List ( ic )) ! DELETE COLUMN IC FROM THE NUMINC LIST. if ( Iwa2 ( ic ) == 0 ) then Iwa1 ( numinc ) = Iwa3 ( ic ) else Iwa3 ( Iwa2 ( ic )) = Iwa3 ( ic ) endif if ( Iwa3 ( ic ) > 0 ) Iwa2 ( Iwa3 ( ic )) = Iwa2 ( ic ) ! ADD COLUMN IC TO THE NUMINC+1 LIST. Iwa2 ( ic ) = 0 Iwa3 ( ic ) = Iwa1 ( numinc + 1 ) if ( Iwa1 ( numinc + 1 ) > 0 ) Iwa2 ( Iwa1 ( numinc + 1 )) = ic Iwa1 ( numinc + 1 ) = ic endif enddo enddo ! END OF ITERATION LOOP. goto 100 endif else maxinc = maxinc - 1 goto 200 endif end subroutine ido !******************************************************************************* !******************************************************************************* !> !  Given a sequence of integers, this subroutine groups !  together those indices with the same sequence value !  and, optionally, sorts the sequence into either !  ascending or descending order. ! !  The sequence of integers is defined by the array `num`, !  and it is assumed that the integers are each from the set !  `0,1,...,nmax`. on output the indices `k` such that `num(k) = l` !  for any `l = 0,1,...,nmax` can be obtained from the arrays !  last and next as follows. !```fortran !  k = last(l) !  while (k /= 0) k = next(k) !``` !  Optionally, the subroutine produces an array index so that !  the sequence `num(index(i)), i = 1,2,...,n` is sorted. subroutine numsrt ( n , Nmax , Num , Mode , Index , Last , Next ) implicit none integer , intent ( in ) :: n !! a positive integer input variable. integer :: Nmax !! a positive integer input variable. integer :: Mode !! an integer input variable. the sequence `num` is !! sorted in ascending order if `mode` is positive and in !! descending order if `mode` is negative. if `mode` is 0, !! no sorting is done. integer , dimension ( n ) :: Num !! an input array of length `n` which contains the !! sequence of integers to be grouped and sorted. it !! is assumed that the integers are each from the set !! `0,1,...,nmax`. integer , dimension ( n ) :: Index !! an integer output array of length `n` set so !! that the sequence !! `num(index(i)), i = 1,2,...,n` !! is sorted according to the setting of mode. !! if `mode` is 0, `index` is not referenced. integer , dimension ( 0 : Nmax ) :: Last !! an integer output array of length `nmax + 1`. the !! index of `num` for the last occurrence of `l` is `last(l)` !! for any `l = 0,1,...,nmax` unless `last(l) = 0`. in !! this case `l` does not appear in `num`. integer , dimension ( n ) :: Next !! an integer output array of length `n`. if !! `num(k) = l`, then the index of `num` for the previous !! occurrence of `l` is `next(k)` for any `l = 0,1,...,nmax` !! unless `next(k) = 0`. in this case there is no previous !! occurrence of `l` in `num`. integer :: i , j , jinc , jl , ju , k , l ! determine the arrays next and last. do i = 0 , Nmax Last ( i ) = 0 enddo do k = 1 , n l = Num ( k ) Next ( k ) = Last ( l ) Last ( l ) = k enddo if ( Mode /= 0 ) then ! store the pointers to the sorted array in index. i = 1 if ( Mode > 0 ) then jl = 0 ju = Nmax jinc = 1 else jl = Nmax ju = 0 jinc = - 1 endif do j = jl , ju , jinc k = Last ( j ) do if ( k == 0 ) exit Index ( i ) = k i = i + 1 k = Next ( k ) enddo enddo end if end subroutine numsrt !******************************************************************************* !******************************************************************************* !> !  given the sparsity pattern of an `m` by `n` matrix `a`, this !  subroutine determines a consistent partition of the !  columns of `a` by a sequential algorithm. ! !  a consistent partition is defined in terms of the loopless !  graph `g` with vertices `a(j), j = 1,2,...,n` where `a(j)` is the !  `j`-th column of `a` and with edge `(a(i),a(j))` if and only if !  columns `i` and `j` have a non-zero in the same row position. ! !  a partition of the columns of a into groups is consistent !  if the columns in any group are not adjacent in the graph `g`. !  in graph-theory terminology, a consistent partition of the !  columns of a corresponds to a coloring of the graph `g`. ! !  the subroutine examines the columns in the order specified !  by the array list, and assigns the current column to the !  group with the smallest possible number. ! !  note that the value of `m` is not needed by `seq` and is !  therefore not present in the subroutine statement. subroutine seq ( n , Indrow , Jpntr , Indcol , Ipntr , List , Ngrp , Maxgrp , Iwa ) implicit none integer :: n !! a positive integer input variable set to the number !! of columns of `a`. integer :: Maxgrp !! an integer output variable which specifies the !! number of groups in the partition of the columns of `a`. integer , dimension ( * ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ) :: Indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( * ) :: Ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ) :: List !! an integer input array of length `n` which specifies !! the order to be used by the sequential algorithm. !! the `j`-th column in this order is `list(j)`. integer , dimension ( n ) :: Ngrp !! an integer output array of length `n` which specifies !! the partition of the columns of `a`. column `jcol` belongs !! to group `ngrp(jcol)`. integer , dimension ( n ) :: Iwa !! an integer work array of length `n` integer :: ic , ip , ir , j , jcol , jp ! initialization block. Maxgrp = 0 do jp = 1 , n Ngrp ( jp ) = n Iwa ( jp ) = 0 enddo ! beginning of iteration loop. do j = 1 , n jcol = List ( j ) ! find all columns adjacent to column jcol. ! ! determine all positions (ir,jcol) which correspond ! to non-zeroes in the matrix. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! for each row ir, determine all positions (ir,ic) ! which correspond to non-zeroes in the matrix. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! array iwa marks the group numbers of the ! columns which are adjacent to column jcol. Iwa ( Ngrp ( ic )) = j enddo enddo ! assign the smallest un-marked group number to jcol. do jp = 1 , Maxgrp if ( Iwa ( jp ) /= j ) then Maxgrp = Maxgrp - 1 exit end if enddo Maxgrp = Maxgrp + 1 Ngrp ( jcol ) = jp enddo ! end of iteration loop. end subroutine seq !******************************************************************************* !******************************************************************************* !> !  given a column-oriented definition of the sparsity pattern !  of an `m` by `n` matrix `a`, this subroutine determines a !  row-oriented definition of the sparsity pattern of `a`. ! !  on input the column-oriented definition is specified by !  the arrays `indrow` and `jpntr`. on output the row-oriented !  definition is specified by the arrays `indcol` and `ipntr`. subroutine setr ( m , n , Indrow , Jpntr , Indcol , Ipntr , Iwa ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of `a`. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of `a`. integer , dimension ( * ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ) :: Indcol !! an integer output array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( m + 1 ) :: Ipntr !! an integer output array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(1)` is set to 1 and that `ipntr(m+1)-1` is !! then the number of non-zero elements of the matrix `a`. integer , dimension ( m ) :: Iwa !! an integer work array of length `m`. integer :: ir , jcol , jp ! store in array iwa the counts of non-zeroes in the rows. do ir = 1 , m Iwa ( ir ) = 0 enddo do jp = 1 , Jpntr ( n + 1 ) - 1 Iwa ( Indrow ( jp )) = Iwa ( Indrow ( jp )) + 1 enddo ! set pointers to the start of the rows in indcol. Ipntr ( 1 ) = 1 do ir = 1 , m Ipntr ( ir + 1 ) = Ipntr ( ir ) + Iwa ( ir ) Iwa ( ir ) = Ipntr ( ir ) enddo ! fill indcol. do jcol = 1 , n do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) Indcol ( Iwa ( ir )) = jcol Iwa ( ir ) = Iwa ( ir ) + 1 enddo enddo end subroutine setr !******************************************************************************* !******************************************************************************* !> !  given the sparsity pattern of an `m` by `n` matrix `a`, this !  subroutine determines the smallest-last ordering of the !  columns of `a`. ! !  the smallest-last ordering is defined for the loopless !  graph `g` with vertices `a(j), j = 1,2,...,n` where `a(j)` is the !  `j`-th column of `a` and with edge `(a(i),a(j))` if and only if !  columns `i` and `j` have a non-zero in the same row position. ! !  the smallest-last ordering is determined recursively by !  letting `list(k), k = n,...,1` be a column with least degree !  in the subgraph spanned by the un-ordered columns. ! !  note that the value of `m` is not needed by `slo` and is !  therefore not present in the subroutine statement. subroutine slo ( n , Indrow , Jpntr , Indcol , Ipntr , Ndeg , List , Maxclq , Iwa1 , & Iwa2 , Iwa3 , Iwa4 ) implicit none integer :: n !! a positive integer input variable set to the number !! of columns of `a`. integer :: Maxclq !! an integer output variable set to the size !! of the largest clique found during the ordering. integer , dimension ( * ) :: Indrow !! an integer input array which contains the row !! indices for the non-zeroes in the matrix `a`. integer , dimension ( n + 1 ) :: Jpntr !! an integer input array of length `n + 1` which !! specifies the locations of the row indices in `indrow`. !! the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(n+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( * ) :: Indcol !! an integer input array which contains the !! column indices for the non-zeroes in the matrix `a`. integer , dimension ( * ) :: Ipntr !! an integer input array of length `m + 1` which !! specifies the locations of the column indices in `indcol`. !! the column indices for row `i` are !! `indcol(k), k = ipntr(i),...,ipntr(i+1)-1`. !! **note** that `ipntr(m+1)-1` is then the number of non-zero !! elements of the matrix `a`. integer , dimension ( n ) :: Ndeg !! an integer input array of length `n` which specifies !! the degree sequence. the degree of the `j`-th column !! of `a` is `ndeg(j)`. integer , dimension ( n ) :: List !! an integer output array of length `n` which specifies !! the smallest-last ordering of the columns of `a`. the `j`-th !! column in this order is `list(j)`. integer , dimension ( 0 : n - 1 ) :: Iwa1 !! integer work array of length `n` integer , dimension ( n ) :: Iwa2 !! integer work array of length `n` integer , dimension ( n ) :: Iwa3 !! integer work array of length `n` integer , dimension ( n ) :: Iwa4 !! integer work array of length `n` integer :: ic , ip , ir , jcol , jp , mindeg , numdeg , numord ! INITIALIZATION BLOCK. mindeg = n do jp = 1 , n Iwa1 ( jp - 1 ) = 0 Iwa4 ( jp ) = n List ( jp ) = Ndeg ( jp ) mindeg = min ( mindeg , Ndeg ( jp )) enddo ! CREATE A DOUBLY-LINKED LIST TO ACCESS THE DEGREES OF THE ! COLUMNS. THE POINTERS FOR THE LINKED LIST ARE AS FOLLOWS. ! ! EACH UN-ORDERED COLUMN IC IS IN A LIST (THE DEGREE LIST) ! OF COLUMNS WITH THE SAME DEGREE. ! ! IWA1(NUMDEG) IS THE FIRST COLUMN IN THE NUMDEG LIST ! UNLESS IWA1(NUMDEG) = 0. IN THIS CASE THERE ARE ! NO COLUMNS IN THE NUMDEG LIST. ! ! IWA2(IC) IS THE COLUMN BEFORE IC IN THE DEGREE LIST ! UNLESS IWA2(IC) = 0. IN THIS CASE IC IS THE FIRST ! COLUMN IN THIS DEGREE LIST. ! ! IWA3(IC) IS THE COLUMN AFTER IC IN THE DEGREE LIST ! UNLESS IWA3(IC) = 0. IN THIS CASE IC IS THE LAST ! COLUMN IN THIS DEGREE LIST. ! ! IF IC IS AN UN-ORDERED COLUMN, THEN LIST(IC) IS THE ! DEGREE OF IC IN THE GRAPH INDUCED BY THE UN-ORDERED ! COLUMNS. IF JCOL IS AN ORDERED COLUMN, THEN LIST(JCOL) ! IS THE SMALLEST-LAST ORDER OF COLUMN JCOL. do jp = 1 , n numdeg = Ndeg ( jp ) Iwa2 ( jp ) = 0 Iwa3 ( jp ) = Iwa1 ( numdeg ) if ( Iwa1 ( numdeg ) > 0 ) Iwa2 ( Iwa1 ( numdeg )) = jp Iwa1 ( numdeg ) = jp enddo Maxclq = 0 numord = n !  BEGINNING OF ITERATION LOOP. ! ! ! MARK THE SIZE OF THE LARGEST CLIQUE ! FOUND DURING THE ORDERING. 100 if ( mindeg + 1 == numord . and . Maxclq == 0 ) Maxclq = numord ! CHOOSE A COLUMN JCOL OF MINIMAL DEGREE MINDEG. 200 jcol = Iwa1 ( mindeg ) if ( jcol > 0 ) then List ( jcol ) = numord numord = numord - 1 ! TERMINATION TEST. if ( numord == 0 ) then ! INVERT THE ARRAY LIST. do jcol = 1 , n Iwa2 ( List ( jcol )) = jcol enddo do jp = 1 , n List ( jp ) = Iwa2 ( jp ) enddo else ! DELETE COLUMN JCOL FROM THE MINDEG LIST. Iwa1 ( mindeg ) = Iwa3 ( jcol ) if ( Iwa3 ( jcol ) > 0 ) Iwa2 ( Iwa3 ( jcol )) = 0 ! FIND ALL COLUMNS ADJACENT TO COLUMN JCOL. Iwa4 ( jcol ) = 0 ! DETERMINE ALL POSITIONS (IR,JCOL) WHICH CORRESPOND ! TO NON-ZEROES IN THE MATRIX. do jp = Jpntr ( jcol ) , Jpntr ( jcol + 1 ) - 1 ir = Indrow ( jp ) ! FOR EACH ROW IR, DETERMINE ALL POSITIONS (IR,IC) ! WHICH CORRESPOND TO NON-ZEROES IN THE MATRIX. do ip = Ipntr ( ir ) , Ipntr ( ir + 1 ) - 1 ic = Indcol ( ip ) ! ARRAY IWA4 MARKS COLUMNS WHICH ARE ADJACENT TO ! COLUMN JCOL. if ( Iwa4 ( ic ) > numord ) then Iwa4 ( ic ) = numord ! UPDATE THE POINTERS TO THE CURRENT DEGREE LISTS. numdeg = List ( ic ) List ( ic ) = List ( ic ) - 1 mindeg = min ( mindeg , List ( ic )) ! DELETE COLUMN IC FROM THE NUMDEG LIST. if ( Iwa2 ( ic ) == 0 ) then Iwa1 ( numdeg ) = Iwa3 ( ic ) else Iwa3 ( Iwa2 ( ic )) = Iwa3 ( ic ) endif if ( Iwa3 ( ic ) > 0 ) Iwa2 ( Iwa3 ( ic )) = Iwa2 ( ic ) ! ADD COLUMN IC TO THE NUMDEG-1 LIST. Iwa2 ( ic ) = 0 Iwa3 ( ic ) = Iwa1 ( numdeg - 1 ) if ( Iwa1 ( numdeg - 1 ) > 0 ) Iwa2 ( Iwa1 ( numdeg - 1 )) = ic Iwa1 ( numdeg - 1 ) = ic endif enddo enddo ! END OF ITERATION LOOP. goto 100 endif else mindeg = mindeg + 1 goto 200 endif end subroutine slo !******************************************************************************* !******************************************************************************* !> !  given the non-zero elements of an `m` by `n` matrix `a` in !  arbitrary order as specified by their row and column !  indices, this subroutine permutes these elements so !  that their column indices are in non-decreasing order. ! !  on input it is assumed that the elements are specified in ! !  `indrow(k),indcol(k), k = 1,...,nnz`. ! !  on output the elements are permuted so that `indcol` is !  in non-decreasing order. in addition, the array `jpntr` !  is set so that the row indices for column `j` are ! !  `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. ! !  note that the value of `m` is not needed by srtdat and is !  therefore not present in the subroutine statement. subroutine srtdat ( n , Nnz , Indrow , Indcol , Jpntr , Iwa ) implicit none integer :: n !! a positive integer input variable set to the number !! of columns of `a`. integer :: Nnz !! a positive integer input variable set to the number !! of non-zero elements of `a`. integer , dimension ( Nnz ) :: Indrow !! an integer array of length `nnz`. on input `indrow` !! must contain the row indices of the non-zero elements of `a`. !! on output `indrow` is permuted so that the corresponding !! column indices of `indcol` are in non-decreasing order. integer , dimension ( Nnz ) :: Indcol !! an integer array of length `nnz`. on input `indcol` !! must contain the column indices of the non-zero elements !! of `a`. on output `indcol` is permuted so that these indices !! are in non-decreasing order. integer , dimension ( n + 1 ) :: Jpntr !! an integer output array of length `n + 1` which !! specifies the locations of the row indices in the output !! `indrow`. the row indices for column `j` are !! `indrow(k), k = jpntr(j),...,jpntr(j+1)-1`. !! **note** that `jpntr(1)` is set to 1 and that `jpntr(n+1)-1` !! is then `nnz`. integer , dimension ( n ) :: Iwa !! an integer work array of length `n`. integer :: i , j , k , l ! store in array iwa the counts of non-zeroes in the columns. do j = 1 , n Iwa ( j ) = 0 enddo do k = 1 , Nnz Iwa ( Indcol ( k )) = Iwa ( Indcol ( k )) + 1 enddo ! set pointers to the start of the columns in indrow. Jpntr ( 1 ) = 1 do j = 1 , n Jpntr ( j + 1 ) = Jpntr ( j ) + Iwa ( j ) Iwa ( j ) = Jpntr ( j ) enddo k = 1 ! begin in-place sort. do j = Indcol ( k ) if ( k >= Jpntr ( j ) ) then ! current element is in position. now examine the ! next element or the first un-sorted element in ! the j-th group. k = max ( k + 1 , Iwa ( j )) else ! current element is not in position. place element ! in position and make the displaced element the ! current element. l = Iwa ( j ) Iwa ( j ) = Iwa ( j ) + 1 i = Indrow ( k ) Indrow ( k ) = Indrow ( l ) Indcol ( k ) = Indcol ( l ) Indrow ( l ) = i Indcol ( l ) = j endif if ( k > Nnz ) exit end do end subroutine srtdat !******************************************************************************* !******************************************************************************* !> !  Given a consistent partition of the columns of an `m` by `n` !  jacobian matrix into groups, this subroutine computes !  approximations to those columns in a given group.  the !  approximations are stored into either a column-oriented !  or a row-oriented pattern. ! !  a partition is consistent if the columns in any group !  do not have a non-zero in the same row position. ! !  approximations to the columns of the jacobian matrix in a !  given group can be obtained by specifying a difference !  parameter array `d` with `d(jcol)` non-zero if and only if !  `jcol` is a column in the group, and an approximation to !  `jac*d` where `jac` denotes the jacobian matrix of a mapping f. ! !  `d` can be defined with the following segment of code. !```fortran !  do jcol = 1, n !  d(jcol) = 0.0 !  if (ngrp(jcol) == numgrp) d(jcol) = eta(jcol) !  end do !``` !  in the above code `numgrp` is the given group number, !  `ngrp(jcol)` is the group number of column `jcol`, and !  `eta(jcol)` is the difference parameter used to !  approximate column `jcol` of the jacobian matrix. !  suitable values for the array `eta` must be provided. ! !  as mentioned above, an approximation to `jac*d` must !  also be provided. for example, the approximation !```fortran !  f(x+d) - f(x) !``` !  corresponds to the forward difference formula at `x`. subroutine fdjs ( m , n , Col , Ind , Npntr , Ngrp , Numgrp , d , Fjacd , Fjac ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of the jacobian matrix. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of the jacobian matrix. integer :: Numgrp !! a positive integer input variable set to a group !! number in the partition. the columns of the jacobian !! matrix in this group are to be estimated on this call. integer , dimension ( * ) :: Ind !! an integer input array which contains the row !! indices for the non-zeroes in the jacobian matrix !! if `col` is true, and contains the column indices for !! the non-zeroes in the jacobian matrix if `col` is false. integer , dimension ( * ) :: Npntr !! an integer input array which specifies the !! locations of the row indices in `ind` if `col` is true, and !! specifies the locations of the column indices in `ind` if !! `col` is false. if `col` is true, the indices for column `j` are !!       `ind(k), k = npntr(j),...,npntr(j+1)-1`. !! if `col` is false, the indices for row `i` are !!       `ind(k), k = npntr(i),...,npntr(i+1)-1`. !! ***Note*** that `npntr(n+1)-1` if `col` is true, or `npntr(m+1)-1` !! if `col` is false, is then the number of non-zero elements !! of the jacobian matrix. integer , dimension ( n ) :: Ngrp !! an integer input array of length `n` which specifies !! the partition of the columns of the jacobian matrix. !! column `jcol` belongs to group `ngrp(jcol)`. real ( wp ), dimension ( n ) :: d !! an input array of length `n` which contains the !! difference parameter vector for the estimate of !! the jacobian matrix columns in group `numgrp`. real ( wp ), dimension ( m ) :: Fjacd !! an input array of length `m` which contains !! an approximation to the difference vector `jac*d`, !! where `jac` denotes the jacobian matrix. real ( wp ), dimension ( * ) :: Fjac !! an output array of length `nnz`, where `nnz` is the !! number of its non-zero elements. at each call of `fdjs`, !! `fjac` is updated to include the non-zero elements of the !! jacobian matrix for those columns in group `numgrp`. `fjac` !! should not be altered between successive calls to `fdjs`. logical , intent ( in ) :: Col !! a logical input variable. if `col` is set true, then the !! jacobian approximations are stored into a column-oriented !! pattern. if `col` is set false, then the jacobian !! approximations are stored into a row-oriented pattern. integer :: ip , irow , jcol , jp ! compute estimates of jacobian matrix columns in group ! numgrp. the array fjacd must contain an approximation ! to jac*d, where jac denotes the jacobian matrix and d ! is a difference parameter vector with d(jcol) non-zero ! if and only if jcol is a column in group numgrp. if ( Col ) then ! column orientation. do jcol = 1 , n if ( Ngrp ( jcol ) == Numgrp ) then do jp = Npntr ( jcol ) , Npntr ( jcol + 1 ) - 1 irow = Ind ( jp ) Fjac ( jp ) = Fjacd ( irow ) / d ( jcol ) enddo endif enddo else ! row orientation. do irow = 1 , m do ip = Npntr ( irow ) , Npntr ( irow + 1 ) - 1 jcol = Ind ( ip ) if ( Ngrp ( jcol ) == Numgrp ) then Fjac ( ip ) = Fjacd ( irow ) / d ( jcol ) exit endif enddo enddo endif end subroutine fdjs !******************************************************************************* !******************************************************************************* end module dsm_module !*******************************************************************************","tags":"","loc":"sourcefile/dsm_module.f90.html"},{"title":"problem_03.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_03.f90~~EfferentGraph sourcefile~problem_03.f90 problem_03.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_03.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_3 use iso_fortran_env use aoc_utilities implicit none integer :: n_lines , i , j , n_cols , jstart , jend logical :: adjacent , tmp integer ( ip ) :: isum character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:), allocatable :: ivals call clk % tic () ! read file: ! pad around with blanks to simplify logic below array = read_file_to_char_array ( 'inputs/day3.txt' , border = '.' ) n_lines = size ( array , 1 ) n_cols = size ( array , 2 ) !----------------- part 1 ----------------- isum = 0 do i = 1 , n_lines ! is this character adjacent to a symbol? jend = 0 do j = 1 , n_cols if ( is_not_number ( array ( i , j ))) cycle if ( j <= jend ) cycle ! skip the cols that we already have jend = 0 adjacent = is_symbol ( array ( i - 1 , j ) ) . or . & is_symbol ( array ( i - 1 , j - 1 )) . or . & is_symbol ( array ( i - 1 , j + 1 )) . or . & is_symbol ( array ( i , j - 1 ) ) . or . & is_symbol ( array ( i , j + 1 ) ) . or . & is_symbol ( array ( i + 1 , j ) ) . or . & is_symbol ( array ( i + 1 , j - 1 )) . or . & is_symbol ( array ( i + 1 , j + 1 )) if ( adjacent ) isum = isum + get_number ( i , j ) ! note: this sets jend end do end do write ( * , * ) '3a: sum :' , isum !----------------- part 2 ----------------- ! now look for '*' and find adjacent numbers .... isum = 0 do i = 1 , n_lines do j = 1 , n_cols if ( array ( i , j ) == '*' ) then ! look for 2 adjacent numbers. if ( allocated ( ivals )) deallocate ( ivals ); allocate ( ivals ( 0 )) ! above tmp = check ( i - 1 , j ) ! if only one on top if (. not . tmp ) then tmp = check ( i - 1 , j - 1 ) tmp = check ( i - 1 , j + 1 ) end if tmp = check ( i , j - 1 ) ! left and right tmp = check ( i , j + 1 ) ! below tmp = check ( i + 1 , j ) ! if only one below if (. not . tmp ) then tmp = check ( i + 1 , j - 1 ) tmp = check ( i + 1 , j + 1 ) end if if ( size ( ivals ) == 2 ) isum = isum + product ( ivals ) ! sum gear ratio end if end do end do write ( * , * ) '3b: result :' , isum call clk % toc ( '3' ) contains logical function check ( i , j ) !! if the char is part of a number, then get it and append to ivals integer , intent ( in ) :: i , j check = is_number ( array ( i , j )) if ( check ) ivals = [ ivals , get_number ( i , j )] end function check logical function is_symbol ( c ) character ( len = 1 ), intent ( in ) :: c is_symbol = is_not_number ( c ) . and . c /= '.' end function is_symbol integer ( ip ) function get_number ( i , j ) !! get the full number contining the character at i,j integer , intent ( in ) :: i , j jstart = j jend = j do if ( array ( i , jstart - 1 ) == '.' . or . is_symbol ( array ( i , jstart - 1 ))) exit jstart = jstart - 1 end do do if ( array ( i , jend + 1 ) == '.' . or . is_symbol ( array ( i , jend + 1 ))) exit jend = jend + 1 end do get_number = int ( array ( i , jstart : jend )) end function get_number end program problem_3","tags":"","loc":"sourcefile/problem_03.f90.html"},{"title":"problem_01.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_01.f90~~EfferentGraph sourcefile~problem_01.f90 problem_01.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_01.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_1 use iso_fortran_env use aoc_utilities implicit none integer :: iunit logical :: status_ok character ( len = :), allocatable :: line integer :: n_lines integer :: i , j , k , n , isum , ifirst , ilast , idxfirst , idxlast character ( len =* ), dimension ( 9 ), parameter :: ichars = [ & 'one  ' , & 'two  ' , & 'three' , & 'four ' , & 'five ' , & 'six  ' , & 'seven' , & 'eight' , & 'nine ' ] call clk % tic () isum = 0 open ( newunit = iunit , file = 'inputs/day1.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) do i = 1 , n_lines ! remove all the chars before the first and after the last number line = read_line ( iunit , status_ok ) n = len ( line ) do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) exit ! done line ( j : j ) = ' ' end do do j = n , 1 , - 1 if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) exit ! done line ( j : j ) = ' ' end do line = trim ( adjustl ( line )) n = len ( line ) isum = isum + 10 * int ( line ( 1 : 1 )) + int ( line ( n : n )) end do write ( * , * ) '1a: sum:' , isum close ( iunit ) ! -------- part 2 ----------- open ( newunit = iunit , file = 'inputs/day1.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do i = 1 , n_lines line = read_line ( iunit , status_ok ) n = len ( line ) ! keep track of the index of the first and last number (digit or string) ifirst = huge ( 1 ) idxfirst = huge ( 1 ) do j = 1 , size ( ichars ) k = min ( index ( line , trim ( ichars ( j ))), index ( line , trim ( ichars ( j )), back = . true .) ) ! accounts for duplicates if ( k > 0 . and . k <= idxfirst ) then ifirst = j idxfirst = k end if end do do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) then if ( j <= idxfirst ) then ifirst = int ( line ( j : j )) idxfirst = j end if end if end do ilast = 0 idxlast = 0 do j = 1 , size ( ichars ) k = max ( index ( line , trim ( ichars ( j ))), index ( line , trim ( ichars ( j )), back = . true .) ) ! accounts for duplicates if ( k > 0 . and . k >= idxlast ) then ilast = j idxlast = k end if end do do j = 1 , n if ( line ( j : j ) >= '1' . and . line ( j : j ) <= '9' ) then if ( j >= idxlast ) then ilast = int ( line ( j : j )) idxlast = j end if end if end do isum = isum + 10 * ifirst + ilast end do write ( * , * ) '1b: sum:' , isum call clk % toc ( '1' ) end program problem_1","tags":"","loc":"sourcefile/problem_01.f90.html"},{"title":"lsqrtest.f90 – AoC-2023","text":"This file depends on sourcefile~~lsqrtest.f90~~EfferentGraph sourcefile~lsqrtest.f90 lsqrtest.f90 sourcefile~lsqrtest_module.f90 lsqrtest_module.f90 sourcefile~lsqrtest.f90->sourcefile~lsqrtest_module.f90 sourcefile~lsqr.f90 lsqr.f90 sourcefile~lsqrtest_module.f90->sourcefile~lsqr.f90 sourcefile~lsqr_kinds.f90 lsqr_kinds.F90 sourcefile~lsqrtest_module.f90->sourcefile~lsqr_kinds.f90 sourcefile~lsqrblas.f90 lsqrblas.f90 sourcefile~lsqrtest_module.f90->sourcefile~lsqrblas.f90 sourcefile~lsqr.f90->sourcefile~lsqr_kinds.f90 sourcefile~lsqr.f90->sourcefile~lsqrblas.f90 sourcefile~lsqrblas.f90->sourcefile~lsqr_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !*************************************************************************************************** !> !  Main program for tests. program main use lsqrtest_module , only : lsqr_test implicit none call lsqr_test () end program main !***************************************************************************************************","tags":"","loc":"sourcefile/lsqrtest.f90.html"},{"title":"lsqrblas.f90 – AoC-2023","text":"This file depends on sourcefile~~lsqrblas.f90~~EfferentGraph sourcefile~lsqrblas.f90 lsqrblas.f90 sourcefile~lsqr_kinds.f90 lsqr_kinds.F90 sourcefile~lsqrblas.f90->sourcefile~lsqr_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~lsqrblas.f90~~AfferentGraph sourcefile~lsqrblas.f90 lsqrblas.f90 sourcefile~lsqr.f90 lsqr.f90 sourcefile~lsqr.f90->sourcefile~lsqrblas.f90 sourcefile~lsqrtest_module.f90 lsqrtest_module.f90 sourcefile~lsqrtest_module.f90->sourcefile~lsqrblas.f90 sourcefile~lsqrtest_module.f90->sourcefile~lsqr.f90 sourcefile~lsqrtest.f90 lsqrtest.f90 sourcefile~lsqrtest.f90->sourcefile~lsqrtest_module.f90 sourcefile~lsqrtest_ez.f90 lsqrtest_ez.f90 sourcefile~lsqrtest_ez.f90->sourcefile~lsqr.f90 sourcefile~nlesolver_module.f90 nlesolver_module.F90 sourcefile~nlesolver_module.f90->sourcefile~lsqr.f90 sourcefile~nlesolver_test_1.f90 nlesolver_test_1.f90 sourcefile~nlesolver_test_1.f90->sourcefile~nlesolver_module.f90 sourcefile~sparse_test.f90 sparse_test.f90 sourcefile~sparse_test.f90->sourcefile~nlesolver_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !*************************************************************************************************** !> !  this file contains BLAS routines required by subroutines [[lsqr]] and [[acheck]]. ! !### History !  * Jacob Williams : 11/8/2019 : using modernized versions of these routines. module lsqpblas_module use lsqr_kinds , only : wp , zero , one implicit none private public :: dcopy , ddot , dnrm2 , dscal contains !*************************************************************************************************** !*************************************************************************************************** !> !  copies a vector, `x`, to a vector, `y`. subroutine dcopy ( n , dx , incx , dy , incy ) integer incx , incy , n real ( wp ) dx ( * ), dy ( * ) integer i , ix , iy , m , mp1 if ( n <= 0 ) return if ( incx == 1 . and . incy == 1 ) then ! code for both increments equal to 1 ! clean-up loop m = mod ( n , 7 ) if ( m /= 0 ) then do i = 1 , m dy ( i ) = dx ( i ) end do if ( n < 7 ) return end if mp1 = m + 1 do i = mp1 , n , 7 dy ( i ) = dx ( i ) dy ( i + 1 ) = dx ( i + 1 ) dy ( i + 2 ) = dx ( i + 2 ) dy ( i + 3 ) = dx ( i + 3 ) dy ( i + 4 ) = dx ( i + 4 ) dy ( i + 5 ) = dx ( i + 5 ) dy ( i + 6 ) = dx ( i + 6 ) end do else ! code for unequal increments or equal increments ! not equal to 1 ix = 1 iy = 1 if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dy ( iy ) = dx ( ix ) ix = ix + incx iy = iy + incy end do end if end subroutine dcopy !*************************************************************************************************** !*************************************************************************************************** !> !  dot product of two vectors real ( wp ) function ddot ( n , dx , incx , dy , incy ) integer incx , incy , n real ( wp ) dx ( * ), dy ( * ) real ( wp ) dtemp integer i , ix , iy , m , mp1 ddot = zero dtemp = zero if ( n <= 0 ) return if ( incx == 1 . and . incy == 1 ) then ! code for both increments equal to 1 ! clean-up loop m = mod ( n , 5 ) if ( m /= 0 ) then do i = 1 , m dtemp = dtemp + dx ( i ) * dy ( i ) end do if ( n < 5 ) then ddot = dtemp return end if end if mp1 = m + 1 do i = mp1 , n , 5 dtemp = dtemp + dx ( i ) * dy ( i ) + dx ( i + 1 ) * dy ( i + 1 ) + dx ( i + 2 ) * dy ( i + 2 ) + dx ( i + 3 ) * dy ( i + 3 ) + dx ( i + 4 ) * dy ( i + 4 ) end do else ! code for unequal increments or equal increments not equal to 1 ix = 1 iy = 1 if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dtemp = dtemp + dx ( ix ) * dy ( iy ) ix = ix + incx iy = iy + incy end do end if ddot = dtemp end function ddot !*************************************************************************************************** !*************************************************************************************************** !> !  euclidean norm of a vector. real ( wp ) function dnrm2 ( n , x , incx ) integer incx , n real ( wp ) x ( * ) real ( wp ) absxi , norm , scale , ssq integer ix if ( n < 1 . or . incx < 1 ) then norm = zero else if ( n == 1 ) then norm = abs ( x ( 1 )) else scale = zero ssq = one ! the following loop is equivalent to this call to the lapack ! auxiliary routine: ! call dlassq( n, x, incx, scale, ssq ) do ix = 1 , 1 + ( n - 1 ) * incx , incx if ( x ( ix ) /= zero ) then absxi = abs ( x ( ix )) if ( scale < absxi ) then ssq = one + ssq * ( scale / absxi ) ** 2 scale = absxi else ssq = ssq + ( absxi / scale ) ** 2 end if end if end do norm = scale * sqrt ( ssq ) end if dnrm2 = norm end function dnrm2 !*************************************************************************************************** !*************************************************************************************************** !> !  scales a vector by a constant. subroutine dscal ( n , da , dx , incx ) real ( wp ) da integer incx , n real ( wp ) dx ( * ) integer i , m , mp1 , nincx if ( n <= 0 . or . incx <= 0 ) return if ( incx == 1 ) then ! code for increment equal to 1 ! clean-up loop m = mod ( n , 5 ) if ( m /= 0 ) then do i = 1 , m dx ( i ) = da * dx ( i ) end do if ( n < 5 ) return end if mp1 = m + 1 do i = mp1 , n , 5 dx ( i ) = da * dx ( i ) dx ( i + 1 ) = da * dx ( i + 1 ) dx ( i + 2 ) = da * dx ( i + 2 ) dx ( i + 3 ) = da * dx ( i + 3 ) dx ( i + 4 ) = da * dx ( i + 4 ) end do else ! code for increment not equal to 1 nincx = n * incx do i = 1 , nincx , incx dx ( i ) = da * dx ( i ) end do end if end subroutine dscal !*************************************************************************************************** !*************************************************************************************************** end module lsqpblas_module !***************************************************************************************************","tags":"","loc":"sourcefile/lsqrblas.f90.html"},{"title":"problem_17.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_17.f90~~EfferentGraph sourcefile~problem_17.f90 problem_17.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_17.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_17 use aoc_utilities use iso_fortran_env !! Based on AOC 2021 Day 15: https://github.com/jacobwilliams/AoC-2021/blob/master/test/problem_15.f90 !! see: https://en.wikipedia.org/wiki/Dijkstra's_algorithm#Pseudocode !! !! only difference is the constraint that it can move at most three blocks in a single direction implicit none integer , parameter :: NSTATE = 4 !! number of state dimensions [i,j,direction,moves_in_that_direction] integer , parameter :: N_DIRECTIONS = 4 ! 1,2,3,4 integer ( ip ), parameter :: UP = 1 ! direction traveling integer ( ip ), parameter :: DOWN = - 1 integer ( ip ), parameter :: LEFT = 2 integer ( ip ), parameter :: RIGHT = - 2 integer , parameter :: MAX_MOVES_IN_DIR = 3 ! queue for the states and distances... rather than constructing the 2d array... ! just create this as we go... type :: item integer ( ip ), dimension ( NSTATE ) :: state = 0 !! state: [i, j, direction, and # of moves] integer ( ip ) :: dist = huge ( 1 ) !! distance for this one logical :: visited = . false . !! if this one is done integer ( ip ) :: iprev = - 1 !! index in the queue of the previous one end type item type ( item ), dimension (:), allocatable :: queue !! will be expanding integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: idx integer :: i , j , n_rows , n_cols integer , dimension (:,:), allocatable :: map !! heat map ! for the CI ! need a faster version ... write ( * , * ) 'it works but takes a few minutes...' stop call clk % tic () ! map = read_file_to_int_array('inputs/day17_test.txt') map = read_file_to_int_array ( 'inputs/day17.txt' ) n_rows = size ( map , 1 ) n_cols = size ( map , 2 ) call add_to_queue ([ 1_ip , 1_ip , 0_ip , 0_ip ], idx ) ! start queue ( idx )% dist = 0 do ! find min distance so far for ones not visited iloc = minloc ( queue % dist , mask = . not . queue % visited ) idx = iloc ( 1 ) ! index in the queue queue ( idx )% visited = . true . !write(*,*) 'visited ', queue(idx)%state(1), queue(idx)%state(2), n_rows, n_cols if ( queue ( idx )% state ( 1 ) == n_rows . and . queue ( idx )% state ( 2 ) == n_cols ) exit ! destination: we are done ! process ajacent ones: call check ( idx , UP ) call check ( idx , DOWN ) call check ( idx , LEFT ) call check ( idx , RIGHT ) end do write ( * , * ) '15a: ' , queue ( idx )% dist ! ...draw the path ! block !     character(len=1),dimension(:,:),allocatable :: char_map !     char_map = int_array_to_char_array(map) !     do !         char_map(queue(idx)%state(1),queue(idx)%state(2)) = '#' !         if (queue(idx)%state(1)==1) then !             write(*,*) queue(idx)%state !         end if !         if (queue(idx)%state(1)==1 .and. queue(idx)%state(2)==1) exit !         idx = queue(idx)%iprev !     end do !     write(*,*) ' path: ' !     do i = 1, n_rows !         write(*,'(*(A1))') char_map(i,:) !     end do ! end block call clk % toc ( '17' ) contains subroutine check ( idx , idirection ) implicit none integer ( ip ), intent ( in ) :: idx ! current item in the queue to process integer ( ip ), intent ( in ) :: idirection !! direction to move from current integer ( ip ) :: alt integer ( ip ), dimension ( 2 ) :: v ! neighbor to move to integer ( ip ) :: imovesv , idxv , distv integer ( ip ), dimension ( NSTATE ) :: istate logical :: in_queue associate ( i => queue ( idx )% state ( 1 ), & j => queue ( idx )% state ( 2 ), & direction => queue ( idx )% state ( 3 ), & n_moves => queue ( idx )% state ( 4 )) if ( direction ==- idirection ) return ! can't reverse ! the one to go to: if ( direction == idirection ) then if ( n_moves == MAX_MOVES_IN_DIR ) return ! can't move in this direction anymore imovesv = n_moves + 1 else imovesv = 1 ! reset on change of direction end if select case ( idirection ) case ( UP ); v = [ i - 1 , j ] case ( DOWN ); v = [ i + 1 , j ] case ( LEFT ); v = [ i , j - 1 ] case ( RIGHT ); v = [ i , j + 1 ] end select if ( v ( 1 ) < 1 . or . v ( 2 ) < 1 . or . v ( 1 ) > n_rows . or . v ( 2 ) > n_cols ) return ! can't go off the board istate = [ v ( 1 ), v ( 2 ), idirection , imovesv ] ! new state idxv = index_in_queue ( istate ) ! is it already in the queue in_queue = idxv > 0 ! if this one is already part of another path if ( in_queue ) then if ( queue ( idxv )% visited ) return ! already visited this one distv = queue ( idxv )% dist ! distance in the queue else !call add_to_queue(istate, idxv) ! add this to the queue for processing ! always add it ?? distv = huge ( 1_ip ) ! not processed yet, so huge number end if !alt = queue(idx)%dist + map(queue(idxv)%state(1), queue(idxv)%state(2)) alt = queue ( idx )% dist + map ( v ( 1 ), v ( 2 )) ! new distance if ( alt < distv ) then ! the new one is better, so replace values in the queue if (. not . in_queue ) call add_to_queue ( istate , idxv ) ! only add it if we accept it ???? ! accept this step queue ( idxv )% dist = alt ! new best dist queue ( idxv )% iprev = idx ! previous end if end associate end subroutine check ! .. need a faster queue... function index_in_queue ( state ) result ( idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ) :: idx !! index in the queue. -1 if not present integer :: i idx = - 1 if (. not . allocated ( queue )) error stop 'error: queue not allocated' do i = 1 , size ( queue ) if ( all ( state == queue ( i )% state )) then idx = i return end if end do end function index_in_queue subroutine add_to_queue ( state , idx ) integer ( ip ), dimension ( NSTATE ), intent ( in ) :: state integer ( ip ), intent ( out ) :: idx !! index of the element in the queue if ( allocated ( queue )) then queue = [ queue , item ( state = state )] idx = size ( queue ) else queue = [ item ( state = state )] idx = 1 end if end subroutine add_to_queue end program problem_17","tags":"","loc":"sourcefile/problem_17.f90.html"},{"title":"problem_25.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_25.f90~~EfferentGraph sourcefile~problem_25.f90 problem_25.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_25.f90->sourcefile~aoc_utilities.f90 sourcefile~dag_module.f90 dag_module.f90 sourcefile~problem_25.f90->sourcefile~dag_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_25 use aoc_utilities use dag_module implicit none integer :: iunit , n_lines , i , j , n_nodes , inode , inode2 character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals , vals2 character ( len = 3 ) :: node1 , node2 character ( len = 3 ), dimension (:), allocatable :: nodes integer , dimension (:), allocatable :: inodedep , icounts character ( len =* ), parameter :: filetype = 'pdf' type ( dag ) :: d type :: node_t !character(len=3) :: name = '' integer , dimension (:), allocatable :: connections !! the ones connected to this one end type node_t type ( node_t ), dimension (:), allocatable :: graph !! index is the node number logical , dimension (:), allocatable :: visited call clk % tic () ! read the data: ! open(newunit=iunit, file='inputs/day25_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day25.txt' , status = 'OLD' ) allocate ( nodes ( 0 )) n_lines = number_of_lines_in_file ( iunit ) do i = 1 , n_lines line = read_line ( iunit ) ! for starters, get a list of all the nodes vals = split ( line , ': ' ) node1 = vals ( 1 )% str if (. not . any ( nodes == node1 )) nodes = [ nodes , node1 ] vals2 = split ( vals ( 2 )% str , ' ' ) do j = 1 , size ( vals2 ) node2 = vals2 ( j )% str if (. not . any ( nodes == node2 )) nodes = [ nodes , node2 ] end do end do rewind ( iunit ) n_nodes = size ( nodes ) ! create a dag: call d % set_vertices ( n_nodes ) allocate ( graph ( n_nodes )) !... do i = 1 , n_nodes allocate ( graph ( i )% connections ( 0 )) ! initialize end do do i = 1 , n_lines line = read_line ( iunit ) ! for starters, get a list of all the nodes vals = split ( line , ': ' ) node1 = vals ( 1 )% str inode = node_index ( node1 ) !inode = findloc(nodes,node1) if (. not . any ( nodes == node1 )) nodes = [ nodes , node1 ] vals2 = split ( vals ( 2 )% str , ' ' ) if ( allocated ( inodedep )) deallocate ( inodedep ) allocate ( inodedep ( 0 )) do j = 1 , size ( vals2 ) node2 = vals2 ( j )% str inode2 = node_index ( node2 ) !-------------------------------------------- ! prune the ones by inspection by looking at the graph, opening in Inkscape, ! coloring the 3 lines and finding the nodes that connect them if ( ( node1 == 'ljm' . and . node2 == 'sfd' ) . or . ( node2 == 'ljm' . and . node1 == 'sfd' ) ) cycle if ( ( node1 == 'gst' . and . node2 == 'rph' ) . or . ( node2 == 'gst' . and . node1 == 'rph' ) ) cycle if ( ( node1 == 'jkn' . and . node2 == 'cfn' ) . or . ( node2 == 'jkn' . and . node1 == 'cfn' ) ) cycle !-------------------------------------------- ! accumulate the graph: ! connection between inode <--> inodedep graph ( inode )% connections = [ graph ( inode )% connections , inode2 ] graph ( inode2 )% connections = [ graph ( inode2 )% connections , inode ] ! for the plot: inodedep = [ inodedep , inode2 ] end do call d % set_edges ( inode , inodedep ) end do ! define some styles for the GraphViz output: do i = 1 , n_nodes call d % set_vertex_info ( i , label = nodes ( i )) end do ! generate the GraphViz output: call d % save_digraph ( 'problem25.dot' , rankdir = 'TB' , dpi = 300 ) call d % destroy () call execute_command_line ( 'dot -Tpdf -o problem25.pdf problem25.dot' ) ! add to dot file:  !todo add this to daglib ... ! mindist=10 ! ranksep=20 ! count the ones connected to each node and get the unique two we need allocate ( visited ( n_nodes )) allocate ( icounts ( 0 )) do i = 1 , n_lines visited = . false . call traverse ( i ) icounts = unique ([ icounts , count ( visited )]) write ( * , * ) i , icounts end do write ( * , * ) '25a:' , product ( icounts ) call clk % toc ( '25' ) contains pure integer function node_index ( node ) !! find the node number for this name character ( len =* ), intent ( in ) :: node integer , dimension ( 1 ) :: idx idx = findloc ( nodes , node ) node_index = idx ( 1 ) end function node_index recursive subroutine traverse ( i ) !! travere the graph and visit all the connected nodes integer , intent ( in ) :: i integer :: j if ( visited ( i )) return visited ( i ) = . true . do j = 1 , size ( graph ( i )% connections ) call traverse ( graph ( i )% connections ( j )) end do end subroutine traverse end program problem_25","tags":"","loc":"sourcefile/problem_25.f90.html"},{"title":"problem_16.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_16.f90~~EfferentGraph sourcefile~problem_16.f90 problem_16.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_16.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_16 use iso_fortran_env use aoc_utilities implicit none integer :: i , j , nrows , ncols , max_count , icount , icase character ( len = 1 ), dimension (:,:), allocatable :: array logical , dimension (:,:,:), allocatable :: visited ! top,bottom,left,right integer , parameter :: TOP = 1 ! direction traveling FROM integer , parameter :: BOTTOM = 2 integer , parameter :: LEFT = 3 integer , parameter :: RIGHT = 4 call clk % tic () ! read the data file: ! array = read_file_to_char_array('inputs/day16_test.txt') ! pad with wall around the array array = read_file_to_char_array ( 'inputs/day16.txt' ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) ! track if we have already done this case, to avoid unnecessary duplication, ! otherwise it may loop indefinitly? allocate ( visited ( 4 , nrows , ncols )) ! part 1: visited = . false . call go ( 1 , 1 , LEFT ) write ( * , * ) '16a: ' , count ( visited ( 1 ,:,:) . or . & visited ( 2 ,:,:) . or . & visited ( 3 ,:,:) . or . & visited ( 4 ,:,:)) ! part 2, just do all the cases: max_count = 0 do icase = 1 , 2 ! first and last col do i = 1 , nrows visited = . false . if ( icase == 1 ) then ; call go ( i , 1 , LEFT ) else ; call go ( i , ncols , RIGHT ) end if icount = count ( visited ( 1 ,:,:) . or . & visited ( 2 ,:,:) . or . & visited ( 3 ,:,:) . or . & visited ( 4 ,:,:)) if ( icount > max_count ) max_count = icount end do end do do icase = 1 , 2 ! first and last row do j = 1 , ncols visited = . false . if ( icase == 1 ) then ; call go ( 1 , j , TOP ) else ; call go ( nrows , j , BOTTOM ) end if icount = count ( visited ( 1 ,:,:) . or . & visited ( 2 ,:,:) . or . & visited ( 3 ,:,:) . or . & visited ( 4 ,:,:)) if ( icount > max_count ) max_count = icount end do end do write ( * , * ) '16b: ' , max_count call clk % toc ( '16' ) contains recursive subroutine go ( i , j , direction_from ) integer , intent ( in ) :: i , j !! grid coordinate integer , intent ( in ) :: direction_from !! direction coming from (TOP,BOTTOM,LEFT,RIGHT integer :: k if ( i > nrows . or . i < 1 . or . j > ncols . or . j < 1 ) return ! off the board if ( visited ( direction_from , i , j )) return ! this case has already been done visited ( direction_from , i , j ) = . true . ! mark this one as visited in this direction associate ( c => array ( i , j )) select case ( c ) case ( '.' ) ! continue in same direction k = 1 do ! loop until we hit something else ! (to avoid unnecessary recursion) select case ( direction_from ) case ( TOP ) ! V if (( i + k ) > nrows ) return if ( array ( i + k , j ) /= '.' ) then call go ( i + k , j , direction_from ) return end if visited ( direction_from , i + k , j ) = . true . case ( BOTTOM ) ! &#94; if (( i - k ) < 1 ) return if ( array ( i - k , j ) /= '.' ) then call go ( i - k , j , direction_from ) return end if visited ( direction_from , i - k , j ) = . true . case ( LEFT ) ! --> if (( j + k ) > ncols ) return if ( array ( i , j + k ) /= '.' ) then call go ( i , j + k , direction_from ) return end if visited ( direction_from , i , j + k ) = . true . case ( RIGHT ) ! <-- if (( j - k ) < 1 ) return if ( array ( i , j - k ) /= '.' ) then call go ( i , j - k , direction_from ) return end if visited ( direction_from , i , j - k ) = . true . end select k = k + 1 end do case ( '-' ) select case ( direction_from ) case ( TOP , BOTTOM ) ! V, &#94; call go ( i , j + 1 , LEFT ) ! split call go ( i , j - 1 , RIGHT ) case ( LEFT ) ! --> call go ( i , j + 1 , LEFT ) case ( RIGHT ) ! <-- call go ( i , j - 1 , RIGHT ) end select case ( '|' ) select case ( direction_from ) case ( TOP ) ! V call go ( i + 1 , j , TOP ) case ( BOTTOM ) ! &#94; call go ( i - 1 , j , BOTTOM ) case ( LEFT , RIGHT ) ! -->, <-- call go ( i + 1 , j , TOP ) call go ( i - 1 , j , BOTTOM ) end select case ( '/' ) select case ( direction_from ) case ( TOP ) ! V call go ( i , j - 1 , RIGHT ) case ( BOTTOM ) ! &#94; call go ( i , j + 1 , LEFT ) case ( LEFT ) ! --> call go ( i - 1 , j , BOTTOM ) case ( RIGHT ) ! <-- call go ( i + 1 , j , TOP ) end select case ( '\\' ) select case ( direction_from ) case ( TOP ) ! V call go ( i , j + 1 , LEFT ) case ( BOTTOM ) ! &#94; call go ( i , j - 1 , RIGHT ) case ( LEFT ) ! --> call go ( i + 1 , j , TOP ) case ( RIGHT ) ! <-- call go ( i - 1 , j , BOTTOM ) end select end select end associate end subroutine go end program problem_16","tags":"","loc":"sourcefile/problem_16.f90.html"},{"title":"problem_19b.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_19b.f90~~EfferentGraph sourcefile~problem_19b.f90 problem_19b.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_19b.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_19b !! reformulated to operate on ranges of the x,m,a,s ratings use aoc_utilities use iso_fortran_env implicit none integer :: iunit , n_lines , iline , i character ( len = :), allocatable :: line !, name type ( string ), dimension (:), allocatable :: vals logical :: accepted integer ( ip ) :: total_accepted type :: interval integer ( ip ), dimension ( 2 ) :: v !! [start, end] of the interval end type interval type :: part type ( interval ), dimension ( 4 ) :: xmas ! [x,m,a,s] ranges end type part type ( part ) :: parts type :: rule logical :: accept = . false . logical :: reject = . false . integer :: operator = 0 ! 1:<, 2:> integer :: operator_arg = 0 ! 1:x, 2:m, 3:a, 4:s integer :: operator_val = 0 ! value to compare to character ( len = :), allocatable :: goto ! where to next (workflow name) end type rule type :: workflow character ( len = :), allocatable :: name type ( rule ), dimension (:), allocatable :: rules end type workflow type ( workflow ), dimension (:), allocatable :: workflows type ( workflow ), allocatable :: w call clk % tic () ! open(newunit=iunit, file='inputs/day19_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day19.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( workflows ( 0 )) do iline = 1 , n_lines line = read_line ( iunit ) if ( line == '' ) exit ! done - dont need the parts list for part b ! parsing workflows : qqz{s>2770:qs,m<1801:hdj,R} if ( allocated ( w )) deallocate ( w ); allocate ( w ) ! blank one vals = split ( line , '{' ) w % name = vals ( 1 )% str ! workflow name !write(*,*) '--->'//w%name//'<-----' vals ( 2 )% str = vals ( 2 )% str ( 1 : len ( vals ( 2 )% str ) - 1 ) ! remove last bracket vals = split ( vals ( 2 )% str , ',' ) ! workflow rules ! add each rule to the workflow allocate ( w % rules ( 0 )) do i = 1 , size ( vals ) w % rules = [ w % rules , parse_rule ( vals ( i )% str )] end do workflows = [ workflows , w ] end do parts = part ( xmas = [ interval ([ 1 , 4000 ]), & interval ([ 1 , 4000 ]), & interval ([ 1 , 4000 ]),& interval ([ 1 , 4000 ])]) i = workflow_name_to_index ( 'in' ) ! start at the first workflow total_accepted = process ( i , 1 , parts ) write ( * , * ) '19b: ' , total_accepted call clk % toc ( '19b' ) contains recursive function process ( iworkflow , irule , p ) result ( iaccepted ) !! process this part range starting with irule integer , intent ( in ) :: iworkflow integer , intent ( in ) :: irule type ( part ), intent ( in ) :: p integer ( ip ) :: iaccepted integer ( ip ), dimension (:), allocatable :: itmp , itmp_t , itmp_f integer ( ip ) :: i type ( part ) :: pt , pf iaccepted = 0 associate ( r => workflows ( iworkflow )% rules ( irule ) ) ! check if we are done if ( r % accept ) then iaccepted = get_accepted ( p ) return else if ( r % reject ) then iaccepted = 0 return end if ! process recursively, by splitting up the intervals when necessary if ( r % operator > 0 ) then ! process the operator select case ( r % operator ) case ( 1 ) ! < ! always create the two sets and process the two cases below ! [note that some sets maybe empty] ! ! example: ![1,200]   < 10   ==> [1,9]    TRUE !                     [10,200] FALSE itmp = [( i , i = p % xmas ( r % operator_arg )% v ( 1 ), p % xmas ( r % operator_arg )% v ( 2 ))] itmp_t = pack ( itmp , mask = itmp < r % operator_val ) !true itmp_f = pack ( itmp , mask = itmp >= r % operator_val ) !false if ( size ( itmp_t ) > 0 ) then ! some are true pt = p pt % xmas ( r % operator_arg )% v = [ itmp_t ( 1 ), itmp_t ( size ( itmp_t ))] if ( r % goto == 'A' ) then iaccepted = iaccepted + get_accepted ( pt ) else if ( r % goto /= 'R' ) then ! go to next workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , pt ) end if end if if ( size ( itmp_f ) > 0 ) then ! some are false pf = p pf % xmas ( r % operator_arg )% v = [ itmp_f ( 1 ), itmp_f ( size ( itmp_f ))] iaccepted = iaccepted + process ( iworkflow , irule + 1 , pf ) ! next rule end if case ( 2 ) ! > itmp = [( i , i = p % xmas ( r % operator_arg )% v ( 1 ), p % xmas ( r % operator_arg )% v ( 2 ))] itmp_t = pack ( itmp , mask = itmp > r % operator_val ) !true itmp_f = pack ( itmp , mask = itmp <= r % operator_val ) !false if ( size ( itmp_t ) > 0 ) then ! some are true pt = p pt % xmas ( r % operator_arg )% v = [ itmp_t ( 1 ), itmp_t ( size ( itmp_t ))] if ( r % goto == 'A' ) then iaccepted = iaccepted + get_accepted ( pt ) else if ( r % goto /= 'R' ) then ! go to next workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , pt ) end if end if if ( size ( itmp_f ) > 0 ) then ! some are false pf = p pf % xmas ( r % operator_arg )% v = [ itmp_f ( 1 ), itmp_f ( size ( itmp_f ))] iaccepted = iaccepted + process ( iworkflow , irule + 1 , pf ) ! next rule end if end select else ! goto another workflow & start at first rule of new workflow iaccepted = iaccepted + process ( workflow_name_to_index ( r % goto ), 1 , p ) end if end associate !end do end function process integer ( ip ) function get_accepted ( p ) !! count of all the parts in the set type ( part ), intent ( in ) :: p get_accepted = ( 1 + ( p % xmas ( 1 )% v ( 2 ) - p % xmas ( 1 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 2 )% v ( 2 ) - p % xmas ( 2 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 3 )% v ( 2 ) - p % xmas ( 3 )% v ( 1 ))) * & ( 1 + ( p % xmas ( 4 )% v ( 2 ) - p % xmas ( 4 )% v ( 1 ))) end function get_accepted function workflow_name_to_index ( name ) result ( idx ) !! get the index of this workflow in the array character ( len =* ), intent ( in ) :: name integer :: idx do idx = 1 , size ( workflows ) if ( name == workflows ( idx )% name ) return ! found it end do if ( idx > size ( workflows )) error stop 'workflow not found: ' // name end function workflow_name_to_index function parse_rule ( s ) result ( r ) character ( len =* ), intent ( in ) :: s type ( rule ) :: r type ( string ), dimension (:), allocatable :: v character ( len =* ), parameter :: xmas = 'xmas' ! 1,2,3,4 if ( s == 'A' ) then r % accept = . true . else if ( s == 'R' ) then r % reject = . true . else if ( index ( s , '>' ) > 0 ) then v = split ( s ( 3 :), ':' ) ! example: a<2006:qkq r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 2 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else if ( index ( s , '<' ) > 0 ) then v = split ( s ( 3 :), ':' ) r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 1 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else r % goto = s ! it's a workflow name end if end if end function parse_rule end program problem_19b","tags":"","loc":"sourcefile/problem_19b.f90.html"},{"title":"lusol_precision.F90 – AoC-2023","text":"Files dependent on this one sourcefile~~lusol_precision.f90~~AfferentGraph sourcefile~lusol_precision.f90 lusol_precision.F90 sourcefile~lusol.f90 lusol.f90 sourcefile~lusol.f90->sourcefile~lusol_precision.f90 sourcefile~lusol_ez.f90 lusol_ez.f90 sourcefile~lusol_ez.f90->sourcefile~lusol_precision.f90 sourcefile~lusol_ez.f90->sourcefile~lusol.f90 sourcefile~lusol_test.f90 lusol_test.f90 sourcefile~lusol_test.f90->sourcefile~lusol_precision.f90 sourcefile~lusol_test.f90->sourcefile~lusol_ez.f90 sourcefile~nlesolver_module.f90 nlesolver_module.F90 sourcefile~nlesolver_module.f90->sourcefile~lusol_ez.f90 sourcefile~nlesolver_test_1.f90 nlesolver_test_1.f90 sourcefile~nlesolver_test_1.f90->sourcefile~nlesolver_module.f90 sourcefile~sparse_test.f90 sparse_test.f90 sourcefile~sparse_test.f90->sourcefile~nlesolver_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! File lusol_precision.f90 ! ! SNOPT module for defining integer(ip), real(rp). ! snPrecision.f90 should be one of the following 3 files: ! ! snPrecision32.f90   sets  ip=4, rp = 8 ! snPrecision64.f90   sets  ip=8, rp = 8 ! snPrecision128.f90  sets  ip=8, rp = 16 ! ! ip  huge !  4  2147483647 !  8  9223372036854775807 ! ! rp  huge !  4  3.40282347E+38 !  8  1.79769313486231571E+308 ! 16  1.18973149535723176508575932662800702E+4932 ! ! rp  eps !  4  1.19209290E-07 !  8  2.22044604925031308E-016 ! 16  1.92592994438723585305597794258492732E-0034 ! ! We don't need selected_int_kind or selected_real_kind now. ! Previously we used these values: ! ip = integer precision    int_kind( 7) = integer(4) !                           int_kind(15) = integer(8) ! rp = real precision      real_kind( 6) = real(4)   (not used in SNOPT) !                          real_kind(15) = real(8) !                          real_kind(30) = real(16) ! ! 11 Mar 2008: First version. ! 20 Apr 2012: First quad version. ! 22 Apr 2012: Made three versions of snPrecision.f90. !              See README.QUAD for use with configure and make. !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ module lusol_precision use iso_fortran_env implicit none public integer ( 4 ), parameter :: ip = int64 #ifdef REAL32 integer ( 4 ), parameter , public :: rp = real32 !! default real kind [4 bytes] #elif REAL64 integer ( 4 ), parameter , public :: rp = real64 !! default real kind [8 bytes] #elif REAL128 integer ( 4 ), parameter , public :: rp = real128 !! default real kind [16 bytes] #else integer ( 4 ), parameter , public :: rp = real64 !! default real kind [8 bytes] #endif end module lusol_precision","tags":"","loc":"sourcefile/lusol_precision.f90.html"},{"title":"test1.f90 – AoC-2023","text":"This file depends on sourcefile~~test1.f90~~EfferentGraph sourcefile~test1.f90 test1.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~test1.f90->sourcefile~kinds_module.f90 sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~test1.f90->sourcefile~numerical_differentiation_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~kinds_module.f90 sourcefile~cache_module.f90 cache_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~cache_module.f90 sourcefile~diff_module.f90 diff_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~diff_module.f90 sourcefile~dsm_module.f90 dsm_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~dsm_module.f90 sourcefile~utilities_module.f90 utilities_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~utilities_module.f90 sourcefile~cache_module.f90->sourcefile~kinds_module.f90 sourcefile~cache_module.f90->sourcefile~utilities_module.f90 sourcefile~diff_module.f90->sourcefile~kinds_module.f90 sourcefile~dsm_module.f90->sourcefile~kinds_module.f90 sourcefile~utilities_module.f90->sourcefile~kinds_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> author: Jacob Williams !  date: October 31, 2016 ! !  Test1 for the numerical differentiation module. program test1 use iso_fortran_env , only : output_unit , error_unit use numerical_differentiation_module use numdiff_kinds_module , only : wp implicit none integer , parameter :: n = 10 integer , parameter :: m = 6 real ( wp ), dimension ( n ), parameter :: x = 1.0_wp real ( wp ), dimension ( n ), parameter :: xlow = - 1 0.0_wp real ( wp ), dimension ( n ), parameter :: xhigh = 1 0.0_wp real ( wp ), dimension ( n ), parameter :: dpert = 1.0e-5_wp integer , parameter :: perturb_mode = 1 integer , parameter :: cache_size = 0 !! `0` indicates not to use cache integer , parameter :: sparsity_mode = 4 type ( numdiff_type ) :: my_prob integer :: i !! counter integer :: j !! counter real ( wp ), dimension (:), allocatable :: jac character ( len = :), allocatable :: formula type ( finite_diff_method ) :: fd logical :: status_ok type ( meth_array ) :: meths integer :: func_evals !! function evaluation counter integer , dimension (:), allocatable :: methods !! array of method IDs character ( len = :), allocatable :: error_msg !! error message string methods = [( i , i = 1 , 44 )] methods = [ methods , 500 , 600 , 700 , 800 ] ! these only have central diffs do j = 1 , size ( methods ) ! try different finite diff methods i = methods ( j ) call get_finite_diff_formula ( i , formula ) if ( formula == '' ) then write ( output_unit , * ) 'id ' , i , 'not available' cycle end if func_evals = 0 call my_prob % destroy () call my_prob % initialize ( n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func = my_func ,& sparsity_mode = sparsity_mode ,& jacobian_method = i ,& partition_sparsity_pattern = . false .,& cache_size = cache_size ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if if ( i == 1 ) then write ( output_unit , '(A)' ) '' call my_prob % print_sparsity_pattern ( output_unit ) write ( output_unit , '(A)' ) '' call my_prob % print_sparsity_matrix ( output_unit ) write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '--------------------------------------' write ( output_unit , '(A,I4)' ) ' specify method [no partitioning] : ' , i write ( output_unit , '(A)' ) '--------------------------------------' write ( output_unit , '(A)' ) '' end if write ( output_unit , '(A)' ) formula write ( output_unit , '(A)' ) '' write ( output_unit , '(A,1X,*(F27.16,\",\"))' ) 'jac =' , jac write ( output_unit , '(A,1X,I5)' ) 'function evaluations:' , func_evals write ( output_unit , '(A)' ) '' end do do j = 1 , size ( methods ) ! try different finite diff methods i = methods ( j ) call get_finite_diff_formula ( i , formula ) if ( formula == '' ) then write ( output_unit , * ) 'id ' , i , 'not available' cycle end if func_evals = 0 call my_prob % destroy () call my_prob % initialize ( n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func = my_func ,& sparsity_mode = sparsity_mode ,& jacobian_method = i ,& partition_sparsity_pattern = . true .,& cache_size = 1000 ) ! use the cache for these cases if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if if ( i == 1 ) then write ( output_unit , '(A)' ) '' call my_prob % print_sparsity_pattern ( output_unit ) write ( output_unit , '(A)' ) '' call my_prob % print_sparsity_matrix ( output_unit ) write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '--------------------------------------' write ( output_unit , '(A,I4)' ) ' specify method [with partitioning] : ' , i write ( output_unit , '(A)' ) '--------------------------------------' write ( output_unit , '(A)' ) '' end if write ( output_unit , '(A)' ) formula write ( output_unit , '(A)' ) '' write ( output_unit , '(A,1X,*(F27.16,\",\"))' ) 'jac =' , jac write ( output_unit , '(A,1X,I5)' ) 'function evaluations:' , func_evals write ( output_unit , '(A)' ) '' end do meths = get_all_methods_in_class ( 3 ) write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) 'select_finite_diff_method' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) '' call my_prob % select_finite_diff_method ( 0.0_wp , 0.0_wp , 1.0_wp , 0.001_wp , meths , fd , status_ok ) call fd % get_formula ( formula ) write ( output_unit , '(A)' ) formula write ( output_unit , '(A)' ) '' call my_prob % select_finite_diff_method ( 0.9999_wp , 0.0_wp , 1.0_wp , 0.001_wp , meths , fd , status_ok ) call fd % get_formula ( formula ) write ( output_unit , '(A)' ) formula write ( output_unit , '(A)' ) '' do i = 2 , 9 write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A,I2)' ) ' specify class [no partitioning] : ' , i write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) '' func_evals = 0 call my_prob % destroy () call my_prob % initialize ( n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func = my_func ,& sparsity_mode = sparsity_mode ,& class = i ,& cache_size = cache_size ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if write ( output_unit , '(A,1X,*(F27.16,\",\"))' ) 'jac =' , jac write ( output_unit , '(A,1X,I5)' ) 'function evaluations:' , func_evals write ( output_unit , '(A)' ) '' end do do i = 2 , 9 write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A,I2)' ) ' specify class [with partitioning] : ' , i write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) '' func_evals = 0 call my_prob % destroy () call my_prob % initialize ( n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func = my_func ,& sparsity_mode = sparsity_mode ,& class = i , partition_sparsity_pattern = . true .,& cache_size = cache_size ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if write ( output_unit , '(A,1X,*(F27.16,\",\"))' ) 'jac =' , jac write ( output_unit , '(A,1X,I5)' ) 'function evaluations:' , func_evals write ( output_unit , '(A)' ) '' end do write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) ' diff algorithm' write ( output_unit , '(A)' ) '-------------------' write ( output_unit , '(A)' ) '' func_evals = 0 call my_prob % diff_initialize ( n , m , xlow , xhigh , my_func , sparsity_mode = 1 ,& ! use a dense method for this one cache_size = cache_size ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if call my_prob % compute_jacobian ( x , jac ) if ( my_prob % failed ()) then call my_prob % get_error_status ( error_msg = error_msg ) write ( error_unit , '(A)' ) error_msg stop end if write ( output_unit , '(A,1X,*(F27.16,\",\"))' ) 'jac =' , jac write ( output_unit , '(A,1X,I5)' ) 'function evaluations:' , func_evals write ( output_unit , '(A)' ) '' contains subroutine my_func ( me , x , f , funcs_to_compute ) !! Problem function implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: f integer , dimension (:), intent ( in ) :: funcs_to_compute if ( any ( funcs_to_compute == 1 )) f ( 1 ) = x ( 1 ) * x ( 2 ) - x ( 3 ) ** 3 if ( any ( funcs_to_compute == 2 )) f ( 2 ) = x ( 3 ) - 1.0_wp if ( any ( funcs_to_compute == 3 )) f ( 3 ) = x ( 4 ) * x ( 5 ) if ( any ( funcs_to_compute == 4 )) f ( 4 ) = 2.0_wp * x ( 6 ) + sin ( x ( 7 )) if ( any ( funcs_to_compute == 5 )) f ( 5 ) = cos ( x ( 8 )) + sqrt ( abs ( x ( 9 ))) if ( any ( funcs_to_compute == 6 )) f ( 6 ) = 1.0_wp / ( 1.0_wp + exp ( x ( 10 ))) func_evals = func_evals + 1 end subroutine my_func !******************************************************************************* end program test1 !*******************************************************************************","tags":"","loc":"sourcefile/test1.f90.html"},{"title":"diff_module.f90 – AoC-2023","text":"This file depends on sourcefile~~diff_module.f90~~EfferentGraph sourcefile~diff_module.f90 diff_module.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~diff_module.f90->sourcefile~kinds_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~diff_module.f90~~AfferentGraph sourcefile~diff_module.f90 diff_module.f90 sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~diff_module.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~numerical_differentiation_module.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~numerical_differentiation_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  Numerical differentiation of a 1D function `f(x)` using Neville's process. ! !## Authors !   * J. Oliver, \"An algorithm for numerical differentiation of a function !     of one real variable\", Journal of Computational and Applied Mathematics !     6 (2) (1980) 145–160. [Algol 60 source in original paper] !   * David Kahaner, Fortran 77 code from !     [NIST](ftp://math.nist.gov/pub/repository/diff/src/DIFF) !   * Jacob Williams : 2/17/2013 : Converted to modern Fortran. !     Some refactoring, addition of test cases. module diff_module use numdiff_kinds_module implicit none private type , public :: diff_func !! class to define the function for [[diff]] private logical :: stop = . false . procedure ( func ), pointer :: f => null () contains private procedure :: faccur procedure , public :: set_function procedure , public :: compute_derivative => diff procedure , public :: terminate end type diff_func abstract interface function func ( me , x ) result ( fx ) !! interface to function for [[diff]] import :: diff_func , wp implicit none class ( diff_func ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ) :: fx end function func end interface contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date:  12/27/2015 ! !  Set the function in a [[diff_func]]. !  Must be called before [[diff]]. subroutine set_function ( me , f ) implicit none class ( diff_func ), intent ( inout ) :: me procedure ( func ) :: f me % f => f end subroutine set_function !***************************************************************************************** !***************************************************************************************** !> !  Can be called by the user in the function to terminate the computation. !  This will set `ifail=-1`. subroutine terminate ( me ) implicit none class ( diff_func ), intent ( inout ) :: me me % stop = . true . end subroutine terminate !***************************************************************************************** !***************************************************************************************** !> !  the procedure `diff` calculates the first, second or !  third order derivative of a function by using neville's process to !  extrapolate from a sequence of simple polynomial approximations based on !  interpolating points distributed symmetrically about `x0` (or lying only on !  one side of `x0` should this be necessary).  if the specified tolerance is !  non-zero then the procedure attempts to satisfy this absolute or relative !  accuracy requirement, while if it is unsuccessful or if the tolerance is !  set to zero then the result having the minimum achievable estimated error !  is returned instead. subroutine diff ( me , iord , x0 , xmin , xmax , eps , accr , deriv , error , ifail ) implicit none class ( diff_func ), intent ( inout ) :: me integer , intent ( in ) :: iord !! 1, 2 or 3 specifies that the first, second or third order !! derivative,respectively, is required. real ( wp ), intent ( in ) :: x0 !! the point at which the derivative of the function is to be calculated. real ( wp ), intent ( in ) :: xmin !! `xmin`, `xmax` restrict the interpolating points to lie in [`xmin`, `xmax`], which !! should be the largest interval including `x0` in which the function is !! calculable and continuous. real ( wp ), intent ( in ) :: xmax !! `xmin`, `xmax` restrict the interpolating points to lie in [`xmin`, `xmax`], which !! should be the largest interval including `x0` in which the function is !! calculable and continuous. real ( wp ), intent ( in ) :: eps !! denotes the tolerance, either absolute or relative. `eps=0` specifies that !! the error is to be minimised, while `eps>0` or `eps<0` specifies that the !! absolute or relative error, respectively, must not exceed `abs(eps)` if !! possible.  the accuracy requirement should not be made stricter than !! necessary, since the amount of computation tends to increase as !! the magnitude of `eps` decreases, and is particularly high when `eps=0`. real ( wp ), intent ( in ) :: accr !! denotes that the absolute (`accr>0`) or relative (`accr<0`) errors in the !! computed values of the function are most unlikely to exceed `abs(accr)`, which !! should be as small as possible.  if the user cannot estimate `accr` with !! complete confidence, then it should be set to zero. real ( wp ), intent ( out ) :: deriv !! the calculated value of the derivative real ( wp ), intent ( out ) :: error !! an estimated upper bound on the magnitude of the absolute error in !! the calculated result.  it should always be examined, since in extreme case !! may indicate that there are no correct significant digits in the value !! returned for derivative. integer , intent ( out ) :: ifail !! will have one of the following values on exit: !!  *0* the procedure was successful. !!  *1* the estimated error in the result exceeds the (non-zero) requested !!      error, but the most accurate result possible has been returned. !!  *2* input data incorrect (derivative and error will be undefined). !!  *3* the interval [`xmin`, `xmax`] is too small (derivative and error will be !!      undefined). !!  *-1* stopped by the user. real ( wp ) :: acc , beta , beta4 , h , h0 , h1 , h2 , & newh1 , newh2 , heval , hprev , baseh , hacc1 , hacc2 , nhacc1 , & nhacc2 , minh , maxh , maxh1 , maxh2 , tderiv , f0 , twof0 , f1 , f2 , f3 , f4 , fmax , & maxfun , pmaxf , df1 , deltaf , pdelta , z , zpower , c0f0 , c1 , c2 , c3 , dnew , dprev , & re , te , newerr , temerr , newacc , pacc1 , pacc2 , facc1 , facc2 , acc0 , & acc1 , acc2 , relacc , twoinf , twosup , s , & d ( 10 ), denom ( 10 ), e ( 10 ), minerr ( 10 ), maxf ( 0 : 10 ), save ( 0 : 13 ), storef ( - 45 : 45 ), factor integer :: i , j , k , n , nmax , method , signh , fcount , init logical :: ignore ( 10 ), contin , saved real ( wp ) :: dummy1 , dummy2 integer , parameter :: eta = digits ( 1.0_wp ) - 1 !! minimum number of significant binary digits (apart from the !! sign digit) used to represent the mantissa of real(wp) numbers. it should !! be decreased by one if the computer truncates rather than rounds. integer , parameter :: inf = - minexponent ( 1.0_wp ) - 2 !! the largest possible positive integers subject to !! 2**(-inf) and -2**(-inf) being representable real(wp) numbers. integer , parameter :: sup = maxexponent ( 1.0_wp ) - 1 !! the largest possible positive integers subject to !! 2**sup and -2**sup being representable real(wp) numbers. real ( wp ), parameter :: sqrt2 = sqrt ( 2.0_wp ) !!  \\sqrt(2)  real ( wp ), parameter :: sqrt3 = sqrt ( 3.0_wp ) !!  \\sqrt(3)  me % stop = . false . ! execution commences with examination of input parameters if ( iord < 1 . or . iord > 3 . or . xmax <= xmin . or . & x0 > xmax . or . x0 < xmin . or . . not . associated ( me % f )) then ifail = 2 else acc = accr twoinf = 2.0_wp ** ( - inf ) twosup = 2.0_wp ** sup factor = 2.0_wp ** ( real (( inf + sup ), wp ) / 3 0.0_wp ) if ( factor < 25 6.0_wp ) factor = 25 6.0_wp maxh1 = xmax - x0 signh = 1 if ( x0 - xmin <= maxh1 ) then maxh2 = x0 - xmin else maxh2 = maxh1 maxh1 = x0 - xmin signh = - 1 end if relacc = 2.0_wp ** ( 1.0_wp - eta ) maxh1 = ( 1.0_wp - relacc ) * maxh1 maxh2 = ( 1.0_wp - relacc ) * maxh2 s = 12 8.0_wp * twoinf if ( abs ( x0 ) > 12 8.0_wp * twoinf * 2.0_wp ** eta ) s = abs ( x0 ) * 2.0_wp ** ( - eta ) if ( maxh1 < s ) then ! interval too small ifail = 3 return end if if ( acc < 0.0_wp ) then if ( - acc > relacc ) relacc = - acc acc = 0.0_wp end if ! determine the smallest spacing at which the calculated ! function values are unequal near x0. f0 = me % f ( x0 ) if ( me % stop ) then ifail = - 1 return end if twof0 = f0 + f0 if ( abs ( x0 ) > twoinf * 2.0_wp ** eta ) then h = abs ( x0 ) * 2.0_wp ** ( - eta ) z = 2.0_wp else h = twoinf z = 6 4.0_wp end if df1 = me % f ( x0 + signh * h ) - f0 if ( me % stop ) then ifail = - 1 return end if do if ( df1 /= 0.0_wp . or . z * h > maxh1 ) exit h = z * h df1 = me % f ( x0 + signh * h ) - f0 if ( me % stop ) then ifail = - 1 return end if if ( z /= 2.0_wp ) then if ( df1 /= 0.0_wp ) then h = h / z z = 2.0_wp df1 = 0.0_wp else if ( z * h > maxh1 ) z = 2.0_wp end if end if end do if ( df1 == 0.0_wp ) then ! constant function deriv = 0.0_wp error = 0.0_wp ifail = 0 return end if if ( h > maxh1 / 12 8.0_wp ) then ! minimum h too large ifail = 3 return end if h = 8.0_wp * h h1 = signh * h h0 = h1 h2 = - h1 minh = 2.0_wp ** ( - min ( inf , sup ) / iord ) if ( minh < h ) minh = h select case ( iord ) case ( 1 ) s = 8.0_wp case ( 2 ) s = 9.0_wp * sqrt3 case ( 3 ) s = 2 7.0_wp end select if ( minh > maxh1 / s ) then ifail = 3 return end if if ( minh > maxh2 / s . or . maxh2 < 12 8.0_wp * twoinf ) then method = 1 else method = 2 end if ! method 1 uses 1-sided formulae, and method 2 symmetric. ! now estimate accuracy of calculated function values. if ( method /= 2 . or . iord == 2 ) then if ( x0 /= 0.0_wp ) then dummy1 = 0.0_wp dummy2 = - h1 call me % faccur ( dummy1 , dummy2 , acc0 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return else acc0 = 0.0_wp end if end if if ( abs ( h1 ) > twosup / 12 8.0_wp ) then hacc1 = twosup else hacc1 = 12 8.0_wp * h1 end if if ( abs ( hacc1 ) / 4.0_wp < minh ) then hacc1 = 4.0_wp * signh * minh else if ( abs ( hacc1 ) > maxh1 ) then hacc1 = signh * maxh1 end if f1 = me % f ( x0 + hacc1 ) if ( me % stop ) then ifail = - 1 return end if call me % faccur ( hacc1 , h1 , acc1 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return if ( method == 2 ) then hacc2 = - hacc1 if ( abs ( hacc2 ) > maxh2 ) hacc2 = - signh * maxh2 f1 = me % f ( x0 + hacc2 ) if ( me % stop ) then ifail = - 1 return end if call me % faccur ( hacc2 , h2 , acc2 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return end if nmax = 8 if ( eta > 36 ) nmax = 10 n = - 1 fcount = 0 deriv = 0.0_wp error = twosup init = 3 contin = . true . do n = n + 1 if (. not . contin ) exit if ( init == 3 ) then ! calculate coefficients for differentiation ! formulae and neville extrapolation algorithm if ( iord == 1 ) then beta = 2.0_wp else if ( method == 2 ) then beta = sqrt2 else beta = sqrt3 end if beta4 = beta ** 4 z = beta if ( method == 2 ) z = z ** 2 zpower = 1.0_wp do k = 1 , nmax zpower = z * zpower denom ( k ) = zpower - 1 end do if ( method == 2 . and . iord == 1 ) then e ( 1 ) = 5.0_wp e ( 2 ) = 6.3_wp do i = 3 , nmax e ( i ) = 6.81_wp end do else if (( method /= 2 . and . iord == 1 ) . or . & ( method == 2 . and . iord == 2 )) then e ( 1 ) = 1 0.0_wp e ( 2 ) = 1 6.0_wp e ( 3 ) = 2 0.36_wp e ( 4 ) = 2 3.0_wp e ( 5 ) = 2 4.46_wp do i = 6 , nmax e ( i ) = 2 6.0_wp end do if ( method == 2 . and . iord == 2 ) then do i = 1 , nmax e ( i ) = 2.0_wp * e ( i ) end do end if else if ( method /= 2 . and . iord == 2 ) then e ( 1 ) = 1 7.78_wp e ( 2 ) = 3 0.06_wp e ( 3 ) = 3 9.66_wp e ( 4 ) = 4 6.16_wp e ( 5 ) = 5 0.26_wp do i = 6 , nmax e ( i ) = 5 5.0_wp end do else if ( method == 2 . and . iord == 3 ) then e ( 1 ) = 2 5.97_wp e ( 2 ) = 4 1.22_wp e ( 3 ) = 5 0.95_wp e ( 4 ) = 5 6.4_wp e ( 5 ) = 5 9.3_wp do i = 6 , nmax e ( i ) = 6 2.0_wp end do else e ( 1 ) = 2 4.5_wp e ( 2 ) = 4 0.4_wp e ( 3 ) = 5 2.78_wp e ( 4 ) = 6 1.2_wp e ( 5 ) = 6 6.55_wp do i = 6 , nmax e ( i ) = 7 3.0_wp end do c0f0 = - twof0 / ( 3.0_wp * beta ) c1 = 3.0_wp / ( 3.0_wp * beta - 1.0_wp ) c2 = - 1.0_wp / ( 3.0_wp * ( beta - 1.0_wp )) c3 = 1.0_wp / ( 3.0_wp * beta * ( 5.0_wp - 2.0_wp * beta )) end if end if if ( init >= 2 ) then ! initialization of steplengths, accuracy and other parameters heval = signh * minh h = heval baseh = heval maxh = maxh2 if ( method == 1 ) maxh = maxh1 do k = 1 , nmax minerr ( k ) = twosup ignore ( k ) = . false . end do if ( method == 1 ) newacc = acc1 if ( method == - 1 ) newacc = acc2 if ( method == 2 ) newacc = ( acc1 + acc2 ) / 2.0_wp if ( newacc < acc ) newacc = acc if (( method /= 2 . or . iord == 2 ) . and . newacc < acc0 ) newacc = acc0 if ( method /= - 1 ) then facc1 = acc1 nhacc1 = hacc1 newh1 = h1 end if if ( method /= 1 ) then facc2 = acc2 nhacc2 = hacc2 newh2 = h2 else facc2 = 0.0_wp nhacc2 = 0.0_wp end if init = 1 j = 0 saved = . false . end if ! calculate new or initial function values if ( init == 1 . and . ( n == 0 . or . iord == 1 ) . and . & . not .( method == 2 . and . fcount >= 45 )) then if ( method == 2 ) then fcount = fcount + 1 f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if storef ( fcount ) = f1 f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if storef ( - fcount ) = f2 else j = j + 1 if ( j <= fcount ) then f1 = storef ( j * method ) else f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if end if end if else f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if if ( method == 2 ) then f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if end if end if if ( n == 0 ) then if ( method == 2 . and . iord == 3 ) then pdelta = f1 - f2 pmaxf = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp heval = beta * heval f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if deltaf = f1 - f2 maxfun = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp heval = beta * heval f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if f2 = me % f ( x0 - heval ) if ( me % stop ) then ifail = - 1 return end if else if ( method /= 2 . and . iord >= 2 ) then if ( iord == 2 ) then f3 = f1 else f4 = f1 heval = beta * heval f3 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if end if heval = beta * heval f2 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if heval = beta * heval f1 = me % f ( x0 + heval ) if ( me % stop ) then ifail = - 1 return end if end if end if ! evaluate a new approximation dnew to the derivative if ( n > nmax ) then n = nmax do i = 1 , n maxf ( i - 1 ) = maxf ( i ) end do end if if ( method == 2 ) then maxf ( n ) = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp if ( iord == 1 ) then dnew = ( f1 - f2 ) / 2.0_wp else if ( iord == 2 ) then dnew = f1 + f2 - twof0 else dnew = - pdelta pdelta = deltaf deltaf = f1 - f2 dnew = dnew + 0.5_wp * deltaf if ( maxf ( n ) < pmaxf ) maxf ( n ) = pmaxf pmaxf = maxfun maxfun = ( abs ( f1 ) + abs ( f2 )) / 2.0_wp end if else maxf ( n ) = abs ( f1 ) if ( iord == 1 ) then dnew = f1 - f0 else if ( iord == 2 ) then dnew = ( twof0 - 3.0_wp * f3 + f1 ) / 3.0_wp if ( maxf ( n ) < abs ( f3 )) maxf ( n ) = abs ( f3 ) f3 = f2 f2 = f1 else dnew = c3 * f1 + c2 * f2 + c1 * f4 + c0f0 if ( maxf ( n ) < abs ( f2 )) maxf ( n ) = abs ( f2 ) if ( maxf ( n ) < abs ( f4 )) maxf ( n ) = abs ( f4 ) f4 = f3 f3 = f2 f2 = f1 end if end if if ( abs ( h ) > 1 ) then dnew = dnew / h ** iord else if ( 12 8.0_wp * abs ( dnew ) > twosup * abs ( h ) ** iord ) then dnew = twosup / 12 8.0_wp else dnew = dnew / h ** iord end if end if if ( init == 0 ) then ! update estimated accuracy of function values newacc = acc if (( method /= 2 . or . iord == 2 ) . and . newacc < acc0 ) newacc = acc0 if ( method /= - 1 . and . abs ( nhacc1 ) <= 1.125_wp * abs ( heval ) / beta4 ) then nhacc1 = heval pacc1 = facc1 call me % faccur ( nhacc1 , newh1 , facc1 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return if ( facc1 < pacc1 ) facc1 = ( 3.0_wp * facc1 + pacc1 ) / 4.0_wp end if if ( method /= 1 . and . abs ( nhacc2 ) <= 1.125_wp * abs ( heval ) / beta4 ) then if ( method == 2 ) then f1 = f2 nhacc2 = - heval else nhacc2 = heval end if pacc2 = facc2 call me % faccur ( nhacc2 , newh2 , facc2 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return if ( facc2 < pacc2 ) facc2 = ( 3.0_wp * facc2 + pacc2 ) / 4.0_wp end if if ( method == 1 . and . newacc < facc1 ) newacc = facc1 if ( method == - 1 . and . newacc < facc2 ) newacc = facc2 if ( method == 2 . and . newacc < ( facc1 + facc2 ) / 2.0_wp ) & newacc = ( facc1 + facc2 ) / 2.0_wp end if ! evaluate successive elements of the current row in the neville ! array, estimating and examining the truncation and rounding ! errors in each contin = n < nmax hprev = abs ( h ) fmax = maxf ( n ) if (( method /= 2 . or . iord == 2 ) . and . fmax < abs ( f0 )) fmax = abs ( f0 ) do k = 1 , n dprev = d ( k ) d ( k ) = dnew dnew = dprev + ( dprev - dnew ) / denom ( k ) te = abs ( dnew - d ( k )) if ( fmax < maxf ( n - k )) fmax = maxf ( n - k ) hprev = hprev / beta if ( newacc >= relacc * fmax ) then re = newacc * e ( k ) else re = relacc * fmax * e ( k ) end if if ( re /= 0.0_wp ) then if ( hprev > 1 ) then re = re / hprev ** iord else if ( 2.0_wp * re > twosup * hprev ** iord ) then re = twosup / 2.0_wp else re = re / hprev ** iord end if end if newerr = te + re if ( te > re ) newerr = 1.25_wp * newerr if (. not . ignore ( k )) then if (( init == 0 . or . ( k == 2 . and . . not . ignore ( 1 ))) & . and . newerr < error ) then deriv = d ( k ) error = newerr end if if ( init == 1 . and . n == 1 ) then tderiv = d ( 1 ) temerr = newerr end if if ( minerr ( k ) < twosup / 4.0_wp ) then s = 4.0_wp * minerr ( k ) else s = twosup end if if ( te > re . or . newerr > s ) then ignore ( k ) = . true . else contin = . true . end if if ( newerr < minerr ( k )) minerr ( k ) = newerr if ( init == 1 . and . n == 2 . and . k == 1 . and . . not . ignore ( 1 )) then if ( newerr < temerr ) then tderiv = d ( 1 ) temerr = newerr end if if ( temerr < error ) then deriv = tderiv error = temerr end if end if end if end do if ( n < nmax ) d ( n + 1 ) = dnew if ( eps < 0.0_wp ) then s = abs ( eps * deriv ) else s = eps end if if ( error <= s ) then contin = . false . else if ( init == 1 . and . ( n == 2 . or . ignore ( 1 ))) then if (( ignore ( 1 ) . or . ignore ( 2 )) . and . saved ) then saved = . false . n = 2 h = beta * save ( 0 ) heval = beta * save ( 1 ) maxf ( 0 ) = save ( 2 ) maxf ( 1 ) = save ( 3 ) maxf ( 2 ) = save ( 4 ) d ( 1 ) = save ( 5 ) d ( 2 ) = save ( 6 ) d ( 3 ) = save ( 7 ) minerr ( 1 ) = save ( 8 ) minerr ( 2 ) = save ( 9 ) if ( method == 2 . and . iord == 3 ) then pdelta = save ( 10 ) deltaf = save ( 11 ) pmaxf = save ( 12 ) maxfun = save ( 13 ) else if ( method /= 2 . and . iord >= 2 ) then f2 = save ( 10 ) f3 = save ( 11 ) if ( iord == 3 ) f4 = save ( 12 ) end if init = 0 ignore ( 1 ) = . false . ignore ( 2 ) = . false . else if (. not . ( ignore ( 1 ) . or . ignore ( 2 )) . and . n == 2 & . and . beta4 * factor * abs ( heval ) <= maxh ) then ! save all current values in case of return to current point saved = . true . save ( 0 ) = h save ( 1 ) = heval save ( 2 ) = maxf ( 0 ) save ( 3 ) = maxf ( 1 ) save ( 4 ) = maxf ( 2 ) save ( 5 ) = d ( 1 ) save ( 6 ) = d ( 2 ) save ( 7 ) = d ( 3 ) save ( 8 ) = minerr ( 1 ) save ( 9 ) = minerr ( 2 ) if ( method == 2 . and . iord == 3 ) then save ( 10 ) = pdelta save ( 11 ) = deltaf save ( 12 ) = pmaxf save ( 13 ) = maxfun else if ( method /= 2 . and . iord >= 2 ) then save ( 10 ) = f2 save ( 11 ) = f3 if ( iord == 3 ) save ( 12 ) = f4 end if h = factor * baseh heval = h baseh = h n = - 1 else init = 0 h = beta * h heval = beta * heval end if else if ( contin . and . beta * abs ( heval ) <= maxh ) then h = beta * h heval = beta * heval else if ( method /= 1 ) then contin = . true . if ( method == 2 ) then init = 3 method = - 1 if ( iord /= 2 ) then if ( x0 /= 0.0_wp ) then dummy1 = 0.0_wp dummy2 = - h0 call me % faccur ( dummy1 , dummy2 , acc0 , x0 , twoinf , f0 , f1 , ifail ) if ( ifail ==- 1 ) return else acc0 = 0.0_wp end if end if else init = 2 method = 1 end if n = - 1 signh = - signh else contin = . false . end if end do if ( eps < 0.0_wp ) then s = abs ( eps * deriv ) else s = eps end if ifail = 0 if ( eps /= 0.0_wp . and . error > s ) ifail = 1 end if end subroutine diff !***************************************************************************************** !***************************************************************************************** !> ! This procedure attempts to estimate the level of rounding errors in ! the calculated function values near the point `x0+h0` by fitting a ! least-squares straight-line approximation to the function at the ! six points `x0+h0-j*h1`, (`j = 0,1,3,5,7,9`), and then setting `facc` to ! twice the largest deviation of the function values from this line. ! `hi` is adjusted if necessary so that it is approximately 8 times the ! smallest spacing at which the function values are unequal near `x0+h0`. subroutine faccur ( me , h0 , h1 , facc , x0 , twoinf , f0 , f1 , ifail ) implicit none class ( diff_func ), intent ( inout ) :: me real ( wp ), intent ( inout ) :: h0 real ( wp ), intent ( inout ) :: h1 real ( wp ), intent ( out ) :: facc real ( wp ), intent ( in ) :: x0 real ( wp ), intent ( in ) :: twoinf real ( wp ), intent ( in ) :: f0 real ( wp ), intent ( in ) :: f1 integer , intent ( out ) :: ifail !! 0 if no error, -1 if user termination. real ( wp ) :: a0 , a1 , f00 , f001 , f2 , deltaf , t0 , t1 , df ( 5 ) integer :: j ifail = 0 t0 = 0.0_wp t1 = 0.0_wp if ( h0 /= 0.0_wp ) then if ( x0 + h0 /= 0.0_wp ) then f00 = f1 else h0 = 0.875_wp * h0 f00 = me % f ( x0 + h0 ) if ( me % stop ) then ifail = - 1 return end if end if if ( abs ( h1 ) >= 3 2.0_wp * twoinf ) h1 = h1 / 8.0_wp if ( 1 6.0_wp * abs ( h1 ) > abs ( h0 )) h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp f001 = me % f ( x0 + h0 - h1 ) if ( me % stop ) then ifail = - 1 return end if if ( f001 == f00 ) then if ( 25 6.0_wp * abs ( h1 ) <= abs ( h0 )) then h1 = 2.0_wp * h1 do f001 = me % f ( x0 + h0 - h1 ) if ( me % stop ) then ifail = - 1 return end if if ( f001 /= f00 . or . 25 6.0_wp * abs ( h1 ) > abs ( h0 )) exit h1 = 2.0_wp * h1 end do h1 = 8.0_wp * h1 else h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp end if else if ( 25 6.0_wp * twoinf <= abs ( h0 )) then do f001 = me % f ( x0 + h0 - h1 / 2.0_wp ) if ( me % stop ) then ifail = - 1 return end if if ( f001 == f00 . or . abs ( h1 ) < 4.0_wp * twoinf ) exit h1 = h1 / 2.0_wp end do h1 = 8.0_wp * h1 if ( 1 6.0_wp * abs ( h1 ) > abs ( h0 )) h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp else h1 = sign ( h1 , 1.0_wp ) * abs ( h0 ) / 1 6.0_wp end if end if else f00 = f0 end if do j = 1 , 5 f2 = me % f ( x0 + h0 - real ( 2 * j - 1 , wp ) * h1 ) if ( me % stop ) then ifail = - 1 return end if df ( j ) = f2 - f00 t0 = t0 + df ( j ) t1 = t1 + real ( 2 * j - 1 , wp ) * df ( j ) end do a0 = ( 3 3.0_wp * t0 - 5.0_wp * t1 ) / 7 3.0_wp a1 = ( - 5.0_wp * t0 + 1.2_wp * t1 ) / 7 3.0_wp facc = abs ( a0 ) do j = 1 , 5 deltaf = abs ( df ( j ) - ( a0 + real ( 2 * j - 1 , wp ) * a1 )) if ( facc < deltaf ) facc = deltaf end do facc = 2.0_wp * facc end subroutine faccur !***************************************************************************************** !***************************************************************************************** end module diff_module !*****************************************************************************************","tags":"","loc":"sourcefile/diff_module.f90.html"},{"title":"cache_module.f90 – AoC-2023","text":"This file depends on sourcefile~~cache_module.f90~2~~EfferentGraph sourcefile~cache_module.f90~2 cache_module.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~cache_module.f90~2->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~cache_module.f90~2~~AfferentGraph sourcefile~cache_module.f90~2 cache_module.f90 sourcefile~problem_12b.f90 problem_12b.f90 sourcefile~problem_12b.f90->sourcefile~cache_module.f90~2 sourcefile~problem_17b.f90 problem_17b.f90 sourcefile~problem_17b.f90->sourcefile~cache_module.f90~2 sourcefile~problem_22.f90 problem_22.f90 sourcefile~problem_22.f90->sourcefile~cache_module.f90~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> author: Jacob Williams ! !  For caching function evaluations. ! !  This is based on the cache module from `NumDiff`. !  It has been modified to cache integers (`int64`) instead of reals. module aoc_cache_module use aoc_utilities , only : ip , wp implicit none private type :: fx !! an [x,f(x)] cached pair. !! x is a vector and f is a vector. private integer ( ip ), dimension (:), allocatable :: x !! vector of input values integer ( ip ), dimension (:), allocatable :: f !! output functions end type fx type , public :: function_cache !! a vector function cache. private type ( fx ), dimension (:), allocatable :: c !! the cache of `f(x)` integer :: chunk_size = 100 !! for resizing vectors !! in the [[unique]] function contains private procedure , public :: initialize => initialize_cache procedure , public :: get => get_from_cache procedure , public :: put => put_in_cache procedure , public :: destroy => destroy_cache end type function_cache contains !******************************************************************************* !******************************************************************************* !> !  Initialize the cache. Must be called first before use. subroutine initialize_cache ( me , isize , chunk_size ) implicit none class ( function_cache ), intent ( inout ) :: me integer , intent ( in ) :: isize !! the size of the hash table integer , intent ( in ), optional :: chunk_size !! chunk size to speed up reallocation !! of arrays. A good value is a guess for !! the actual number of elements of `f` that !! will be saved per value of `x` [default is 100] call me % destroy () allocate ( me % c ( 0 : isize - 1 )) if ( present ( chunk_size )) then me % chunk_size = chunk_size else me % chunk_size = 100 end if end subroutine initialize_cache !******************************************************************************* !******************************************************************************* !> !  Check if the `x` vector is in the cache, if so return `f`. !  Note that only some of the elements may be present, so it will return !  the ones there are there, and indicate which ones were found. subroutine get_from_cache ( me , x , i , f , found ) implicit none class ( function_cache ), intent ( inout ) :: me integer ( ip ), dimension (:), intent ( in ) :: x !! independant variable vector integer ( ip ), intent ( out ) :: i !! index in the hash table integer ( ip ), dimension (:), allocatable , intent ( out ) :: f !! `f(x)` from the cache (if it was found) logical , intent ( out ) :: found !! if `x` was found in the cache integer :: j !! counter ! initialize: found = . false . if ( allocated ( me % c )) then ! get index in the hash table: i = mod ( abs ( vector_djb_hash ( x )), int ( size ( me % c ), ip ) ) ! check the table: if ( allocated ( me % c ( i )% x )) then if ( size ( me % c ( i )% x ) == size ( x )) then if ( all ( me % c ( i )% x == x )) then found = . true . f = me % c ( i )% f end if end if end if else error stop 'Error: the cache has not been initialized.' end if end subroutine get_from_cache !******************************************************************************* !******************************************************************************* !> !  Put a value into the cache. subroutine put_in_cache ( me , i , x , f ) implicit none class ( function_cache ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: i !! index in the hash table integer ( ip ), dimension (:), intent ( in ) :: x !! independant variable vector integer ( ip ), dimension (:), intent ( in ) :: f !! function integer ( ip ), parameter :: null = huge ( 1 ) !! an unusual value to initialize arrays if ( allocated ( me % c )) then if ( i <= size ( me % c )) then ! add to the cache me % c ( i )% x = x me % c ( i )% f = f else error stop 'Error: invalid index in hash table.' end if else error stop 'Error: the cache has not been initialized.' end if end subroutine put_in_cache !******************************************************************************* !******************************************************************************* !> !  Destroy a cache. subroutine destroy_cache ( me ) implicit none class ( function_cache ), intent ( out ) :: me end subroutine destroy_cache !******************************************************************************* !******************************************************************************* !> !  DJB hash algorithm for a `integer(ip)` vector. ! !### See also !  * J. Shahbazian, Fortran hashing algorithm, July 6, 2013 !   [Fortran Dev](https://fortrandev.wordpress.com/2013/07/06/fortran-hashing-algorithm/) pure function vector_djb_hash ( r ) result ( hash ) integer ( ip ), dimension (:), intent ( in ) :: r !! the vector integer ( ip ) :: hash !! the hash value integer :: i !! counter hash = 5381_ip do i = 1 , size ( r ) hash = ishft ( hash , 5_ip ) + hash + r ( i ) end do end function vector_djb_hash !******************************************************************************* !******************************************************************************* end module aoc_cache_module !*******************************************************************************","tags":"","loc":"sourcefile/cache_module.f90~2.html"},{"title":"problem_09.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_09.f90~~EfferentGraph sourcefile~problem_09.f90 problem_09.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_09.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_9 use iso_fortran_env use aoc_utilities implicit none integer :: i , iunit , n_lines integer ( ip ) :: isum call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day9_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day9.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = sum ([( extrapolate ( parse ( read_line ( iunit ))), i = 1 , n_lines )]) close ( iunit ) write ( * , * ) '9a: sum: ' , isum open ( newunit = iunit , file = 'inputs/day9.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = sum ([( extrapolate ( reverse ( parse ( read_line ( iunit )))), i = 1 , n_lines )]) close ( iunit ) write ( * , * ) '9b: sum: ' , isum call clk % toc ( '9' ) contains pure function extrapolate ( ivals ) result ( iextrap ) !! extrapolate the next value in the sequence using !! a difference table. Straightfoward implemention: !! create the full table, and then evaluate it. integer ( ip ), dimension (:), intent ( in ) :: ivals integer ( ip ) :: iextrap integer :: i , n type ( int64_vec ), dimension (:), allocatable :: diff_table !! difference table (vector of vectors) ! create the difference table: diff_table = [ int64_vec ( ivals )]; n = 1 do n = n + 1 diff_table = [ diff_table , int64_vec ( diff ( diff_table ( n - 1 )% vals ))] ! next line is diff of previous line if ( all ( diff_table ( n )% vals == 0 )) exit end do ! extrapolate iextrap = 0 do i = n - 1 , 1 , - 1 associate ( ilast => diff_table ( i )% vals ( size ( diff_table ( i )% vals )) ) iextrap = iextrap + ilast end associate end do end function extrapolate end program problem_9","tags":"","loc":"sourcefile/problem_09.f90.html"},{"title":"dsm_test.f90 – AoC-2023","text":"This file depends on sourcefile~~dsm_test.f90~~EfferentGraph sourcefile~dsm_test.f90 dsm_test.f90 sourcefile~dsm_module.f90 dsm_module.f90 sourcefile~dsm_test.f90->sourcefile~dsm_module.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~dsm_test.f90->sourcefile~kinds_module.f90 sourcefile~dsm_module.f90->sourcefile~kinds_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program dsm_test !! This is a test program for subroutines [[dsm]] and [[fdjs]]. !! the test data represents a neutron kinetics problem. !! !!### Reference !!  * Argonne National Laboratory. MINPACK Project. July 1983. !!    Thomas F. Coleman, Burton S. Garbow, Jorge J. More !!  * Thomas F. Coleman, Burton S. Garbow, Jorge J. More, \"Algorithm 618: !!    FORTRAN subroutines for estimating sparse Jacobian Matrices\", !!    ACM Transactions on Mathematical Software (TOMS), !!    Volume 10 Issue 3, Sept. 1984, Pages 346-347 use dsm_module use iso_fortran_env , only : output_unit use numdiff_kinds_module , only : wp implicit none integer , parameter :: nwrite = output_unit !! unit for printing integer i , info , ip , j , jp , l , m , maxgrp , maxrow , & mingrp , minrow , n , nnz , numgrp integer indcol ( 6000 ) , indrow ( 6000 ) , ipntr ( 1201 ) , jpntr ( 1201 ) , & ngrp ( 1200 ) logical col real ( wp ) :: dnsm , errij , errmax , fjact , fjactr , sum real ( wp ) :: d ( 1200 ) , fjac ( 6000 ) , fjacd ( 1200 ) , fvec ( 1200 ) , x ( 1200 ) , & xd ( 1200 ) col = . true . ! !     TEST FOR DSM AND FDJS. ! write ( nwrite , 99001 ) ! !     FORMAT STATEMENTS. ! 99001 format ( // ' TESTS FOR DSM AND FDJS - NEUTRON KINETICS PROBLEM' // & & ' STATISTICS GENERATED ' // '       N - NUMBER OF COLUMNS ' / & & '     NNZ - NUMBER OF NON-ZERO ELEMENTS' / & & '    DNSM - MATRIX DENSITY (PERCENTAGE)' / & & '  MINROW - MINIMUM NUMBER OF NON-ZEROS IN ANY ROW' / & & '  MAXROW - MAXIMUM NUMBER OF NON-ZEROS IN ANY ROW' / & & '  MINGRP - LOWER BOUND ON NUMBER OF GROUPS' / & & '  MAXGRP - NUMBER OF GROUPS DETERMINED BY DSM' // ) do n = 300 , 1200 , 300 write ( nwrite , 99002 ) 99002 format ( // 3 x , 'N' , 6 x , 'NNZ' , 5 x , 'DNSM' , 5 x , 'MINROW' , 4 x , 'MAXROW' , 4 x ,& & 'MINGRP' , 4 x , 'MAXGRP' // ) ! !        DEFINITION OF SPARSITY PATTERN. ! m = n l = n / 3 nnz = 0 do j = 1 , n nnz = nnz + 1 indrow ( nnz ) = j indcol ( nnz ) = j if ( mod ( j , l ) /= 0 ) then nnz = nnz + 1 indrow ( nnz ) = j + 1 indcol ( nnz ) = j endif if ( j <= 2 * l ) then nnz = nnz + 1 indrow ( nnz ) = j + l indcol ( nnz ) = j if ( mod ( j , l ) /= 1 ) then nnz = nnz + 1 indrow ( nnz ) = j - 1 indcol ( nnz ) = j endif endif nnz = nnz + 1 if ( j > l ) then indrow ( nnz ) = j - l else indrow ( nnz ) = j + 2 * l endif indcol ( nnz ) = j enddo ! !        CALL DSM. ! call dsm ( m , n , nnz , indrow , indcol , ngrp , maxgrp , mingrp , info , ipntr , jpntr ) if ( info <= 0 ) write ( nwrite , 99003 ) info 99003 format ( // ' *** MISTAKE IN INPUT DATA, INFO IS ***' , i6 ) ! !        STATISTICS FOR THE MATRIX. ! maxrow = 0 minrow = n do i = 1 , m maxrow = max ( maxrow , ipntr ( i + 1 ) - ipntr ( i )) minrow = min ( minrow , ipntr ( i + 1 ) - ipntr ( i )) enddo dnsm = real ( 100 * nnz , wp ) / real ( m * n , wp ) write ( nwrite , 99004 ) n , nnz , dnsm , minrow , maxrow , & & mingrp , maxgrp 99004 format ( 2 ( i5 , 3 x ), f6 . 2 , 4 x , 4 ( i5 , 5 x )) ! !        TEST FOR FDJS. ! do j = 1 , n x ( j ) = real ( j , wp ) / real ( n , wp ) enddo call fcn ( n , x , indcol , ipntr , fvec ) ! !        APPROXIMATE THE JACOBIAN MATRIX. ! do numgrp = 1 , maxgrp do j = 1 , n d ( j ) = 0.0_wp if ( ngrp ( j ) == numgrp ) d ( j ) = 1.0e-6_wp !d(j) = 0.001_wp xd ( j ) = x ( j ) + d ( j ) enddo call fcn ( n , xd , indcol , ipntr , fjacd ) do i = 1 , m fjacd ( i ) = fjacd ( i ) - fvec ( i ) enddo if ( col ) then call fdjs ( m , n , col , indrow , jpntr , ngrp , numgrp , d , fjacd , fjac ) else call fdjs ( m , n , col , indcol , ipntr , ngrp , numgrp , d , fjacd , fjac ) endif enddo ! !        TEST THE APPROXIMATION TO THE JACOBIAN. ! errmax = 0.0_wp if ( col ) then ! !           TEST FOR THE COLUMN-ORIENTED DEFINITION OF !           THE SPARSITY PATTERN. ! do j = 1 , n do jp = jpntr ( j ) , jpntr ( j + 1 ) - 1 i = indrow ( jp ) sum = 0.0_wp do ip = ipntr ( i ) , ipntr ( i + 1 ) - 1 sum = sum + x ( indcol ( ip )) enddo sum = sum + x ( i ) fjact = 1.0_wp + 2.0_wp * sum if ( i == j ) fjact = 2.0_wp * fjact errij = fjac ( jp ) - fjact if ( fjact /= 0.0_wp ) errij = errij / fjact errmax = max ( errmax , abs ( errij )) enddo enddo else ! !           TEST FOR THE ROW-ORIENTED DEFINITION OF !           THE SPARSITY PATTERN. ! do i = 1 , m sum = 0.0_wp do ip = ipntr ( i ) , ipntr ( i + 1 ) - 1 sum = sum + x ( indcol ( ip )) enddo sum = sum + x ( i ) fjactr = 1.0_wp + 2.0_wp * sum do ip = ipntr ( i ) , ipntr ( i + 1 ) - 1 j = indcol ( ip ) fjact = fjactr if ( i == j ) fjact = 2.0_wp * fjact errij = fjac ( ip ) - fjact if ( fjact /= 0.0_wp ) errij = errij / fjact errmax = max ( errmax , abs ( errij )) enddo enddo endif write ( nwrite , 99005 ) errmax 99005 format ( // ' LARGEST RELATIVE ERROR OF APPROXIMATION IS' , e10 . 2 ) col = . not . col enddo stop contains subroutine fcn ( n , x , Indcol , Ipntr , Fvec ) !! Function subroutine for testing [[fdjs]]. implicit none integer n integer Indcol ( * ) , Ipntr ( n + 1 ) real ( wp ) :: x ( n ) , Fvec ( n ) integer i , ip real ( wp ) :: sum do i = 1 , n sum = 0.0_wp do ip = Ipntr ( i ) , Ipntr ( i + 1 ) - 1 sum = sum + x ( Indcol ( ip )) enddo sum = sum + x ( i ) Fvec ( i ) = sum * ( 1.0_wp + sum ) + 1.0_wp enddo end subroutine fcn end program dsm_test","tags":"","loc":"sourcefile/dsm_test.f90.html"},{"title":"problem_15.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_15.f90~~EfferentGraph sourcefile~problem_15.f90 problem_15.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_15.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !********************************************************************************* !> !  A module for problem 15, part 2. module problem_15_module use iso_fortran_env use aoc_utilities implicit none type :: lens character ( len = :), allocatable :: label integer ( ip ) :: focal_length = 0 end type lens type :: box type ( lens ), dimension (:), allocatable :: lenses !! the lenses in the box contains procedure :: add_lens procedure :: remove_lens end type box contains subroutine add_lens ( me , l ) ! = class ( box ), intent ( inout ) :: me type ( lens ), intent ( in ) :: l !! lense to add integer :: i !! counter if ( allocated ( me % lenses )) then do i = 1 , size ( me % lenses ) if ( me % lenses ( i )% label == l % label ) then me % lenses ( i ) = l ! replace with this one return end if end do me % lenses = [ me % lenses , l ] ! if not found, add to end else me % lenses = [ l ] ! first one in the box end if end subroutine add_lens subroutine remove_lens ( me , label ) ! - !! remove the lens with the label (if present) class ( box ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: label integer :: i type ( lens ), dimension (:), allocatable :: tmp if ( allocated ( me % lenses )) then allocate ( tmp ( 0 )) do i = 1 , size ( me % lenses ) if ( me % lenses ( i )% label /= label ) tmp = [ tmp , me % lenses ( i )] end do call move_alloc ( tmp , me % lenses ) end if end subroutine remove_lens end module problem_15_module !********************************************************************************* program problem_15 use iso_fortran_env use aoc_utilities use problem_15_module implicit none integer :: i , iunit , j type ( string ), dimension (:), allocatable :: vals , vals2 integer ( ip ), dimension (:), allocatable :: ivals type ( box ), dimension ( 0 : 255 ) :: boxes ! for part 2 integer ( ip ) :: ibox ! 0-255 character ( len = :), allocatable :: label integer ( ip ) :: ival , focusing_power , lens_focusing_power call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day15_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day15.txt' , status = 'OLD' ) vals = split ( read_line ( iunit ), ',' ) close ( iunit ) allocate ( ivals ( size ( vals ))) do i = 1 , size ( vals ) ! part 1: ivals ( i ) = hash ( vals ( i )% str ) ! part 2: if ( index ( vals ( i )% str , '=' ) > 0 ) then vals2 = split ( vals ( i )% str , '=' ) label = vals2 ( 1 )% str ibox = hash ( label ) ival = int ( vals2 ( 2 )% str ) ! focal length call boxes ( ibox )% add_lens ( lens ( label , ival )) else if ( index ( vals ( i )% str , '-' ) > 0 ) then vals2 = split ( vals ( i )% str , '-' ) label = vals2 ( 1 )% str ibox = hash ( label ) call boxes ( ibox )% remove_lens ( label ) end if end do write ( * , * ) '15a: ' , sum ( ivals ) focusing_power = 0 do i = 0 , 255 ! all the boxes if ( allocated ( boxes ( i )% lenses )) then do j = 1 , size ( boxes ( i )% lenses ) ! all the lenses in the box lens_focusing_power = ( i + 1 ) * ( j ) * ( boxes ( i )% lenses ( j )% focal_length ) focusing_power = focusing_power + lens_focusing_power end do end if end do write ( * , * ) '15b: ' , focusing_power call clk % toc ( '15' ) contains pure elemental integer ( ip ) function hash ( s ) !! Determine the ASCII code for the current character of the string. character ( len =* ), intent ( in ) :: s integer :: i hash = 0 do i = 1 , len ( s ) hash = modulo ( 17_ip * ( hash + iachar ( s ( i : i ))), 256_ip ) end do end function hash end program problem_15","tags":"","loc":"sourcefile/problem_15.f90.html"},{"title":"lsqrtest_module.f90 – AoC-2023","text":"This file depends on sourcefile~~lsqrtest_module.f90~~EfferentGraph sourcefile~lsqrtest_module.f90 lsqrtest_module.f90 sourcefile~lsqr.f90 lsqr.f90 sourcefile~lsqrtest_module.f90->sourcefile~lsqr.f90 sourcefile~lsqr_kinds.f90 lsqr_kinds.F90 sourcefile~lsqrtest_module.f90->sourcefile~lsqr_kinds.f90 sourcefile~lsqrblas.f90 lsqrblas.f90 sourcefile~lsqrtest_module.f90->sourcefile~lsqrblas.f90 sourcefile~lsqr.f90->sourcefile~lsqr_kinds.f90 sourcefile~lsqr.f90->sourcefile~lsqrblas.f90 sourcefile~lsqrblas.f90->sourcefile~lsqr_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~lsqrtest_module.f90~~AfferentGraph sourcefile~lsqrtest_module.f90 lsqrtest_module.f90 sourcefile~lsqrtest.f90 lsqrtest.f90 sourcefile~lsqrtest.f90->sourcefile~lsqrtest_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !*************************************************************************************************** !> !  Test module for [[lsqr]]. ! !  These routines define a class of least-squares test problems !  for testing algorithms LSQR and CRAIG !  (Paige and Saunders, ACM TOMS, 1982). ! !### Author ! *  Michael Saunders, Dept of Operations Research, Stanford University. ! !### History !  * 1982---1991:  Various versions implemented. !  * 06 Feb 1992:  Test-problem generator lstp generalized to allow !    any m and n.  lstp is now the same as the generator !    for LSQR and CRAIG. !  * 30 Nov 1993:  Modified lstp. !    For a while, damp = 0 implied r = damp*s = 0. !    This was a result of generating x and s. !    Reverted to generating x and r as in LSQR paper. !  * 12 Nov 2019 : Jacob Williams : significant refactoring into modern Fortran. module lsqrtest_module use lsqr_kinds use lsqpblas_module , only : dnrm2 , dcopy , dscal use lsqr_module , only : lsqr_solver implicit none private integer , parameter :: lenrw = 10000 type , extends ( lsqr_solver ) :: test_solver integer :: nout = - 1 !! output unit for printing real ( wp ), dimension ( lenrw ) :: rw !! workspace array contains procedure :: aprod => aprod_test_solver procedure :: test procedure :: aprod1 procedure :: aprod2 procedure :: lstp end type public :: lsqr_test contains !*************************************************************************************************** !*************************************************************************************************** !> !  Unit test. subroutine lsqr_test () integer :: iunit , nbar , nduplc , n , m , ndamp , npower real ( wp ) :: damp type ( test_solver ) :: solver open ( newunit = iunit , file = 'LSQR.LIS' , status = 'REPLACE' ) solver % nout = iunit nbar = 1000 nduplc = 40 m = 2 * nbar n = nbar do ndamp = 2 , 7 npower = ndamp damp = 1 0.0_wp ** ( - ndamp - 6 ) call solver % test ( m , n , nduplc , npower , damp ) end do m = nbar n = nbar do ndamp = 2 , 7 npower = ndamp damp = 1 0.0_wp ** ( - ndamp - 6 ) call solver % test ( m , n , nduplc , npower , damp ) end do m = nbar n = 2 * nbar do ndamp = 2 , 7 npower = ndamp damp = 1 0.0_wp ** ( - ndamp - 6 ) call solver % test ( m , n , nduplc , npower , damp ) end do close ( iunit ) end subroutine lsqr_test !*************************************************************************************************** !*************************************************************************************************** !> !  This is an example driver routine for running LSQR. !  It generates a test problem, solves it, and examines the results. !  Note that subroutine aprod must be declared external !  if it is used only in the call to LSQR (and acheck). ! !### History !  * 1982---1991:  Various versions implemented. !  * 04 Sep 1991:  \"wantse\" added to argument list of LSQR, !    making standard errors optional. !  * 10 Feb 1992:  Revised for use with lsqrchk fortran. !  * 31 Mar 2005: changed atol = eps**0.666667 to eps*0.99 !    to increase accuracy of the solution.  LSQR appears to be !    successful on all 18 test problems except 5 and 6 !    (which are over-determined and too ill-conditioned to !    permit any correct digits). !    The output from an Intel Xeon system with g77 is in LSQR.LIS. !    The two \"appears to have failed\" messages are no cause for alarm. !  Michael Saunders, Dept of Operations Research, Stanford University. subroutine test ( me , m , n , nduplc , npower , damp ) class ( test_solver ), intent ( inout ) :: me integer :: m , n , nduplc , npower real ( wp ) :: damp integer , parameter :: maxm = 2000 integer , parameter :: maxn = 2000 integer , parameter :: mxmn = 2000 real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) !! machine precision character ( len = 34 ), parameter :: line = '----------------------------------' integer :: inform , istop , itnlim , j , itn , maxmn , minmn , nprint integer :: locd , lochy , lochz , locw , ltotal logical :: wantse real ( wp ) :: b ( maxm ), u ( maxm ), & v ( maxn ), w ( mxmn ), x ( maxn ), & se ( maxn ), xtrue ( maxn ), y ( mxmn ) real ( wp ) :: atol , btol , conlim , & anorm , acond , rnorm , arnorm , & enorm , etol , xnorm , test1 , test2 , test3 , wnorm if ( m > maxm . or . n > maxn ) then ! m or n too large. write ( me % nout , 8000 ) return end if ! Set the desired solution xtrue. ! For least-squares problems, this is it. ! For underdetermined systems, lstp may alter it. do j = 1 , n ! xtrue(j) = one xtrue ( j ) = j * 0.1_wp end do ! Generate the specified test problem. ! The workspace array  rw  is used for the following vectors: !    d(minmn), hy(m), hz(n), w(maxmn). ! The vectors  d, hy, hz  will define the test matrix A. ! w is needed for workspace in aprod1 and aprod2. maxmn = max ( m , n ) minmn = min ( m , n ) locd = 1 lochy = locd + minmn lochz = lochy + m locw = lochz + n ltotal = locw + maxmn - 1 if ( ltotal > lenrw ) then ! Not enough workspace. write ( me % nout , 9000 ) ltotal end if call me % lstp ( m , n , maxmn , minmn , nduplc , npower , damp , xtrue , & b , me % rw ( locd ), me % rw ( lochy ), me % rw ( lochz ), me % rw ( locw ), & acond , rnorm ) write ( me % nout , 1000 ) line , line , & m , n , nduplc , npower , damp , acond , rnorm , & line , line ! Check that aprod generates y + Ax and x + A'y consistently. call me % acheck ( m , n , me % nout , eps , v , w , x , y , inform ) if ( inform > 0 ) then write ( me % nout , '(a)' ) ' Check eps and power in subroutine acheck' stop end if ! Solve the problem defined by aprod, damp and b. ! Copy the rhs vector b into u  (LSQR will overwrite u) ! and set the other input parameters for LSQR. ! We ask for standard errors only if they are well-defined. call dcopy ( m , b , 1 , u , 1 ) !---  wantse = m > n  .or.  damp > zero wantse = . false . atol = eps ** 0.99_wp btol = atol conlim = 100 0.0_wp * acond itnlim = 4 * ( m + n + 50 ) call me % lsqr ( m , n , damp , wantse , & u , v , w , x , se , & atol , btol , conlim , itnlim , me % nout , & istop , itn , anorm , acond , rnorm , arnorm , xnorm ) ! Examine the results. !-  if (damp == zero) then !-     write(nout, 2000)       xnorm, rnorm, arnorm !-  else !-     write(nout, 2100) damp, xnorm, rnorm, arnorm !-  end if call me % xcheck ( m , n , me % nout , anorm , damp , eps , & b , u , v , w , x , & inform , test1 , test2 , test3 ) ! Print the solution and standard error estimates from  LSQR. nprint = min ( m , n , 8 ) write ( me % nout , 2500 ) ( j , x ( j ) , j = 1 , nprint ) if ( wantse ) then write ( me % nout , 2600 ) ( j , se ( j ), j = 1 , nprint ) end if ! Print a clue about whether the solution looks OK. do j = 1 , n w ( j ) = x ( j ) - xtrue ( j ) end do wnorm = dnrm2 ( n , w , 1 ) xnorm = dnrm2 ( n , xtrue , 1 ) enorm = wnorm / ( one + xnorm ) etol = 0.001_wp if ( enorm <= etol ) then write ( me % nout , 3000 ) enorm else write ( me % nout , 3100 ) enorm end if return 1000 format ( 1 p & // 1 x , 2 a & / ' Least-Squares Test Problem      P(' , 4 i5 , e12 . 2 , ' )' & // ' Condition no. =' , e12 . 4 , '     Residual function =' , e17 . 9 & / 1 x , 2 a ) 2000 format ( 1 p & // ' We are solving    min norm(Ax - b)    with no damping.' & // ' Estimates from LSQR:' & / '    norm(x)         =' , e10 . 3 , ' = xnorm' & / '    norm(r)         =' , e10 . 3 , ' = rnorm' & / '    norm(A''r)       =' , e10 . 3 , ' = arnorm' ) 2100 format ( 1 p & // ' We are solving    min norm(Ax - b)    with damp =' , e10 . 3 & / '                           (damp*x)' & // ' Estimates from LSQR:' & / '    norm(x)         =' , e10 . 3 , ' = xnorm' & / '    norm(rbar)      =' , e10 . 3 , ' = rnorm' & / '    norm(Abar''rbar) =' , e10 . 3 , ' = arnorm' ) 2500 format ( // ' Solution  x:' / 4 ( i6 , g14 . 6 )) 2600 format ( / ' Standard errors  se:' / 4 ( i6 , g14 . 6 )) 3000 format ( 1 p / ' LSQR  appears to be successful.' , & '     Relative error in  x  =' , e10 . 2 ) 3100 format ( 1 p / ' LSQR  appears to have failed.  ' , & '     Relative error in  x  =' , e10 . 2 ) 8000 format ( / ' XXX  m or n is too large.' ) 9000 format ( / ' XXX  Insufficient workspace.' , & '  The length of  rw  should be at least' , i6 ) end subroutine test !*************************************************************************************************** !*************************************************************************************************** !> !   This is the matrix-vector product routine required by subroutines !   LSQR and CRAIG for a test matrix of the form  A = HY*D*HZ. !   The quantities defining D, HY, HZ are in the work array rw, !   followed by a work array w.  These are passed to aprod1 and aprod2 !   in order to make the code readable. subroutine aprod_test_solver ( me , mode , m , n , x , y ) class ( test_solver ), intent ( inout ) :: me integer , intent ( in ) :: mode integer , intent ( in ) :: m integer , intent ( in ) :: n real ( wp ), dimension (:), intent ( inout ) :: x !! dimension n real ( wp ), dimension (:), intent ( inout ) :: y !! dimension m integer :: locd , lochy , lochz , locw , maxmn , minmn maxmn = max ( m , n ) minmn = min ( m , n ) locd = 1 lochy = locd + minmn lochz = lochy + m locw = lochz + n if ( mode == 1 ) then call me % aprod1 ( m , n , maxmn , minmn , x , y , & me % rw ( locd ), me % rw ( lochy ), me % rw ( lochz ), me % rw ( locw ) ) else call me % aprod2 ( m , n , maxmn , minmn , x , y , & me % rw ( locd ), me % rw ( lochy ), me % rw ( lochz ), me % rw ( locw ) ) end if end subroutine aprod_test_solver !*************************************************************************************************** !*************************************************************************************************** !> !  aprod1  computes  y = y + A*x  for subroutine aprod, !  where A is a test matrix of the form  A = HY*D*HZ, !  and the latter matrices HY, D, HZ are represented by !  input vectors with the same name. subroutine aprod1 ( me , m , n , maxmn , minmn , x , y , d , hy , hz , w ) class ( test_solver ), intent ( inout ) :: me integer :: m , n , maxmn , minmn real ( wp ) :: x ( n ), y ( m ), d ( minmn ), hy ( m ), hz ( n ), w ( maxmn ) integer :: i call hprod ( n , hz , x , w ) do i = 1 , minmn w ( i ) = d ( i ) * w ( i ) end do do i = n + 1 , m w ( i ) = zero end do call hprod ( m , hy , w , w ) do i = 1 , m y ( i ) = y ( i ) + w ( i ) end do end subroutine aprod1 !*************************************************************************************************** !*************************************************************************************************** !> !  aprod2  computes  x = x + A(t)*y  for subroutine aprod, !  where  A  is a test matrix of the form  A = HY*D*HZ, !  and the latter matrices  HY, D, HZ  are represented by !  input vectors with the same name. subroutine aprod2 ( me , m , n , maxmn , minmn , x , y , d , hy , hz , w ) class ( test_solver ), intent ( inout ) :: me integer :: m , n , maxmn , minmn real ( wp ) :: x ( n ), y ( m ), d ( minmn ), hy ( m ), hz ( n ), w ( maxmn ) integer :: i call hprod ( m , hy , y , w ) do i = 1 , minmn w ( i ) = d ( i ) * w ( i ) end do do i = m + 1 , n w ( i ) = zero end do call hprod ( n , hz , w , w ) do i = 1 , n x ( i ) = x ( i ) + w ( i ) end do end subroutine aprod2 !*************************************************************************************************** !*************************************************************************************************** !> !  hprod  applies a Householder transformation stored in  hz !  to get  y = ( I - 2*hz*hz(transpose) ) * x. subroutine hprod ( n , hz , x , y ) integer :: n real ( wp ) :: hz ( n ), x ( n ), y ( n ) integer :: i real ( wp ) :: s s = zero do i = 1 , n s = hz ( i ) * x ( i ) + s end do s = s + s do i = 1 , n y ( i ) = x ( i ) - s * hz ( i ) end do end subroutine hprod !*************************************************************************************************** !*************************************************************************************************** !> !  lstp  generate a sparse least-squares test problem of the form !             (   A    )*x = ( b ) !             ( damp*I )     ( 0 ) !  for solution by LSQR, or a sparse underdetermined system !                Ax + damp*s = b !  for solution by CRAIG.  The matrix A is m by n and is !  constructed in the form  A = HY*D*HZ,  where D is an m by n !  diagonal matrix, and HY and HZ are Householder transformations. ! !  m and n may contain any positive values. !  The first 8 parameters are input to lstp.  The last 8 are output. !  If m >= n  or  damp = 0, the true solution is x as given. !  Otherwise, x is modified to contain the true solution. subroutine lstp ( me , m , n , maxmn , minmn , nduplc , npower , damp , x , & b , d , hy , hz , w , acond , rnorm ) class ( test_solver ), intent ( inout ) :: me integer :: m , n , maxmn , minmn , nduplc , npower real ( wp ) :: damp , acond , rnorm real ( wp ) :: b ( m ), x ( n ), d ( minmn ), hy ( m ), hz ( n ), w ( maxmn ) integer :: i , j real ( wp ) alfa , beta , dampsq , t real ( wp ), parameter :: fourpi = 4.0_wp * acos ( - 1.0_wp ) !4.0*3.141592 ! ------------------------------------------------------------------ ! Make two vectors of norm 1.0 for the Householder transformations. ! fourpi  need not be exact. ! ------------------------------------------------------------------ minmn = min ( m , n ) dampsq = damp ** 2 alfa = fourpi / m beta = fourpi / n do i = 1 , m hy ( i ) = sin ( i * alfa ) end do do i = 1 , n hz ( i ) = cos ( i * beta ) end do alfa = dnrm2 ( m , hy , 1 ) beta = dnrm2 ( n , hz , 1 ) call dscal ( m , ( - one / alfa ), hy , 1 ) call dscal ( n , ( - one / beta ), hz , 1 ) ! ------------------------------------------------------------------ ! Set the diagonal matrix  D.  These are the singular values of  A. ! ------------------------------------------------------------------ do i = 1 , minmn j = ( i - 1 + nduplc ) / nduplc t = j * nduplc t = t / minmn d ( i ) = t ** npower end do acond = ( d ( minmn ) ** 2 + dampsq ) / ( d ( 1 ) ** 2 + dampsq ) acond = sqrt ( acond ) ! ------------------------------------------------------------------ ! Set the true solution   x. ! It must be of the form  x = Z ( w )  for some  w. !                               ( 0 ) ! ------------------------------------------------------------------ call hprod ( n , hz , x , w ) do i = m + 1 , n w ( i ) = zero end do call hprod ( n , hz , w , x ) ! Solve D r1bar = dampsq x1bar ! where r1bar and x1bar are both in w. do i = 1 , minmn w ( i ) = dampsq * w ( i ) / d ( i ) end do ! Set r2bar to be anything.  (It is empty if m <= n) ! Then form r = Y rbar (again in w). do i = minmn + 1 , m w ( i ) = one end do call Hprod ( m , hy , w , w ) ! Compute the rhs    b = r  +  Ax. rnorm = dnrm2 ( m , w , 1 ) call dcopy ( m , w , 1 , b , 1 ) call me % aprod1 ( m , n , maxmn , minmn , x , b , d , hy , hz , w ) end subroutine lstp !*************************************************************************************************** !*************************************************************************************************** end module lsqrtest_module !***************************************************************************************************","tags":"","loc":"sourcefile/lsqrtest_module.f90.html"},{"title":"problem_08.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_08.f90~~EfferentGraph sourcefile~problem_08.f90 problem_08.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_08.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_8 use iso_fortran_env use aoc_utilities implicit none integer :: iunit , n_lines character ( len = :), allocatable :: line , instructions type ( string ), dimension (:), allocatable :: vals integer ( ip ) :: i , j , idx , idx_zzz , imoves , ias , izs integer ( ip ), dimension (:), allocatable :: instructions_ints integer ( ip ), dimension (:), allocatable :: idx_vec , idx_zzz_vec integer ( ip ), dimension (:), allocatable :: imoves_vec type :: node character ( len = 3 ) :: name = '' character ( len = 3 ), dimension ( 2 ) :: lr integer , dimension ( 2 ) :: lr_idx ! the indices in the nodes array of the l,r nodes end type node type ( node ), dimension (:), allocatable :: nodes call clk % tic () ! read the data file: ! open(newunit=iunit, file='inputs/day8_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day8.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( nodes ( n_lines - 2 )) instructions = read_line ( iunit ) allocate ( instructions_ints ( len ( instructions ))) do i = 1 , len ( instructions ) select case ( instructions ( i : i )) ! make an int array for easier access case ( 'L' ); instructions_ints ( i ) = 1 case ( 'R' ); instructions_ints ( i ) = 2 end select end do do i = 0 , n_lines - 1 line = read_line ( iunit ) if ( line == '' ) cycle read ( line , \"(A3,1X,1X,1X,1X,A3,1X,1X,A3,1X)\" ) nodes ( i )% name , nodes ( i )% lr ( 1 ), nodes ( i )% lr ( 2 ) end do close ( iunit ) ! compute all the lr indices: do i = 1 , size ( nodes ) nodes ( i )% lr_idx ( 1 ) = find_node ( nodes ( i )% lr ( 1 )) nodes ( i )% lr_idx ( 2 ) = find_node ( nodes ( i )% lr ( 2 )) end do !******************************************** imoves = moves ( find_node ( 'AAA' ), find_node ( 'ZZZ' )) write ( * , * ) '8a : number of moves:' , imoves !******************************************** ! get indices of the ones that end in A and Z: allocate ( idx_vec ( 0 ), idx_zzz_vec ( 0 )) do i = 1 , size ( nodes ) if ( nodes ( i )% name ( 3 : 3 ) == 'A' ) idx_vec = [ idx_vec , i ] if ( nodes ( i )% name ( 3 : 3 ) == 'Z' ) idx_zzz_vec = [ idx_zzz_vec , i ] end do if ( size ( idx_vec ) /= size ( idx_zzz_vec )) error stop 'error: they need to be the same size?' allocate ( imoves_vec ( size ( idx_vec ))) ! for EACH start, find the number of moves that it takes to get to ONE of the ends. do i = 1 , size ( idx_vec ) imoves_vec ( i ) = moves_any_z ( idx_vec ( i ), idx_zzz_vec ) end do ! don't know why this works ¯\\_(ツ)_/¯ ! I think it's a feature of the specific data given ! (it's a repeating cycle once it gets to the end) write ( * , * ) '8b : number of moves: ' , lcm ( lcm ( lcm ( lcm ( lcm ( imoves_vec ( 1 ),& imoves_vec ( 2 )),& imoves_vec ( 3 )),& imoves_vec ( 4 )),& imoves_vec ( 5 )),& imoves_vec ( 6 )) ! ! ! ! brute force. run all the moves in parallel until they are all done. ! ! ! i = 0 ! imoves = 0 ! do !     if (all_in_set(idx_vec, idx_zzz_vec)) exit !     imoves = imoves + 1 ! another move !     i = i + 1 !     if (i>len(instructions)) i = 1 !     do concurrent (j = 1 : size(idx_vec)) !         idx_vec(j) = nodes(idx_vec(j))%lr_idx(instructions_ints(i)) !     end do ! end do ! write(*,*) '8b : number of moves:', imoves call clk % toc ( '8' ) contains pure function moves ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart , iend !! indices for start and end nodes integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( idx == iend ) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves pure function moves_any_z ( istart , iend ) result ( imoves ) integer ( ip ), intent ( in ) :: istart !! indices for start and end nodes integer ( ip ), dimension (:), intent ( in ) :: iend integer ( ip ) :: imoves integer :: i integer ( ip ) :: idx i = 0 imoves = 0 idx = istart do !write(*,*) nodes(idx)%name if ( any ( idx == iend )) exit ! if (idx == istart) write(*,*) 'back to start' imoves = imoves + 1 ! another move i = i + 1 if ( i > len ( instructions )) i = 1 idx = nodes ( idx )% lr_idx ( instructions_ints ( i )) end do end function moves_any_z pure logical function all_in_set ( ivals , iset ) !! returns true if all the elements of ivals are in the set iset integer ( ip ), dimension (:), intent ( in ) :: ivals , iset integer :: i all_in_set = . true . do i = 1 , size ( ivals ) if (. not . any ( ivals ( i ) == iset )) then all_in_set = . false . exit end if end do end function all_in_set pure integer ( ip ) function find_node ( name ) character ( len =* ), intent ( in ) :: name integer ( ip ) :: i do i = 1 , size ( nodes ) if ( name == nodes ( i )% name ) then find_node = i return end if end do error stop 'could not find node' end function find_node end program problem_8","tags":"","loc":"sourcefile/problem_08.f90.html"},{"title":"numerical_differentiation_module.f90 – AoC-2023","text":"This file depends on sourcefile~~numerical_differentiation_module.f90~~EfferentGraph sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~cache_module.f90 cache_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~cache_module.f90 sourcefile~diff_module.f90 diff_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~diff_module.f90 sourcefile~dsm_module.f90 dsm_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~dsm_module.f90 sourcefile~kinds_module.f90 kinds_module.F90 sourcefile~numerical_differentiation_module.f90->sourcefile~kinds_module.f90 sourcefile~utilities_module.f90 utilities_module.f90 sourcefile~numerical_differentiation_module.f90->sourcefile~utilities_module.f90 sourcefile~cache_module.f90->sourcefile~kinds_module.f90 sourcefile~cache_module.f90->sourcefile~utilities_module.f90 sourcefile~diff_module.f90->sourcefile~kinds_module.f90 sourcefile~dsm_module.f90->sourcefile~kinds_module.f90 sourcefile~utilities_module.f90->sourcefile~kinds_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~numerical_differentiation_module.f90~~AfferentGraph sourcefile~numerical_differentiation_module.f90 numerical_differentiation_module.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~numerical_differentiation_module.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~numerical_differentiation_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> author: Jacob Williams !  date: October 29, 2016 ! !  Numerical differentiation module for computing the Jacobian matrix !  (the derivative matrix of `m` functions w.r.t. `n` variables) using !  finite differences. module numerical_differentiation_module use numdiff_kinds_module use numdiff_utilities_module use iso_fortran_env , only : error_unit use dsm_module , only : dsm use diff_module , only : diff_func use numdiff_cache_module , only : function_cache implicit none private real ( wp ), parameter :: zero = 0.0_wp type , public :: finite_diff_method !! defines the finite difference method !! used to compute the Jacobian. !! !! See: [[get_finite_difference_method]] !! for the different methods. private integer :: id = 0 !! unique ID for the method character ( len = :), allocatable :: name !! the name of the method integer :: class = 0 !! 2=backward diffs, 3=central diffs, etc... real ( wp ), dimension (:), allocatable :: dx_factors !! multiplicative factors for `dx` perturbation real ( wp ), dimension (:), allocatable :: df_factors !! multiplicative factors for accumulating function evaluations real ( wp ) :: df_den_factor = zero !! denominator factor for finite difference equation (times `dx`) contains private procedure , public :: get_formula procedure , public :: print => print_finite_difference_method end type finite_diff_method interface finite_diff_method !! constructor module procedure initialize_finite_difference_method end interface type , public :: meth_array !! to store an array of [[finite_diff_method]] types !! this is used when the `mode=2` option is used !! in [[numdiff_type]] private type ( finite_diff_method ), dimension (:), allocatable :: meth end type meth_array type , public :: sparsity_pattern !! A sparsity pattern private logical :: sparsity_computed = . false . !! has the sparsity pattern already been computed? integer :: num_nonzero_elements = 0 !! number of nonzero elements in the jacobian !! (will be the dimension of `irow` and `icol`) integer , dimension (:), allocatable :: irow !! sparsity pattern - rows of non-zero elements integer , dimension (:), allocatable :: icol !! sparsity pattern - columns of non-zero elements logical :: linear_sparsity_computed = . false . !! if the linear pattern has been populated integer :: num_nonzero_linear_elements = 0 !! number of constant elements in the jacobian integer , dimension (:), allocatable :: linear_irow !! linear sparsity pattern - rows of non-zero elements integer , dimension (:), allocatable :: linear_icol !! linear sparsity pattern - columns of non-zero elements real ( wp ), dimension (:), allocatable :: linear_vals !! linear elements of the jacobian integer , dimension (:), allocatable :: indices !! index vector !! `[1,2,...,num_nonzero_elements]` !! for putting `df` into `jac` integer :: maxgrp = 0 !! the number of groups in the partition !! of the columns of `a`. integer , dimension (:), allocatable :: ngrp !! specifies the partition of the columns of `a`. !! column `jcol` belongs to group `ngrp(jcol)`. !! `size(n)` contains private procedure :: dsm_wrapper procedure :: compute_indices procedure , public :: destroy => destroy_sparsity procedure , public :: print => print_sparsity procedure , public :: columns_in_partition_group end type sparsity_pattern type , public :: numdiff_type !! base type for sparsity and Jacobian computations. private logical :: exception_raised = . false . !! if true, an exception has been raised integer :: istat = 0 !! a non-zero value will cause all routine to exit. !! this can be set to `-1` by calling [[terminate]]. character ( len = :), allocatable :: error_msg !! error message (if `istat/=0`) integer :: n = 0 !! number of `x` variables integer :: m = 0 !! number of `f` functions real ( wp ), dimension (:), allocatable :: xlow !! lower bounds on `x` real ( wp ), dimension (:), allocatable :: xhigh !! upper bounds on `x` logical :: print_messages = . true . !! if true, warning messages are printed !! to the `error_unit` for any errors. integer :: chunk_size = 100 !! chuck size for allocating the arrays (>0) integer :: perturb_mode = 1 !! perturbation mode: !! !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` real ( wp ), dimension (:), allocatable :: dpert !! perturbation vector for `x` logical :: partition_sparsity_pattern = . false . !! to partition the sparsity pattern using [[dsm]] type ( sparsity_pattern ) :: sparsity !! the sparsity pattern real ( wp ), dimension (:), allocatable :: xlow_for_sparsity !! lower bounds on `x` for computing sparsity (optional) real ( wp ), dimension (:), allocatable :: xhigh_for_sparsity !! upper bounds on `x` for computing sparsity (optional) real ( wp ), dimension (:), allocatable :: dpert_for_sparsity !! perturbation vector for `x` when computing !! sparsity for `sparsity_mode=4` integer :: num_sparsity_points = 3 !! for `sparsity_mode=4`, the number of jacobian !! evaluations used to estimate the sparsity pattern. !! See [[compute_sparsity_random_2]] integer :: sparsity_perturb_mode = 1 !! perturbation mode (if `sparsity_mode=4`): !! !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` ! if computing the sparsity pattern, we also have an option to ! compute the linear pattern, which indicates constant elements ! of the jacobian. these elements don't need to be computed again. logical :: compute_linear_sparsity_pattern = . false . !! to also compute the linear sparsity pattern real ( wp ) :: linear_sparsity_tol = epsilon ( 1.0_wp ) !! the equality tolerance for derivatives to !! indicate a constant jacobian element (linear sparsity) real ( wp ) :: function_precision_tol = epsilon ( 1.0_wp ) !! the function precision. two functions values !! that are the within this tolerance are !! considered the same value. This is used !! when estimating the sparsity pattern when !! `sparsity_mode=2` in [[compute_sparsity_random]] integer :: mode = 1 !! **1** = use `meth` (specified methods), !! **2** = use `class` (specified class, method is selected on-the-fly). type ( finite_diff_method ), dimension (:), allocatable :: meth !! the finite difference method to use !! compute the `n`th column of the Jacobian !! `size(n)`.  Either this or `class` is used integer , dimension (:), allocatable :: class !! the class of method to use to !! compute the `n`th column of the Jacobian !! `size(n)`. Either this or `meth` is used type ( meth_array ), dimension (:), allocatable :: class_meths !! array of methods for the specified classes. !! used with `class` when `mode=2` ! parameters when using diff: real ( wp ) :: eps = 1.0e-9_wp !! tolerance parameter for [[diff]] real ( wp ) :: acc = 0.0_wp !! tolerance parameter for [[diff]] type ( function_cache ) :: cache !! if using the function cache logical :: use_diff = . false . !! if we are using the Neville's process method, !! rather than finite differences procedure ( func ), pointer :: problem_func => null () !! the user-defined function ! these are required to be defined by the user: procedure ( func ), pointer :: compute_function => null () !! compute the user-defined function !! this can point to the `problem_func` or, if using !! the cache, it points to [[compute_function_with_cache]]. procedure ( spars_f ), pointer :: compute_sparsity => null () !! for computing the sparsity pattern procedure ( info_f ), pointer :: info_function => null () !! an optional function the user can define !! which is called when each column of the jacobian is computed. !! It can be used to perform any setup operations. procedure ( jacobian_f ), pointer :: jacobian_function => null () !! the low-level function called by [[compute_jacobian]] !! that actually computes the jacobian. contains private procedure , public :: initialize => initialize_numdiff !! initialize the class procedure , public :: diff_initialize => initialize_numdiff_for_diff !! initialize the class procedure , public :: compute_jacobian !! main routine to compute the Jacobian !! using the selected options. It !! returns the sparse (vector) form. procedure , public :: compute_jacobian_dense !! return the dense `size(m,n)` !! matrix form of the Jacobian. procedure , public :: compute_jacobian_times_vector !! returns the product of the Jacobian !! matrix and an input vector procedure , public :: destroy => destroy_numdiff_type !! destroy the class procedure , public :: print_sparsity_pattern !! print the sparsity pattern in vector form to a file procedure , public :: print_sparsity_matrix !! print the sparsity pattern in matrix form to a file procedure , public :: set_sparsity_pattern !! manually set the sparsity pattern procedure , public :: select_finite_diff_method !! select a method in a specified class so !! that the variable bounds are not violated !! when by the perturbations. procedure , public :: select_finite_diff_method_for_partition_group !! version of [[select_finite_diff_method]] !! for partitioned sparsity pattern. procedure , public :: set_numdiff_bounds !! can be called to change the variable bounds. procedure , public :: compute_sparsity_pattern !! if the user needs to compute the sparsity pattern manually. !! (otherwise it will be done the first time the Jacobian is computed) procedure , public :: get_sparsity_pattern !! returns the sparsity pattern (if it is allocated) procedure , public :: terminate !! can be called by user to stop the computation procedure , public :: failed !! to check if an exception was raised. procedure , public :: get_error_status !! the status of error condition ! internal routines: procedure :: destroy_sparsity_pattern !! destroy the sparsity pattern procedure :: compute_perturb_vector procedure :: compute_perturbation_vector !! computes the variable perturbation factor procedure :: compute_sparsity_perturbation_vector procedure :: perturb_x_and_compute_f procedure :: perturb_x_and_compute_f_partitioned procedure :: set_numdiff_sparsity_bounds procedure :: set_sparsity_mode procedure :: generate_dense_sparsity_partition procedure :: compute_jacobian_for_sparsity procedure :: resize_sparsity_vectors procedure :: raise_exception procedure :: clear_exceptions end type numdiff_type abstract interface subroutine func ( me , x , f , funcs_to_compute ) !! The function (vector array of output functions `f`, computed !! from a vector of input variables `x`). !! This must be defined for all computations. import :: numdiff_type , wp implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! array of variables (size `n`) real ( wp ), dimension (:), intent ( out ) :: f !! array of functions (size `m`) integer , dimension (:), intent ( in ) :: funcs_to_compute !! the elements of the !! function vector that need !! to be computed (the other !! are ignored) end subroutine func subroutine spars_f ( me , x ) !! The function to compute the sparsity pattern. !! It populates the `irow` and `icol` variables in the class. import :: numdiff_type , wp implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) end subroutine spars_f subroutine info_f ( me , column , i , x ) !! User-defined info function (optional). !! Informs user what is being done during Jacobian computation. !! It can be used to perform any setup operations that need to !! done on the user's end. import :: numdiff_type , wp implicit none class ( numdiff_type ), intent ( inout ) :: me integer , dimension (:), intent ( in ) :: column !! the columns being computed. integer , intent ( in ) :: i !! perturbing these columns for the `i`th time (1,2,...) real ( wp ), dimension (:), intent ( in ) :: x !! the nominal variable vector end subroutine info_f subroutine jacobian_f ( me , x , dx , jac ) !! Actual function for computing the Jacobian !! called by [[compute_jacobian]]. import :: numdiff_type , wp implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector (size `num_nonzero_elements`) end subroutine jacobian_f end interface ! other: public :: get_finite_diff_formula public :: get_all_methods_in_class contains !******************************************************************************* !******************************************************************************* !> !  Constructor for a [[finite_diff_method]]. ! !@note factors are input as integers for convenience, but are converted !      to reals for the actual computations. (note: this means we can't !      currently define methods that have non-integer factors). function initialize_finite_difference_method ( id , name , class , dx_factors ,& df_factors , df_den_factor ) result ( me ) implicit none type ( finite_diff_method ) :: me integer , intent ( in ) :: id !! unique ID for the method character ( len =* ), intent ( in ) :: name !! the name of the method integer , intent ( in ) :: class !! 2=backward diffs, 3=central diffs, etc... integer , dimension (:), intent ( in ) :: dx_factors !! multiplicative factors for dx perturbation integer , dimension (:), intent ( in ) :: df_factors !! multiplicative factors for accumulating function evaluations integer , intent ( in ) :: df_den_factor !! denominator factor for finite difference equation (times dx) if ( size ( dx_factors ) /= size ( df_factors )) then error stop 'Error in initialize_finite_difference_method: ' // & 'dx_factors and df_factors arrays must be the same size.' else me % id = id me % name = trim ( name ) me % class = class ! the following is not strictly necessary if the ! compiler fully supports auto-LHS allocation: allocate ( me % dx_factors ( size ( dx_factors ))) allocate ( me % df_factors ( size ( df_factors ))) me % dx_factors = real ( dx_factors , wp ) me % df_factors = real ( df_factors , wp ) me % df_den_factor = real ( df_den_factor , wp ) end if end function initialize_finite_difference_method !******************************************************************************* !******************************************************************************* !> !  Print the contents of a [[finite_diff_method]]. Used for debugging. subroutine print_finite_difference_method ( me , iunit ) implicit none class ( finite_diff_method ), intent ( in ) :: me integer , intent ( in ) :: iunit !! file unit for printing !! (assumed to be opened) write ( iunit , '(A,1X,I5)' ) 'id            :' , me % id write ( iunit , '(A,1X,A)' ) 'name          :' , me % name write ( iunit , '(A,1X,I5)' ) 'class         :' , me % class write ( iunit , '(A,1X,*(I5,\",\"))' ) 'dx_factors    :' , int ( me % dx_factors ) write ( iunit , '(A,1X,*(I5,\",\"))' ) 'df_factors    :' , int ( me % df_factors ) write ( iunit , '(A,1X,I5)' ) 'df_den_factor :' , int ( me % df_den_factor ) end subroutine print_finite_difference_method !******************************************************************************* !******************************************************************************* !> !  Wrapper for computing the function, using the cache. subroutine compute_function_with_cache ( me , x , f , funcs_to_compute ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! array of variables (size `n`) real ( wp ), dimension (:), intent ( out ) :: f !! array of functions (size `m`) integer , dimension (:), intent ( in ) :: funcs_to_compute !! the elements of the !! function vector that need !! to be computed (the other !! are ignored) integer :: i !! index in the cache logical , dimension ( size ( funcs_to_compute )) :: ffound !! functions found in the cache logical :: xfound !! if `x` was found in the cache if ( me % exception_raised ) return ! check for exceptions call me % cache % get ( x , funcs_to_compute , i , f , xfound , ffound ) if ( xfound . and . any ( ffound )) then ! at least one of the functions was found if ( all ( ffound )) return ! all were found ! compute the ones that weren't found, ! and add them to the cache: call me % problem_func ( x , f , pack ( funcs_to_compute , mask = (. not . ffound ))) call me % cache % put ( i , x , f , pack ( funcs_to_compute , mask = (. not . ffound ))) else ! compute the function and add it to the cache: call me % problem_func ( x , f , funcs_to_compute ) call me % cache % put ( i , x , f , funcs_to_compute ) end if end subroutine compute_function_with_cache !******************************************************************************* !******************************************************************************* !> !  Return a string with the finite difference formula. ! !### Example !  * For 3-point backward: `dfdx = (f(x-2h)-4f(x-h)+3f(x)) / (2h)` subroutine get_formula ( me , formula ) class ( finite_diff_method ), intent ( in ) :: me character ( len = :), allocatable , intent ( out ) :: formula integer :: i !! counter character ( len = :), allocatable :: x !! temp variable for integer to string conversion character ( len = :), allocatable :: f !! temp variable for integer to string conversion if ( allocated ( me % dx_factors ) . and . allocated ( me % df_factors )) then formula = 'dfdx = (' do i = 1 , size ( me % dx_factors ) if ( int ( me % df_factors ( i )) == 1 ) then if ( i == 1 ) then formula = formula // 'f(' else formula = formula // '+f(' end if elseif ( int ( me % df_factors ( i )) ==- 1 ) then formula = formula // '-f(' else if ( i == 1 ) then f = integer_to_string ( int ( me % df_factors ( i ))) else f = integer_to_string ( int ( me % df_factors ( i )), with_sign = . true .) end if formula = formula // trim ( adjustl ( f )) // 'f(' end if if ( int ( me % dx_factors ( i )) == 0 ) then formula = formula // 'x' elseif ( int ( me % dx_factors ( i )) == 1 ) then formula = formula // 'x+h' elseif ( int ( me % dx_factors ( i )) ==- 1 ) then formula = formula // 'x-h' else x = integer_to_string ( int ( me % dx_factors ( i )), with_sign = . true .) formula = formula // 'x' // trim ( adjustl ( x )) // 'h' end if formula = formula // ')' end do f = integer_to_string ( int ( me % df_den_factor )) if ( int ( me % df_den_factor ) == 1 ) then formula = formula // ') / h' else formula = formula // ') / (' // trim ( adjustl ( f )) // 'h)' end if else formula = '' end if end subroutine get_formula !******************************************************************************* !******************************************************************************* !> !  Return a string with the finite difference formula. !  Input is the method `id` code. ! !###See also: !  * [[get_formula]] subroutine get_finite_diff_formula ( id , formula , name ) implicit none integer , intent ( in ) :: id !! the id code for the method character ( len = :), allocatable , intent ( out ) :: formula !! the formula string character ( len = :), allocatable , intent ( out ), optional :: name type ( finite_diff_method ) :: fd logical :: found call get_finite_difference_method ( id , fd , found ) if ( found . and . fd % id /= 0 ) then call get_formula ( fd , formula ) if ( present ( name )) name = fd % name else formula = '' if ( present ( name )) name = '' end if end subroutine get_finite_diff_formula !******************************************************************************* !******************************************************************************* !> !  Return a [[finite_diff_method]] given the `id` code. !  (the `id` codes begin at 1, are sequential, and uniquely define the method). ! !### Available methods ! !   *  (f(x+h)-f(x)) / h  !   *  (f(x)-f(x-h)) / h  !   *  (f(x+h)-f(x-h)) / (2h)  !   *  (-3f(x)+4f(x+h)-f(x+2h)) / (2h)  !   *  (f(x-2h)-4f(x-h)+3f(x)) / (2h)  !   *  (-2f(x-h)-3f(x)+6f(x+h)-f(x+2h)) / (6h)  !   *  (f(x-2h)-6f(x-h)+3f(x)+2f(x+h)) / (6h)  !   *  (-11f(x)+18f(x+h)-9f(x+2h)+2f(x+3h)) / (6h)  !   *  (-2f(x-3h)+9f(x-2h)-18f(x-h)+11f(x)) / (6h)  !   *  (f(x-2h)-8f(x-h)+8f(x+h)-f(x+2h)) / (12h)  !   *  (-3f(x-h)-10f(x)+18f(x+h)-6f(x+2h)+f(x+3h)) / (12h)  !   *  (-f(x-3h)+6f(x-2h)-18f(x-h)+10f(x)+3f(x+h)) / (12h)  !   *  (-25f(x)+48f(x+h)-36f(x+2h)+16f(x+3h)-3f(x+4h)) / (12h)  !   *  (3f(x-4h)-16f(x-3h)+36f(x-2h)-48f(x-h)+25f(x)) / (12h)  !   *  (3f(x-2h)-30f(x-h)-20f(x)+60f(x+h)-15f(x+2h)+2f(x+3h)) / (60h)  !   *  (-2f(x-3h)+15f(x-2h)-60f(x-h)+20f(x)+30f(x+h)-3f(x+2h)) / (60h)  !   *  (-12f(x-h)-65f(x)+120f(x+h)-60f(x+2h)+20f(x+3h)-3f(x+4h)) / (60h)  !   *  (3f(x-4h)-20f(x-3h)+60f(x-2h)-120f(x-h)+65f(x)+12f(x+h)) / (60h)  !   *  (-137f(x)+300f(x+h)-300f(x+2h)+200f(x+3h)-75f(x+4h)+12f(x+5h)) / (60h)  !   *  (-12f(x-5h)+75f(x-4h)-200f(x-3h)+300f(x-2h)-300f(x-h)+137f(x)) / (60h)  !   *  (-f(x-3h)+9f(x-2h)-45f(x-h)+45f(x+h)-9f(x+2h)+f(x+3h)) / (60h)  !   *  (2f(x-2h)-24f(x-h)-35f(x)+80f(x+h)-30f(x+2h)+8f(x+3h)-f(x+4h)) / (60h)  !   *  (f(x-4h)-8f(x-3h)+30f(x-2h)-80f(x-h)+35f(x)+24f(x+h)-2f(x+2h)) / (60h)  !   *  (-10f(x-h)-77f(x)+150f(x+h)-100f(x+2h)+50f(x+3h)-15f(x+4h)+2f(x+5h)) / (60h)  !   *  (-2f(x-5h)+15f(x-4h)-50f(x-3h)+100f(x-2h)-150f(x-h)+77f(x)+10f(x+h)) / (60h)  !   *  (-147f(x)+360f(x+h)-450f(x+2h)+400f(x+3h)-225f(x+4h)+72f(x+5h)-10f(x+6h)) / (60h)  !   *  (10f(x-6h)-72f(x-5h)+225f(x-4h)-400f(x-3h)+450f(x-2h)-360f(x-h)+147f(x)) / (60h)  !   *  (-4f(x-3h)+42f(x-2h)-252f(x-h)-105f(x)+420f(x+h)-126f(x+2h)+28f(x+3h)-3f(x+4h)) / (420h)  !   *  (3f(x-4h)-28f(x-3h)+126f(x-2h)-420f(x-h)+105f(x)+252f(x+h)-42f(x+2h)+4f(x+3h)) / (420h)  !   *  (10f(x-2h)-140f(x-h)-329f(x)+700f(x+h)-350f(x+2h)+140f(x+3h)-35f(x+4h)+4f(x+5h)) / (420h)  !   *  (-4f(x-5h)+35f(x-4h)-140f(x-3h)+350f(x-2h)-700f(x-h)+329f(x)+140f(x+h)-10f(x+2h)) / (420h)  !   *  (-60f(x-h)-609f(x)+1260f(x+h)-1050f(x+2h)+700f(x+3h)-315f(x+4h)+84f(x+5h)-10f(x+6h)) / (420h)  !   *  (10f(x-6h)-84f(x-5h)+315f(x-4h)-700f(x-3h)+1050f(x-2h)-1260f(x-h)+609f(x)+60f(x+h)) / (420h)  !   *  (-1089f(x)+2940f(x+h)-4410f(x+2h)+4900f(x+3h)-3675f(x+4h)+1764f(x+5h)-490f(x+6h)+60f(x+7h)) / (420h)  !   *  (-60f(x-7h)+490f(x-6h)-1764f(x-5h)+3675f(x-4h)-4900f(x-3h)+4410f(x-2h)-2940f(x-h)+1089f(x)) / (420h)  !   *  (3f(x-4h)-32f(x-3h)+168f(x-2h)-672f(x-h)+672f(x+h)-168f(x+2h)+32f(x+3h)-3f(x+4h)) / (840h)  !   *  (-5f(x-3h)+60f(x-2h)-420f(x-h)-378f(x)+1050f(x+h)-420f(x+2h)+140f(x+3h)-30f(x+4h)+3f(x+5h)) / (840h)  !   *  (-3f(x-5h)+30f(x-4h)-140f(x-3h)+420f(x-2h)-1050f(x-h)+378f(x)+420f(x+h)-60f(x+2h)+5f(x+3h)) / (840h)  !   *  (15f(x-2h)-240f(x-h)-798f(x)+1680f(x+h)-1050f(x+2h)+560f(x+3h)-210f(x+4h)+48f(x+5h)-5f(x+6h)) / (840h)  !   *  (5f(x-6h)-48f(x-5h)+210f(x-4h)-560f(x-3h)+1050f(x-2h)-1680f(x-h)+798f(x)+240f(x+h)-15f(x+2h)) / (840h)  !   *  (-105f(x-h)-1338f(x)+2940f(x+h)-2940f(x+2h)+2450f(x+3h)-1470f(x+4h)+588f(x+5h)-140f(x+6h)+15f(x+7h)) / (840h)  !   *  (-15f(x-7h)+140f(x-6h)-588f(x-5h)+1470f(x-4h)-2450f(x-3h)+2940f(x-2h)-2940f(x-h)+1338f(x)+105f(x+h)) / (840h)  !   *  (-2283f(x)+6720f(x+h)-11760f(x+2h)+15680f(x+3h)-14700f(x+4h)+9408f(x+5h)-3920f(x+6h)+960f(x+7h)-105f(x+8h)) / (840h)  !   *  (105f(x-8h)-960f(x-7h)+3920f(x-6h)-9408f(x-5h)+14700f(x-4h)-15680f(x-3h)+11760f(x-2h)-6720f(x-h)+2283f(x)) / (840h)  !   *  (-2f(x-5h)+25f(x-4h)-150f(x-3h)+600f(x-2h)-2100f(x-h)+2100f(x+h)-600f(x+2h)+150f(x+3h)-25f(x+4h)+2f(x+5h)) / (2520h)  !   *  (5f(x-6h)-72f(x-5h)+495f(x-4h)-2200f(x-3h)+7425f(x-2h)-23760f(x-h)+23760f(x+h)-7425f(x+2h)+2200f(x+3h)-495f(x+4h)+ !        72f(x+5h)-5f(x+6h)) / (27720h)  !   *  (-15f(x-7h)+245f(x-6h)-1911f(x-5h)+9555f(x-4h)-35035f(x-3h)+105105f(x-2h)-315315f(x-h)+315315f(x+h)-105105f(x+2h)+ !        35035f(x+3h)-9555f(x+4h)+1911f(x+5h)-245f(x+6h)+15f(x+7h)) / (360360h)  !   *  (7f(x-8h)-128f(x-7h)+1120f(x-6h)-6272f(x-5h)+25480f(x-4h)-81536f(x-3h)+224224f(x-2h)-640640f(x-h)+640640f(x+h)- !        224224f(x+2h)+81536f(x+3h)-25480f(x+4h)+6272f(x+5h)-1120f(x+6h)+128f(x+7h)-7f(x+8h)) / (720720h)  ! !  Where f(x) is the user-defined function of x !  and h is a \"small\" perturbation. ! !### References !  * G. E. Mullges, F. Uhlig, \"Numerical Algorithms with Fortran\", Springer, 1996. !  * G. W. Griffiths, \"Numerical Analysis Using R\", Cambridge University Press, 2016. ! !@note This is the only routine that has to be changed if a new !      finite difference method is added. ! !@note The order within a class is assumed to be the order that we would prefer !      to use them (e.g., central diffs are first, etc.) This is used in !      the [[select_finite_diff_method]] routine. subroutine get_finite_difference_method ( id , fd , found ) implicit none integer , intent ( in ) :: id !! the id code for the method type ( finite_diff_method ), intent ( out ) :: fd !! this method (can be used !! in [[compute_jacobian]]) logical , intent ( out ) :: found !! true if it was found found = . true . select case ( id ) ! 2 point methods case ( 1 ) ! (f(x+h)-f(x)) / h fd = finite_diff_method ( id , '2-point forward 1' , 2 ,[ 1 , 0 ],[ 1 , - 1 ], 1 ) case ( 2 ) ! (f(x)-f(x-h)) / h fd = finite_diff_method ( id , '2-point backward 1' , 2 ,[ 0 , - 1 ],[ 1 , - 1 ], 1 ) ! 3 point methods case ( 3 ) ! (f(x+h)-f(x-h)) / (2h) fd = finite_diff_method ( id , '3-point central' , 3 ,[ 1 , - 1 ],[ 1 , - 1 ], 2 ) case ( 4 ) ! (-3f(x)+4f(x+h)-f(x+2h)) / (2h) fd = finite_diff_method ( id , '3-point forward 2' , 3 ,[ 0 , 1 , 2 ],[ - 3 , 4 , - 1 ], 2 ) case ( 5 ) ! (f(x-2h)-4f(x-h)+3f(x)) / (2h) fd = finite_diff_method ( id , '3-point backward 2' , 3 ,[ - 2 , - 1 , 0 ],[ 1 , - 4 , 3 ], 2 ) ! 4 point methods case ( 6 ) ! (-2f(x-h)-3f(x)+6f(x+h)-f(x+2h)) / (6h) fd = finite_diff_method ( id , '4-point forward 2' , 4 ,[ - 1 , 0 , 1 , 2 ],[ - 2 , - 3 , 6 , - 1 ], 6 ) case ( 7 ) ! (f(x-2h)-6f(x-h)+3f(x)+2f(x+h)) / (6h) fd = finite_diff_method ( id , '4-point backward 2' , 4 ,[ - 2 , - 1 , 0 , 1 ],[ 1 , - 6 , 3 , 2 ], 6 ) case ( 8 ) ! (-11f(x)+18f(x+h)-9f(x+2h)+2f(x+3h)) / (6h) fd = finite_diff_method ( id , '4-point forward 3' , 4 ,[ 0 , 1 , 2 , 3 ],[ - 11 , 18 , - 9 , 2 ], 6 ) case ( 9 ) ! (-2f(x-3h)+9f(x-2h)-18f(x-h)+11f(x)) / (6h) fd = finite_diff_method ( id , '4-point backward 3' , 4 ,[ - 3 , - 2 , - 1 , 0 ],[ - 2 , 9 , - 18 , 11 ], 6 ) ! 5 point methods case ( 10 ) ! (f(x-2h)-8f(x-h)+8f(x+h)-f(x+2h)) / (12h) fd = finite_diff_method ( id , '5-point central' , 5 ,[ - 2 , - 1 , 1 , 2 ],[ 1 , - 8 , 8 , - 1 ], 12 ) case ( 11 ) ! (-3f(x-h)-10f(x)+18f(x+h)-6f(x+2h)+f(x+3h)) / (12h) fd = finite_diff_method ( id , '5-point forward 3' , 5 ,[ - 1 , 0 , 1 , 2 , 3 ],[ - 3 , - 10 , 18 , - 6 , 1 ], 12 ) case ( 12 ) ! (-f(x-3h)+6f(x-2h)-18f(x-h)+10f(x)+3f(x+h)) / (12h) fd = finite_diff_method ( id , '5-point backward 3' , 5 ,[ - 3 , - 2 , - 1 , 0 , 1 ],[ - 1 , 6 , - 18 , 10 , 3 ], 12 ) case ( 13 ) ! (-25f(x)+48f(x+h)-36f(x+2h)+16f(x+3h)-3f(x+4h)) / (12h) fd = finite_diff_method ( id , '5-point forward 4' , 5 ,[ 0 , 1 , 2 , 3 , 4 ],[ - 25 , 48 , - 36 , 16 , - 3 ], 12 ) case ( 14 ) ! (3f(x-4h)-16f(x-3h)+36f(x-2h)-48f(x-h)+25f(x)) / (12h) fd = finite_diff_method ( id , '5-point backward 4' , 5 ,[ - 4 , - 3 , - 2 , - 1 , 0 ],[ 3 , - 16 , 36 , - 48 , 25 ], 12 ) ! 6 point methods case ( 15 ) ! (3f(x-2h)-30f(x-h)-20f(x)+60f(x+h)-15f(x+2h)+2f(x+3h)) / (60h) fd = finite_diff_method ( id , '6-point forward 3' , 6 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 ],[ 3 , - 30 , - 20 , 60 , - 15 , 2 ], 60 ) case ( 16 ) ! (-2f(x-3h)+15f(x-2h)-60f(x-h)+20f(x)+30f(x+h)-3f(x+2h)) / (60h) fd = finite_diff_method ( id , '6-point backward 3' , 6 ,[ - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ - 2 , 15 , - 60 , 20 , 30 , - 3 ], 60 ) case ( 17 ) ! (-12f(x-h)-65f(x)+120f(x+h)-60f(x+2h)+20f(x+3h)-3f(x+4h)) / (60h) fd = finite_diff_method ( id , '6-point forward 4' , 6 ,[ - 1 , 0 , 1 , 2 , 3 , 4 ],[ - 12 , - 65 , 120 , - 60 , 20 , - 3 ], 60 ) case ( 18 ) ! (3f(x-4h)-20f(x-3h)+60f(x-2h)-120f(x-h)+65f(x)+12f(x+h)) / (60h) fd = finite_diff_method ( id , '6-point backward 4' , 6 ,[ - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ 3 , - 20 , 60 , - 120 , 65 , 12 ], 60 ) case ( 19 ) ! (-137f(x)+300f(x+h)-300f(x+2h)+200f(x+3h)-75f(x+4h)+12f(x+5h)) / (60h) fd = finite_diff_method ( id , '6-point forward 5' , 6 ,[ 0 , 1 , 2 , 3 , 4 , 5 ],[ - 137 , 300 , - 300 , 200 , - 75 , 12 ], 60 ) case ( 20 ) ! (-12f(x-5h)+75f(x-4h)-200f(x-3h)+300f(x-2h)-300f(x-h)+137f(x)) / (60h) fd = finite_diff_method ( id , '6-point backward 5' , 6 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ - 12 , 75 , - 200 , 300 , - 300 , 137 ], 60 ) ! 7 point methods case ( 21 ) ! (-f(x-3h)+9f(x-2h)-45f(x-h)+45f(x+h)-9f(x+2h)+f(x+3h)) / (60h) fd = finite_diff_method ( id , '7-point central' , 7 ,[ - 3 , - 2 , - 1 , 1 , 2 , 3 ],[ - 1 , 9 , - 45 , 45 , - 9 , 1 ], 60 ) case ( 22 ) ! (2f(x-2h)-24f(x-h)-35f(x)+80f(x+h)-30f(x+2h)+8f(x+3h)-f(x+4h)) / (60h) fd = finite_diff_method ( id , '7-point forward 4' , 7 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 , 4 ],[ 2 , - 24 , - 35 , 80 , - 30 , 8 , - 1 ], 60 ) case ( 23 ) ! (f(x-4h)-8f(x-3h)+30f(x-2h)-80f(x-h)+35f(x)+24f(x+h)-2f(x+2h)) / (60h) fd = finite_diff_method ( id , '7-point backward 4' , 7 ,[ - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ 1 , - 8 , 30 , - 80 , 35 , 24 , - 2 ], 60 ) case ( 24 ) ! (-10f(x-h)-77f(x)+150f(x+h)-100f(x+2h)+50f(x+3h)-15f(x+4h)+2f(x+5h)) / (60h) fd = finite_diff_method ( id , '7-point forward 5' , 7 ,[ - 1 , 0 , 1 , 2 , 3 , 4 , 5 ],[ - 10 , - 77 , 150 , - 100 , 50 , - 15 , 2 ], 60 ) case ( 25 ) ! (-2f(x-5h)+15f(x-4h)-50f(x-3h)+100f(x-2h)-150f(x-h)+77f(x)+10f(x+h)) / (60h) fd = finite_diff_method ( id , '7-point backward 5' , 7 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ - 2 , 15 , - 50 , 100 , - 150 , 77 , 10 ], 60 ) case ( 26 ) ! (-147f(x)+360f(x+h)-450f(x+2h)+400f(x+3h)-225f(x+4h)+72f(x+5h)-10f(x+6h)) / (60h) fd = finite_diff_method ( id , '7-point forward 6' , 7 ,[ 0 , 1 , 2 , 3 , 4 , 5 , 6 ],[ - 147 , 360 , - 450 , 400 , - 225 , 72 , - 10 ], 60 ) case ( 27 ) ! (10f(x-6h)-72f(x-5h)+225f(x-4h)-400f(x-3h)+450f(x-2h)-360f(x-h)+147f(x)) / (60h) fd = finite_diff_method ( id , '7-point backward 6' , 7 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ 10 , - 72 , 225 , - 400 , 450 , - 360 , 147 ], 60 ) ! 8 point methods case ( 28 ) ! (-4f(x-3h)+42f(x-2h)-252f(x-h)-105f(x)+420f(x+h)-126f(x+2h)+28f(x+3h)-3f(x+4h)) / (420h) fd = finite_diff_method ( id , '8-point forward 4' , 8 ,[ - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 , 4 ],[ - 4 , 42 , - 252 , - 105 , 420 , - 126 , 28 , - 3 ], 420 ) case ( 29 ) ! (3f(x-4h)-28f(x-3h)+126f(x-2h)-420f(x-h)+105f(x)+252f(x+h)-42f(x+2h)+4f(x+3h)) / (420h) fd = finite_diff_method ( id , '8-point backward 4' , 8 ,[ - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 ],[ 3 , - 28 , 126 , - 420 , 105 , 252 , - 42 , 4 ], 420 ) case ( 30 ) ! (10f(x-2h)-140f(x-h)-329f(x)+700f(x+h)-350f(x+2h)+140f(x+3h)-35f(x+4h)+4f(x+5h)) / (420h) fd = finite_diff_method ( id , '8-point forward 5' , 8 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 ],[ 10 , - 140 , - 329 , 700 , - 350 , 140 , - 35 , 4 ], 420 ) case ( 31 ) ! (-4f(x-5h)+35f(x-4h)-140f(x-3h)+350f(x-2h)-700f(x-h)+329f(x)+140f(x+h)-10f(x+2h)) / (420h) fd = finite_diff_method ( id , '8-point backward 5' , 8 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ - 4 , 35 , - 140 , 350 , - 700 , 329 , 140 , - 10 ], 420 ) case ( 32 ) ! (-60f(x-h)-609f(x)+1260f(x+h)-1050f(x+2h)+700f(x+3h)-315f(x+4h)+84f(x+5h)-10f(x+6h)) / (420h) fd = finite_diff_method ( id , '8-point forward 6' , 8 ,[ - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 ],[ - 60 , - 609 , 1260 , - 1050 , 700 , - 315 , 84 , - 10 ], 420 ) case ( 33 ) ! (10f(x-6h)-84f(x-5h)+315f(x-4h)-700f(x-3h)+1050f(x-2h)-1260f(x-h)+609f(x)+60f(x+h)) / (420h) fd = finite_diff_method ( id , '8-point backward 6' , 8 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ 10 , - 84 , 315 , - 700 , 1050 , - 1260 , 609 , 60 ], 420 ) case ( 34 ) ! (-1089f(x)+2940f(x+h)-4410f(x+2h)+4900f(x+3h)-3675f(x+4h)+1764f(x+5h)-490f(x+6h)+60f(x+7h)) / (420h) fd = finite_diff_method ( id , '8-point forward 7' , 8 ,[ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ],[ - 1089 , 2940 , - 4410 , 4900 , - 3675 , 1764 , - 490 , 60 ], 420 ) case ( 35 ) ! (-60f(x-7h)+490f(x-6h)-1764f(x-5h)+3675f(x-4h)-4900f(x-3h)+4410f(x-2h)-2940f(x-h)+1089f(x)) / (420h) fd = finite_diff_method ( id , '8-point backward 7' , 8 ,[ - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ - 60 , 490 , - 1764 , 3675 , - 4900 , 4410 , - 2940 , 1089 ], 420 ) ! 9 point methods case ( 36 ) ! (3f(x-4h)-32f(x-3h)+168f(x-2h)-672f(x-h)+672f(x+h)-168f(x+2h)+32f(x+3h)-3f(x+4h)) / (840h) fd = finite_diff_method ( id , '9-point central' , & 9 ,[ - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 ],[ 3 , - 32 , 168 , - 672 , 672 , - 168 , 32 , - 3 ], 840 ) case ( 37 ) ! (-5f(x-3h)+60f(x-2h)-420f(x-h)-378f(x)+1050f(x+h)-420f(x+2h)+140f(x+3h)-30f(x+4h)+3f(x+5h)) / (840h) fd = finite_diff_method ( id , '9-point forward 5' , & 9 ,[ - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 ],[ - 5 , 60 , - 420 , - 378 , 1050 , - 420 , 140 , - 30 , 3 ], 840 ) case ( 38 ) ! (-3f(x-5h)+30f(x-4h)-140f(x-3h)+420f(x-2h)-1050f(x-h)+378f(x)+420f(x+h)-60f(x+2h)+5f(x+3h)) / (840h) fd = finite_diff_method ( id , '9-point backward 5' , & 9 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 ],[ - 3 , 30 , - 140 , 420 , - 1050 , 378 , 420 , - 60 , 5 ], 840 ) case ( 39 ) ! (15f(x-2h)-240f(x-h)-798f(x)+1680f(x+h)-1050f(x+2h)+560f(x+3h)-210f(x+4h)+48f(x+5h)-5f(x+6h)) / (840h) fd = finite_diff_method ( id , '9-point forward 6' , & 9 ,[ - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 ],[ 15 , - 240 , - 798 , 1680 , - 1050 , 560 , - 210 , 48 , - 5 ], 840 ) case ( 40 ) ! (5f(x-6h)-48f(x-5h)+210f(x-4h)-560f(x-3h)+1050f(x-2h)-1680f(x-h)+798f(x)+240f(x+h)-15f(x+2h)) / (840h) fd = finite_diff_method ( id , '9-point backward 6' , & 9 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 ],[ 5 , - 48 , 210 , - 560 , 1050 , - 1680 , 798 , 240 , - 15 ], 840 ) case ( 41 ) ! (-105f(x-h)-1338f(x)+2940f(x+h)-2940f(x+2h)+2450f(x+3h)-1470f(x+4h)+588f(x+5h)-140f(x+6h)+15f(x+7h)) / (840h) fd = finite_diff_method ( id , '9-point forward 7' , & 9 ,[ - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ],[ - 105 , - 1338 , 2940 , - 2940 , 2450 , - 1470 , 588 , - 140 , 15 ], 840 ) case ( 42 ) ! (-15f(x-7h)+140f(x-6h)-588f(x-5h)+1470f(x-4h)-2450f(x-3h)+2940f(x-2h)-2940f(x-h)+1338f(x)+105f(x+h)) / (840h) fd = finite_diff_method ( id , '9-point backward 7' , & 9 ,[ - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 ],[ - 15 , 140 , - 588 , 1470 , - 2450 , 2940 , - 2940 , 1338 , 105 ], 840 ) case ( 43 ) ! (-2283f(x)+6720f(x+h)-11760f(x+2h)+15680f(x+3h)-14700f(x+4h)+9408f(x+5h)-3920f(x+6h)+960f(x+7h)-105f(x+8h)) / (840h) fd = finite_diff_method ( id , '9-point forward 8' , & 9 ,[ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ],[ - 2283 , 6720 , - 11760 , 15680 , - 14700 , 9408 , - 3920 , 960 , - 105 ], 840 ) case ( 44 ) ! (105f(x-8h)-960f(x-7h)+3920f(x-6h)-9408f(x-5h)+14700f(x-4h)-15680f(x-3h)+11760f(x-2h)-6720f(x-h)+2283f(x)) / (840h) fd = finite_diff_method ( id , '9-point backward 8' , & 9 ,[ - 8 , - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ],[ 105 , - 960 , 3920 , - 9408 , 14700 , - 15680 , 11760 , - 6720 , 2283 ], 840 ) ! 11 point methods case ( 500 ) ! (-2f(x-5h)+25f(x-4h)-150f(x-3h)+600f(x-2h)-2100f(x-h)+2100f(x+h)-600f(x+2h)+150f(x+3h)-25f(x+4h)+2f(x+5h)) / (2520h) fd = finite_diff_method ( id , '11-point central' , & 11 ,[ - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 ],[ - 2 , 25 , - 150 , 600 , - 2100 , 2100 , - 600 , 150 , - 25 , 2 ], 2520 ) ! 13 point methods case ( 600 ) ! (5f(x-6h)-72f(x-5h)+495f(x-4h)-2200f(x-3h)+7425f(x-2h)-23760f(x-h)+23760f(x+h)-7425f(x+2h)+2200f(x+3h)-495f(x+4h)+72f(x+5h)-5f(x+6h)) / (27720h) fd = finite_diff_method ( id , '13-point central' , & 13 ,[ - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 , 6 ],& [ 5 , - 72 , 495 , - 2200 , 7425 , - 23760 , 23760 , - 7425 , 2200 , - 495 , 72 , - 5 ], 27720 ) ! 15 point methods case ( 700 ) ! (-15f(x-7h)+245f(x-6h)-1911f(x-5h)+9555f(x-4h)-35035f(x-3h)+105105f(x-2h)-315315f(x-h)+315315f(x+h)-105105f(x+2h)+35035f(x+3h)-9555f(x+4h)+1911f(x+5h)-245f(x+6h)+15f(x+7h)) / (360360h) fd = finite_diff_method ( id , '15-point central' , & 15 ,[ - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ],& [ - 15 , 245 , - 1911 , 9555 , - 35035 , 105105 , - 315315 , 315315 , - 105105 , 35035 , - 9555 , 1911 , - 245 , 15 ], 360360 ) ! 17 point methods case ( 800 ) ! (7f(x-8h)-128f(x-7h)+1120f(x-6h)-6272f(x-5h)+25480f(x-4h)-81536f(x-3h)+224224f(x-2h)-640640f(x-h)+640640f(x+h)-224224f(x+2h)+81536f(x+3h)-25480f(x+4h)+6272f(x+5h)-1120f(x+6h)+128f(x+7h)-7f(x+8h)) / (720720h) fd = finite_diff_method ( id , '17-point central' , & 17 ,[ - 8 , - 7 , - 6 , - 5 , - 4 , - 3 , - 2 , - 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ],& [ 7 , - 128 , 1120 , - 6272 , 25480 , - 81536 , 224224 , - 640640 , 640640 , - 224224 , 81536 , - 25480 , 6272 , - 1120 , 128 , - 7 ], 720720 ) case default found = . false . end select end subroutine get_finite_difference_method !******************************************************************************* !******************************************************************************* !> !  Returns all the methods with the given `class` !  (i.e., number of points in the formula). function get_all_methods_in_class ( class ) result ( list_of_methods ) implicit none integer , intent ( in ) :: class !! the `class` is the number of points in the !! finite different computation type ( meth_array ) :: list_of_methods !! all the methods with the specified `class` type ( finite_diff_method ) :: fd !! temp variable for getting a !! method from [[get_finite_difference_method]] integer :: id !! method id counter logical :: found !! status flag integer :: n !! temp size variable type ( finite_diff_method ), dimension (:), allocatable :: tmp !! for resizing `meth` array ! currently, the only way to do this is to call the ! get_finite_difference_method routine and see if there ! is one available. id = 0 do id = id + 1 call get_finite_difference_method ( id , fd , found ) if ( found ) then if ( fd % class == class ) then if ( allocated ( list_of_methods % meth )) then ! add to the list n = size ( list_of_methods % meth ) allocate ( tmp ( n + 1 )) tmp ( 1 : n ) = list_of_methods % meth tmp ( n + 1 ) = fd call move_alloc ( tmp , list_of_methods % meth ) ! ... this doesn't appear to work on Intel compiler ... !list_of_methods%meth = [list_of_methods%meth,fd]  ! add to the list else ! first element: allocate ( list_of_methods % meth ( 1 )) list_of_methods % meth = fd end if elseif ( fd % class > class ) then ! we assume they are in increasing order exit end if else exit ! done end if end do end function get_all_methods_in_class !******************************************************************************* !******************************************************************************* !> !  Select a finite diff method of a given `class` so that the perturbations !  of `x` will not violate the variable bounds. subroutine select_finite_diff_method ( me , x , xlow , xhigh , dx , list_of_methods , fd , status_ok ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x !! the variable value real ( wp ), intent ( in ) :: xlow !! the variable lower bound real ( wp ), intent ( in ) :: xhigh !! the variable upper bound real ( wp ), intent ( in ) :: dx !! the perturbation value (>0) type ( meth_array ), intent ( in ) :: list_of_methods !! list of available methods to choose from type ( finite_diff_method ), intent ( out ) :: fd !! this method can be used logical , intent ( out ) :: status_ok !! true if it really doesn't violate the bounds !! (say, the bounds are very close to each other) !! if `status_ok=False`, then the first method in !! the given class is returned in `fd`. integer :: i !! counter integer :: j !! counter real ( wp ) :: xs !! if `x` is outside the bounds, this is the value !! on the nearest bound. otherwise equal to `x`. real ( wp ) :: xp !! perturbed `x` value ! initialize: status_ok = . false . if ( me % exception_raised ) return ! check for exceptions ! make sure it is within the bounds xs = min ( xhigh , max ( xlow , x )) ! try all the methods in the class: do i = 1 , size ( list_of_methods % meth ) status_ok = . true . ! will be set to false if any ! perturbation violates the bounds ! check each of the perturbations: do j = 1 , size ( list_of_methods % meth ( i )% dx_factors ) xp = xs + list_of_methods % meth ( i )% dx_factors ( j ) * dx if ( xp < xlow . or . xp > xhigh ) then status_ok = . false . exit end if end do if ( status_ok ) then ! this one is OK to use fd = list_of_methods % meth ( i ) exit end if end do if (. not . status_ok ) then ! no method was found that doesn't violate the bounds, ! so just return the first one in the list. fd = list_of_methods % meth ( 1 ) end if end subroutine select_finite_diff_method !******************************************************************************* !******************************************************************************* !> !  Select a finite diff method of a given `class` so that the perturbations !  of `x` will not violate the variable bounds for any variable in the group. ! !  The `x` vector are only the variables in a group (not the full variable vector) subroutine select_finite_diff_method_for_partition_group ( me , x , xlow , xhigh , dx ,& list_of_methods , fd , status_ok ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! the variable values real ( wp ), dimension (:), intent ( in ) :: xlow !! the variable lower bounds real ( wp ), dimension (:), intent ( in ) :: xhigh !! the variable upper bounds real ( wp ), dimension (:), intent ( in ) :: dx !! the perturbation values (>0) type ( meth_array ), intent ( in ) :: list_of_methods !! list of available methods to choose from type ( finite_diff_method ), intent ( out ) :: fd !! this method can be used logical , intent ( out ) :: status_ok !! true if it really doesn't violate the bounds !! (say, the bounds are very close to each other) !! if `status_ok=False`, then the first method in !! the given class is returned in `fd`. integer :: i !! counter integer :: j !! counter real ( wp ), dimension ( size ( x )) :: xp !! perturbed `x` values real ( wp ), dimension ( size ( x )) :: xs !! if `x` is outside the bounds, this is the value !! on the nearest bound. otherwise equal to `x`. ! initialize: status_ok = . false . if ( me % exception_raised ) return ! check for exceptions ! make sure they are within the bounds xs = min ( xhigh , max ( xlow , x )) ! try all the methods in the class: do i = 1 , size ( list_of_methods % meth ) status_ok = . true . ! will be set to false if any ! perturbation violates the bounds ! check each of the perturbations: do j = 1 , size ( list_of_methods % meth ( i )% dx_factors ) xp = xs + list_of_methods % meth ( i )% dx_factors ( j ) * dx if ( any ( xp < xlow ) . or . any ( xp > xhigh )) then status_ok = . false . exit end if end do if ( status_ok ) then ! this one is OK to use fd = list_of_methods % meth ( i ) exit end if end do if (. not . status_ok ) then ! no method was found that doesn't violate the bounds, ! so just return the first one in the list. fd = list_of_methods % meth ( 1 ) end if end subroutine select_finite_diff_method_for_partition_group !******************************************************************************* !******************************************************************************* !> !  Alternate version of [[initialize_numdiff]] routine when !  using [[diff]] to compute the Jacobian. subroutine initialize_numdiff_for_diff ( me , n , m , xlow , xhigh ,& problem_func , sparsity_mode , info ,& chunk_size , eps , acc , cache_size ,& xlow_for_sparsity , xhigh_for_sparsity ,& dpert_for_sparsity , sparsity_perturb_mode ,& linear_sparsity_tol , function_precision_tol ,& num_sparsity_points , print_messages ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of `x` variables integer , intent ( in ) :: m !! number of `f` functions real ( wp ), dimension ( n ), intent ( in ) :: xlow !! lower bounds on `x` real ( wp ), dimension ( n ), intent ( in ) :: xhigh !! upper bounds on `x` procedure ( func ) :: problem_func !! the user function that defines the problem !! (returns `m` functions) integer , intent ( in ) :: sparsity_mode !! the sparsity computation method: !! !! **1** - assume dense, !! **2** - three-point simple method, !! **3** - will be specified by the user in !! a subsequent call to [[set_sparsity_pattern]]. !! **4** - computes a two-point jacobian !! at `num_sparsity_points` points. procedure ( info_f ), optional :: info !! a function the user can define !! which is called when each column !! of the jacobian is computed. !! It can be used to perform any !! setup operations. integer , intent ( in ), optional :: chunk_size !! chunk size for allocating the arrays !! (must be >0) [default is 100] real ( wp ), intent ( in ), optional :: eps !! tolerance parameter for [[diff]] !! if not present, default is `1.0e-9_wp` real ( wp ), intent ( in ), optional :: acc !! tolerance parameter for [[diff]] !! if not present, default is `0.0_wp` integer , intent ( in ), optional :: cache_size !! if present, this is the cache size !! for the function cache !! (default is not to enable cache) real ( wp ), dimension ( n ), intent ( in ), optional :: xlow_for_sparsity !! lower bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xlow` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: xhigh_for_sparsity !! upper bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xhigh` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: dpert_for_sparsity !! required if `sparsity_mode=4` integer , intent ( in ), optional :: sparsity_perturb_mode !! perturbation mode (required if `sparsity_mode=4`): !! !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` integer , intent ( in ), optional :: num_sparsity_points !! for `sparsity_mode=4`, the number of jacobian !! evaluations used to estimate the sparsity pattern. real ( wp ), intent ( in ), optional :: linear_sparsity_tol !! the equality tolerance for derivatives to !! indicate a constant jacobian element (linear sparsity) real ( wp ), intent ( in ), optional :: function_precision_tol !! the function precision. two functions values !! that are the within this tolerance are !! considered the same value. This is used !! when estimating the sparsity pattern when !! `sparsity_mode=2` in [[compute_sparsity_random]] logical , intent ( in ), optional :: print_messages !! if true, print error messages to `error_unit`. !! default is True. logical :: cache !! if the cache is to be used me % use_diff = . true . ! cache: cache = present ( cache_size ) if ( cache ) cache = cache_size > 0 if ( cache ) then me % compute_function => compute_function_with_cache call me % cache % initialize ( cache_size , n , m ) else me % compute_function => problem_func call me % cache % destroy () end if ! functions: me % problem_func => problem_func me % jacobian_function => compute_jacobian_with_diff ! size of the problem: me % n = n me % m = m ! input variable bounds: call me % set_numdiff_bounds ( xlow , xhigh ) ! set the sparsity function call me % set_sparsity_mode ( sparsity_mode , xlow_for_sparsity , xhigh_for_sparsity ) if ( sparsity_mode == 4 ) then ! these must be present, since we don't have a dpert and perturb mode for the gradients: if ( present ( dpert_for_sparsity ) . and . present ( sparsity_perturb_mode )) then me % dpert_for_sparsity = abs ( dpert_for_sparsity ) ! perturbation options: select case ( sparsity_perturb_mode ) case ( 1 : 3 ) me % sparsity_perturb_mode = sparsity_perturb_mode case default call me % raise_exception ( 1 , 'initialize_numdiff_for_diff' ,& 'sparsity_perturb_mode must be 1, 2, or 3.' ) return end select else call me % raise_exception ( 2 , 'initialize_numdiff_for_diff' ,& 'missing required inputs for sparsity mode 4' ) return end if end if ! if these aren't present, they will just keep the defaults: if ( present ( linear_sparsity_tol )) me % linear_sparsity_tol = linear_sparsity_tol if ( present ( function_precision_tol )) me % function_precision_tol = function_precision_tol if ( present ( num_sparsity_points )) me % num_sparsity_points = num_sparsity_points ! optional: if ( present ( chunk_size )) me % chunk_size = abs ( chunk_size ) if ( present ( eps )) me % eps = eps if ( present ( acc )) me % acc = acc if ( present ( info )) me % info_function => info if ( present ( print_messages )) me % print_messages = print_messages end subroutine initialize_numdiff_for_diff !******************************************************************************* !******************************************************************************* !> !  Change the variable bounds in a [[numdiff_type]]. ! !### See also !  * [[set_numdiff_sparsity_bounds]] ! !@note The bounds must be set when the class is initialized, !      but this routine can be used to change them later if required. subroutine set_numdiff_bounds ( me , xlow , xhigh ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: xlow !! lower bounds on `x` real ( wp ), dimension (:), intent ( in ) :: xhigh !! upper bounds on `x` integer :: i !! counter for error print character ( len = :), allocatable :: error_info !! error message info character ( len = :), allocatable :: istr !! for integer to string character ( len = 30 ) :: xlow_str , xhigh_str !! for real to string if ( me % exception_raised ) return ! check for exceptions if ( allocated ( me % xlow )) deallocate ( me % xlow ) if ( allocated ( me % xhigh )) deallocate ( me % xhigh ) if ( size ( xlow ) /= me % n . or . size ( xhigh ) /= me % n ) then call me % raise_exception ( 3 , 'set_numdiff_bounds' ,& 'invalid size of xlow or xhigh' ) return else if ( any ( xlow >= xhigh )) then error_info = 'all xlow must be < xhigh' do i = 1 , size ( xlow ) if ( xlow ( i ) >= xhigh ( i )) then istr = integer_to_string ( i ) write ( xlow_str , '(F30.16)' ) xlow ( i ) write ( xhigh_str , '(F30.16)' ) xhigh ( i ) error_info = error_info // new_line ( '' ) // '  Error for optimization variable ' // trim ( adjustl ( istr )) // & ': xlow=' // trim ( adjustl ( xlow_str )) // & ' >= xhigh=' // trim ( adjustl ( xhigh_str )) end if end do call me % raise_exception ( 4 , 'set_numdiff_bounds' , error_info ) return else allocate ( me % xlow ( me % n )) allocate ( me % xhigh ( me % n )) me % xlow = xlow me % xhigh = xhigh end if end subroutine set_numdiff_bounds !******************************************************************************* !******************************************************************************* !> !  Set sparsity mode. subroutine set_sparsity_mode ( me , sparsity_mode , xlow_for_sparsity , xhigh_for_sparsity ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: sparsity_mode !! the sparsity computation method: !! **1** - assume dense, !! **2** - three-point simple method, !! **3** - will be specified by the user in !! a subsequent call to [[set_sparsity_pattern]]. !! **4** - computes a two-point jacobian !! at `num_sparsity_points` points. real ( wp ), dimension (:), intent ( in ), optional :: xlow_for_sparsity !! lower bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xlow` is used. real ( wp ), dimension (:), intent ( in ), optional :: xhigh_for_sparsity !! upper bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xhigh` is used. if ( me % exception_raised ) return ! check for exceptions ! set the sparsity function select case ( sparsity_mode ) case ( 1 ) ! dense me % compute_sparsity => compute_sparsity_dense case ( 3 ) ! user defined me % compute_sparsity => null () case ( 2 ) ! three-point simple method me % compute_sparsity => compute_sparsity_random ! in this case, we have the option of specifying ! separate bounds for computing the sparsity: call me % set_numdiff_sparsity_bounds ( xlow_for_sparsity , xhigh_for_sparsity ) case ( 4 ) ! compute 2-point jacobian in specified number of points me % compute_sparsity => compute_sparsity_random_2 ! in this case, we have the option of specifying ! separate bounds for computing the sparsity: call me % set_numdiff_sparsity_bounds ( xlow_for_sparsity , xhigh_for_sparsity ) case default call me % raise_exception ( 5 , 'set_sparsity_mode' ,& 'sparsity_mode must be 1, 2, 3, or 4.' ) return end select end subroutine set_sparsity_mode !******************************************************************************* !******************************************************************************* !> !  Sets the variable bounds for sparsity in a [[numdiff_type]]. !  These are only used for `sparsity_mode=2`. ! !### See also !  * [[set_numdiff_bounds]] ! !@note This routine assumes that `xlow` and `xhigh` have already !      been set in the class. subroutine set_numdiff_sparsity_bounds ( me , xlow , xhigh ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ), optional :: xlow !! lower bounds on `x` to be used for !! sparsity computation. If not present, !! then then `xlow` values in the class are used. real ( wp ), dimension (:), intent ( in ), optional :: xhigh !! upper bounds on `x` to be used for !! sparsity computation. If not present, !! then then `xhigh` values in the class are used. if ( me % exception_raised ) return ! check for exceptions if ( allocated ( me % xlow_for_sparsity )) deallocate ( me % xlow_for_sparsity ) if ( allocated ( me % xhigh_for_sparsity )) deallocate ( me % xhigh_for_sparsity ) if (. not . present ( xlow )) then allocate ( me % xlow_for_sparsity ( size ( me % xlow ))) me % xlow_for_sparsity = me % xlow else allocate ( me % xlow_for_sparsity ( size ( xlow ))) me % xlow_for_sparsity = xlow end if if (. not . present ( xhigh )) then allocate ( me % xhigh_for_sparsity ( size ( me % xhigh ))) me % xhigh_for_sparsity = me % xhigh else allocate ( me % xhigh_for_sparsity ( size ( xhigh ))) me % xhigh_for_sparsity = xhigh end if ! error checks: if ( size ( me % xlow_for_sparsity ) /= me % n . or . size ( me % xhigh_for_sparsity ) /= me % n ) then call me % raise_exception ( 6 , 'set_numdiff_sparsity_bounds' ,& 'invalid size of xlow or xhigh' ) else if ( any ( me % xlow_for_sparsity >= me % xhigh_for_sparsity )) then call me % raise_exception ( 7 , 'set_numdiff_sparsity_bounds' ,& 'all xlow must be < xhigh' ) end if end subroutine set_numdiff_sparsity_bounds !******************************************************************************* !******************************************************************************* !> !  Initialize a [[numdiff_type]] class. This must be called first. ! !@note Only one of the following inputs can be used: `jacobian_method`, !      `jacobian_methods`, `class`, or `classes`. subroutine initialize_numdiff ( me , n , m , xlow , xhigh , perturb_mode , dpert ,& problem_func , sparsity_mode , jacobian_method , jacobian_methods ,& class , classes , info , chunk_size , partition_sparsity_pattern ,& cache_size , xlow_for_sparsity , xhigh_for_sparsity ,& dpert_for_sparsity , sparsity_perturb_mode ,& linear_sparsity_tol , function_precision_tol ,& num_sparsity_points ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of `x` variables integer , intent ( in ) :: m !! number of `f` functions real ( wp ), dimension ( n ), intent ( in ) :: xlow !! lower bounds on `x` real ( wp ), dimension ( n ), intent ( in ) :: xhigh !! upper bounds on `x` integer , intent ( in ) :: perturb_mode !! perturbation mode: !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` real ( wp ), dimension ( n ), intent ( in ) :: dpert !! perturbation vector for `x` procedure ( func ) :: problem_func !! the user function that defines the problem !! (returns `m` functions) integer , intent ( in ) :: sparsity_mode !! the sparsity computation method: !! **1** - assume dense, !! **2** - three-point simple method, !! **3** - will be specified by the user in !! a subsequent call to [[set_sparsity_pattern]]. !! **4** - computes a two-point jacobian !! at `num_sparsity_points` points. integer , intent ( in ), optional :: jacobian_method !! `id` code for the finite difference method !! to use for all `n` variables. !! see [[get_finite_difference_method]] integer , dimension ( n ), intent ( in ), optional :: jacobian_methods !! `id` codes for the finite difference method !! to use for each variable. !! see [[get_finite_difference_method]] integer , intent ( in ), optional :: class !! method class for the finite difference method !! to use for all `n` variables. !! see [[get_finite_difference_method]] integer , dimension ( n ), intent ( in ), optional :: classes !! method class for the finite difference methods !! to use for each variable. !! see [[get_finite_difference_method]] procedure ( info_f ), optional :: info !! a function the user can define !! which is called when each column !! of the jacobian is computed. !! It can be used to perform any !! setup operations. integer , intent ( in ), optional :: chunk_size !! chunk size for allocating the arrays !! (must be >0) [default is 100] logical , intent ( in ), optional :: partition_sparsity_pattern !! if the sparisty pattern is to !! be partitioned using [[DSM]] !! [default is False] integer , intent ( in ), optional :: cache_size !! if present, this is the cache size !! for the function cache !! (default is not to enable cache) real ( wp ), dimension ( n ), intent ( in ), optional :: xlow_for_sparsity !! lower bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xlow` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: xhigh_for_sparsity !! upper bounds on `x` used for !! sparsity computation (when !! `sparsity_mode` is 2). If not !! present, then `xhigh` is used. real ( wp ), dimension ( n ), intent ( in ), optional :: dpert_for_sparsity !! for `sparsity_mode=4`, the perturbation integer , intent ( in ), optional :: sparsity_perturb_mode !! perturbation mode (required if `sparsity_mode=4`): !! **1** - perturbation is `dx=dpert`, !! **2** - perturbation is `dx=dpert*x`, !! **3** - perturbation is `dx=dpert*(1+x)` real ( wp ), intent ( in ), optional :: linear_sparsity_tol !! the equality tolerance for derivatives to !! indicate a constant jacobian element (linear sparsity) real ( wp ), intent ( in ), optional :: function_precision_tol !! the function precision. two functions values !! that are the within this tolerance are !! considered the same value. This is used !! when estimating the sparsity pattern when !! `sparsity_mode=2` in [[compute_sparsity_random]] integer , intent ( in ), optional :: num_sparsity_points !! for `sparsity_mode=4`, the number of jacobian !! evaluations used to estimate the sparsity pattern. integer :: i !! counter logical :: found !! flag for [[get_finite_difference_method]] logical :: cache !! if the cache is to be used me % use_diff = . false . ! cache: cache = present ( cache_size ) if ( cache ) cache = cache_size > 0 if ( cache ) then me % compute_function => compute_function_with_cache call me % cache % initialize ( cache_size , n , m ) else me % compute_function => problem_func call me % cache % destroy () end if ! functions: me % problem_func => problem_func if ( present ( partition_sparsity_pattern )) then me % partition_sparsity_pattern = partition_sparsity_pattern else me % partition_sparsity_pattern = . false . end if ! method: if ( allocated ( me % meth )) deallocate ( me % meth ) if ( allocated ( me % class )) deallocate ( me % class ) if ( allocated ( me % class_meths )) deallocate ( me % class_meths ) if ( present ( jacobian_method ) . and . . not . present ( jacobian_methods ) . and . & . not . present ( class ) . and . . not . present ( classes )) then ! use the same for all variable me % mode = 1 allocate ( me % meth ( n )) do i = 1 , n call get_finite_difference_method ( jacobian_method , me % meth ( i ), found ) if (. not . found ) then call me % raise_exception ( 8 , 'initialize_numdiff' ,& 'invalid jacobian_method' ) return end if end do elseif (. not . present ( jacobian_method ) . and . present ( jacobian_methods ) . and . & . not . present ( class ) . and . . not . present ( classes )) then ! specify a separate method for each variable me % mode = 1 allocate ( me % meth ( n )) do i = 1 , n call get_finite_difference_method ( jacobian_methods ( i ), me % meth ( i ), found ) if (. not . found ) then call me % raise_exception ( 9 , 'initialize_numdiff' ,& 'invalid jacobian_methods' ) return end if end do if ( me % partition_sparsity_pattern ) then call me % raise_exception ( 10 , 'initialize_numdiff' ,& 'when using partitioned sparsity pattern, ' // & 'all columns must use the same ' // & 'finite diff method.' ) return end if elseif (. not . present ( jacobian_method ) . and . . not . present ( jacobian_methods ) . and . & present ( class ) . and . . not . present ( classes )) then ! use the class for all variables me % mode = 2 allocate ( me % class ( n )) me % class = class allocate ( me % class_meths ( n )) me % class_meths ( 1 ) = get_all_methods_in_class ( class ) if ( n > 1 ) me % class_meths ( 2 : n ) = me % class_meths ( 1 ) ! just copy them over elseif (. not . present ( jacobian_method ) . and . . not . present ( jacobian_methods ) . and . & . not . present ( class ) . and . present ( classes )) then ! specify a separate class for each variable me % mode = 2 me % class = classes allocate ( me % class_meths ( n )) do i = 1 , n me % class_meths ( i ) = get_all_methods_in_class ( me % class ( i )) end do if ( me % partition_sparsity_pattern ) then call me % raise_exception ( 11 , 'initialize_numdiff' ,& 'when using partitioned sparsity pattern, ' // & 'all columns must use the same ' // & 'finite diff method.' ) end if else call me % raise_exception ( 12 , 'initialize_numdiff' ,& 'must specify one of either ' // & 'jacobian_method, jacobian_methods, class, or classes.' ) end if ! size of the problem: me % n = n me % m = m ! input variable bounds: call me % set_numdiff_bounds ( xlow , xhigh ) ! perturbation options: select case ( perturb_mode ) case ( 1 : 3 ) me % perturb_mode = perturb_mode case default call me % raise_exception ( 13 , 'initialize_numdiff' ,& 'perturb_mode must be 1, 2, or 3.' ) return end select if ( allocated ( me % dpert )) deallocate ( me % dpert ) allocate ( me % dpert ( n )) me % dpert = abs ( dpert ) ! optional: if ( present ( info )) me % info_function => info if ( present ( chunk_size )) me % chunk_size = abs ( chunk_size ) ! set the jacobian function, depending on the options: if ( me % partition_sparsity_pattern ) then me % jacobian_function => compute_jacobian_partitioned else me % jacobian_function => compute_jacobian_standard end if ! set the sparsity function call me % set_sparsity_mode ( sparsity_mode , xlow_for_sparsity , xhigh_for_sparsity ) if ( present ( linear_sparsity_tol )) me % linear_sparsity_tol = linear_sparsity_tol if ( present ( function_precision_tol )) me % function_precision_tol = function_precision_tol if ( present ( num_sparsity_points )) me % num_sparsity_points = num_sparsity_points if ( present ( dpert_for_sparsity )) then me % dpert_for_sparsity = abs ( dpert_for_sparsity ) else me % dpert_for_sparsity = dpert ! use the same dpert as the jacobian end if if ( present ( sparsity_perturb_mode )) then select case ( sparsity_perturb_mode ) case ( 1 : 3 ) me % sparsity_perturb_mode = sparsity_perturb_mode case default call me % raise_exception ( 14 , 'initialize_numdiff' ,& 'sparsity_perturb_mode must be 1, 2, or 3.' ) return end select else me % sparsity_perturb_mode = perturb_mode ! use the same perturb mode as the jacobian end if end subroutine initialize_numdiff !******************************************************************************* !******************************************************************************* !> !  destroy the [[numdiff_type]] class. subroutine destroy_numdiff_type ( me ) implicit none class ( numdiff_type ), intent ( out ) :: me end subroutine destroy_numdiff_type !******************************************************************************* !******************************************************************************* !> !  destroy a [[sparsity_pattern]] type. subroutine destroy_sparsity ( me ) implicit none class ( sparsity_pattern ), intent ( out ) :: me end subroutine destroy_sparsity !******************************************************************************* !******************************************************************************* !> !  Wrapper for [[dsm]] to compute the sparsity pattern partition. subroutine dsm_wrapper ( me , n , m , info ) implicit none class ( sparsity_pattern ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of columns of jacobian matrix integer , intent ( in ) :: m !! number of rows of jacobian matrix integer , intent ( out ) :: info !! status output from [[dsm]] integer :: mingrp !! for call to [[dsm]] integer , dimension (:), allocatable :: ipntr !! for call to [[dsm]] integer , dimension (:), allocatable :: jpntr !! for call to [[dsm]] integer , dimension (:), allocatable :: irow !! for call to [[dsm]] !! (temp copy since [[dsm]] !! will modify it) integer , dimension (:), allocatable :: icol !! for call to [[dsm]] !! (temp copy since [[dsm]] !! will modify it) allocate ( ipntr ( m + 1 )) allocate ( jpntr ( n + 1 )) allocate ( me % ngrp ( n )) irow = me % irow icol = me % icol call dsm ( m , n , me % num_nonzero_elements ,& irow , icol ,& me % ngrp , me % maxgrp ,& mingrp , info , ipntr , jpntr ) end subroutine dsm_wrapper !******************************************************************************* !******************************************************************************* !> !  Returns the columns in a sparsity partition group. ! !@note This is just a wrapper to get data from `ngrp`. subroutine columns_in_partition_group ( me , igroup , n_cols , cols , nonzero_rows , indices , status_ok ) implicit none class ( sparsity_pattern ), intent ( in ) :: me integer , intent ( in ) :: igroup !! group number. Should be `>0` and `<=me%mxgrp` integer , intent ( out ) :: n_cols !! number of columns in the `igroup` group. integer , dimension (:), allocatable , intent ( out ) :: cols !! the column numbers in the `igroup` group. !! (if none, then it is not allocated) integer , dimension (:), allocatable , intent ( out ) :: nonzero_rows !! the row numbers of all the nonzero !! Jacobian elements in this group integer , dimension (:), allocatable , intent ( out ) :: indices !! nonzero indices in `jac` for a group logical , intent ( out ) :: status_ok !! true if the partition is valid integer :: i !! counter integer :: num_nonzero_elements_in_col !! number of nonzero elements in a column integer :: num_nonzero_elements_in_group !! number of nonzero elements in a group integer , dimension (:), allocatable :: col_indices !! nonzero indices in `jac` for a column if ( me % maxgrp > 0 . and . allocated ( me % ngrp )) then status_ok = . true . n_cols = count ( me % ngrp == igroup ) if ( n_cols > 0 ) then allocate ( cols ( n_cols )) cols = pack ([( i , i = 1 , size ( me % ngrp ))], mask = me % ngrp == igroup ) end if ! get all the non-zero elements in each column: num_nonzero_elements_in_group = 0 ! initialize do i = 1 , n_cols num_nonzero_elements_in_col = count ( me % icol == cols ( i )) if ( num_nonzero_elements_in_col /= 0 ) then ! there are functions to ! compute in this column num_nonzero_elements_in_group = num_nonzero_elements_in_group + & num_nonzero_elements_in_col if ( allocated ( col_indices )) deallocate ( col_indices ) allocate ( col_indices ( num_nonzero_elements_in_col )) col_indices = pack ( me % indices , mask = me % icol == cols ( i )) if ( allocated ( nonzero_rows )) then nonzero_rows = [ nonzero_rows , me % irow ( col_indices )] indices = [ indices , col_indices ] else nonzero_rows = me % irow ( col_indices ) indices = col_indices end if end if end do else status_ok = . false . end if end subroutine columns_in_partition_group !******************************************************************************* !******************************************************************************* !> !  Destroy the sparsity pattern in the class. subroutine destroy_sparsity_pattern ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me call me % sparsity % destroy () end subroutine destroy_sparsity_pattern !******************************************************************************* !******************************************************************************* !> !  Computes the `indices` vector in the class. subroutine compute_indices ( me ) implicit none class ( sparsity_pattern ), intent ( inout ) :: me integer :: i !! counter allocate ( me % indices ( me % num_nonzero_elements )) me % indices = [( i , i = 1 , me % num_nonzero_elements )] end subroutine compute_indices !******************************************************************************* !******************************************************************************* !> !  To specify the sparsity pattern directly if it is already known. ! !@note If specifying the linear pattern, all three optional arguments !      must be present. subroutine set_sparsity_pattern ( me , irow , icol , linear_irow , linear_icol , linear_vals , maxgrp , ngrp ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , dimension (:), intent ( in ) :: irow !! sparsity pattern nonzero elements row indices integer , dimension (:), intent ( in ) :: icol !! sparsity pattern nonzero elements column indices integer , dimension (:), intent ( in ), optional :: linear_irow !! linear sparsity pattern nonzero elements row indices integer , dimension (:), intent ( in ), optional :: linear_icol !! linear sparsity pattern nonzero elements column indices real ( wp ), dimension (:), intent ( in ), optional :: linear_vals !! linear sparsity values (constant elements of the Jacobian) integer , intent ( in ), optional :: maxgrp !! DSM sparsity partition !! [only used if `me%partition_sparsity_pattern=True`] integer , dimension (:), intent ( in ), optional :: ngrp !! DSM sparsity partition (size `n`) !! [only used if `me%partition_sparsity_pattern=True`] integer :: info !! status output form [[dsm]] call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions if ( size ( irow ) /= size ( icol ) . or . any ( irow > me % m ) . or . any ( icol > me % n )) then call me % raise_exception ( 15 , 'set_sparsity_pattern' ,& 'invalid inputs' ) return else me % sparsity % sparsity_computed = . true . me % sparsity % num_nonzero_elements = size ( irow ) me % sparsity % irow = irow me % sparsity % icol = icol call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) then if ( present ( maxgrp ) . and . present ( ngrp )) then ! use the user-input partition: if ( maxgrp > 0 . and . all ( ngrp >= 1 . and . ngrp <= maxgrp ) . and . size ( ngrp ) == me % n ) then me % sparsity % maxgrp = maxgrp me % sparsity % ngrp = ngrp else call me % raise_exception ( 28 , 'set_sparsity_pattern' ,& 'invalid sparsity partition inputs.' ) return end if else call me % sparsity % dsm_wrapper ( me % n , me % m , info ) if ( info /= 1 ) then call me % raise_exception ( 16 , 'set_sparsity_pattern' ,& 'error partitioning sparsity pattern.' ) return end if end if end if end if ! linear pattern: if ( present ( linear_irow ) . and . present ( linear_icol ) . and . present ( linear_vals )) then if ( size ( linear_irow ) /= size ( linear_icol ) . or . & size ( linear_vals ) /= size ( linear_icol ) . or . & any ( linear_irow > me % m ) . or . & any ( linear_icol > me % n )) then call me % raise_exception ( 17 , 'set_sparsity_pattern' ,& 'invalid linear sparsity pattern' ) return else me % sparsity % linear_irow = linear_irow me % sparsity % linear_icol = linear_icol me % sparsity % linear_vals = linear_vals me % sparsity % linear_sparsity_computed = . true . me % sparsity % num_nonzero_linear_elements = size ( linear_irow ) end if end if end subroutine set_sparsity_pattern !******************************************************************************* !******************************************************************************* !> !  assume all elements of Jacobian are non-zero. subroutine compute_sparsity_dense ( me , x ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) integer :: i !! counter integer :: r !! row counter integer :: c !! column counter call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions me % sparsity % num_nonzero_elements = me % m * me % n allocate ( me % sparsity % irow ( me % sparsity % num_nonzero_elements )) allocate ( me % sparsity % icol ( me % sparsity % num_nonzero_elements )) call me % sparsity % compute_indices () ! create the dense matrix: i = 0 do c = 1 , me % n do r = 1 , me % m i = i + 1 me % sparsity % irow ( i ) = r me % sparsity % icol ( i ) = c end do end do ! No real need for this, since it can't be partitioned (all elements are true) if ( me % partition_sparsity_pattern ) call me % generate_dense_sparsity_partition () me % sparsity % sparsity_computed = . true . end subroutine compute_sparsity_dense !******************************************************************************* !******************************************************************************* !> !  Generate a \"dense\" sparsity partition. subroutine generate_dense_sparsity_partition ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer :: i !! counter if ( me % exception_raised ) return ! check for exceptions me % sparsity % maxgrp = me % n allocate ( me % sparsity % ngrp ( me % n )) me % sparsity % ngrp = [( i , i = 1 , me % n )] end subroutine generate_dense_sparsity_partition !******************************************************************************* !******************************************************************************* !> !  Compute the sparsity pattern by computing the function at three !  \"random\" points in the [`xlow_for_sparsity`, `xhigh_for_sparsity`] interval !  and checking if the function values are the same. subroutine compute_sparsity_random ( me , x ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) !! (not used here) integer :: i !! column counter integer :: j !! row counter integer :: n_icol !! `icol` size counter integer :: n_irow !! `irow` size counter integer :: n_linear_icol !! `linear_icol` size counter integer :: n_linear_irow !! `linear_irow` size counter integer :: n_linear_vals !! `linear_vals` size counter integer , dimension ( me % m ) :: idx !! indices to compute `[1,2,...,m]` real ( wp ), dimension ( me % n ) :: x1 !! perturbed variable vector real ( wp ), dimension ( me % n ) :: x2 !! perturbed variable vector real ( wp ), dimension ( me % n ) :: x3 !! perturbed variable vector real ( wp ), dimension ( me % n ) :: x4 !! perturbed variable vector real ( wp ), dimension ( me % m ) :: f1 !! function evaluation real ( wp ), dimension ( me % m ) :: f2 !! function evaluation real ( wp ), dimension ( me % m ) :: f3 !! function evaluation real ( wp ), dimension ( me % m ) :: f4 !! function evaluation real ( wp ) :: dfdx1 !! for linear sparsity estimation real ( wp ) :: dfdx2 !! for linear sparsity estimation real ( wp ) :: dfdx3 !! for linear sparsity estimation real ( wp ) :: dfdx !! for linear sparsity estimation integer :: info !! status output form [[dsm]] real ( wp ), dimension ( 4 ), parameter :: coeffs = [ 0.20123456787654321_wp ,& 0.40123456787654321_wp ,& 0.60123456787654321_wp ,& 0.80123456787654321_wp ] !! Pick three pseudo-random points roughly equally spaced. !! (add some noise in attempt to avoid freak zeros) !!```` !! xlow---|----|--x--|---xhigh !!        1    2     3 !!```` !! !! Also using an extra point to estimate the !! constant elements of the Jacobian. ! initialize: call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions ! error check: if (. not . allocated ( me % xlow_for_sparsity ) . or . . not . allocated ( me % xhigh_for_sparsity )) then call me % raise_exception ( 18 , 'compute_sparsity_random' ,& 'the x bounds have not been set.' ) return end if associate ( xlow => me % xlow_for_sparsity , xhigh => me % xhigh_for_sparsity ) ! we will compute all the functions: idx = [( i , i = 1 , me % m )] n_icol = 0 ! initialize vector size counters n_irow = 0 n_linear_icol = 0 n_linear_irow = 0 n_linear_vals = 0 ! define a nominal point roughly in the middle: x2 = xlow + ( xhigh - xlow ) * coeffs ( 2 ) call me % compute_function ( x2 , f2 , idx ) if ( me % exception_raised ) return ! check for exceptions if ( me % compute_linear_sparsity_pattern ) then ! we need another point where we perturb all the variables ! to check to make sure it is linear in only one variable. x4 = xlow + ( xhigh - xlow ) * coeffs ( 4 ) call me % compute_function ( x4 , f4 , idx ) if ( me % exception_raised ) return ! check for exceptions end if do i = 1 , me % n ! columns of Jacobian ! restore nominal: x1 = x2 x3 = x2 x1 ( i ) = xlow ( i ) + ( xhigh ( i ) - xlow ( i )) * coeffs ( 1 ) x3 ( i ) = xlow ( i ) + ( xhigh ( i ) - xlow ( i )) * coeffs ( 3 ) call me % compute_function ( x1 , f1 , idx ) if ( me % exception_raised ) return ! check for exceptions call me % compute_function ( x3 , f3 , idx ) if ( me % exception_raised ) return ! check for exceptions do j = 1 , me % m ! each function (rows of Jacobian) if ( equal_within_tol ([ f1 ( j ), f2 ( j ), f3 ( j )], me % function_precision_tol )) then ! no change in the function, so no sparsity element here. cycle else if ( me % compute_linear_sparsity_pattern ) then ! if computing the linear pattern separately. ! do the three points lie on a line? (x1,f1) -> (x2, f2), -> (x3,f3) ! [check that the slopes are equal within a tolerance] dfdx1 = ( f1 ( j ) - f2 ( j )) / ( x1 ( i ) - x2 ( i )) ! slope of line from 1->2 dfdx2 = ( f1 ( j ) - f3 ( j )) / ( x1 ( i ) - x3 ( i )) ! slope of line from 1->3 dfdx3 = ( f1 ( j ) - f4 ( j )) / ( x1 ( i ) - x4 ( i )) ! slope of line from 1->4 if ( equal_within_tol ([ dfdx1 , dfdx2 , dfdx3 ], me % linear_sparsity_tol )) then ! this is a linear element (constant value) dfdx = ( dfdx1 + dfdx2 + dfdx3 ) / 3.0_wp ! just take the average and use that call expand_vector ( me % sparsity % linear_icol , n_linear_icol , me % chunk_size , val = i ) call expand_vector ( me % sparsity % linear_irow , n_linear_irow , me % chunk_size , val = j ) call expand_vector ( me % sparsity % linear_vals , n_linear_vals , me % chunk_size , val = dfdx ) cycle ! this element will not be added to the nonlinear pattern end if end if ! otherwise, add it to the nonlinear pattern: call expand_vector ( me % sparsity % icol , n_icol , me % chunk_size , val = i ) call expand_vector ( me % sparsity % irow , n_irow , me % chunk_size , val = j ) end if end do end do ! resize to correct size: call me % resize_sparsity_vectors ( n_icol , n_irow , n_linear_icol ,& n_linear_irow , n_linear_vals ) end associate call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) then call me % sparsity % dsm_wrapper ( me % n , me % m , info ) if ( info /= 1 ) then call me % raise_exception ( 19 , 'compute_sparsity_random' ,& 'error partitioning sparsity pattern.' ) return end if end if ! finished: me % sparsity % sparsity_computed = . true . end subroutine compute_sparsity_random !******************************************************************************* !******************************************************************************* !> !  Resize the sparsity arrays after accumulating them. subroutine resize_sparsity_vectors ( me , n_icol , n_irow , n_linear_icol ,& n_linear_irow , n_linear_vals ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( inout ) :: n_icol integer , intent ( inout ) :: n_irow integer , intent ( inout ) :: n_linear_icol integer , intent ( inout ) :: n_linear_irow integer , intent ( inout ) :: n_linear_vals if ( me % exception_raised ) return ! check for exceptions ! resize to correct size: if ( allocated ( me % sparsity % icol )) then call expand_vector ( me % sparsity % icol , n_icol , me % chunk_size , finished = . true .) call expand_vector ( me % sparsity % irow , n_irow , me % chunk_size , finished = . true .) me % sparsity % num_nonzero_elements = size ( me % sparsity % irow ) else me % sparsity % num_nonzero_elements = 0 end if ! linear pattern (note: there may be no linear elements): me % sparsity % linear_sparsity_computed = me % compute_linear_sparsity_pattern . and . & allocated ( me % sparsity % linear_vals ) if ( me % sparsity % linear_sparsity_computed ) then call expand_vector ( me % sparsity % linear_icol , n_linear_icol , me % chunk_size , finished = . true .) call expand_vector ( me % sparsity % linear_irow , n_linear_irow , me % chunk_size , finished = . true .) call expand_vector ( me % sparsity % linear_vals , n_linear_vals , me % chunk_size , finished = . true .) me % sparsity % num_nonzero_linear_elements = n_linear_vals else me % sparsity % num_nonzero_linear_elements = 0 end if end subroutine resize_sparsity_vectors !******************************************************************************* !******************************************************************************* !> !  Compute the sparsity pattern by computing a 2-point jacobian at a specified !  number of \"random\" points (`num_sparsity_points`) in the !  [`xlow_for_sparsity`, `xhigh_for_sparsity`] interval and checking if !  they are the same. subroutine compute_sparsity_random_2 ( me , x ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) !! (not used here) type :: jac_type !! so we can define an array of jacobian columns real ( wp ), dimension (:), allocatable :: jac !! a column of the jacobian end type jac_type real ( wp ), dimension (:), allocatable :: coeffs !! coefficients for computing `xp` real ( wp ), dimension (:,:), allocatable :: xp !! perturbed `x` array (size `n,num_sparsity_points`) type ( jac_type ), dimension (:), allocatable :: jac_array !! array of jacobian columns type ( sparsity_pattern ) :: tmp_sparsity_pattern !! will accumulate the pattern here !! and copy it into the class when !! finished. integer :: i !! counter for the number of points integer :: j !! counter integer :: icol !! column counter integer :: irow !! row counter real ( wp ) :: dfdx !! value of a jacobian element integer :: n_icol !! `icol` size counter integer :: n_irow !! `irow` size counter integer :: n_linear_icol !! `linear_icol` size counter integer :: n_linear_irow !! `linear_irow` size counter integer :: n_linear_vals !! `linear_vals` size counter type ( meth_array ) :: class_meths !! set of finite diff methods to use real ( wp ), dimension (:), allocatable :: jac !! array of jacobian element values integer :: info !! status output form [[dsm]] ! initialize: call me % destroy_sparsity_pattern () if ( me % exception_raised ) return ! check for exceptions ! error check: if (. not . allocated ( me % xlow_for_sparsity ) . or . . not . allocated ( me % xhigh_for_sparsity )) then call me % raise_exception ( 20 , 'compute_sparsity_random_2' ,& 'the x bounds have not been set.' ) return end if ! compute the coefficients: coeffs = divide_interval ( me % num_sparsity_points ) ! save the initial settings: tmp_sparsity_pattern = me % sparsity ! we create a provisional sparsity pattern here, ! to compute one row at a time: me % sparsity % irow = [( irow , irow = 1 , me % m )] me % sparsity % sparsity_computed = . true . me % sparsity % num_nonzero_elements = me % m call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) call me % generate_dense_sparsity_partition () n_icol = 0 n_irow = 0 n_linear_icol = 0 n_linear_irow = 0 n_linear_vals = 0 allocate ( jac ( me % num_sparsity_points )) ! the idea here is to compute the (dense) jacobian ! one column at at time, and keep a running track of ! the ones that have changed. ! first precompute the perturbation arrays for each point: allocate ( xp ( me % n , me % num_sparsity_points )) do i = 1 , me % num_sparsity_points xp (:, i ) = me % xlow_for_sparsity + ( me % xhigh_for_sparsity - me % xlow_for_sparsity ) * coeffs ( i ) end do ! we will use 2-point methods (simple differences): class_meths = get_all_methods_in_class ( 2 ) do icol = 1 , me % n ! column loop ! size the array: if ( allocated ( jac_array )) deallocate ( jac_array ) allocate ( jac_array ( me % num_sparsity_points )) ! compute the ith column of the jacobian: me % sparsity % icol = [( icol , j = 1 , me % m )] do i = 1 , me % num_sparsity_points call me % compute_jacobian_for_sparsity ( icol , class_meths , xp (:, i ), jac_array ( i )% jac ) if ( me % exception_raised ) return ! check for exceptions end do ! check each row: do irow = 1 , me % m ! get the jacobian values for this row,col for all the points: do j = 1 , me % num_sparsity_points jac ( j ) = jac_array ( j )% jac ( irow ) end do ! put the results into the tmp_sparsity_pattern if ( equal_within_tol ([ 0.0_wp , jac ], me % linear_sparsity_tol )) then ! they are all zero cycle else if ( me % compute_linear_sparsity_pattern ) then if ( equal_within_tol ( jac , me % linear_sparsity_tol )) then ! this is a linear element (constant value) dfdx = sum ( jac ) / me % num_sparsity_points ! just take the average and use that call expand_vector ( tmp_sparsity_pattern % linear_icol , n_linear_icol , me % chunk_size , val = icol ) call expand_vector ( tmp_sparsity_pattern % linear_irow , n_linear_irow , me % chunk_size , val = irow ) call expand_vector ( tmp_sparsity_pattern % linear_vals , n_linear_vals , me % chunk_size , val = dfdx ) cycle ! this element will not be added to the nonlinear pattern end if end if ! otherwise, add it to the nonlinear pattern: call expand_vector ( tmp_sparsity_pattern % icol , n_icol , me % chunk_size , val = icol ) call expand_vector ( tmp_sparsity_pattern % irow , n_irow , me % chunk_size , val = irow ) end if end do end do ! copy over the computed pattern: me % sparsity = tmp_sparsity_pattern ! resize to correct size: call me % resize_sparsity_vectors ( n_icol , n_irow , n_linear_icol ,& n_linear_irow , n_linear_vals ) call me % sparsity % compute_indices () if ( me % partition_sparsity_pattern ) then call me % sparsity % dsm_wrapper ( me % n , me % m , info ) if ( info /= 1 ) then call me % raise_exception ( 21 , 'compute_sparsity_random_2' ,& 'error partitioning sparsity pattern.' ) return end if end if me % sparsity % sparsity_computed = . true . end subroutine compute_sparsity_random_2 !******************************************************************************* !******************************************************************************* !> !  Computes the sparsity pattern and return it. !  Uses the settings currently in the class. subroutine compute_sparsity_pattern ( me , x , irow , icol , linear_irow , linear_icol , linear_vals ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) integer , dimension (:), allocatable , intent ( out ) :: irow !! sparsity pattern nonzero elements row indices integer , dimension (:), allocatable , intent ( out ) :: icol !! sparsity pattern nonzero elements column indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_irow !! linear sparsity pattern !! nonzero elements row indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_icol !! linear sparsity pattern nonzero !! elements column indices real ( wp ), dimension (:), allocatable , intent ( out ), optional :: linear_vals !! linear sparsity values (constant !! elements of the Jacobian) if ( me % exception_raised ) return ! check for exceptions if ( associated ( me % compute_sparsity )) then call me % compute_sparsity ( x ) if ( me % exception_raised ) return ! check for exceptions call me % get_sparsity_pattern ( irow , icol , linear_irow , linear_icol , linear_vals ) end if end subroutine compute_sparsity_pattern !******************************************************************************* !******************************************************************************* !> !  Returns the sparsity pattern from the class. !  If it hasn't been computed, the output arrays will not be allocated. subroutine get_sparsity_pattern ( me , irow , icol ,& linear_irow , linear_icol , linear_vals ,& maxgrp , ngrp ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , dimension (:), allocatable , intent ( out ) :: irow !! sparsity pattern nonzero elements row indices integer , dimension (:), allocatable , intent ( out ) :: icol !! sparsity pattern nonzero elements column indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_irow !! linear sparsity pattern !! nonzero elements row indices integer , dimension (:), allocatable , intent ( out ), optional :: linear_icol !! linear sparsity pattern nonzero !! elements column indices real ( wp ), dimension (:), allocatable , intent ( out ), optional :: linear_vals !! linear sparsity values (constant !! elements of the Jacobian) integer , intent ( out ), optional :: maxgrp !! DSM sparsity partition integer , dimension (:), allocatable , intent ( out ), optional :: ngrp !! DSM sparsity partition if ( me % exception_raised ) return ! check for exceptions if ( allocated ( me % sparsity % irow ) . and . allocated ( me % sparsity % icol )) then irow = me % sparsity % irow icol = me % sparsity % icol end if ! optional linear pattern output: if ( present ( linear_irow )) then if ( allocated ( me % sparsity % linear_irow )) linear_irow = me % sparsity % linear_irow end if if ( present ( linear_icol )) then if ( allocated ( me % sparsity % linear_icol )) linear_icol = me % sparsity % linear_icol end if if ( present ( linear_vals )) then if ( allocated ( me % sparsity % linear_vals )) linear_vals = me % sparsity % linear_vals end if ! optional DSM partition: if ( present ( ngrp ) . and . allocated ( me % sparsity % ngrp )) ngrp = me % sparsity % ngrp if ( present ( maxgrp )) maxgrp = me % sparsity % maxgrp end subroutine get_sparsity_pattern !******************************************************************************* !******************************************************************************* !> !  just a wrapper for [[compute_jacobian]], that returns a dense (`m x n`) matrix. ! !@note This one will include the constant elements if the linear pattern is available. subroutine compute_jacobian_dense ( me , x , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:,:), allocatable , intent ( out ) :: jac !! the jacobian matrix real ( wp ), dimension (:), allocatable :: jac_vec !! sparse jacobian representation integer :: i !! counter if ( me % exception_raised ) return ! check for exceptions ! size output matrix: allocate ( jac ( me % m , me % n )) ! convert to dense form: jac = zero ! compute sparse form of jacobian: call me % compute_jacobian ( x , jac_vec ) if ( me % exception_raised ) return ! check for exceptions if ( allocated ( jac_vec )) then ! add the nonlinear elements: do i = 1 , me % sparsity % num_nonzero_elements jac ( me % sparsity % irow ( i ), me % sparsity % icol ( i )) = jac_vec ( i ) end do deallocate ( jac_vec ) end if ! add the constant elements if necessary: do i = 1 , me % sparsity % num_nonzero_linear_elements jac ( me % sparsity % linear_irow ( i ), me % sparsity % linear_icol ( i )) = me % sparsity % linear_vals ( i ) end do end subroutine compute_jacobian_dense !******************************************************************************* !******************************************************************************* !> !  Perturb the specified optimization variable, and compute the function. !  This routine is designed so that `df` is accumulated as each function !  evaluation is done, to avoid having to allocate more temporary storage. subroutine perturb_x_and_compute_f ( me , x , dx_factor , dx ,& df_factor , column , idx , df ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! nominal variable vector real ( wp ), intent ( in ) :: dx_factor !! factor to multiply `dx` real ( wp ), dimension (:), intent ( in ) :: dx !! the perturbation value for this column real ( wp ), intent ( in ) :: df_factor !! factor to multiply function value integer , intent ( in ) :: column !! the variable to perturb integer , dimension (:), intent ( in ) :: idx !! the elements in this !! column of the Jacobian !! to compute (passed to function) real ( wp ), dimension ( me % m ), intent ( inout ) :: df !! the accumulated function value !! note: for the first call, this !! should be set to zero real ( wp ), dimension ( me % n ) :: xp !! the perturbed variable vector real ( wp ), dimension ( me % m ) :: f !! function evaluation if ( me % exception_raised ) return ! check for exceptions xp = x if ( dx_factor /= zero ) xp ( column ) = xp ( column ) + dx_factor * dx ( column ) call me % compute_function ( xp , f , idx ) if ( me % exception_raised ) return ! check for exceptions df ( idx ) = df ( idx ) + df_factor * f ( idx ) end subroutine perturb_x_and_compute_f !******************************************************************************* !******************************************************************************* !> !  Returns the product `J*v`, where `J` is the `m x n` Jacobian matrix !  and `v` is an `n x 1` vector. ! !@note This one will include the constant elements if the linear pattern is available. subroutine compute_jacobian_times_vector ( me , x , v , z ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:), intent ( in ) :: v !! vector (size `n`) real ( wp ), dimension (:), intent ( out ) :: z !! The product `J*v` (size `m`) real ( wp ), dimension (:), allocatable :: jac !! sparse jacobian vector integer :: i !! counter integer :: r !! row number in full jacobian integer :: c !! column number in full jacobian if ( me % exception_raised ) return ! check for exceptions ! first compute the jacobian in sparse vector form: call me % compute_jacobian ( x , jac ) if ( me % exception_raised ) return ! check for exceptions ! initialize output vector: z = 0.0_wp if ( allocated ( jac )) then !   J    v   z !  ---   -   - !  X0X   X   X !  0X0 * X = X !  00X   X   X !  00X       X ! multiplication by input v: do i = 1 , me % sparsity % num_nonzero_elements r = me % sparsity % irow ( i ) c = me % sparsity % icol ( i ) z ( r ) = z ( r ) + jac ( i ) * v ( c ) end do deallocate ( jac ) end if ! linear elements if available: do i = 1 , me % sparsity % num_nonzero_linear_elements r = me % sparsity % linear_irow ( i ) c = me % sparsity % linear_icol ( i ) z ( r ) = z ( r ) + me % sparsity % linear_vals ( i ) * v ( c ) end do end subroutine compute_jacobian_times_vector !******************************************************************************* !******************************************************************************* !> !  Compute the Jacobian. ! !@note The output `jac` only includes the elements of the nonlinear Jacobian. !      If the constant elements are being handled separately (if the linear !      pattern is available), then those elements can be obtained by !      calling `get_sparsity_pattern` if required. subroutine compute_jacobian ( me , x , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:), allocatable , intent ( out ) :: jac !! sparse jacobian vector real ( wp ), dimension ( me % n ) :: dx !! absolute perturbation (>0) for each variable if ( me % exception_raised ) return ! check for exceptions ! if we don't have a sparsity pattern yet then compute it: ! [also computes the indices vector] if (. not . me % sparsity % sparsity_computed ) call me % compute_sparsity ( x ) if ( me % sparsity % num_nonzero_elements == 0 ) return ! size the jacobian vector: allocate ( jac ( me % sparsity % num_nonzero_elements )) ! compute dx vector: if (. not . me % use_diff ) then ! only need this for the finite difference methods (not diff) call me % compute_perturbation_vector ( x , dx ) if ( me % exception_raised ) return ! check for exceptions end if ! compute the jacobian: if ( associated ( me % jacobian_function )) then call me % jacobian_function ( x , dx , jac ) else call me % raise_exception ( 22 , 'compute_jacobian' ,& 'jacobian_function has not been associated.' ) return end if end subroutine compute_jacobian !******************************************************************************* !******************************************************************************* !> !  A separate version of [[compute_jacobian]] to be used only when !  computing the sparsity pattern in [[compute_sparsity_random_2]]. !  It uses `class_meths` and the sparsity dperts and bounds. ! !@note Based on [[compute_jacobian]]. The index manipulation here could be !      greatly simplified, since we realdy know we are computed all the !      elements in one column. subroutine compute_jacobian_for_sparsity ( me , i , class_meths , x , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: i !! the column being computed type ( meth_array ), intent ( in ) :: class_meths !! set of finite diff methods to use real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension (:), allocatable , intent ( out ) :: jac !! sparse jacobian vector real ( wp ), dimension ( me % n ) :: dx !! absolute perturbation (>0) for each variable integer , dimension (:), allocatable :: nonzero_elements_in_col !! the indices of the !! nonzero Jacobian !! elements in a column integer :: j !! function evaluation counter real ( wp ), dimension ( me % m ) :: df !! accumulated function type ( finite_diff_method ) :: fd !! a finite different method (when !! specifying class rather than the method) logical :: status_ok !! error flag integer :: num_nonzero_elements_in_col !! number of nonzero elements in a column if ( me % exception_raised ) return ! check for exceptions ! Note that a sparsity pattern has already been set ! size the jacobian vector: allocate ( jac ( me % sparsity % num_nonzero_elements )) ! compute the perturbation vector (really we only need dx(i)): call me % compute_sparsity_perturbation_vector ( x , dx ) if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero ! determine functions to compute for this column: num_nonzero_elements_in_col = count ( me % sparsity % icol == i ) if ( num_nonzero_elements_in_col /= 0 ) then ! there are functions to compute nonzero_elements_in_col = pack ( me % sparsity % irow , mask = me % sparsity % icol == i ) call me % select_finite_diff_method ( x ( i ), me % xlow_for_sparsity ( i ), me % xhigh_for_sparsity ( i ),& dx ( i ), class_meths , fd , status_ok ) if (. not . status_ok ) then if ( me % print_messages ) then write ( error_unit , '(A,1X,I5)' ) & 'Error in compute_jacobian_for_sparsity: variable bounds violated for column: ' , i end if end if ! compute this column of the Jacobian: df = zero do j = 1 , size ( fd % dx_factors ) if ( associated ( me % info_function )) call me % info_function ([ i ], j , x ) call me % perturb_x_and_compute_f ( x , fd % dx_factors ( j ),& dx , fd % df_factors ( j ),& i , nonzero_elements_in_col , df ) if ( me % exception_raised ) return ! check for exceptions end do df ( nonzero_elements_in_col ) = df ( nonzero_elements_in_col ) / & ( fd % df_den_factor * dx ( i )) ! put result into the output vector: jac ( pack ( me % sparsity % indices , mask = me % sparsity % icol == i )) = & df ( nonzero_elements_in_col ) end if end subroutine compute_jacobian_for_sparsity !******************************************************************************* !******************************************************************************* !> !  Compute the Jacobian using finite differences. !  (one column at a time) subroutine compute_jacobian_standard ( me , x , dx , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) !! for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector (size !! `num_nonzero_elements`) integer , dimension (:), allocatable :: nonzero_elements_in_col !! the indices of the !! nonzero Jacobian !! elements in a column integer :: i !! column counter integer :: j !! function evaluation counter real ( wp ), dimension ( me % m ) :: df !! accumulated function type ( finite_diff_method ) :: fd !! a finite different method (when !! specifying class rather than the method) logical :: status_ok !! error flag integer :: num_nonzero_elements_in_col !! number of nonzero elements in a column if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero ! compute Jacobian matrix column-by-column: do i = 1 , me % n ! determine functions to compute for this column: num_nonzero_elements_in_col = count ( me % sparsity % icol == i ) if ( num_nonzero_elements_in_col /= 0 ) then ! there are functions to compute nonzero_elements_in_col = pack ( me % sparsity % irow , mask = me % sparsity % icol == i ) select case ( me % mode ) case ( 1 ) ! use the specified methods ! compute this column of the Jacobian: df = zero do j = 1 , size ( me % meth ( i )% dx_factors ) if ( associated ( me % info_function )) call me % info_function ([ i ], j , x ) call me % perturb_x_and_compute_f ( x , me % meth ( i )% dx_factors ( j ),& dx , me % meth ( i )% df_factors ( j ),& i , nonzero_elements_in_col , df ) if ( me % exception_raised ) return ! check for exceptions end do df ( nonzero_elements_in_col ) = df ( nonzero_elements_in_col ) / & ( me % meth ( i )% df_den_factor * dx ( i )) case ( 2 ) ! select the method from the class so as not to violate the bounds call me % select_finite_diff_method ( x ( i ), me % xlow ( i ), me % xhigh ( i ),& dx ( i ), me % class_meths ( i ), fd , status_ok ) if (. not . status_ok ) then if ( me % print_messages ) then write ( error_unit , '(A,1X,I5)' ) & 'Error in compute_jacobian_standard: variable bounds violated for column: ' , i end if end if ! compute this column of the Jacobian: df = zero do j = 1 , size ( fd % dx_factors ) if ( associated ( me % info_function )) call me % info_function ([ i ], j , x ) call me % perturb_x_and_compute_f ( x , fd % dx_factors ( j ),& dx , fd % df_factors ( j ),& i , nonzero_elements_in_col , df ) if ( me % exception_raised ) return ! check for exceptions end do df ( nonzero_elements_in_col ) = df ( nonzero_elements_in_col ) / & ( fd % df_den_factor * dx ( i )) case default call me % raise_exception ( 23 , 'compute_jacobian_standard' ,& 'invalid mode' ) return end select ! put result into the output vector: jac ( pack ( me % sparsity % indices , mask = me % sparsity % icol == i )) = & df ( nonzero_elements_in_col ) end if end do end subroutine compute_jacobian_standard !******************************************************************************* !******************************************************************************* !> !  Compute the Jacobian one element at a time using the Neville's process !  algorithm [[diff]]. This takes a very large number of function evaluations, !  but should give a very accurate answer. subroutine compute_jacobian_with_diff ( me , x , dx , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) !! for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector (size !! `num_nonzero_elements`) integer , parameter :: iord = 1 !! tells [[diff]] to compute first derivative integer :: i !! counter for nonzero elements of jacobian type ( diff_func ) :: d !! the [[diff]] class to use real ( wp ) :: x0 !! value of ith variable for [[diff]] real ( wp ) :: xmin !! ith variable lower bound real ( wp ) :: xmax !! ith variable upper bound real ( wp ) :: deriv !! derivative value df/dx from [[diff]] real ( wp ) :: error !! estimated error from [[diff]] integer :: ifail !! [[diff]] error flag real ( wp ), dimension ( me % n ) :: xp !! used by [[dfunc]]. real ( wp ), dimension ( me % m ) :: fvec !! used by [[dfunc]]. integer :: ir !! row index of next non-zero element integer :: ic !! column index of next non-zero element integer :: ic_prev !! previous column perturbed integer :: icount !! count of number of times a column has been perturbed logical :: use_info !! if we are reporting to the user if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero use_info = associated ( me % info_function ) if ( use_info ) ic_prev = - 1 ! set the function for diff: call d % set_function ( dfunc ) ! each element is computed one by one do i = 1 , me % sparsity % num_nonzero_elements ir = me % sparsity % irow ( i ) ic = me % sparsity % icol ( i ) x0 = x ( ic ) xmin = me % xlow ( ic ) xmax = me % xhigh ( ic ) ! if reporting to the user, have to keep track ! of which column is being perturbed, and how ! many times: if ( use_info ) then if ( ic /= ic_prev ) icount = 0 end if call d % compute_derivative ( iord , x0 , xmin , xmax , me % eps , me % acc , deriv , error , ifail ) if ( ifail == 0 . or . ifail == 1 ) then jac ( i ) = deriv else if ( ifail == - 1 ) then ! this indicates an exception was ! already raised, so just return. return else call me % raise_exception ( 24 , 'compute_jacobian_with_diff' ,& 'error computing derivative with DIFF.' ) return end if if ( use_info ) ic_prev = ic end do contains function dfunc ( this , xval ) result ( fx ) !! interface to user function for [[diff]] routine. implicit none class ( diff_func ), intent ( inout ) :: this real ( wp ), intent ( in ) :: xval !! input variable (`ic` variable) real ( wp ) :: fx !! derivative of `ir` function !! w.r.t. `xval` variable if ( use_info ) then icount = icount + 1 call me % info_function ([ ic ], icount , x ) end if xp = x xp ( ic ) = xval call me % compute_function ( xp , fvec , funcs_to_compute = [ ir ]) if ( me % exception_raised ) then ! check for exceptions fx = 0.0_wp call me % terminate () else fx = fvec ( ir ) end if end function dfunc end subroutine compute_jacobian_with_diff !******************************************************************************* !******************************************************************************* !> !  Compute the Jacobian using finite differences, !  (using the partitioned sparsity pattern to compute multiple columns !  at a time). subroutine compute_jacobian_partitioned ( me , x , dx , jac ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dx !! absolute perturbation (>0) for each variable real ( wp ), dimension (:), intent ( out ) :: jac !! sparse jacobian vector integer :: i !! column counter integer :: j !! function evaluation counter integer :: igroup !! group number counter integer :: n_cols !! number of columns in a group integer , dimension (:), allocatable :: cols !! array of column indices in a group integer , dimension (:), allocatable :: nonzero_rows !! the indices of the nonzero Jacobian !! elementes (row numbers) in a group integer , dimension (:), allocatable :: indices !! nonzero indices in `jac` for a group integer , dimension (:), allocatable :: col_indices !! nonzero indices in `jac` for a column real ( wp ), dimension ( me % m ) :: df !! accumulated function type ( finite_diff_method ) :: fd !! a finite different method (when !! specifying class rather than the method) logical :: status_ok !! error flag integer :: num_nonzero_elements_in_col if ( me % exception_raised ) return ! check for exceptions ! initialize: jac = zero ! compute by group: do igroup = 1 , me % sparsity % maxgrp ! get the columns in this group: call me % sparsity % columns_in_partition_group ( igroup , n_cols , cols ,& nonzero_rows , indices , status_ok ) if (. not . status_ok ) then call me % raise_exception ( 25 , 'compute_jacobian_partitioned' ,& 'the partition has not been computed.' ) return end if if ( n_cols > 0 ) then if ( allocated ( nonzero_rows )) then select case ( me % mode ) case ( 1 ) ! use the specified methods ! note: all the methods must be the same within a group ! compute the columns of the Jacobian in this group: df = zero do j = 1 , size ( me % meth ( 1 )% dx_factors ) if ( associated ( me % info_function )) call me % info_function ( cols , j , x ) call me % perturb_x_and_compute_f_partitioned ( x , me % meth ( 1 )% dx_factors ( j ),& dx , me % meth ( 1 )% df_factors ( j ),& cols , nonzero_rows , df ) if ( me % exception_raised ) return ! check for exceptions end do ! divide by the denominator, which can be different for each column: do i = 1 , n_cols num_nonzero_elements_in_col = count ( me % sparsity % icol == cols ( i )) if ( allocated ( col_indices )) deallocate ( col_indices ) allocate ( col_indices ( num_nonzero_elements_in_col )) col_indices = pack ( me % sparsity % indices , mask = me % sparsity % icol == cols ( i )) df ( me % sparsity % irow ( col_indices )) = df ( me % sparsity % irow ( col_indices )) / & ( me % meth ( 1 )% df_den_factor * dx ( cols ( i ))) end do case ( 2 ) ! select the method from the class so as not to violate ! the bounds on *any* of the variables in the group ! note: all the classes must be the same within a group call me % select_finite_diff_method_for_partition_group ( & x ( cols ), me % xlow ( cols ), me % xhigh ( cols ),& dx ( cols ), me % class_meths ( 1 ), fd , status_ok ) if (. not . status_ok ) then if ( me % print_messages ) then ! will not consider this a fatal error for now: write ( error_unit , '(A,1X,I5,1X,A,1X,*(I5,1X))' ) & 'Error in compute_jacobian_partitioned: ' // & 'variable bounds violated for group: ' ,& igroup , '. columns: ' , cols end if end if ! compute the columns of the Jacobian in this group: df = zero do j = 1 , size ( fd % dx_factors ) if ( associated ( me % info_function )) call me % info_function ( cols , j , x ) call me % perturb_x_and_compute_f_partitioned ( x , fd % dx_factors ( j ),& dx , fd % df_factors ( j ),& cols , nonzero_rows , df ) if ( me % exception_raised ) return ! check for exceptions end do ! divide by the denominator, which can be different for each column: do i = 1 , n_cols num_nonzero_elements_in_col = count ( me % sparsity % icol == cols ( i )) if ( allocated ( col_indices )) deallocate ( col_indices ) allocate ( col_indices ( num_nonzero_elements_in_col )) col_indices = pack ( me % sparsity % indices , mask = me % sparsity % icol == cols ( i )) df ( me % sparsity % irow ( col_indices )) = df ( me % sparsity % irow ( col_indices )) / & ( fd % df_den_factor * dx ( cols ( i ))) end do case default call me % raise_exception ( 26 , 'compute_jacobian_partitioned' , 'invalid mode' ) return end select ! put result into the output vector: jac ( indices ) = df ( nonzero_rows ) end if end if end do end subroutine compute_jacobian_partitioned !******************************************************************************* !******************************************************************************* !> !  Perturb the specified optimization variable, and compute the function. !  This routine is designed so that `df` is accumulated as each function !  evaluation is done, to avoid having to allocate more temporary storage. subroutine perturb_x_and_compute_f_partitioned ( me , x , dx_factor , dx ,& df_factor , columns , idx , df ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! nominal variable vector real ( wp ), intent ( in ) :: dx_factor !! factor to multiply `dx` real ( wp ), dimension (:), intent ( in ) :: dx !! the perturbation value for this column real ( wp ), intent ( in ) :: df_factor !! factor to multiply function value integer , dimension (:), intent ( in ) :: columns !! the variables to perturb integer , dimension (:), intent ( in ) :: idx !! the elements in this !! column of the Jacobian !! to compute (passed to function) real ( wp ), dimension ( me % m ), intent ( inout ) :: df !! the accumulated function value !! note: for the first call, this !! should be set to zero real ( wp ), dimension ( me % n ) :: xp !! the perturbed variable vector real ( wp ), dimension ( me % m ) :: f !! function evaluation if ( me % exception_raised ) return ! check for exceptions xp = x if ( dx_factor /= zero ) xp ( columns ) = xp ( columns ) + dx_factor * dx ( columns ) call me % compute_function ( xp , f , idx ) if ( me % exception_raised ) return ! check for exceptions df ( idx ) = df ( idx ) + df_factor * f ( idx ) end subroutine perturb_x_and_compute_f_partitioned !******************************************************************************* !******************************************************************************* !> !  Compute `dx`, the perturbation vector for `x` subroutine compute_perturb_vector ( me , x , dpert , perturb_mode , dx ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( in ) :: dpert integer , intent ( in ) :: perturb_mode real ( wp ), dimension ( me % n ), intent ( out ) :: dx !! absolute perturbation (>0) !! for each variable real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) !! the smallest allowed absolute step if ( me % exception_raised ) return ! check for exceptions select case ( perturb_mode ) case ( 1 ) dx = abs ( dpert ) case ( 2 ) dx = abs ( dpert * x ) case ( 3 ) dx = abs ( dpert ) * ( 1.0_wp + abs ( x )) case default call me % raise_exception ( 27 , 'compute_perturb_vector' ,& 'invalid value for perturb_mode (must be 1, 2, or 3)' ) return end select ! make sure none are too small: where ( dx < eps ) dx = eps end where end subroutine compute_perturb_vector !******************************************************************************* !******************************************************************************* !> !  Compute `dx`, the perturbation vector for `x` used !  when computing the gradients. subroutine compute_perturbation_vector ( me , x , dx ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( out ) :: dx !! absolute perturbation (>0) !! for each variable if ( me % exception_raised ) return ! check for exceptions call me % compute_perturb_vector ( x , me % dpert , me % perturb_mode , dx ) end subroutine compute_perturbation_vector !******************************************************************************* !******************************************************************************* !> !  Compute `dx`, the perturbation vector for `x` used !  when computing the sparsity pattern. subroutine compute_sparsity_perturbation_vector ( me , x , dx ) implicit none class ( numdiff_type ), intent ( inout ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: x !! vector of variables (size `n`) real ( wp ), dimension ( me % n ), intent ( out ) :: dx !! absolute perturbation (>0) !! for each variable if ( me % exception_raised ) return ! check for exceptions call me % compute_perturb_vector ( x , me % dpert_for_sparsity , me % sparsity_perturb_mode , dx ) end subroutine compute_sparsity_perturbation_vector !******************************************************************************* !******************************************************************************* !> !  Print the sparsity pattern. subroutine print_sparsity ( me , n , m , iunit , dense ) implicit none class ( sparsity_pattern ), intent ( in ) :: me integer , intent ( in ) :: n !! number of variables (columns of jacobian) integer , intent ( in ) :: m !! number of functions (rows of jacobian) integer , intent ( in ) :: iunit !! file unit to write to. !! (assumed to be already opened) logical , intent ( in ), optional :: dense !! if present and true, the matrix form !! of the sparsity pattern is printed !! (default is vector form) logical :: print_matrix !! if the matrix form is to be printed integer :: r !! row counter character ( len = 1 ), dimension ( n ) :: row !! a row of the sparsity matrix if ( present ( dense )) then print_matrix = dense else print_matrix = . false . ! default end if write ( iunit , '(A)' ) '---Sparsity pattern---' if ( allocated ( me % irow ) . and . allocated ( me % icol )) then if ( print_matrix ) then do r = 1 , m ! print by row row = '0' row ( pack ( me % icol , mask = me % irow == r )) = 'X' write ( iunit , '(*(A1))' ) row end do else write ( iunit , '(A,1X,*(I3,\",\"))' ) 'irow:' , me % irow write ( iunit , '(A,1X,*(I3,\",\"))' ) 'icol:' , me % icol end if if ( allocated ( me % ngrp )) then write ( iunit , '(A)' ) '' write ( iunit , '(A)' ) '---Sparsity partition---' write ( iunit , '(A,1x,I5)' ) 'Number of groups:' , me % maxgrp write ( iunit , '(A,1x,*(I5,1X))' ) 'Group array:     ' , me % ngrp end if end if write ( iunit , '(A)' ) '' ! print linear pattern if available if ( me % linear_sparsity_computed ) then write ( iunit , '(A)' ) '---Linear sparsity pattern---' if ( allocated ( me % linear_icol ) . and . allocated ( me % linear_irow )) then if ( print_matrix ) then do r = 1 , m ! print by row row = '0' row ( pack ( me % linear_icol , mask = me % linear_irow == r )) = 'X' write ( iunit , '(*(A1))' ) row end do else write ( iunit , '(A,1X,*(I3,\",\"))' ) 'irow:' , me % linear_irow write ( iunit , '(A,1X,*(I3,\",\"))' ) 'icol:' , me % linear_icol write ( iunit , '(A,1X,*(E30.16,\",\"))' ) 'vals:' , me % linear_vals end if end if write ( iunit , '(A)' ) '' end if end subroutine print_sparsity !******************************************************************************* !******************************************************************************* !> !  Print the sparsity pattern in vector form (`irow`, `icol`). subroutine print_sparsity_pattern ( me , iunit ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: iunit !! file unit to write to. !! (assumed to be already opened) call me % sparsity % print ( me % n , me % m , iunit , dense = . false .) end subroutine print_sparsity_pattern !******************************************************************************* !******************************************************************************* !> !  Print the sparsity pattern in matrix form. subroutine print_sparsity_matrix ( me , iunit ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: iunit !! file unit to write to. !! (assumed to be already opened) call me % sparsity % print ( me % n , me % m , iunit , dense = . true .) end subroutine print_sparsity_matrix !******************************************************************************* !******************************************************************************* !> !  A user-callable routine. When called, it will terminate !  all computations and return. The `istat` return code will be !  set to `-1`. This can be called in the function or the info function. subroutine terminate ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me if ( me % exception_raised ) return ! check for existing exceptions me % istat = - 1 me % error_msg = 'Terminated by the user' me % exception_raised = . true . end subroutine terminate !******************************************************************************* !******************************************************************************* !> !  Raise an exception. subroutine raise_exception ( me , istat , routine , error_msg ) implicit none class ( numdiff_type ), intent ( inout ) :: me integer , intent ( in ) :: istat !! error code. character ( len =* ), intent ( in ) :: routine !! the routine where the error was raised. character ( len =* ), intent ( in ) :: error_msg !! error message string. me % istat = istat me % error_msg = 'Error in ' // trim ( routine ) // ' : ' // trim ( error_msg ) me % exception_raised = . true . end subroutine raise_exception !******************************************************************************* !******************************************************************************* !> !  Clear all exceptions. subroutine clear_exceptions ( me ) implicit none class ( numdiff_type ), intent ( inout ) :: me me % istat = 0 if ( allocated ( me % error_msg )) deallocate ( me % error_msg ) me % exception_raised = . false . end subroutine clear_exceptions !******************************************************************************* !******************************************************************************* !> !  Returns True if an exception has been raised. pure logical function failed ( me ) implicit none class ( numdiff_type ), intent ( in ) :: me failed = me % exception_raised end function failed !******************************************************************************* !******************************************************************************* !> !  Returns the current error code and message. subroutine get_error_status ( me , istat , error_msg ) implicit none class ( numdiff_type ), intent ( in ) :: me integer , intent ( out ), optional :: istat !! error code (`istat=0` means no errors). character ( len = :), allocatable , intent ( out ), optional :: error_msg !! error message string. if ( present ( istat )) istat = me % istat if ( present ( error_msg )) then if ( allocated ( me % error_msg )) then error_msg = me % error_msg else error_msg = '' end if end if end subroutine get_error_status !******************************************************************************* !******************************************************************************* !> !  Convert an integer to a string. function integer_to_string ( i , with_sign ) result ( str ) implicit none integer , intent ( in ) :: i !! the integer logical , intent ( in ), optional :: with_sign !! also include the sign (default is False) character ( len = :), allocatable :: str !! integer converted to a string integer :: istat !! `iostat` code for write statement character ( len = 100 ) :: tmp !! logical :: sgn !! local copy of `with_sign` if ( present ( with_sign )) then sgn = with_sign else sgn = . false . end if if ( sgn ) then write ( tmp , '(SP,I100)' , iostat = istat ) i else write ( tmp , '(I100)' , iostat = istat ) i end if if ( istat == 0 ) then str = trim ( adjustl ( tmp )) else str = '****' end if end function integer_to_string !******************************************************************************* !******************************************************************************* end module numerical_differentiation_module !*******************************************************************************","tags":"","loc":"sourcefile/numerical_differentiation_module.f90.html"},{"title":"lusol_ez.f90 – AoC-2023","text":"This file depends on sourcefile~~lusol_ez.f90~~EfferentGraph sourcefile~lusol_ez.f90 lusol_ez.f90 sourcefile~lusol.f90 lusol.f90 sourcefile~lusol_ez.f90->sourcefile~lusol.f90 sourcefile~lusol_precision.f90 lusol_precision.F90 sourcefile~lusol_ez.f90->sourcefile~lusol_precision.f90 sourcefile~lusol.f90->sourcefile~lusol_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~lusol_ez.f90~~AfferentGraph sourcefile~lusol_ez.f90 lusol_ez.f90 sourcefile~lusol_test.f90 lusol_test.f90 sourcefile~lusol_test.f90->sourcefile~lusol_ez.f90 sourcefile~nlesolver_module.f90 nlesolver_module.F90 sourcefile~nlesolver_module.f90->sourcefile~lusol_ez.f90 sourcefile~nlesolver_test_1.f90 nlesolver_test_1.f90 sourcefile~nlesolver_test_1.f90->sourcefile~nlesolver_module.f90 sourcefile~sparse_test.f90 sparse_test.f90 sourcefile~sparse_test.f90->sourcefile~nlesolver_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  Wrapper for LUSOL. Will eventually be moved into a separate repo. module lusol_ez_module use lusol , only : lu1fac , lu6sol use lusol_precision , only : ip , rp implicit none private type , public :: lusol_settings integer ( ip ) :: nout = 6 integer ( ip ) :: lprint = 0 integer ( ip ) :: maxcol = 5 integer ( ip ) :: method = 0 ! TPP integer ( ip ) :: keepLU = 1 real ( rp ) :: Ltol1 = 10 0.0_rp real ( rp ) :: Ltol2 = 1 0.0_rp real ( rp ) :: small = epsilon ( 1.0_rp ) ** 0.8_rp real ( rp ) :: Utol1 = epsilon ( 1.0_rp ) ** 0.67_rp real ( rp ) :: Utol2 = epsilon ( 1.0_rp ) ** 0.67_rp real ( rp ) :: Uspace = 3.0_rp real ( rp ) :: dens1 = 0.3_rp real ( rp ) :: dens2 = 0.5_rp integer ( ip ) :: mode = 5 ! for [[lu6sol]] : `w` solves `A w = v`. end type lusol_settings public :: solve contains !***************************************************************************************** !***************************************************************************************** !> !  Wrapper for [[lu1fac]] + [[lu6sol]] to solve a linear system `A*x = b`. subroutine solve ( n_cols , n_rows , n_nonzero , irow , icol , mat , b , x , istat , settings ) integer , intent ( in ) :: n_cols !! `n`: number of columns in A. integer , intent ( in ) :: n_rows !! `m`: number of rows in A. integer , intent ( in ) :: n_nonzero !! number of nonzero elements of A. integer , dimension ( n_nonzero ), intent ( in ) :: irow , icol !! sparsity pattern (size is `n_nonzero`) real ( rp ), dimension ( n_nonzero ), intent ( in ) :: mat !! matrix elements (size is `n_nonzero`) real ( rp ), dimension ( n_rows ), intent ( in ) :: b !! right hand side (size is `m`) real ( rp ), dimension ( n_cols ), intent ( out ) :: x !! solution !size is `n` integer , intent ( out ) :: istat !! status code type ( lusol_settings ), intent ( in ), optional :: settings !! settings (if not present, defaults are used) integer ( ip ) :: nelem , n , m integer ( ip ) :: lena real ( rp ), dimension (:), allocatable :: a integer ( ip ), dimension (:), allocatable :: indc integer ( ip ), dimension (:), allocatable :: indr real ( rp ), dimension (:), allocatable :: ww real ( rp ), dimension (:), allocatable :: w real ( rp ), dimension (:), allocatable :: v integer ( ip ) :: inform integer ( ip ) :: luparm ( 30 ) real ( rp ) :: parmlu ( 30 ) integer ( ip ), dimension (:), allocatable :: p , q , & lenc , lenr , & iploc , iqloc , & ipinv , iqinv , & locc , locr type ( lusol_settings ) :: options if ( present ( settings )) options = settings ! use user-supplied settings n = n_cols m = n_rows nelem = n_nonzero lena = 1 + max ( 2 * nelem , 10 * m , 10 * n , 10000 ) allocate ( a ( lena )) allocate ( indc ( lena )) allocate ( indr ( lena )) associate ( n => n_cols , m => n_rows ) allocate ( p ( m ), q ( n ), lenc ( n ), lenr ( m ), & iploc ( n ), iqloc ( m ), ipinv ( m ), & iqinv ( n ), locc ( n ) , locr ( m )) allocate ( ww ( n )) allocate ( w ( n )) ! x allocate ( v ( m )) ! b end associate a = 0 ; indc = 0 ; indr = 0 a ( 1 : nelem ) = mat indc ( 1 : nelem ) = irow indr ( 1 : nelem ) = icol ! settings luparm = 0 luparm ( 1 ) = options % nout luparm ( 2 ) = options % lprint luparm ( 3 ) = options % maxcol luparm ( 6 ) = options % method luparm ( 8 ) = options % keepLU parmlu = 0 parmlu ( 1 ) = options % Ltol1 parmlu ( 2 ) = options % Ltol2 parmlu ( 3 ) = options % small parmlu ( 4 ) = options % Utol1 parmlu ( 5 ) = options % Utol2 parmlu ( 6 ) = options % Uspace parmlu ( 7 ) = options % dens1 parmlu ( 8 ) = options % dens2 call lu1fac ( m , n , nelem , lena , luparm , parmlu , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & iploc , iqloc , ipinv , iqinv , ww , inform ) !write(*,*) 'lu1fac inform = ', inform !  inform = 0 if the LU factors were obtained successfully. !         = 1 if U appears to be singular, as judged by lu6chk. !         = 3 if some index pair indc(l), indr(l) lies outside !             the matrix dimensions 1:m , 1:n. !         = 4 if some index pair indc(l), indr(l) duplicates !             another such pair. !         = 7 if the arrays a, indc, indr were not large enough. !             Their length \"lena\" should be increase to at least !             the value \"minlen\" given in luparm(13). !         = 8 if there was some other fatal error.  (Shouldn't happen!) !         = 9 if no diagonal pivot could be found with TSP or TDP. !             The matrix must not be sufficiently definite !             or quasi-definite. !         =10 if there was some other fatal error. v = b ! right hand side ! solve `A w = v`. call lu6sol ( options % mode , m , n , v , w , & lena , luparm , parmlu , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & inform ) !write(*,*) 'lu6sol inform = ', inform ! On exit, inform = 0 except as follows. ! If mode = 3,4,5,6 and if U (and hence A) is singular, then ! inform = 1 if there is a nonzero residual in solving the system ! involving U.  parmlu(20) returns the norm of the residual. x = w ! solution istat = int ( inform ) end subroutine solve !***************************************************************************************** !***************************************************************************************** end module lusol_ez_module !*****************************************************************************************","tags":"","loc":"sourcefile/lusol_ez.f90.html"},{"title":"test.f90 – AoC-2023","text":"This file depends on sourcefile~~test.f90~~EfferentGraph sourcefile~test.f90 test.f90 sourcefile~fmin_module.f90 fmin_module.F90 sourcefile~test.f90->sourcefile~fmin_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  Tests for [[fmin_module]]. program test use fmin_module , wp => fmin_rk real ( wp ) :: ax , bx , xmin , xerr , x real ( wp ), parameter :: pi = acos ( - 1.0_wp ) real ( wp ), parameter :: tol = 1.0e-8_wp ax = - 4.0_wp bx = 0.0_wp x = - pi / 2.0_wp ! actual answer xmin = fmin ( func , ax , bx , tol ) xerr = xmin - x ! difference from try value write ( * , * ) 'xmin       = ' , xmin write ( * , * ) 'xmin exact = ' , x write ( * , * ) 'xmin error = ' , xerr if ( abs ( xerr ) > 1 0.0_wp * tol ) then error stop 'test failed' end if contains !***************************************************************************************** !***************************************************************************************** !> !  Test function to minimize. function func ( x ) result ( f ) implicit none real ( wp ), intent ( in ) :: x !! indep. variable real ( wp ) :: f !! function value `f(x)` f = sin ( x ) end function func !***************************************************************************************** !***************************************************************************************** end program test !*****************************************************************************************","tags":"","loc":"sourcefile/test.f90.html"},{"title":"lusol.f90 – AoC-2023","text":"This file depends on sourcefile~~lusol.f90~~EfferentGraph sourcefile~lusol.f90 lusol.f90 sourcefile~lusol_precision.f90 lusol_precision.F90 sourcefile~lusol.f90->sourcefile~lusol_precision.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~lusol.f90~~AfferentGraph sourcefile~lusol.f90 lusol.f90 sourcefile~lusol_ez.f90 lusol_ez.f90 sourcefile~lusol_ez.f90->sourcefile~lusol.f90 sourcefile~lusol_test.f90 lusol_test.f90 sourcefile~lusol_test.f90->sourcefile~lusol_ez.f90 sourcefile~nlesolver_module.f90 nlesolver_module.F90 sourcefile~nlesolver_module.f90->sourcefile~lusol_ez.f90 sourcefile~nlesolver_test_1.f90 nlesolver_test_1.f90 sourcefile~nlesolver_test_1.f90->sourcefile~nlesolver_module.f90 sourcefile~sparse_test.f90 sparse_test.f90 sourcefile~sparse_test.f90->sourcefile~nlesolver_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! File:       lusol.f90 ! ! Contains    lu1fac   lu1fad   lu1gau   lu1mar   lu1mRP   lu1mCP   lu1mSP ! Contains    lu1pen   lu1mxc   lu1mxr   lu1or1   lu1or2   lu1or3   lu1or4 ! Contains    lu1pq1   lu1pq2   lu1pq3   lu1rec   lu1slk !             lu1ful   lu1DPP   lu1DCP ! Contains    Hbuild   Hchange  Hdelete  Hdown    Hinsert  Hup ! Contains    lu6sol   lu6L     lu6Lt    lu6U     Lu6Ut    lu6LD    lu6chk ! Contains    lu7add   lu7cyc   lu7elm   lu7for   lu7rnk   lu7zap ! Contains    lu8rpc ! ! Contains    jdamax ! ! This file is an f90 version of most parts of the f77 sparse LU package LUSOL ! (the parts needed by MINOS, SQOPT and SNOPT).  The parts included are ! !    lusol1.f    Factor a given matrix A from scratch (lu1fac). !    lusol2.f    Heap-management routines for lu1fac. !    lusol6a.f   Solve with the current LU factors. !    lusol7a.f   Utilities for all update routines. !    lusol8a.f   Replace a column (Bartels-Golub update). ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Had to change ip, iq to p, q to avoid clash with ip, rp. ! 17 Dec 2011: BLAS idamax replaced by private jdamax (taken from sn17util.f90). !              Note: jdamax( lencol, a(k,k), 1 ) has to become !                    jdamax( lencol,a(k:m,k),1 ) ! 03 Feb 2012: It's ok to have a(k,k) above, but a(k:m) is more illuminating. ! 03 Feb 2012: Bug fixed in lu1DPP and lu1DCP (translation of call daxpy). ! 09 Mar 2013: Begin project for improving efficiency of TRP. !              Mostly this needs a new version of lu1mxr. !              Ding Ma and Michael Saunders, Stanford University. ! 03 Apr 2013: New lu1mxr finds max element Amaxr(i) in each modified row i !              much more efficiently.  Three new local arrays needed: !              markc(n) and markr(m) in lu1fad, and cols(n) in lu1mxr. !              This is easy in f90. ! 28 Sep 2015: lu1fad: Change 2 * lenD to 3 * lenD for safety. ! 13 Nov 2015: lu6chk: Remove resetting of Utol1 for TRP !              to prevent slacks replacing slacks when DUmax is big. ! 12 Dec 2015: lu1slk called before lu1fad to set nslack. !              lu1fad grabs slacks first during Utri. ! 13 Dec 2015: lu1mxc now handles empty columns correctly. ! 20 Dec 2015: lu1rec returns ilast as output parameter. ! 21 Dec 2015: lu1DCP exits if aijmax <= small. ! 20 Jan 2016: sn28lusol.f90 updated to match sn27lu.f of 21 Dec 2015. ! 25 Jan 2016: Module snConstants replaced by local zero, one, i1. ! 27 Jan 2016: i2 is another local constant. !              NOTE: Local function jdamax is like a BLAS routine, !              but no BLAS routines are used in this f90 version of LUSOL. !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ module lusol use lusol_precision , only : ip , rp implicit none private public :: lu1fac , lu6sol , lu8rpc private :: jdamax intrinsic :: abs , int , max , min , real integer ( ip ), parameter :: i1 = 1 , i2 = 2 real ( rp ), parameter :: zero = 0.0 , one = 1.0 contains !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! History from lusol1.f ! ! 26 Apr 2002: TCP implemented using heap data structure. ! 01 May 2002: lu1DCP implemented. ! 07 May 2002: lu1mxc must put 0.0 at top of empty columns. ! 09 May 2002: lu1mCP implements Markowitz with cols searched !              in heap order. !              Often faster (searching 20 or 40 cols) but more dense. ! 11 Jun 2002: TRP implemented. !              lu1mRP implements Markowitz with Threshold Rook Pivoting. !              lu1mxc maintains max col elements.  (Previously lu1max.) !              lu1mxr maintains max row elements. ! 12 Jun 2002: lu1mCP seems too slow on big problems (e.g. memplus). !              Disabled it for the moment.  (Use lu1mar + TCP.) ! 14 Dec 2002: TSP implemented. !              lu1mSP implements Markowitz with !              Threshold Symmetric Pivoting. ! 07 Mar 2003: character*1, character*2 changed to f90 form. !              Comments changed from * in column to ! in column 1. !              Comments kept within column 72 to avoid compiler warning. ! 19 Dec 2004: Hdelete(...) has new input argument Hlenin. ! 21 Dec 2004: Print Ltol and Lmax with e10.2 instead of e10.1. ! 26 Mar 2006: lu1fad: Ignore nsing from lu1ful. !              lu1DPP: nsing redefined (but not used by lu1fad). !              lu1DCP: nsing redefined (but not used by lu1fad). ! 13 Dec 2015: lu1mxc bug on empty cols (setting a(lc) = 0.0). !              TRO11X3 starts with col 57 containing two nonzeros = 1e-18. !              col 58 is already empty, so col 59 (a slack -1.0) got incorrectly !              changed to 0.0.  This explains Matlab error on data with empty cols. !              lu1mxc fixed.  TRP and TCP ok now on TRO11X3. ! 20 Jan 2016: Current version of lusol1.f90. !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1fac ( m , n , nelem , lena , luparm , parmlu , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & iploc , iqloc , ipinv , iqinv , w , inform ) integer ( ip ), intent ( in ) :: m , n , nelem , lena integer ( ip ), intent ( inout ) :: luparm ( 30 ) integer ( ip ), intent ( inout ) :: indc ( lena ), indr ( lena ), & p ( m ) , q ( n ) , & lenc ( n ) , lenr ( m ) , & iploc ( n ) , iqloc ( m ) , & ipinv ( m ) , iqinv ( n ) , & locc ( n ) , locr ( m ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), a ( lena ), w ( n ) integer ( ip ), intent ( out ) :: inform !------------------------------------------------------------------ ! lu1fac computes a factorization A = L*U, where A is a sparse ! matrix with m rows and n columns, P*L*P' is lower triangular ! and P*U*Q is upper triangular for certain permutations P, Q ! (which are returned in the arrays p, q). ! Stability is ensured by limiting the size of the elements of L. ! ! The nonzeros of A are input via the parallel arrays a, indc, indr, ! which should contain nelem entries of the form    aij,    i,    j ! in any order.  There should be no duplicate pairs         i,    j. ! ! ****************************************************************** ! *        Beware !!!   The row indices i must be in indc,         * ! *              and the column indices j must be in indr.         * ! *              (Not the other way round!)                        * ! ****************************************************************** ! ! It does not matter if some of the entries in a(*) are zero. ! Entries satisfying  abs( a(i) ) .le. parmlu(3)  are ignored. ! Other parameters in luparm and parmlu are described below. ! ! The matrix A may be singular.  On exit, nsing = luparm(11) gives ! the number of apparent singularities.  This is the number of ! \"small\" diagonals of the permuted factor U, as judged by ! the input tolerances Utol1 = parmlu(4) and  Utol2 = parmlu(5). ! The diagonal element diagj associated with column j of A is ! \"small\" if !                 abs( diagj ) .le. Utol1 ! or !                 abs( diagj ) .le. Utol2 * max( uj ), ! ! where max( uj ) is the maximum element in the j-th column of U. ! The position of such elements is returned in w(*).  In general, ! w(j) = + max( uj ),  but if column j is a singularity, ! w(j) = - max( uj ).  Thus, w(j) .le. 0 if column j appears to be ! dependent on the other columns of A. ! ! NOTE: lu1fac (like certain other sparse LU packages) does not ! treat dense columns efficiently.  This means it will be slow ! on \"arrow matrices\" of the form !                  A = (x       a) !                      (  x     b) !                      (    x   c) !                      (      x d) !                      (x x x x e) ! if the numerical values in the dense column allow it to be ! chosen LATE in the pivot order. ! ! With TPP (Threshold Partial Pivoting), the dense column is ! likely to be chosen late. ! ! With TCP (Threshold Complete Pivoting), if any of a,b,c,d ! is significantly larger than other elements of A, it will ! be chosen as the first pivot and the dense column will be ! eliminated, giving reasonably sparse factors. ! However, if element e is so big that TCP chooses it, the factors ! will become dense.  (It's hard to win on these examples!) !================================================================== ! ! ! Notes on the array names ! ------------------------ ! ! During the LU factorization, the sparsity pattern of the matrix ! being factored is stored twice: in a column list and a row list. ! ! The column list is ( a, indc, locc, lenc ) ! where !       a(*)    holds the nonzeros, !       indc(*) holds the indices for the column list, !       locc(j) points to the start of column j in a(*) and indc(*), !       lenc(j) is the number of nonzeros in column j. ! ! The row list is    (    indr, locr, lenr ) ! where !       indr(*) holds the indices for the row list, !       locr(i) points to the start of row i in indr(*), !       lenr(i) is the number of nonzeros in row i. ! ! ! At all stages of the LU factorization, p contains a complete ! row permutation.  At the start of stage k,  p(1), ..., p(k-1) ! are the first k-1 rows of the final row permutation P. ! The remaining rows are stored in an ordered list !                    ( p, iploc, ipinv ) ! where !       iploc(nz) points to the start in p(*) of the set of rows !                 that currently contain nz nonzeros, !       ipinv(i)  points to the position of row i in p(*). ! ! For example, !       iploc(1) = k   (and this is where rows of length 1 begin), !       iploc(2) = k+p  if there are p rows of length 1 !                      (and this is where rows of length 2 begin). ! ! Similarly for q, iqloc, iqinv. !================================================================== ! ! ! 00 Jun 1983  Original version. ! 00 Jul 1987  nrank  saved in luparm(16). ! 12 Apr 1989  ipinv, iqinv added as workspace. ! 26 Apr 1989  maxtie replaced by maxcol in Markowitz search. ! 16 Mar 1992  jumin  saved in luparm(19). ! 10 Jun 1992  lu1fad has to move empty rows and cols to the bottom !              (via lu1pq3) before doing the dense LU. ! 12 Jun 1992  Deleted dense LU (lu1ful, lu1vlu). ! 25 Oct 1993  keepLU implemented. ! 07 Feb 1994  Added new dense LU (lu1ful, lu1den). ! 21 Dec 1994  Bugs fixed in lu1fad (nrank) and lu1ful (ipvt). ! 08 Aug 1995  Use p instead of w as parameter to lu1or3 (for F90). ! 13 Sep 2000  TPP and TCP options implemented. ! 17 Oct 2000  Fixed troubles due to A = empty matrix (Todd Munson). ! 01 Dec 2000  Save Lmax, Umax, etc. after both lu1fad and lu6chk. !              lu1fad sets them when keepLU = false. !              lu6chk sets them otherwise, and includes items !              from the dense LU. ! 11 Mar 2001  lu6chk now looks at diag(U) when keepLU = false. ! 26 Apr 2002  New TCP implementation using heap routines to !              store largest element in each column. !              New workspace arrays Ha, Hj, Hk required. !              For compatibility, borrow space from a, indc, indr !              rather than adding new input parameters. ! 01 May 2002  lu1den changed to lu1DPP (dense partial  pivoting). !              lu1DCP implemented       (dense complete pivoting). !              Both TPP and TCP now switch to dense mode and end. ! ! 10 Jan 2010: First f90 version. !--------------------------------------------------------------------- ! ! !  INPUT PARAMETERS ! !  m      (not altered) is the number of rows in A. !  n      (not altered) is the number of columns in A. !  nelem  (not altered) is the number of matrix entries given in !         the arrays a, indc, indr. !  lena   (not altered) is the dimension of  a, indc, indr. !         This should be significantly larger than nelem. !         Typically one should have !            lena > max( 2*nelem, 10*m, 10*n, 10000 ) !         but some applications may need more. !         On machines with virtual memory it is safe to have !         lena \"far bigger than necessary\", since not all of the !         arrays will be used. !  a      (overwritten) contains entries   Aij  in   a(1:nelem). !  indc   (overwritten) contains the indices i in indc(1:nelem). !  indr   (overwritten) contains the indices j in indr(1:nelem). ! !  luparm input parameters:                                Typical value ! !  luparm( 1) = nout     File number for printed messages.         6 ! !  luparm( 2) = lprint   Print level.                              0 !                   <  0 suppresses output. !                   =  0 gives error messages. !                  >= 10 gives statistics about the LU factors. !                  >= 50 gives debug output from lu1fac !                        (the pivot row and column and the !                        no. of rows and columns involved at !                        each elimination step). ! !  luparm( 3) = maxcol   lu1fac: maximum number of columns         5 !                        searched allowed in a Markowitz-type !                        search for the next pivot element. !                        For some of the factorization, the !                        number of rows searched is !                        maxrow = maxcol - 1. ! !  luparm( 6) = 0    =>  TPP: Threshold Partial   Pivoting.        0 !             = 1    =>  TRP: Threshold Rook      Pivoting. !             = 2    =>  TCP: Threshold Complete  Pivoting. !             = 3    =>  TSP: Threshold Symmetric Pivoting. !             = 4    =>  TDP: Threshold Diagonal  Pivoting. !                             (TDP not yet implemented). !                        TRP and TCP are more expensive than TPP but !                        more stable and better at revealing rank. !                        Take care with setting parmlu(1), especially !                        with TCP. !                        NOTE: TSP and TDP are for symmetric matrices !                        that are either definite or quasi-definite. !                        TSP is effectively TRP for symmetric matrices. !                        TDP is effectively TCP for symmetric matrices. ! !  luparm( 8) = keepLU   lu1fac: keepLU = 1 means the numerical    1 !                        factors will be computed if possible. !                        keepLU = 0 means L and U will be discarded !                        but other information such as the row and !                        column permutations will be returned. !                        The latter option requires less storage. ! !  parmlu input parameters:                                Typical value ! !  parmlu( 1) = Ltol1    Max Lij allowed during Factor. !                                                  TPP     10.0 or 100.0 !                                                  TRP      4.0 or  10.0 !                                                  TCP      5.0 or  10.0 !                                                  TSP      4.0 or  10.0 !                        With TRP and TCP (Rook and Complete Pivoting), !                        values less than 25.0 may be expensive !                        on badly scaled data.  However, !                        values less than 10.0 may be needed !                        to obtain a reliable rank-revealing !                        factorization. !  parmlu( 2) = Ltol2    Max Lij allowed during Updates.            10.0 !                        during updates. !  parmlu( 3) = small    Absolute tolerance for       eps**0.8 = 3.0d-13 !                        treating reals as zero. !  parmlu( 4) = Utol1    Absolute tol for flagging    eps**0.67= 3.7d-11 !                        small diagonals of U. !  parmlu( 5) = Utol2    Relative tol for flagging    eps**0.67= 3.7d-11 !                        small diagonals of U. !                        (eps = machine precision) !  parmlu( 6) = Uspace   Factor limiting waste space in  U.      3.0 !                        In lu1fac, the row or column lists !                        are compressed if their length !                        exceeds Uspace times the length of !                        either file after the last compression. !  parmlu( 7) = dens1    The density at which the Markowitz      0.3 !                        pivot strategy should search maxcol !                        columns and no rows. !                        (Use 0.3 unless you are experimenting !                        with the pivot strategy.) !  parmlu( 8) = dens2    the density at which the Markowitz      0.5 !                        strategy should search only 1 column, !                        or (if storage is available) !                        the density at which all remaining !                        rows and columns will be processed !                        by a dense LU code. !                        For example, if dens2 = 0.1 and lena is !                        large enough, a dense LU will be used !                        once more than 10 per cent of the !                        remaining matrix is nonzero. ! ! !  OUTPUT PARAMETERS ! !  a, indc, indr     contain the nonzero entries in the LU factors of A. !         If keepLU = 1, they are in a form suitable for use !         by other parts of the LUSOL package, such as lu6sol. !         U is stored by rows at the start of a, indr. !         L is stored by cols at the end   of a, indc. !         If keepLU = 0, only the diagonals of U are stored, at the !         end of a. !  p, q   are the row and column permutations defining the !         pivot order.  For example, row p(1) and column q(1) !         defines the first diagonal of U. !  lenc(1:numl0) contains the number of entries in nontrivial !         columns of L (in pivot order). !  lenr(1:m) contains the number of entries in each row of U !         (in original order). !  locc(1:n) = 0 (ready for the LU update routines). !  locr(1:m) points to the beginning of the rows of U in a, indr. !  iploc, iqloc, ipinv, iqinv  are undefined. !  w      indicates singularity as described above. !  inform = 0 if the LU factors were obtained successfully. !         = 1 if U appears to be singular, as judged by lu6chk. !         = 3 if some index pair indc(l), indr(l) lies outside !             the matrix dimensions 1:m , 1:n. !         = 4 if some index pair indc(l), indr(l) duplicates !             another such pair. !         = 7 if the arrays a, indc, indr were not large enough. !             Their length \"lena\" should be increase to at least !             the value \"minlen\" given in luparm(13). !         = 8 if there was some other fatal error.  (Shouldn't happen!) !         = 9 if no diagonal pivot could be found with TSP or TDP. !             The matrix must not be sufficiently definite !             or quasi-definite. !         =10 if there was some other fatal error. ! !  luparm output parameters: ! !  luparm(10) = inform   Return code from last call to any LU routine. !  luparm(11) = nsing    No. of singularities marked in the !                        output array w(*). !  luparm(12) = jsing    Column index of last singularity. !  luparm(13) = minlen   Minimum recommended value for  lena. !  luparm(14) = maxlen   ? !  luparm(15) = nupdat   No. of updates performed by the lu8 routines. !  luparm(16) = nrank    No. of nonempty rows of U. !  luparm(17) = ndens1   No. of columns remaining when the density of !                        the matrix being factorized reached dens1. !  luparm(18) = ndens2   No. of columns remaining when the density of !                        the matrix being factorized reached dens2. !  luparm(19) = jumin    The column index associated with DUmin. !  luparm(20) = numL0    No. of columns in initial  L. !  luparm(21) = lenL0    Size of initial  L  (no. of nonzeros). !  luparm(22) = lenU0    Size of initial  U. !  luparm(23) = lenL     Size of current  L. !  luparm(24) = lenU     Size of current  U. !  luparm(25) = lrow     Length of row file. !  luparm(26) = ncp      No. of compressions of LU data structures. !  luparm(27) = mersum   lu1fac: sum of Markowitz merit counts. !  luparm(28) = nUtri    lu1fac: triangular rows in U. !  luparm(29) = nLtri    lu1fac: triangular rows in L. !  luparm(30) = nslack   lu1fac: no. of unit vectors at start of U. (info only) ! ! ! !  parmlu output parameters: ! !  parmlu(10) = Amax     Maximum element in  A. !  parmlu(11) = Lmax     Maximum multiplier in current  L. !  parmlu(12) = Umax     Maximum element in current  U. !  parmlu(13) = DUmax    Maximum diagonal in  U. !  parmlu(14) = DUmin    Minimum diagonal in  U. !  parmlu(15) = Akmax    Maximum element generated at any stage !                        during TCP factorization. !  parmlu(16) = growth   TPP: Umax/Amax    TRP, TCP, TSP: Akmax/Amax !  parmlu(17) = !  parmlu(18) = !  parmlu(19) = !  parmlu(20) = resid    lu6sol: residual after solve with U or U'. !  ... !  parmlu(30) = !--------------------------------------------------------------------- character ( 1 ) :: mnkey character ( 2 ) :: kPiv ( 0 : 3 ) integer ( ip ) :: i , idummy , j , jsing , jumin , & k , l , l2 , lena2 , lenH , lenL , & lenLk , lenU , lenUk , lerr , & ll , llsave , lm , lmaxr , locH , & lprint , lPiv , lrow , ltopl , & lu , mersum , minlen , nbump , & ncp , ndens1 , ndens2 , & nLtri , nmove , nout , nrank , & nsing , numl0 , numnz , nslack , nUtri logical :: keepLU , TCP , TPP , TRP , TSP real ( rp ) :: Agrwth , Akmax , Amax , avgmer , & condU , delem , densty , dincr , & dm , dn , DUmax , DUmin , growth , & Lmax , Ltol , small , Ugrwth , & Umax ! Grab relevant input parameters. nout = luparm ( 1 ) lprint = luparm ( 2 ) lPiv = luparm ( 6 ) keepLU = luparm ( 8 ) /= 0 Ltol = parmlu ( 1 ) ! Limit on size of Lij small = parmlu ( 3 ) ! Drop tolerance TPP = lPiv == 0 ! Threshold Partial   Pivoting (normal). TRP = lPiv == 1 ! Threshold Rook      Pivoting TCP = lPiv == 2 ! Threshold Complete  Pivoting. TSP = lPiv == 3 ! Threshold Symmetric Pivoting. kPiv ( 0 ) = 'PP' kPiv ( 1 ) = 'RP' kPiv ( 2 ) = 'CP' kPiv ( 3 ) = 'SP' ! Initialize output parameters. inform = 0 minlen = nelem + 2 * ( m + n ) numl0 = 0 lenL = 0 lenU = 0 lrow = 0 mersum = 0 nUtri = m nLtri = 0 ndens1 = 0 ndens2 = 0 nrank = 0 nsing = 0 jsing = 0 jumin = 0 nslack = 0 Amax = zero Lmax = zero Umax = zero DUmax = zero DUmin = zero Akmax = zero if ( m > n ) then mnkey = '>' else if ( m == n ) then mnkey = '=' else mnkey = '<' end if ! Float version of dimensions. dm = m dn = n delem = nelem ! Initialize workspace parameters. luparm ( 26 ) = 0 ! ncp if ( lena < minlen ) go to 970 !------------------------------------------------------------------- ! Organize the  aij's  in  a, indc, indr. ! lu1or1  deletes small entries, tests for illegal  i,j's, !         and counts the nonzeros in each row and column. ! lu1or2  reorders the elements of  A  by columns. ! lu1or3  uses the column list to test for duplicate entries !         (same indices  i,j). ! lu1or4  constructs a row list from the column list. !------------------------------------------------------------------- call lu1or1 ( m , n , nelem , lena , small , & a , indc , indr , lenc , lenr , & Amax , numnz , lerr , inform ) if ( nout > 0 . and . lprint >= 10 ) then densty = 10 0.0_rp * delem / ( dm * dn ) write ( nout , 1000 ) m , mnkey , n , numnz , Amax , densty end if if ( inform /= 0 ) go to 930 !!! nelem  = numnz     !!! Don't change nelem. !!! nelem is now numnz below (it might be less than the input value). call lu1or2 ( n , numnz , lena , a , indc , indr , lenc , locc ) call lu1or3 ( m , n , lena , indc , lenc , locc , p , lerr , inform ) if ( inform /= 0 ) go to 940 call lu1or4 ( m , n , numnz , lena , indc , indr , lenc , lenr , locc , locr ) !------------------------------------------------------------------ ! Set up lists of rows and columns with equal numbers of nonzeros, ! using  indc(*)  as workspace. ! 12 Dec 2015: Always call lu1slk here now. ! This sets nslack and w(j) = 1.0 for slacks, else 0.0. !------------------------------------------------------------------ call lu1pq1 ( m , n , lenr , p , iploc , ipinv , indc ( numnz + 1 ) ) call lu1pq1 ( n , m , lenc , q , iqloc , iqinv , indc ( numnz + 1 ) ) call lu1slk ( m , n , lena , q , iqloc , a , indc , locc , nslack , w ) luparm ( 30 ) = nslack !------------------------------------------------------------------ ! For TCP, allocate Ha, Hj, Hk at the end of a, indc, indr. ! Then compute the factorization  A = L*U. !------------------------------------------------------------------ lenH = 0 ! Keep -Wmaybe-uninitialized happy. lena2 = 0 ! locH = 0 ! lmaxr = 0 ! if ( TPP . or . TSP ) then lenH = 1 lena2 = lena locH = lena lmaxr = 1 else if ( TRP ) then lenH = 1 ! Dummy lena2 = lena - m ! Reduced length of      a locH = lena ! Dummy lmaxr = lena2 + 1 ! Start of Amaxr      in a else if ( TCP ) then lenH = n ! Length of heap lena2 = lena - lenH ! Reduced length of      a, indc, indr locH = lena2 + 1 ! Start of Ha, Hj, Hk in a, indc, indr lmaxr = 1 ! Dummy end if call lu1fad ( m , n , numnz , lena2 , luparm , parmlu , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & iploc , iqloc , ipinv , iqinv , w , & lenH , a ( locH ), indc ( locH ), indr ( locH ), a ( lmaxr ), & inform , lenL , lenU , minlen , mersum , & nUtri , nLtri , ndens1 , ndens2 , nrank , nslack , & Lmax , Umax , DUmax , DUmin , Akmax ) luparm ( 16 ) = nrank luparm ( 23 ) = lenL if ( inform == 7 ) go to 970 if ( inform == 9 ) go to 985 if ( inform == 10 ) go to 981 if ( inform > 0 ) go to 980 if ( keepLU ) then !--------------------------------------------------------------- ! The LU factors are at the top of  a, indc, indr, ! with the columns of  L  and the rows of  U  in the order ! ! ( free )   ... ( u3 ) ( l3 ) ( u2 ) ( l2 ) ( u1 ) ( l1 ). ! ! Starting with ( l1 ) and ( u1 ), move the rows of  U  to the ! left and the columns of  L  to the right, giving ! ! ( u1 ) ( u2 ) ( u3 ) ...   ( free )   ... ( l3 ) ( l2 ) ( l1 ). ! ! Also, set  numl0 = the number of nonempty columns of L. !--------------------------------------------------------------- lu = 0 ll = lena + 1 lm = lena2 + 1 ltopl = ll - lenL - lenU lrow = lenU do k = 1 , nrank i = p ( k ) lenUk = - lenr ( i ) lenr ( i ) = lenUk j = q ( k ) lenLk = - lenc ( j ) - 1 if ( lenLk > 0 ) then numl0 = numl0 + 1 iqloc ( numl0 ) = lenLk end if if ( lu + lenUk < ltopl ) then !========================================================= ! There is room to move ( uk ).  Just right-shift ( lk ). !========================================================= do idummy = 1 , lenLk ll = ll - 1 lm = lm - 1 a ( ll ) = a ( lm ) indc ( ll ) = indc ( lm ) indr ( ll ) = indr ( lm ) end do else !========================================================= ! There is no room for ( uk ) yet.  We have to ! right-shift the whole of the remaining LU file. ! Note that ( lk ) ends up in the correct place. !========================================================= llsave = ll - lenLk nmove = lm - ltopl do idummy = 1 , nmove ll = ll - 1 lm = lm - 1 a ( ll ) = a ( lm ) indc ( ll ) = indc ( lm ) indr ( ll ) = indr ( lm ) end do ltopl = ll ll = llsave lm = ll end if !====================================================== ! Left-shift ( uk ). !====================================================== locr ( i ) = lu + 1 l2 = lm - 1 lm = lm - lenUk do l = lm , l2 lu = lu + 1 a ( lu ) = a ( l ) indr ( lu ) = indr ( l ) end do end do !--------------------------------------------------------------- ! Save the lengths of the nonempty columns of  L, ! and initialize  locc(j)  for the LU update routines. !--------------------------------------------------------------- lenc ( 1 : numl0 ) = iqloc ( 1 : numl0 ) locc ( 1 : n ) = 0 !--------------------------------------------------------------- ! Test for singularity. ! lu6chk  sets  nsing, jsing, jumin, Lmax, Umax, DUmax, DUmin ! (including entries from the dense LU). ! input      i1 = 1 means we're calling lu6chk from LUSOL. ! output inform = 1 if there are singularities (nsing > 0). ! 12 Dec 2015: nslack is now an input. !--------------------------------------------------------------- call lu6chk ( i1 , m , n , nslack , w , lena , luparm , parmlu , & a , indc , indr , p , q , & lenc , lenr , locc , locr , inform ) nsing = luparm ( 11 ) jsing = luparm ( 12 ) jumin = luparm ( 19 ) Lmax = parmlu ( 11 ) Umax = parmlu ( 12 ) DUmax = parmlu ( 13 ) DUmin = parmlu ( 14 ) else !--------------------------------------------------------------- ! keepLU = 0.  L and U were not kept, just the diagonals of U. ! lu1fac will probably be called again soon with keepLU = .true. ! 11 Mar 2001: lu6chk revised.  We can call it with keepLU = 0, !              but we want to keep Lmax, Umax from lu1fad. ! 05 May 2002: Allow for TCP with new lu1DCP.  Diag(U) starts !              below lena2, not lena.  Need lena2 in next line. ! 12 Dec 2015: nslack is now an input. !--------------------------------------------------------------- call lu6chk ( i1 , m , n , nslack , w , lena2 , luparm , parmlu , & a , indc , indr , p , q , & lenc , lenr , locc , locr , inform ) nsing = luparm ( 11 ) jsing = luparm ( 12 ) jumin = luparm ( 19 ) DUmax = parmlu ( 13 ) DUmin = parmlu ( 14 ) end if go to 990 !------------ ! Error exits. !------------ 930 inform = 3 if ( lprint >= 0 ) write ( nout , 1300 ) lerr , indc ( lerr ), indr ( lerr ) go to 990 940 inform = 4 if ( lprint >= 0 ) write ( nout , 1400 ) lerr , indc ( lerr ), indr ( lerr ) go to 990 970 inform = 7 if ( lprint >= 0 ) write ( nout , 1700 ) lena , minlen go to 990 980 inform = 8 if ( lprint >= 0 ) write ( nout , 1800 ) go to 990 981 inform = 10 go to 990 985 inform = 9 if ( lprint >= 0 ) write ( nout , 1900 ) ! Store output parameters. 990 luparm ( 10 ) = inform luparm ( 11 ) = nsing luparm ( 12 ) = jsing luparm ( 13 ) = minlen luparm ( 15 ) = 0 luparm ( 16 ) = nrank luparm ( 17 ) = ndens1 luparm ( 18 ) = ndens2 luparm ( 19 ) = jumin luparm ( 20 ) = numl0 luparm ( 21 ) = lenL luparm ( 22 ) = lenU luparm ( 23 ) = lenL luparm ( 24 ) = lenU luparm ( 25 ) = lrow luparm ( 27 ) = mersum luparm ( 28 ) = nUtri luparm ( 29 ) = nLtri parmlu ( 10 ) = Amax parmlu ( 11 ) = Lmax parmlu ( 12 ) = Umax parmlu ( 13 ) = DUmax parmlu ( 14 ) = DUmin parmlu ( 15 ) = Akmax Agrwth = Akmax / ( Amax + 1.0e-20_rp ) Ugrwth = Umax / ( Amax + 1.0e-20_rp ) if ( TPP ) then growth = Ugrwth else ! TRP or TCP or TSP growth = Agrwth end if parmlu ( 16 ) = growth !------------------------------------------------------------------ ! Print statistics for the LU factors. !------------------------------------------------------------------ ncp = luparm ( 26 ) condU = DUmax / max ( DUmin , 1.0e-20_rp ) dincr = lenL + lenU - nelem dincr = dincr * 10 0.0_rp / max ( delem , one ) avgmer = mersum avgmer = avgmer / dm nbump = m - nUtri - nLtri if ( nout > 0 . and . lprint >= 10 ) then if ( TPP ) then write ( nout , 1100 ) avgmer , lenL , lenL + lenU , ncp , dincr , & nUtri , lenU , Ltol , Umax , Ugrwth , & nLtri , ndens1 , Lmax else write ( nout , 1120 ) kPiv ( lPiv ), avgmer , & lenL , lenL + lenU , ncp , dincr , & nUtri , lenU , Ltol , Umax , Ugrwth , & nLtri , ndens1 , Lmax , Akmax , Agrwth end if write ( nout , 1200 ) nbump , ndens2 , DUmax , DUmin , condU end if return 1000 format ( ' m' , i12 , ' ' , a , 'n' , i12 , '  Elems' , i9 , & '  Amax' , es10 . 1 , '  Density' , f7 . 2 ) 1100 format ( ' Merit' , f8 . 1 , '  lenL' , i9 , '  L+U' , i11 , & '  Cmpressns' , i5 , '  Incres' , f8 . 2 & / ' Utri' , i9 , '  lenU' , i9 , '  Ltol' , es10 . 2 , & '  Umax' , es10 . 1 , '  Ugrwth' , es8 . 1 & / ' Ltri' , i9 , '  dense1' , i7 , '  Lmax' , es10 . 2 ) 1120 format ( ' Mer' , a2 , f8 . 1 , '  lenL' , i9 , '  L+U' , i11 , & '  Cmpressns' , i5 , '  Incres' , f8 . 2 & / ' Utri' , i9 , '  lenU' , i9 , '  Ltol' , es10 . 2 , & '  Umax' , es10 . 1 , '  Ugrwth' , es8 . 1 & / ' Ltri' , i9 , '  dense1' , i7 , '  Lmax' , es10 . 2 , & '  Akmax' , es9 . 1 , '  Agrwth' , es8 . 1 ) 1200 format ( ' bump' , i9 , '  dense2' , i7 , '  DUmax' , es9 . 1 , & '  DUmin' , es9 . 1 , '  condU' , es9 . 1 ) 1300 format ( / ' lu1fac  error...  entry  a(' , i8 , ')  has an illegal' , & ' row or column index' & // ' indc, indr =' , 2 i8 ) 1400 format ( / ' lu1fac  error...  entry  a(' , i8 , ')  has the same' , & ' indices as an earlier entry' & // ' indc, indr =' , 2 i8 ) 1700 format ( / ' lu1fac  error...  insufficient storage' & // ' Increase  lena  from' , i10 , '  to at least' , i10 ) 1800 format ( / ' lu1fac  error...  fatal bug' , & '   (sorry --- this should never happen)' ) 1900 format ( / ' lu1fac  error...  TSP used but' , & ' diagonal pivot could not be found' ) end subroutine lu1fac !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1fad ( m , n , nelem , lena , luparm , parmlu , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & iploc , iqloc , ipinv , iqinv , w , & lenH , Ha , Hj , Hk , Amaxr , & inform , lenL , lenU , minlen , mersum , & nUtri , nLtri , ndens1 , ndens2 , nrank , nslack , & Lmax , Umax , DUmax , DUmin , Akmax ) integer ( ip ), intent ( in ) :: m , n , nelem , lena , lenH , nslack integer ( ip ), intent ( inout ) :: luparm ( 30 ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), a ( lena ), Amaxr ( m ), & w ( n ), Ha ( lenH ) integer ( ip ), intent ( inout ) :: indc ( lena ), indr ( lena ), & p ( m ) , q ( n ) , & lenc ( n ) , lenr ( m ) , & locc ( n ) , locr ( m ) , & iploc ( n ) , iqloc ( m ) , & ipinv ( m ), iqinv ( n ), & Hj ( lenH ) , Hk ( lenH ) integer ( ip ), intent ( out ) :: inform , lenL , lenU , & minlen , mersum , & nUtri , nLtri , ndens1 , ndens2 , nrank real ( rp ), intent ( out ) :: Lmax , Umax , DUmax , DUmin , Akmax !------------------------------------------------------------------ ! lu1fad  is a driver for the numerical phase of lu1fac. ! At each stage it computes a column of  L  and a row of  U, ! using a Markowitz criterion to select the pivot element, ! subject to a stability criterion that bounds the elements of  L. ! ! 00 Jan 1986  Version documented in LUSOL paper: !              Gill, Murray, Saunders and Wright (1987), !              Maintaining LU factors of a general sparse matrix, !              Linear algebra and its applications 88/89, 239-270. ! ! 02 Feb 1989  Following Suhl and Aittoniemi (1987), the largest !              element in each column is now kept at the start of !              the column, i.e. in position locc(j) of a and indc. !              This should speed up the Markowitz searches. !              To save time on highly triangular matrices, we wait !              until there are no further columns of length 1 !              before setting and maintaining that property. ! ! 12 Apr 1989  ipinv and iqinv added (inverses of p and q) !              to save searching p and q for rows and columns !              altered in each elimination step.  (Used in lu1pq2) ! ! 19 Apr 1989  Code segmented to reduce its size. !              lu1gau does most of the Gaussian elimination work. !              lu1mar does just the Markowitz search. !              lu1mxc moves biggest elements to top of columns. !              lu1pen deals with pending fill-in in the row list. !              lu1pq2 updates the row and column permutations. ! ! 26 Apr 1989  maxtie replaced by maxcol, maxrow in the Markowitz !              search.  maxcol, maxrow change as density increases. ! ! 25 Oct 1993  keepLU implemented. ! ! 07 Feb 1994  Exit main loop early to finish off with a dense LU. !              densLU tells lu1fad whether to do it. ! 21 Dec 1994  Bug fixed.  nrank was wrong after the call to lu1ful. ! 12 Nov 1999  A parallel version of dcopy gave trouble in lu1ful !              during left-shift of dense matrix D within a(*). !              Fixed this unexpected problem here in lu1fad !              by making sure the first and second D don't overlap. ! ! 13 Sep 2000  TCP (Threshold Complete Pivoting) implemented. !              lu2max added !              (finds aijmax from biggest elems in each col). !              Utri, Ltri and Spars1 phases apply. !              No switch to Dense CP yet.  (Only TPP switches.) ! 14 Sep 2000  imax needed to remember row containing aijmax. ! 22 Sep 2000  For simplicity, lu1mxc always fixes !              all modified cols. !              (TPP spars2 used to fix just the first maxcol cols.) ! 08 Nov 2000: Speed up search for aijmax. !              Don't need to search all columns if the elimination !              didn't alter the col containing the current aijmax. ! 21 Nov 2000: lu1slk implemented for Utri phase with TCP !              to guard against deceptive triangular matrices. !              (Utri used to have aijtol >= 0.9999 to include !              slacks, but this allows other 1s to be accepted.) !              Utri now accepts slacks, but applies normal aijtol !              test to other pivots. ! 28 Nov 2000: TCP with empty cols must call lu1mxc and lu2max !              with ( lq1, n, ... ), not just ( 1, n, ... ). ! 23 Mar 2001: lu1fad bug with TCP. !              A col of length 1 might not be accepted as a pivot. !              Later it appears in a pivot row and temporarily !              has length 0 (when pivot row is removed !              but before the column is filled in).  If it is the !              last column in storage, the preceding col also thinks !              it is \"last\".  Trouble arises when the preceding col !              needs fill-in -- it overlaps the real \"last\" column. !              (Very rarely, same trouble might have happened if !              the drop tolerance caused columns to have length 0.) ! !              Introduced ilast to record the last row in row file, !                         jlast to record the last col in col file. !              lu1rec returns ilast = indr(lrow + 1) !                          or jlast = indc(lcol + 1). !        ***   (Should be an output parameter, but didn't want to !              alter lu1rec's parameter list.) !              lu1rec also treats empty rows or cols safely. !              (Doesn't eliminate them!) !        ***   20 Dec 2015: Made ilast an output as it should be. ! ! 26 Apr 2002: Heap routines added for TCP. !              lu2max no longer needed. !              imax, jmax used only for printing. ! 01 May 2002: lu1DCP implemented (dense complete pivoting). !              Both TPP and TCP now switch to dense LU !              when density exceeds dens2. ! 06 May 2002: In dense mode, store diag(U) in natural order. ! 09 May 2002: lu1mCP implemented (Markowitz TCP via heap). ! 11 Jun 2002: lu1mRP implemented (Markowitz TRP). ! 28 Jun 2002: Fixed call to lu1mxr. ! 14 Dec 2002: lu1mSP implemented (Markowitz TSP). ! 15 Dec 2002: Both TPP and TSP can grab cols of length 1 !              during Utri. ! 19 Dec 2004: Hdelete(...) has new input argument Hlenin. ! 26 Mar 2006: lu1fad returns nrank  = min( mrank, nrank ) !              and ignores nsing from lu1ful ! ! 10 Jan 2010: First f90 version. ! 03 Apr 2013: lu1mxr recoded to improve efficiency of TRP. ! 12 Dec 2015: nslack is now an input. ! 20 Dec 2015: lu1rec returns ilast as output parameter. !------------------------------------------------------------------ logical :: Utri , Ltri , spars1 , spars2 , dense , & densLU , keepLU , TCP , TPP , TRP , TSP real ( rp ) :: abest , aijmax , aijtol , amax , & dens1 , dens2 , diag , & Lij , Ltol , small , Uspace !------------------------------------------------------------------ ! Local variables !--------------- ! ! lcol   is the length of the column file.  It points to the last !        nonzero in the column list. ! lrow   is the analogous quantity for the row file. ! lfile  is the file length (lcol or lrow) after the most recent !        compression of the column list or row list. ! nrowd  and  ncold  are the number of rows and columns in the !        matrix defined by the pivot column and row.  They are the !        dimensions of the submatrix D being altered at this stage. ! melim  and  nelim  are the number of rows and columns in the !        same matrix D, excluding the pivot column and row. ! mleft  and  nleft  are the number of rows and columns !        still left to be factored. ! nzchng is the increase in nonzeros in the matrix that remains !        to be factored after the current elimination !        (usually negative). ! nzleft is the number of nonzeros still left to be factored. ! nspare is the space we leave at the end of the last row or !        column whenever a row or column is being moved to the end !        of its file.  nspare = 1 or 2 might help reduce the !        number of file compressions when storage is tight. ! ! The row and column ordering permutes A into the form ! !                        ------------------------ !                         \\                     | !                          \\         U1         | !                           \\                   | !                            -------------------- !                            |\\ !                            | \\ !                            |  \\ !            P A Q   =       |   \\ !                            |    \\ !                            |     -------------- !                            |     |            | !                            |     |            | !                            | L1  |     A2     | !                            |     |            | !                            |     |            | !                            -------------------- ! ! where the block A2 is factored as  A2 = L2 U2. ! The phases of the factorization are as follows. ! ! Utri   is true when U1 is being determined. !        Any column of length 1 is accepted immediately (if TPP). ! ! Ltri   is true when L1 is being determined. !        lu1mar exits as soon as an acceptable pivot is found !        in a row of length 1. ! ! spars1 is true while the density of the (modified) A2 is less !        than the parameter dens1 = parmlu(7) = 0.3 say. !        lu1mar searches maxcol columns and maxrow rows, !        where  maxcol = luparm(3),  maxrow = maxcol - 1. !        lu1mxc is used to keep the biggest element at the top !        of all remaining columns. ! ! spars2 is true while the density of the modified A2 is less !        than the parameter dens2 = parmlu(8) = 0.6 say. !        lu1mar searches maxcol columns and no rows. !        lu1mxc could fix up only the first maxcol cols (with TPP). !        22 Sep 2000: For simplicity, lu1mxc fixes all modified cols. ! ! dense  is true once the density of A2 reaches dens2. !        lu1mar searches only 1 column (the shortest). !        lu1mxc could fix up only the first column (with TPP). !        22 Sep 2000: For simplicity, lu1mxc fixes all modified cols. !------------------------------------------------------------------ integer ( ip ) :: Hlen , Hlenin , hops , h , & i , ibest , ilast , imax , & j , jbest , jlast , jmax , lPiv , & k , kbest , kk , kslack , & l , last , lc , lc1 , lcol , & lD , ldiagU , lenD , leni , lenj , & lfile , lfirst , lfree , limit , & ll , ll1 , lpivc , lpivc1 , lpivc2 , & lpivr , lpivr1 , lpivr2 , lprint , & lq , lq1 , lq2 , lr , lr1 , & lrow , ls , lsave , lu , lu1 , & mark , maxcol , maxmn , maxrow , mbest , & melim , minfre , minmn , mleft , & mrank , ncold , nelim , nfill , & nfree , nleft , nout , nrowd , nrowu , & nsing , nspare , nzchng , nzleft integer ( ip ) :: markc ( n ), markr ( m ) real ( rp ) :: v nout = luparm ( 1 ) lprint = luparm ( 2 ) maxcol = luparm ( 3 ) lPiv = luparm ( 6 ) keepLU = luparm ( 8 ) /= 0 TPP = lPiv == 0 ! Threshold Partial   Pivoting (normal). TRP = lPiv == 1 ! Threshold Rook      Pivoting TCP = lPiv == 2 ! Threshold Complete  Pivoting. TSP = lPiv == 3 ! Threshold Symmetric Pivoting. densLU = . false . maxrow = maxcol - 1 ilast = m ! Assume row m is last in the row file. jlast = n ! Assume col n is last in the col file. lfile = nelem lrow = nelem lcol = nelem minmn = min ( m , n ) maxmn = max ( m , n ) nzleft = nelem nspare = 1 ldiagU = 0 ! Keep -Wmaybe-uninitialized happy. if ( keepLU ) then lu1 = lena + 1 else ! Store only the diagonals of U in the top of memory. ldiagU = lena - n lu1 = ldiagU + 1 end if Ltol = parmlu ( 1 ) small = parmlu ( 3 ) Uspace = parmlu ( 6 ) dens1 = parmlu ( 7 ) dens2 = parmlu ( 8 ) Utri = . true . Ltri = . false . spars1 = . false . spars2 = . false . dense = . false . kslack = 0 ! 12 Dec 2015: Count slacks accepted during Utri. ! Check parameters. Ltol = max ( Ltol , 1.0001_rp ) dens1 = min ( dens1 , dens2 ) ! Initialize output parameters. ! lenL, lenU, minlen, mersum, nUtri, nLtri, ndens1, ndens2, nrank, ! nslack, are already initialized by lu1fac. lenL = 0 lenU = 0 minlen = 0 mersum = 0 nLtri = 0 nUtri = 0 ndens1 = 0 ndens2 = 0 nrank = 0 Lmax = zero Umax = zero DUmax = zero DUmin = 1.0e+20_rp if ( nelem == 0 ) Dumin = zero Akmax = zero hops = 0 ! More initialization. if ( TPP . or . TSP ) then ! Don't worry yet about lu1mxc. aijmax = zero aijtol = zero Hlen = 1 else ! TRP or TCP ! Move biggest element to top of each column. ! Set w(*) to mark slack columns (unit vectors). ! 12 Dec 2015: lu1fac (lu1slk) sets w(*) before lu1fad. ! 13 Dec 2015: lu1mxc fixed (empty cols caused trouble). call lu1mxc ( i1 , n , q , a , indc , lenc , locc ) ! call lu1slk( m, n, lena, q, iqloc, a, locc, w ) end if if ( TRP ) then ! Find biggest element in each row. mark = 0 call lu1mxr ( mark , i1 , m , m , n , lena , inform , & a , indc , lenc , locc , indr , lenr , locr , & p , markc , markr , Amaxr ) if ( inform > 0 ) go to 981 end if if ( TCP ) then ! Set Ha(1:Hlen) = biggest element in each column, ! Hj(1:Hlen) = corresponding column indices. ! 17 Dec 2015: Allow for empty columns. Hlen = 0 do kk = 1 , n Hlen = Hlen + 1 j = q ( kk ) if ( lenc ( j ) > 0 ) then lc = locc ( j ) amax = abs ( a ( lc ) ) else amax = zero end if Ha ( Hlen ) = amax Hj ( Hlen ) = j Hk ( j ) = Hlen end do ! Build the heap, creating new Ha, Hj and setting Hk(1:Hlen). call Hbuild ( Ha , Hj , Hk , Hlen , Hlen , hops ) end if !------------------------------------------------------------------ ! Start of main loop. !------------------------------------------------------------------ mleft = m + 1 nleft = n + 1 do 800 nrowu = 1 , minmn ! mktime = (nrowu / ntime) + 4 ! eltime = (nrowu / ntime) + 9 mleft = mleft - 1 nleft = nleft - 1 ! Bail out if there are no nonzero rows left. if ( iploc ( 1 ) > m ) go to 900 ! For TCP, the largest Aij is at the top of the heap. if ( TCP ) then aijmax = Ha ( 1 ) ! Marvelously easy ! Akmax = max ( Akmax , aijmax ) aijtol = aijmax / Ltol end if !=============================================================== ! Find a suitable pivot element. !=============================================================== if ( Utri ) then !------------------------------------------------------------ ! So far all columns have had length 1. ! We are still looking for the (backward) triangular part of A ! that forms the first rows and columns of U. ! 12 Dec 2015: Use nslack and kslack to choose slacks first. !------------------------------------------------------------ lq1 = iqloc ( 1 ) lq2 = n if ( m > 1 ) lq2 = iqloc ( 2 ) - 1 if ( kslack < nslack ) then do lq = lq1 , lq2 j = q ( lq ) if ( w ( j ) > zero ) then ! Accept a slack kslack = kslack + 1 jbest = j lc = locc ( jbest ) ibest = indc ( lc ) abest = a ( lc ) mbest = 0 go to 300 end if end do ! DEBUG ERROR ! write(*,*) 'slack not found' ! write(*,*) 'kslack, nslack =', kslack, nslack ! stop else if ( kslack == nslack ) then ! Maybe print msg if ( lprint >= 50 ) then write ( nout , * ) 'Slacks ended.  nslack =' , nslack end if kslack = nslack + 1 ! So print happens once end if ! All slacks will be grabbed before we get here. if ( lq1 <= lq2 ) then ! There are more cols of length 1. if ( TPP . or . TSP ) then jbest = q ( lq1 ) ! Grab the first one. else ! TRP or TCP    ! Scan all columns of length 1. jbest = 0 do lq = lq1 , lq2 j = q ( lq ) ! 12 Dec 2015: Slacks grabbed earlier. ! if (w(j) > zero) then ! Accept a slack !   jbest  = j !   go to 250 ! end if lc = locc ( j ) amax = abs ( a ( lc ) ) if ( TRP ) then i = indc ( lc ) aijtol = Amaxr ( i ) / Ltol end if if ( amax >= aijtol ) then jbest = j go to 250 end if end do end if 250 if ( jbest > 0 ) then lc = locc ( jbest ) ibest = indc ( lc ) mbest = 0 go to 300 end if end if ! This is the end of the U triangle. ! We will not return to this part of the code. ! TPP and TSP call lu1mxc for the first time ! (to move biggest element to top of each column). if ( lprint >= 50 ) then write ( nout , 1100 ) 'Utri ended.  spars1 = true' end if Utri = . false . Ltri = . true . spars1 = . true . nUtri = nrowu - 1 if ( TPP . or . TSP ) then call lu1mxc ( lq1 , n , q , a , indc , lenc , locc ) end if end if if ( spars1 ) then !------------------------------------------------------------ ! Perform a Markowitz search. ! Search cols of length 1, then rows of length 1, ! then   cols of length 2, then rows of length 2, etc. !------------------------------------------------------------ ! if (TPP) then ! 12 Jun 2002: Next line disables lu1mCP below if ( TPP . or . TCP ) then call lu1mar ( m , n , lena , maxmn , & TCP , aijtol , Ltol , maxcol , maxrow , & ibest , jbest , mbest , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & iploc , iqloc ) else if ( TRP ) then call lu1mRP ( m , n , lena , maxmn , & Ltol , maxcol , maxrow , & ibest , jbest , mbest , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & iploc , iqloc , Amaxr ) ! else if (TCP) then ! Disabled by test above ! call lu1mCP( m    , n     , lena  , aijtol, & !              ibest, jbest , mbest ,         & !              a    , indc  , indr  ,         & !              lenc , lenr  , locc  ,         & !              Hlen , Ha    , Hj    ) else if ( TSP ) then call lu1mSP ( m , n , lena , maxmn , & Ltol , maxcol , & ibest , jbest , mbest , & a , indc , q , locc , iqloc ) if ( ibest == 0 ) go to 990 end if if ( Ltri ) then ! So far all rows have had length 1. ! We are still looking for the (forward) triangle of A ! that forms the first rows and columns of L. if ( mbest > 0 ) then Ltri = . false . nLtri = nrowu - 1 - nUtri if ( lprint >= 50 ) then write ( nout , 1100 ) 'Ltri ended.' end if end if else ! See if what's left is as dense as dens1. if ( nzleft >= ( dens1 * mleft ) * nleft ) then spars1 = . false . spars2 = . true . ndens1 = nleft maxrow = 0 if ( lprint >= 50 ) then write ( nout , 1100 ) 'spars1 ended.  spars2 = true' end if end if end if else if ( spars2 . or . dense ) then !------------------------------------------------------------ ! Perform a restricted Markowitz search, ! looking at only the first maxcol columns.  (maxrow = 0.) !------------------------------------------------------------ ! if (TPP) then ! 12 Jun 2002: Next line disables lu1mCP below if ( TPP . or . TCP ) then call lu1mar ( m , n , lena , maxmn , & TCP , aijtol , Ltol , maxcol , maxrow , & ibest , jbest , mbest , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & iploc , iqloc ) else if ( TRP ) then call lu1mRP ( m , n , lena , maxmn , & Ltol , maxcol , maxrow , & ibest , jbest , mbest , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & iploc , iqloc , Amaxr ) ! else if (TCP) then ! Disabled by test above ! call lu1mCP( m    , n     , lena  , aijtol, & !              ibest, jbest , mbest ,         & !              a    , indc  , indr  ,         & !              lenc , lenr  , locc  ,         & !              Hlen , Ha    , Hj    ) else if ( TSP ) then call lu1mSP ( m , n , lena , maxmn , & Ltol , maxcol , & ibest , jbest , mbest , & a , indc , q , locc , iqloc ) if ( ibest == 0 ) go to 985 end if ! See if what's left is as dense as dens2. if ( spars2 ) then if ( nzleft >= ( dens2 * mleft ) * nleft ) then spars2 = . false . dense = . true . ndens2 = nleft maxcol = 1 if ( lprint >= 50 ) then write ( nout , 1100 ) 'spars2 ended.  dense = true' end if end if end if end if !--------------------------------------------------------------- ! See if we can finish quickly. !--------------------------------------------------------------- if ( dense ) then lenD = mleft * nleft nfree = lu1 - 1 ! 28 Sep 2015: Change 2 to 3 for safety. if ( nfree >= 3 * lenD ) then ! There is room to treat the remaining matrix as ! a dense matrix D. ! We may have to compress the column file first. ! 12 Nov 1999: D used to be put at the !              beginning of free storage (lD = lcol + 1). !              Now put it at the end     (lD = lu1 - lenD) !              so the left-shift in lu1ful will not !              involve overlapping storage !              (fatal with parallel dcopy). densLU = . true . ndens2 = nleft lD = lu1 - lenD if ( lcol >= lD ) then call lu1rec ( n , . true ., luparm , lcol , jlast , & lena , a , indc , lenc , locc ) lfile = lcol end if go to 900 end if end if !=============================================================== ! The best aij has been found. ! The pivot row ibest and the pivot column jbest ! define a dense matrix D of size nrowd x ncold. !=============================================================== 300 ncold = lenr ( ibest ) nrowd = lenc ( jbest ) melim = nrowd - 1 nelim = ncold - 1 mersum = mersum + mbest lenL = lenL + melim lenU = lenU + ncold if ( lprint >= 50 ) then if ( nrowu == 1 ) then write ( nout , 1100 ) 'lu1fad debug:' end if if ( TPP . or . TRP . or . TSP ) then write ( nout , 1200 ) nrowu , ibest , jbest , nrowd , ncold else ! TCP jmax = Hj ( 1 ) imax = indc ( locc ( jmax )) write ( nout , 1200 ) nrowu , ibest , jbest , nrowd , ncold , & imax , jmax , aijmax end if end if !=============================================================== ! Allocate storage for the next column of  L  and next row of  U. ! Initially the top of a, indc, indr are used as follows: ! !            ncold       melim       ncold        melim ! ! a      |...........|...........|ujbest..ujn|li1......lim| ! ! indc   |...........|  lenr(i)  |  lenc(j)  |  markl(i)  | ! ! indr   |...........| iqloc(i)  |  jfill(j) |  ifill(i)  | ! !       &#94;           &#94;             &#94;           &#94;            &#94; !       lfree   lsave             lu1         ll1          oldlu1 ! ! Later the correct indices are inserted: ! ! indc   |           |           |           |i1........im| ! ! indr   |           |           |jbest....jn|ibest..ibest| ! !=============================================================== if ( keepLU ) then ! relax else ! Always point to the top spot. ! Only the current column of L and row of U will ! take up space, overwriting the previous ones. lu1 = ldiagU + 1 end if ll1 = lu1 - melim lu1 = ll1 - ncold lsave = lu1 - nrowd lfree = lsave - ncold ! Make sure the column file has room. ! Also force a compression if its length exceeds a certain limit. limit = int ( Uspace * real ( lfile )) + m + n + 1000 minfre = ncold + melim nfree = lfree - lcol if ( nfree < minfre . or . lcol > limit ) then call lu1rec ( n , . true ., luparm , lcol , jlast , & lena , a , indc , lenc , locc ) lfile = lcol nfree = lfree - lcol if ( nfree < minfre ) go to 970 end if ! Make sure the row file has room. minfre = melim + ncold nfree = lfree - lrow if ( nfree < minfre . or . lrow > limit ) then call lu1rec ( m , . false ., luparm , lrow , ilast , & lena , a , indr , lenr , locr ) lfile = lrow nfree = lfree - lrow if ( nfree < minfre ) go to 970 end if !=============================================================== ! Move the pivot element to the front of its row ! and to the top of its column. !=============================================================== lpivr = locr ( ibest ) lpivr1 = lpivr + 1 lpivr2 = lpivr + nelim do l = lpivr , lpivr2 if ( indr ( l ) == jbest ) exit end do indr ( l ) = indr ( lpivr ) indr ( lpivr ) = jbest lpivc = locc ( jbest ) lpivc1 = lpivc + 1 lpivc2 = lpivc + melim do l = lpivc , lpivc2 if ( indc ( l ) == ibest ) exit end do indc ( l ) = indc ( lpivc ) indc ( lpivc ) = ibest abest = a ( l ) a ( l ) = a ( lpivc ) a ( lpivc ) = abest if ( keepLU ) then ! relax else ! Store just the diagonal of U, in natural order. !!!   a(ldiagU + nrowu) = abest ! This was in pivot order. a ( ldiagU + jbest ) = abest end if !============================================================== ! Delete pivot col from heap. ! Hk tells us where it is in the heap. !============================================================== if ( TCP ) then kbest = Hk ( jbest ) Hlenin = Hlen call Hdelete ( Ha , Hj , Hk , Hlenin , Hlen , n , kbest , h ) hops = hops + h end if !=============================================================== ! Delete the pivot row from the column file ! and store it as the next row of  U. ! Set indr(lu) = 0    to initialize jfill ptrs on columns of D, !     indc(lu) = lenj to save the original column lengths. !=============================================================== a ( lu1 ) = abest indr ( lu1 ) = jbest indc ( lu1 ) = nrowd lu = lu1 diag = abs ( abest ) Umax = max ( Umax , diag ) DUmax = max ( DUmax , diag ) DUmin = min ( DUmin , diag ) do lr = lpivr1 , lpivr2 lu = lu + 1 j = indr ( lr ) lenj = lenc ( j ) lenc ( j ) = lenj - 1 lc1 = locc ( j ) last = lc1 + lenc ( j ) do l = lc1 , last if ( indc ( l ) == ibest ) exit end do a ( lu ) = a ( l ) indr ( lu ) = 0 indc ( lu ) = lenj Umax = max ( Umax , abs ( a ( lu ) ) ) a ( l ) = a ( last ) indc ( l ) = indc ( last ) indc ( last ) = 0 ! Free entry if ( j == jlast ) lcol = lcol - 1 end do !=============================================================== ! Delete the pivot column from the row file ! and store the nonzeros of the next column of  L. ! Set  indc(ll) = 0      to initialize markl(*) markers, ! indr(ll) = 0           to initialize ifill(*) row fill-in cntrs, ! indc(ls) = leni        to save the original row lengths, ! indr(ls) = iqloc(i)    to save parts of  iqloc(*), ! iqloc(i) = lsave - ls  to point to the nonzeros of  L !          = -1, -2, -3, ... in mark(*). !=============================================================== indc ( lsave ) = ncold if ( melim == 0 ) go to 700 ll = ll1 - 1 ls = lsave abest = one / abest do lc = lpivc1 , lpivc2 ll = ll + 1 ls = ls + 1 i = indc ( lc ) leni = lenr ( i ) lenr ( i ) = leni - 1 lr1 = locr ( i ) last = lr1 + lenr ( i ) do l = lr1 , last if ( indr ( l ) == jbest ) exit end do indr ( l ) = indr ( last ) indr ( last ) = 0 ! Free entry if ( i == ilast ) lrow = lrow - 1 a ( ll ) = - a ( lc ) * abest Lij = abs ( a ( ll ) ) Lmax = max ( Lmax , Lij ) !!!!! DEBUG ! if (Lij > Ltol) then ! write( *  ,*) ' Big Lij!!!', nrowu ! write(nout,*) ' Big Lij!!!', nrowu ! end if indc ( ll ) = 0 indr ( ll ) = 0 indc ( ls ) = leni indr ( ls ) = iqloc ( i ) iqloc ( i ) = lsave - ls end do !=============================================================== ! Do the Gaussian elimination. ! This involves adding a multiple of the pivot column ! to all other columns in the pivot row. ! ! Sometimes more than one call to lu1gau is needed to allow ! compression of the column file. ! lfirst  says which column the elimination should start with. ! minfre  is a bound on the storage needed for any one column. ! lu      points to off-diagonals of u. ! nfill   keeps track of pending fill-in in the row file. !=============================================================== if ( nelim == 0 ) go to 700 lfirst = lpivr1 minfre = mleft + nspare lu = 1 nfill = 0 400 call lu1gau ( m , melim , ncold , nspare , small , & lpivc1 , lpivc2 , lfirst , lpivr2 , lfree , minfre , & ilast , jlast , lrow , lcol , lu , nfill , & a , indc , indr , & lenc , lenr , locc , locr , & iqloc , a ( ll1 ), indc ( ll1 ), & a ( lu1 ), indr ( ll1 ), indr ( lu1 ) ) if ( lfirst > 0 ) then ! The elimination was interrupted. ! Compress the column file and try again. ! lfirst, lu and nfill have appropriate new values. call lu1rec ( n , . true ., luparm , lcol , jlast , & lena , a , indc , lenc , locc ) lfile = lcol lpivc = locc ( jbest ) lpivc1 = lpivc + 1 lpivc2 = lpivc + melim nfree = lfree - lcol if ( nfree < minfre ) go to 970 go to 400 end if !=============================================================== ! The column file has been fully updated. ! Deal with any pending fill-in in the row file. !=============================================================== if ( nfill > 0 ) then ! Compress the row file if necessary. ! lu1gau has set nfill to be the number of pending fill-ins ! plus the current length of any rows that need to be moved. minfre = nfill nfree = lfree - lrow if ( nfree < minfre ) then call lu1rec ( m , . false ., luparm , lrow , ilast , & lena , a , indr , lenr , locr ) lfile = lrow lpivr = locr ( ibest ) lpivr1 = lpivr + 1 lpivr2 = lpivr + nelim nfree = lfree - lrow if ( nfree < minfre ) go to 970 end if ! Move rows that have pending fill-in to end of the row file. ! Then insert the fill-in. call lu1pen ( m , melim , ncold , nspare , ilast , & lpivc1 , lpivc2 , lpivr1 , lpivr2 , lrow , & lenc , lenr , locc , locr , & indc , indr , indr ( ll1 ), indr ( lu1 ) ) end if !=============================================================== ! Restore the saved values of iqloc. ! Insert the correct indices for the col of L and the row of U. !=============================================================== 700 lenr ( ibest ) = 0 lenc ( jbest ) = 0 ll = ll1 - 1 ls = lsave do lc = lpivc1 , lpivc2 ll = ll + 1 ls = ls + 1 i = indc ( lc ) iqloc ( i ) = indr ( ls ) indc ( ll ) = i indr ( ll ) = ibest end do lu = lu1 - 1 do lr = lpivr , lpivr2 lu = lu + 1 indr ( lu ) = indr ( lr ) end do !=============================================================== ! Free the space occupied by the pivot row ! and update the column permutation. ! Then free the space occupied by the pivot column ! and update the row permutation. ! ! nzchng is found in both calls to lu1pq2, but we use it only ! after the second. !=============================================================== call lu1pq2 ( ncold , nzchng , & indr ( lpivr ), indc ( lu1 ), lenc , iqloc , q , iqinv ) call lu1pq2 ( nrowd , nzchng , & indc ( lpivc ), indc ( lsave ), lenr , iploc , p , ipinv ) nzleft = nzleft + nzchng !=============================================================== ! lu1mxr resets Amaxr(i) in each modified row i. ! lu1mxc moves the largest aij to the top of each modified col j. ! 28 Jun 2002: Note that cols of L have an implicit diag of 1.0, !              so lu1mxr is called with ll1, not ll1+1, whereas !              lu1mxc is called with             lu1+1. !=============================================================== if ( Utri . and . TPP ) then ! Relax -- we're not keeping big elements at the top yet. else if ( TRP . and . melim > 0 ) then ! Beware: The parts of p that we need are in indc(ll1:ll) ! 28 Sep 2015: inform is now an output. mark = mark + 1 call lu1mxr ( mark , ll1 , ll , m , n , lena , inform , & a , indc , lenc , locc , indr , lenr , locr , & indc , markc , markr , Amaxr ) ! &#94;&#94;&#94;&#94;  Here are the p(k1:k2) needed by lu1mxr. if ( inform > 0 ) go to 981 end if if ( nelim > 0 ) then call lu1mxc ( lu1 + 1 , lu , indr , a , indc , lenc , locc ) if ( TCP ) then ! Update modified columns in heap ! 20 Dec 2015: Allow for empty columns. do kk = lu1 + 1 , lu j = indr ( kk ) k = Hk ( j ) if ( lenc ( j ) > 0 ) then v = abs ( a ( locc ( j )) ) ! Biggest aij in column j else v = zero end if call Hchange ( Ha , Hj , Hk , Hlen , n , k , v , j , h ) hops = hops + h end do end if end if end if !=============================================================== ! Negate lengths of pivot row and column so they will be ! eliminated during compressions. !=============================================================== lenr ( ibest ) = - ncold lenc ( jbest ) = - nrowd ! Test for fatal bug: row or column lists overwriting L and U. if ( lrow > lsave ) go to 980 if ( lcol > lsave ) go to 980 ! Reset the file lengths if pivot row or col was at the end. if ( ibest == ilast ) then lrow = locr ( ibest ) end if if ( jbest == jlast ) then lcol = locc ( jbest ) end if 800 end do !------------------------------------------------------------------ ! End of main loop. !------------------------------------------------------------------ !------------------------------------------------------------------ ! Normal exit. ! Move empty rows and cols to the end of p, q. ! Then finish with a dense LU if necessary. !------------------------------------------------------------------ 900 inform = 0 call lu1pq3 ( m , lenr , p , ipinv , mrank ) call lu1pq3 ( n , lenc , q , iqinv , nrank ) nrank = min ( mrank , nrank ) if ( densLU ) then call lu1ful ( m , n , lena , lenD , lu1 , TPP , & mleft , nleft , nrank , nrowu , & lenL , lenU , nsing , & keepLU , small , & a , a ( lD ), indc , indr , p , q , & lenc , lenr , locc , ipinv , locr ) !***     21 Dec 1994: Bug in next line. !***     nrank  = nrank - nsing.  Changed to next line: !***     nrank  = minmn - nsing !***     26 Mar 2006: Previous line caused bug with m<n and nsing>0. ! Don't mess with nrank any more.  Let end of lu1fac handle it. end if minlen = lenL + lenU + 2 * ( m + n ) go to 990 ! Not enough space free after a compress. ! Set  minlen  to an estimate of the necessary value of  lena. 970 inform = 7 minlen = lena + lfile + 2 * ( m + n ) go to 990 ! Fatal error.  This will never happen! ! (Famous last words.) 980 inform = 8 go to 990 ! Fatal error in lu1mxr.  This will never happen! 981 inform = 10 go to 990 ! Fatal error with TSP.  Diagonal pivot not found. 985 inform = 9 ! Exit. 990 return 1100 format ( / 1 x , a ) 1200 format ( ' nrowu' , i7 , '   i,jbest' , 2 i7 , '   nrowd,ncold' , 2 i6 , & '   i,jmax' , 2 i7 , '   aijmax' , es10 . 2 ) end subroutine lu1fad !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1gau ( m , melim , ncold , nspare , small , & lpivc1 , lpivc2 , lfirst , lpivr2 , lfree , minfre , & ilast , jlast , lrow , lcol , lu , nfill , & a , indc , indr , & lenc , lenr , locc , locr , & mark , al , markl , & au , ifill , jfill ) integer ( ip ), intent ( in ) :: m , melim , ncold , nspare , & lpivc1 , lpivc2 , lpivr2 , lfree , minfre integer ( ip ), intent ( in ) :: locr ( * ), mark ( * ) real ( rp ), intent ( in ) :: small real ( rp ), intent ( in ) :: al ( melim ), au ( ncold ) integer ( ip ), intent ( inout ) :: ilast , jlast , lfirst , lrow , lcol , lu , nfill real ( rp ), intent ( inout ) :: a ( * ) integer ( ip ), intent ( inout ) :: locc ( * ), indc ( * ), indr ( * ), lenc ( * ), lenr ( * ), & markl ( melim ), ifill ( melim ), jfill ( ncold ) !------------------------------------------------------------------ ! lu1gau does most of the work for each step of ! Gaussian elimination. ! A multiple of the pivot column is added to each other column j ! in the pivot row.  The column list is fully updated. ! The row list is updated if there is room, but some fill-ins may ! remain, as indicated by ifill and jfill. ! ! Input: ! ilast    is the row    at the end of the row    list. ! jlast    is the column at the end of the column list. ! lfirst   is the first column to be processed. ! lu + 1   is the corresponding element of U in au(*). ! nfill    keeps track of pending fill-in. ! a(*)     contains the nonzeros for each column j. ! indc(*)  contains the row indices for each column j. ! al(*)    contains the new column of L.  A multiple of it is !          used to modify each column. ! mark(*)  has been set to -1, -2, -3, ... in the rows !          corresponding to nonzero 1, 2, 3, ... of the col of L. ! au(*)    contains the new row of U.  Each nonzero gives the !          required multiple of the column of L. ! ! Workspace: ! markl(*) marks the nonzeros of L actually used. !          (A different mark, namely j, is used for each column.) ! ! Output: ! ilast     New last row    in the row    list. ! jlast     New last column in the column list. ! lfirst    = 0 if all columns were completed, !           > 0 otherwise. ! lu        returns the position of the last nonzero of U !           actually used, in case we come back in again. ! nfill     keeps track of the total extra space needed in the !           row file. ! ifill(ll) counts pending fill-in for rows involved in the new !           column of L. ! jfill(lu) marks the first pending fill-in stored in columns !           involved in the new row of U. ! ! 16 Apr 1989: First version of lu1gau. ! 23 Apr 1989: lfirst, lu, nfill are now input and output !              to allow re-entry if elimination is interrupted. ! 23 Mar 2001: Introduced ilast, jlast. ! 27 Mar 2001: Allow fill-in \"in situ\" if there is already room !              up to but NOT INCLUDING the end of the !              row or column file. !              Seems safe way to avoid overwriting empty rows/cols !              at the end.  (May not be needed though, now that we !              have ilast and jlast.) ! ! 10 Jan 2010: First f90 version. ! 28 Feb 2010: Declare intent and local variables. !------------------------------------------------------------------ logical :: atend integer ( ip ) :: i , j , k , l , l1 , l2 , last , lc , lc1 , lc2 , & leni , lenj , ll , lr , lr1 , lrep , & ndone , ndrop , nfree real ( rp ) :: aij , uj do 600 lr = lfirst , lpivr2 j = indr ( lr ) lenj = lenc ( j ) nfree = lfree - lcol if ( nfree < minfre ) go to 900 !--------------------------------------------------------------- ! Inner loop to modify existing nonzeros in column  j. ! The \"do l = lc1, lc2\" loop performs most of the arithmetic ! involved in the whole LU factorization. ! ndone  counts how many multipliers were used. ! ndrop  counts how many modified nonzeros are negligibly small. !--------------------------------------------------------------- lu = lu + 1 uj = au ( lu ) lc1 = locc ( j ) lc2 = lc1 + lenj - 1 atend = j == jlast ndone = 0 if ( lenj == 0 ) go to 500 ndrop = 0 do l = lc1 , lc2 i = indc ( l ) ll = - mark ( i ) if ( ll > 0 ) then ndone = ndone + 1 markl ( ll ) = j a ( l ) = a ( l ) + al ( ll ) * uj if ( abs ( a ( l ) ) <= small ) then ndrop = ndrop + 1 end if end if end do !--------------------------------------------------------------- ! Remove any negligible modified nonzeros from both ! the column file and the row file. !--------------------------------------------------------------- if ( ndrop == 0 ) go to 500 k = lc1 do l = lc1 , lc2 i = indc ( l ) if ( abs ( a ( l ) ) > small ) then a ( k ) = a ( l ) indc ( k ) = i k = k + 1 cycle end if ! Delete the nonzero from the row file. lenj = lenj - 1 lenr ( i ) = lenr ( i ) - 1 lr1 = locr ( i ) last = lr1 + lenr ( i ) do lrep = lr1 , last if ( indr ( lrep ) == j ) exit end do indr ( lrep ) = indr ( last ) indr ( last ) = 0 if ( i == ilast ) lrow = lrow - 1 end do ! Free the deleted elements from the column file. do l = k , lc2 indc ( l ) = 0 end do if ( atend ) lcol = k - 1 !--------------------------------------------------------------- ! Deal with the fill-in in column j. !--------------------------------------------------------------- 500 if ( ndone == melim ) go to 590 ! See if column j already has room for the fill-in. if ( atend ) go to 540 last = lc1 + lenj - 1 l1 = last + 1 l2 = last + ( melim - ndone ) ! 27 Mar 2001: Be sure it's not at or past end of the col file. if ( l2 >= lcol ) go to 520 do l = l1 , l2 if ( indc ( l ) /= 0 ) go to 520 end do go to 540 ! We must move column j to the end of the column file. ! First, leave some spare room at the end of the ! current last column. ! 14 Jul 2015: (William Gandler) Fix deceptive loop !              do l = lcol + 1, lcol + nspare !                 lcol    = l 520 l1 = lcol + 1 l2 = lcol + nspare do l = l1 , l2 !  lcol    = l indc ( l ) = 0 ! Spare space is free. end do lcol = l2 atend = . true . jlast = j l1 = lc1 lc1 = lcol + 1 locc ( j ) = lc1 do l = l1 , last lcol = lcol + 1 a ( lcol ) = a ( l ) indc ( lcol ) = indc ( l ) indc ( l ) = 0 ! Free space. end do !--------------------------------------------------------------- ! Inner loop for the fill-in in column j. ! This is usually not very expensive. !--------------------------------------------------------------- 540 last = lc1 + lenj - 1 ll = 0 do lc = lpivc1 , lpivc2 ll = ll + 1 if ( markl ( ll ) == j ) cycle aij = al ( ll ) * uj if ( abs ( aij ) <= small ) cycle lenj = lenj + 1 last = last + 1 a ( last ) = aij i = indc ( lc ) indc ( last ) = i leni = lenr ( i ) ! Add 1 fill-in to row i if there is already room. ! 27 Mar 2001: Be sure it's not at or past the end ! of the row file. l = locr ( i ) + leni if ( l < lrow . and . indr ( l ) <= 0 ) then indr ( l ) = j lenr ( i ) = leni + 1 else ! Row i does not have room for the fill-in. ! Increment ifill(ll) to count how often this has ! happened to row i.  Also, add m to the row index ! indc(last) in column j to mark it as a fill-in that is ! still pending. ! If this is the first pending fill-in for row i, ! nfill includes the current length of row i ! (since the whole row has to be moved later). ! If this is the first pending fill-in for column j, ! jfill(lu) records the current length of column j ! (to shorten the search for pending fill-ins later). if ( ifill ( ll ) == 0 ) nfill = nfill + leni + nspare if ( jfill ( lu ) == 0 ) jfill ( lu ) = lenj nfill = nfill + 1 ifill ( ll ) = ifill ( ll ) + 1 indc ( last ) = m + i end if end do if ( atend ) lcol = last ! End loop for column  j.  Store its final length. 590 lenc ( j ) = lenj 600 end do ! Successful completion. lfirst = 0 return ! Interruption.  We have to come back in after the ! column file is compressed.  Give lfirst a new value. ! lu and nfill will retain their current values. 900 lfirst = lr return end subroutine lu1gau !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1mar ( m , n , lena , maxmn , & TCP , aijtol , Ltol , maxcol , maxrow , & ibest , jbest , mbest , & a , indc , indr , p , q , & lenc , lenr , locc , locr , iploc , iqloc ) logical , intent ( in ) :: TCP integer ( ip ), intent ( in ) :: m , n , lena , maxmn , maxcol , maxrow real ( rp ), intent ( in ) :: aijtol , Ltol , a ( lena ) integer ( ip ), intent ( in ) :: indc ( lena ), indr ( lena ), p ( m ) , q ( n ) , & lenc ( n ) , lenr ( m ) , iploc ( n ), iqloc ( m ), & locc ( n ) , locr ( m ) integer ( ip ), intent ( out ) :: ibest , jbest , mbest !------------------------------------------------------------------ ! lu1mar  uses a Markowitz criterion to select a pivot element ! for the next stage of a sparse LU factorization, ! subject to a Threshold Partial Pivoting stability criterion (TPP) ! that bounds the elements of L. ! ! 00 Jan 1986: Version documented in LUSOL paper: !              Gill, Murray, Saunders and Wright (1987), !              \"Maintaining LU factors of a general sparse matrix\", !              Linear algebra and its applications 88/89, 239-270. ! ! 02 Feb 1989: Following Suhl and Aittoniemi (1987), the largest !              element in each column is now kept at the start of !              the column, i.e. in position locc(j) of a and indc. !              This should speed up the Markowitz searches. ! ! 26 Apr 1989: Both columns and rows searched during spars1 phase. !              Only columns searched during spars2 phase. !              maxtie replaced by maxcol and maxrow. ! 05 Nov 1993: Initializing  \"mbest = m * n\"  wasn't big enough when !              m = 10, n = 3, and last column had 7 nonzeros. ! 09 Feb 1994: Realised that \"mbest = maxmn * maxmn\" might overflow. !              Changed to    \"mbest = maxmn * 1000\". ! 27 Apr 2000: On large example from Todd Munson, !              that allowed  \"if (mbest .le. nz1**2) go to 900\" !              to exit before any pivot had been found. !              Introduced kbest = mbest / nz1. !              Most pivots can be rejected with no integer(ip) multiply. !              True merit is evaluated only if it's as good as the !              best so far (or better).  There should be no danger !              of integer(ip) overflow unless A is incredibly !              large and dense. ! ! 10 Sep 2000  TCP, aijtol added for Threshold Complete Pivoting. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent. !------------------------------------------------------------------ integer ( ip ) :: i , j , kbest , lc , lc1 , lc2 , len1 , & lp , lp1 , lp2 , lq , lq1 , lq2 , lr , lr1 , lr2 , & merit , ncol , nrow , nz , nz1 real ( rp ) :: abest , aij , amax , cmax , lbest real ( rp ), parameter :: gamma = 2.0 ! gamma  is \"gamma\" in the tie-breaking rule TB4 in the LUSOL paper. !------------------------------------------------------------------ ! Search cols of length nz = 1, then rows of length nz = 1, ! then   cols of length nz = 2, then rows of length nz = 2, etc. !------------------------------------------------------------------ abest = zero lbest = zero ibest = 0 kbest = maxmn + 1 mbest = - 1 ncol = 0 nrow = 0 nz1 = 0 NZS : do nz = 1 , maxmn ! nz1    = nz - 1 ! if (mbest .le. nz1**2) go to 900 if ( kbest <= nz1 ) exit NZS if ( ibest > 0 ) then if ( ncol >= maxcol ) go to 200 end if if ( nz > m ) go to 200 !--------------------------------------------------------------- ! Search the set of columns of length  nz. !--------------------------------------------------------------- lq1 = iqloc ( nz ) lq2 = n if ( nz < m ) lq2 = iqloc ( nz + 1 ) - 1 Cols : do lq = lq1 , lq2 ncol = ncol + 1 j = q ( lq ) lc1 = locc ( j ) lc2 = lc1 + nz1 amax = abs ( a ( lc1 ) ) ! Test all aijs in this column. ! amax is the largest element (the first in the column). ! cmax is the largest multiplier if aij becomes pivot. if ( TCP ) then if ( amax < aijtol ) cycle Cols ! Nothing in whole column end if Colj : do lc = lc1 , lc2 i = indc ( lc ) len1 = lenr ( i ) - 1 ! merit  = nz1 * len1 ! if (merit > mbest) cycle if ( len1 > kbest ) cycle Colj ! aij  has a promising merit. ! Apply the stability test. ! We require  aij  to be sufficiently large compared to ! all other nonzeros in column  j.  This is equivalent ! to requiring cmax to be bounded by Ltol. if ( lc == lc1 ) then ! This is the maximum element, amax. ! Find the biggest element in the rest of the column ! and hence get cmax.  We know cmax .le. 1, but ! we still want it exactly in order to break ties. ! 27 Apr 2002: Settle for cmax = 1. aij = amax cmax = one ! cmax   = zero ! do 140 l = lc1 + 1, lc2 ! cmax  = max( cmax, abs( a(l) ) ) ! 140            continue ! cmax   = cmax / amax else ! aij is not the biggest element, so cmax >= 1. ! Bail out if cmax will be too big. aij = abs ( a ( lc ) ) if ( TCP ) then ! Absolute test for Complete Pivoting if ( aij < aijtol ) cycle Colj else !!! TPP if ( aij * Ltol < amax ) cycle Colj end if cmax = amax / aij end if ! aij  is big enough.  Its maximum multiplier is cmax. merit = nz1 * len1 if ( merit == mbest ) then ! Break ties. ! (Initializing mbest < 0 prevents getting here if ! nothing has been found yet.) ! In this version we minimize cmax ! but if it is already small we maximize the pivot. if ( lbest <= gamma . and . cmax <= gamma ) then if ( abest >= aij ) cycle Colj else if ( lbest <= cmax ) cycle Colj end if end if ! aij  is the best pivot so far. ibest = i jbest = j kbest = len1 mbest = merit abest = aij lbest = cmax if ( nz == 1 ) exit NZS end do Colj ! Finished with that column. if ( ibest > 0 ) then if ( ncol >= maxcol ) exit Cols end if end do Cols !--------------------------------------------------------------- ! Search the set of rows of length  nz. !--------------------------------------------------------------- ! 200  if (mbest .le. nz*nz1) go to 900 200 if ( kbest <= nz ) exit NZS if ( ibest > 0 ) then if ( nrow >= maxrow ) go to 290 end if if ( nz > n ) go to 290 lp1 = iploc ( nz ) lp2 = m if ( nz < n ) lp2 = iploc ( nz + 1 ) - 1 Rows : do lp = lp1 , lp2 nrow = nrow + 1 i = p ( lp ) lr1 = locr ( i ) lr2 = lr1 + nz1 Rowi : do lr = lr1 , lr2 j = indr ( lr ) len1 = lenc ( j ) - 1 ! merit  = nz1 * len1 ! if (merit > mbest) cycle if ( len1 > kbest ) cycle Rowi ! aij  has a promising merit. ! Find where  aij  is in column  j. lc1 = locc ( j ) lc2 = lc1 + len1 amax = abs ( a ( lc1 ) ) do lc = lc1 , lc2 if ( indc ( lc ) == i ) exit end do ! Apply the same stability test as above. aij = abs ( a ( lc ) ) if ( TCP ) then !!! Absolute test for Complete Pivoting if ( aij < aijtol ) cycle Rowi end if if ( lc == lc1 ) then ! This is the maximum element, amax. ! Find the biggest element in the rest of the column ! and hence get cmax.  We know cmax .le. 1, but ! we still want it exactly in order to break ties. ! 27 Apr 2002: Settle for cmax = 1. cmax = one ! cmax   = zero !     do 240 l = lc1 + 1, lc2 !        cmax  = max( cmax, abs( a(l) ) ) ! 240 continue ! cmax   = cmax / amax else ! aij is not the biggest element, so cmax .ge. 1. ! Bail out if cmax will be too big. if ( TCP ) then ! relax else if ( aij * Ltol < amax ) cycle Rowi end if cmax = amax / aij end if ! aij  is big enough.  Its maximum multiplier is cmax. merit = nz1 * len1 if ( merit == mbest ) then ! Break ties as before. ! (Initializing mbest < 0 prevents getting here if ! nothing has been found yet.) if ( lbest <= gamma . and . cmax <= gamma ) then if ( abest >= aij ) cycle Rowi else if ( lbest <= cmax ) cycle Rowi end if end if ! aij  is the best pivot so far. ibest = i jbest = j kbest = len1 mbest = merit abest = aij lbest = cmax if ( nz == 1 ) exit NZS end do Rowi ! Finished with that row. if ( ibest > 0 ) then if ( nrow >= maxrow ) exit Rows end if end do Rows ! See if it's time to quit. 290 if ( ibest > 0 ) then if ( nrow >= maxrow . and . ncol >= maxcol ) exit NZS end if ! Press on with next nz. nz1 = nz if ( ibest > 0 ) kbest = mbest / nz1 end do NZS end subroutine lu1mar !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1mRP ( m , n , lena , maxmn , & Ltol , maxcol , maxrow , & ibest , jbest , mbest , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & iploc , iqloc , Amaxr ) integer ( ip ), intent ( in ) :: m , n , lena , maxmn , maxcol , maxrow real ( rp ), intent ( in ) :: Ltol integer ( ip ), intent ( in ) :: indc ( lena ), indr ( lena ), p ( m ) , q ( n ) , & lenc ( n ) , lenr ( m ) , iploc ( n ), iqloc ( m ), & locc ( n ) , locr ( m ) real ( rp ), intent ( in ) :: a ( lena ) , Amaxr ( m ) integer ( ip ), intent ( out ) :: ibest , jbest , mbest !------------------------------------------------------------------ ! lu1mRP  uses a Markowitz criterion to select a pivot element ! for the next stage of a sparse LU factorization, ! subject to a Threshold Rook Pivoting stability criterion (TRP) ! that bounds the elements of L and U. ! ! 11 Jun 2002: First version of lu1mRP derived from lu1mar. ! 11 Jun 2002: Current version of lu1mRP. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent. !------------------------------------------------------------------ integer ( ip ) :: i , j , kbest , lc , lc1 , lc2 , len1 , & lp , lp1 , lp2 , lq , lq1 , lq2 , lr , lr1 , lr2 , & merit , ncol , nrow , nz , nz1 real ( rp ) :: abest , aij , amax , atoli , atolj !------------------------------------------------------------------ ! Search cols of length nz = 1, then rows of length nz = 1, ! then   cols of length nz = 2, then rows of length nz = 2, etc. !------------------------------------------------------------------ abest = zero ibest = 0 kbest = maxmn + 1 mbest = - 1 ncol = 0 nrow = 0 nz1 = 0 NZS : do nz = 1 , maxmn ! nz1    = nz - 1 ! if (mbest .le. nz1**2) go to 900 if ( kbest <= nz1 ) exit NZS if ( ibest > 0 ) then if ( ncol >= maxcol ) go to 200 end if if ( nz > m ) go to 200 !--------------------------------------------------------------- ! Search the set of columns of length  nz. !--------------------------------------------------------------- lq1 = iqloc ( nz ) lq2 = n if ( nz < m ) lq2 = iqloc ( nz + 1 ) - 1 Cols : do lq = lq1 , lq2 ncol = ncol + 1 j = q ( lq ) lc1 = locc ( j ) lc2 = lc1 + nz1 amax = abs ( a ( lc1 ) ) atolj = amax / Ltol ! Min size of pivots in col j ! Test all aijs in this column. Colj : do lc = lc1 , lc2 i = indc ( lc ) len1 = lenr ( i ) - 1 ! merit  = nz1 * len1 ! if (merit > mbest) cycle Colj if ( len1 > kbest ) cycle Colj ! aij  has a promising merit. ! Apply the Threshold Rook Pivoting stability test. ! First we require aij to be sufficiently large ! compared to other nonzeros in column j. ! Then  we require aij to be sufficiently large ! compared to other nonzeros in row    i. aij = abs ( a ( lc ) ) if ( aij < atolj ) cycle Colj if ( aij * Ltol < Amaxr ( i )) cycle Colj ! aij  is big enough. merit = nz1 * len1 if ( merit == mbest ) then ! Break ties. ! (Initializing mbest < 0 prevents getting here if ! nothing has been found yet.) if ( abest >= aij ) cycle Colj end if ! aij  is the best pivot so far. ibest = i jbest = j kbest = len1 mbest = merit abest = aij if ( nz == 1 ) exit NZS end do Colj ! Finished with that column. if ( ibest > 0 ) then if ( ncol >= maxcol ) exit Cols end if end do Cols !--------------------------------------------------------------- ! Search the set of rows of length  nz. !--------------------------------------------------------------- ! 200  if (mbest .le. nz*nz1) go to 900 200 if ( kbest <= nz ) exit NZS if ( ibest > 0 ) then if ( nrow >= maxrow ) go to 290 end if if ( nz > n ) go to 290 lp1 = iploc ( nz ) lp2 = m if ( nz < n ) lp2 = iploc ( nz + 1 ) - 1 Rows : do lp = lp1 , lp2 nrow = nrow + 1 i = p ( lp ) lr1 = locr ( i ) lr2 = lr1 + nz1 atoli = Amaxr ( i ) / Ltol ! Min size of pivots in row i Rowi : do lr = lr1 , lr2 j = indr ( lr ) len1 = lenc ( j ) - 1 ! merit  = nz1 * len1 ! if (merit > mbest) cycle if ( len1 > kbest ) cycle Rowi ! aij  has a promising merit. ! Find where  aij  is in column j. lc1 = locc ( j ) lc2 = lc1 + len1 amax = abs ( a ( lc1 ) ) do lc = lc1 , lc2 if ( indc ( lc ) == i ) exit end do ! Apply the Threshold Rook Pivoting stability test. ! First we require aij to be sufficiently large ! compared to other nonzeros in row    i. ! Then  we require aij to be sufficiently large ! compared to other nonzeros in column j. aij = abs ( a ( lc ) ) if ( aij < atoli ) cycle Rowi if ( aij * Ltol < amax ) cycle Rowi ! aij  is big enough. merit = nz1 * len1 if ( merit == mbest ) then ! Break ties as before. ! (Initializing mbest < 0 prevents getting here if ! nothing has been found yet.) if ( abest >= aij ) cycle Rowi end if ! aij  is the best pivot so far. ibest = i jbest = j kbest = len1 mbest = merit abest = aij if ( nz == 1 ) exit NZS end do Rowi ! This was loop 260 ! Finished with that row. if ( ibest > 0 ) then if ( nrow >= maxrow ) exit Rows end if end do Rows ! See if it's time to quit. 290 if ( ibest > 0 ) then if ( nrow >= maxrow . and . ncol >= maxcol ) exit NZS end if ! Press on with next nz. nz1 = nz if ( ibest > 0 ) kbest = mbest / nz1 end do NZS end subroutine lu1mRP !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1mCP ( m , n , lena , aijtol , & ibest , jbest , mbest , & a , indc , indr , & lenc , lenr , locc , & Hlen , Ha , Hj ) integer ( ip ), intent ( in ) :: m , n , lena , Hlen integer ( ip ), intent ( in ) :: indc ( lena ), indr ( lena ), & lenc ( n ) , lenr ( m ) , locc ( n ), Hj ( Hlen ) real ( rp ), intent ( in ) :: aijtol real ( rp ), intent ( in ) :: a ( lena ) , Ha ( Hlen ) integer ( ip ), intent ( out ) :: ibest , jbest , mbest !------------------------------------------------------------------ ! lu1mCP  uses a Markowitz criterion to select a pivot element ! for the next stage of a sparse LU factorization, ! subject to a Threshold Complete Pivoting stability criterion (TCP) ! that bounds the elements of L and U. ! ! 09 May 2002: First version of lu1mCP. !              It searches columns only, using the heap that !              holds the largest element in each column. ! 09 May 2002: Current version of lu1mCP. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent. !------------------------------------------------------------------ integer ( ip ) :: i , j , kheap , lc , lc1 , lc2 , len1 , lenj , & maxcol , merit , ncol , nz1 real ( rp ) :: abest , aij , amax , cmax , lbest real ( rp ), parameter :: gamma = 2.0 ! gamma  is \"gamma\" in the tie-breaking rule TB4 in the LUSOL paper. !------------------------------------------------------------------ ! Search up to maxcol columns stored at the top of the heap. ! The very top column helps initialize mbest. !------------------------------------------------------------------ abest = zero lbest = zero ibest = 0 jbest = Hj ( 1 ) ! Column at the top of the heap lenj = lenc ( jbest ) mbest = lenj * Hlen ! Bigger than any possible merit maxcol = 40 ! ??? Big question ncol = 0 ! No. of columns searched Cols : do kheap = 1 , Hlen amax = Ha ( kheap ) if ( amax < aijtol ) cycle Cols ncol = ncol + 1 j = Hj ( kheap ) !--------------------------------------------------------------- ! This column has at least one entry big enough (the top one). ! Search the column for other possibilities. !--------------------------------------------------------------- lenj = lenc ( j ) nz1 = lenj - 1 lc1 = locc ( j ) lc2 = lc1 + nz1 !--amax   = abs( a(lc1) ) ! Test all aijs in this column. ! amax is the largest element (the first in the column). ! cmax is the largest multiplier if aij becomes pivot. Colj : do lc = lc1 , lc2 i = indc ( lc ) len1 = lenr ( i ) - 1 merit = nz1 * len1 if ( merit > mbest ) cycle Colj ! aij  has a promising merit. if ( lc == lc1 ) then ! This is the maximum element, amax. ! Find the biggest element in the rest of the column ! and hence get cmax.  We know cmax .le. 1, but ! we still want it exactly in order to break ties. ! 27 Apr 2002: Settle for cmax = 1. aij = amax cmax = one ! cmax   = zero !     do 140 l = lc1 + 1, lc2 !        cmax  = max( cmax, abs( a(l) ) ) ! 140 continue ! cmax   = cmax / amax else ! aij is not the biggest element, so cmax .ge. 1. ! Bail out if cmax will be too big. aij = abs ( a ( lc ) ) if ( aij < aijtol ) cycle Colj cmax = amax / aij end if ! aij  is big enough.  Its maximum multiplier is cmax. if ( merit == mbest ) then ! Break ties. ! (Initializing mbest \"too big\" prevents getting here if ! nothing has been found yet.) ! In this version we minimize cmax ! but if it is already small we maximize the pivot. if ( lbest <= gamma . and . cmax <= gamma ) then if ( abest >= aij ) cycle Colj else if ( lbest <= cmax ) cycle Colj end if end if ! aij  is the best pivot so far. ibest = i jbest = j mbest = merit abest = aij lbest = cmax if ( merit == 0 ) exit Cols ! Col or row of length 1 end do Colj if ( ncol >= maxcol ) exit Cols end do Cols end subroutine lu1mCP !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1mSP ( m , n , lena , maxmn , & Ltol , maxcol , & ibest , jbest , mbest , & a , indc , q , locc , iqloc ) integer ( ip ), intent ( in ) :: m , n , lena , maxmn , maxcol real ( rp ), intent ( in ) :: Ltol , a ( lena ) integer ( ip ), intent ( in ) :: indc ( lena ), q ( n ), iqloc ( m ), locc ( n ) integer ( ip ), intent ( out ) :: ibest , jbest , mbest !------------------------------------------------------------------ ! lu1mSP  is intended for symmetric matrices that are either ! definite or quasi-definite. ! lu1mSP  uses a Markowitz criterion to select a pivot element for ! the next stage of a sparse LU factorization of a symmetric matrix, ! subject to a Threshold Symmetric Pivoting stability criterion ! (TSP) restricted to diagonal elements to preserve symmetry. ! This bounds the elements of L and U and should have rank-revealing ! properties analogous to Threshold Rook Pivoting for unsymmetric ! matrices. ! ! 14 Dec 2002: First version of lu1mSP derived from lu1mRP. !              There is no safeguard to ensure that A is symmetric. ! 14 Dec 2002: Current version of lu1mSP. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent. !------------------------------------------------------------------ integer ( ip ) :: i , j , kbest , lc , lc1 , lc2 , & lq , lq1 , lq2 , merit , ncol , nz , nz1 real ( rp ) :: abest , aij , amax , atolj !------------------------------------------------------------------ ! Search cols of length nz = 1, then cols of length nz = 2, etc. !------------------------------------------------------------------ abest = zero ibest = 0 kbest = maxmn + 1 mbest = - 1 ncol = 0 nz1 = 0 NZS : do nz = 1 , maxmn ! nz1    = nz - 1 ! if (mbest <= nz1**2) exit if ( kbest <= nz1 ) exit NZS if ( ibest > 0 ) then if ( ncol >= maxcol ) go to 200 end if if ( nz > m ) go to 200 !--------------------------------------------------------------- ! Search the set of columns of length  nz. !--------------------------------------------------------------- lq1 = iqloc ( nz ) lq2 = n if ( nz < m ) lq2 = iqloc ( nz + 1 ) - 1 Cols : do lq = lq1 , lq2 ncol = ncol + 1 j = q ( lq ) lc1 = locc ( j ) lc2 = lc1 + nz1 amax = abs ( a ( lc1 ) ) atolj = amax / Ltol ! Min size of pivots in col j ! Test all aijs in this column. ! Ignore everything except the diagonal. Colj : do lc = lc1 , lc2 i = indc ( lc ) if ( i /= j ) cycle Colj ! Skip off-diagonals. ! merit  = nz1 * nz1 ! if (merit > mbest) cycle if ( nz1 > kbest ) cycle Colj ! aij  has a promising merit. ! Apply the Threshold Partial Pivoting stability test ! (which is equivalent to Threshold Rook Pivoting for ! symmetric matrices). ! We require aij to be sufficiently large ! compared to other nonzeros in column j. aij = abs ( a ( lc ) ) if ( aij < atolj ) cycle Colj ! aij  is big enough. merit = nz1 * nz1 if ( merit == mbest ) then ! Break ties. ! (Initializing mbest < 0 prevents getting here if ! nothing has been found yet.) if ( abest >= aij ) cycle Colj end if ! aij  is the best pivot so far. ibest = i jbest = j kbest = nz1 mbest = merit abest = aij if ( nz == 1 ) exit NZS end do Colj ! Finished with that column. if ( ibest > 0 ) then if ( ncol >= maxcol ) exit Cols end if end do Cols ! See if it's time to quit. 200 if ( ibest > 0 ) then if ( ncol >= maxcol ) exit NZS end if ! Press on with next nz. nz1 = nz if ( ibest > 0 ) kbest = mbest / nz1 end do NZS end subroutine lu1mSP !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1pen ( m , melim , ncold , nspare , ilast , & lpivc1 , lpivc2 , lpivr1 , lpivr2 , lrow , & lenc , lenr , locc , locr , & indc , indr , ifill , jfill ) integer ( ip ), intent ( in ) :: m , melim , ncold , nspare , & lpivc1 , lpivc2 , lpivr1 , lpivr2 integer ( ip ), intent ( in ) :: locc ( * ), ifill ( melim ), jfill ( ncold ) integer ( ip ), intent ( inout ) :: lrow integer ( ip ), intent ( inout ) :: indc ( * ), indr ( * ), lenc ( * ), lenr ( * ) integer ( ip ), intent ( inout ) :: locr ( * ) integer ( ip ), intent ( out ) :: ilast !------------------------------------------------------------------ ! lu1pen deals with pending fill-in in the row file. ! ifill(ll) says if a row involved in the new column of L ! has to be updated.  If positive, it is the total ! length of the final updated row. ! jfill(lu) says if a column involved in the new row of U ! contains any pending fill-ins.  If positive, it points ! to the first fill-in in the column that has yet to be ! added to the row file. ! ! 16 Apr 1989: First version of lu1pen. ! 23 Mar 2001: ilast used and updated. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent. ! 14 Jul 2015: (William Gandler) Fix deceptive loop !              do l = lrow + 1, lrow + nspare !                 lrow    = l !------------------------------------------------------------------ integer ( ip ) :: i , j , l , l1 , l2 , last , lc , lc1 , lc2 , ll , lr , lr1 , lr2 , lu ll = 0 do lc = lpivc1 , lpivc2 ll = ll + 1 if ( ifill ( ll ) == 0 ) cycle ! Another row has pending fill. ! First, add some spare space at the end ! of the current last row. ! 14 Jul 2015: (William Gandler) Fix deceptive loop !              (same as fix in previous comment) l1 = lrow + 1 l2 = lrow + nspare do l = l1 , l2 !  lrow    = l indr ( l ) = 0 end do lrow = l2 ! Now move row i to the end of the row file. i = indc ( lc ) ilast = i lr1 = locr ( i ) lr2 = lr1 + lenr ( i ) - 1 locr ( i ) = lrow + 1 do lr = lr1 , lr2 lrow = lrow + 1 indr ( lrow ) = indr ( lr ) indr ( lr ) = 0 end do lrow = lrow + ifill ( ll ) end do ! Scan all columns of  D  and insert the pending fill-in ! into the row file. lu = 1 do lr = lpivr1 , lpivr2 lu = lu + 1 if ( jfill ( lu ) == 0 ) cycle j = indr ( lr ) lc1 = locc ( j ) + jfill ( lu ) - 1 lc2 = locc ( j ) + lenc ( j ) - 1 do lc = lc1 , lc2 i = indc ( lc ) - m if ( i > 0 ) then indc ( lc ) = i last = locr ( i ) + lenr ( i ) indr ( last ) = j lenr ( i ) = lenr ( i ) + 1 end if end do end do end subroutine lu1pen !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1mxc ( k1 , k2 , q , a , indc , lenc , locc ) integer ( ip ), intent ( in ) :: k1 , k2 integer ( ip ), intent ( in ) :: q ( k2 ), lenc ( * ), locc ( * ) integer ( ip ), intent ( inout ) :: indc ( * ) real ( rp ), intent ( inout ) :: a ( * ) !------------------------------------------------------------------ ! lu1mxc  moves the largest element in each of columns q(k1:k2) ! to the top of its column. ! If k1 > k2, nothing happens. ! ! 06 May 2002: (and earlier) !              All columns k1:k2 must have one or more elements. ! 07 May 2002: Allow for empty columns.  The heap routines need to !              find 0.0 as the \"largest element\". ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent. ! 13 Dec 2015: BUG!  We can't set a(lc1) = zero for an empty col. !              We need to fix the heap routines another way. !              Here, fixed the case lenc(j) = 0. !------------------------------------------------------------------ integer ( ip ) :: i , j , k , l , lc , lc1 , lc2 real ( rp ) :: amax do k = k1 , k2 j = q ( k ) lc1 = locc ( j ) ! The next 10 lines are equivalent to ! l      = idamax( lenc(j), a(lc1), 1 )  +  lc1 - 1 ! >>>>>>>> lc2 = lc1 + lenc ( j ) - 1 amax = zero l = lc1 do lc = lc1 , lc2 if ( amax < abs ( a ( lc ) )) then amax = abs ( a ( lc ) ) l = lc end if end do ! >>>>>>>> ! Note that empty columns do nothing (l = lc1). if ( l > lc1 ) then amax = a ( l ) a ( l ) = a ( lc1 ) a ( lc1 ) = amax i = indc ( l ) indc ( l ) = indc ( lc1 ) indc ( lc1 ) = i end if end do end subroutine lu1mxc !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1mxr ( mark , k1 , k2 , m , n , lena , inform , & a , indc , lenc , locc , indr , lenr , locr , & p , markc , markr , Amaxr ) integer ( ip ), intent ( in ) :: mark , k1 , k2 , m , n , lena integer ( ip ), intent ( out ) :: inform integer ( ip ), intent ( in ) :: indc ( lena ), lenc ( n ), locc ( n ), & indr ( lena ), lenr ( m ), locr ( m ), p ( k2 ) real ( rp ), intent ( in ) :: a ( lena ) integer ( ip ), intent ( inout ) :: markc ( n ), markr ( m ) real ( rp ), intent ( inout ) :: Amaxr ( m ) !------------------------------------------------------------------ ! lu1mxr  finds the largest element in each of rows i = p(k1:k2) ! and stores it in each Amaxr(i). ! The nonzeros are stored column-wise in (a,indc,lenc,locc) ! and their structure is     row-wise in (  indr,lenr,locr). ! ! 11 Jun 2002: First version of lu1mxr. !              Allow for empty columns. ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent. ! 03 Apr 2013: Recoded to improve efficiency.  Need new arrays !              markc(n), markr(m) and local array cols(n). ! !              First call:  mark = 0, k1 = 1, k2 = m. !              Initialize all of markc(n), markr(m), Amaxr(m). !              Columns are searched only once. !              cols(n) is not used. ! !              Later: mark := mark + 1 (greater than for previous call). !              Cols involved in rows p(k1:k2) are searched only once. !              cols(n) is local storage. !              markc(:), markr(:) are marked (= mark) in some places. !              For next call with new mark, !              all of markc, markr will initially appear unmarked. ! 28 Sep 2015: inform is now an output to mean i is invalid. !------------------------------------------------------------------ integer ( ip ) :: cols ( n ) integer ( ip ) :: i , j , k , lc , lc1 , lc2 , lr , lr1 , lr2 , ncol inform = 0 if ( mark == 0 ) then ! First call: Find Amaxr(1:m) for original A. markr ( 1 : m ) = 0 markc ( 1 : n ) = 0 Amaxr ( 1 : m ) = zero do j = 1 , n lc1 = locc ( j ) lc2 = lc1 + lenc ( j ) - 1 do lc = lc1 , lc2 i = indc ( lc ) Amaxr ( i ) = max ( Amaxr ( i ), abs ( a ( lc )) ) end do end do else ! Later calls: Find Amaxr(i) for rows i = p(k1:k2). ncol = 0 do k = k1 , k2 ! Search rows to find which cols are involved. i = p ( k ) markr ( i ) = mark ! Mark this row Amaxr ( i ) = zero lr1 = locr ( i ) lr2 = lr1 + lenr ( i ) - 1 do lr = lr1 , lr2 ! Mark all unmarked cols in this row. j = indr ( lr ) ! Build up a list of which ones they are. if ( markc ( j ) /= mark ) then markc ( j ) = mark ncol = ncol + 1 cols ( ncol ) = j end if end do end do do k = 1 , ncol ! Search involved columns. j = cols ( k ) lc1 = locc ( j ) lc2 = lc1 + lenc ( j ) - 1 do lc = lc1 , lc2 i = indc ( lc ) ! 25 Sep 2015: Check for invalid i that would cause a crash. ! if (i > m) then !    write(*,*) 'lu1mxr fatal error: i =', i !    inform = 10 !    return ! end if if ( markr ( i ) == mark ) then Amaxr ( i ) = max ( Amaxr ( i ), abs ( a ( lc )) ) end if end do end do end if end subroutine lu1mxr !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1or1 ( m , n , nelem , lena , small , & a , indc , indr , lenc , lenr , & Amax , numnz , lerr , inform ) integer ( ip ), intent ( in ) :: m , n , nelem , lena real ( rp ), intent ( in ) :: small real ( rp ), intent ( inout ) :: a ( lena ) integer ( ip ), intent ( inout ) :: indc ( lena ), indr ( lena ) integer ( ip ), intent ( out ) :: lerr , inform integer ( ip ), intent ( out ) :: lenc ( n ), lenr ( m ) !------------------------------------------------------------------ ! lu1or1  organizes the elements of an  m by n  matrix  A  as ! follows.  On entry, the parallel arrays   a, indc, indr, ! contain  nelem  entries of the form     aij,    i,    j, ! in any order.  nelem  must be positive. ! ! Entries not larger than the input parameter  small  are treated as ! zero and removed from   a, indc, indr.  The remaining entries are ! defined to be nonzero.  numnz  returns the number of such nonzeros ! and  Amax  returns the magnitude of the largest nonzero. ! The arrays  lenc, lenr  return the number of nonzeros in each ! column and row of  A. ! ! inform = 0  on exit, except  inform = 1  if any of the indices in ! indc, indr  imply that the element  aij  lies outside the  m by n ! dimensions of  A. ! ! xx Feb 1985: Original version. ! 17 Oct 2000: a, indc, indr now have size lena to allow nelem = 0. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. !------------------------------------------------------------------ integer ( ip ) :: i , j , l , numnz real ( rp ) :: Amax lenr ( 1 : m ) = 0 lenc ( 1 : n ) = 0 lerr = 0 Amax = zero numnz = nelem do l = nelem , 1 , - 1 if ( abs ( a ( l )) > small ) then i = indc ( l ) j = indr ( l ) Amax = max ( Amax , abs ( a ( l )) ) if ( i < 1 . or . i > m ) go to 910 if ( j < 1 . or . j > n ) go to 910 lenr ( i ) = lenr ( i ) + 1 lenc ( j ) = lenc ( j ) + 1 else ! Replace a negligible element by last element.  Since ! we are going backwards, we know the last element is ok. a ( l ) = a ( numnz ) indc ( l ) = indc ( numnz ) indr ( l ) = indr ( numnz ) numnz = numnz - 1 end if end do inform = 0 return 910 lerr = l inform = 1 return end subroutine lu1or1 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1or2 ( n , numa , lena , a , inum , jnum , lenc , locc ) integer ( ip ), intent ( in ) :: n , numa , lena integer ( ip ), intent ( in ) :: lenc ( n ) integer ( ip ), intent ( inout ) :: inum ( lena ), jnum ( lena ) real ( rp ), intent ( inout ) :: a ( lena ) integer ( ip ), intent ( out ) :: locc ( n ) !------------------------------------------------------------------ ! lu1or2  sorts a list of matrix elements  a(i,j)  into column ! order, given  numa  entries  a(i,j),  i,  j  in the parallel ! arrays  a, inum, jnum  respectively.  The matrix is assumed ! to have n columns and an arbitrary number of rows. ! ! On entry, lenc(*) must contain the length of each column. ! ! On exit,  a(*) and inum(*)  are sorted,  jnum(*) = 0,  and ! locc(j)  points to the start of column j. ! ! lu1or2  is derived from mc20ad, a routine in the Harwell ! Subroutine Library, author J. K. Reid. ! xx Feb 1985: Original version. ! 17 Oct 2000: a, inum, jnum now have size lena to allow nelem = 0. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. !------------------------------------------------------------------ integer ( ip ) :: i , ice , icep , j , ja , jb , jce , jcep , l real ( rp ) :: ace , acep ! Set  loc(j)  to point to the beginning of column  j. l = 1 do j = 1 , n locc ( j ) = l l = l + lenc ( j ) end do ! Sort the elements into column order. ! The algorithm is an in-place sort and is of order  numa. do i = 1 , numa ! Establish the current entry. jce = jnum ( i ) if ( jce == 0 ) cycle ace = a ( i ) ice = inum ( i ) jnum ( i ) = 0 ! Chain from current entry. do j = 1 , numa ! The current entry is not in the correct position. ! Determine where to store it. l = locc ( jce ) locc ( jce ) = locc ( jce ) + 1 ! Save the contents of that location. acep = a ( l ) icep = inum ( l ) jcep = jnum ( l ) ! Store current entry. a ( l ) = ace inum ( l ) = ice jnum ( l ) = 0 ! If next current entry needs to be processed, ! copy it into current entry. if ( jcep == 0 ) exit ace = acep ice = icep jce = jcep end do end do ! Reset loc(j) to point to the start of column j. ja = 1 do j = 1 , n jb = locc ( j ) locc ( j ) = ja ja = jb end do end subroutine lu1or2 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1or3 ( m , n , lena , indc , lenc , locc , iw , lerr , inform ) integer ( ip ), intent ( in ) :: m , n , lena integer ( ip ), intent ( in ) :: indc ( lena ), lenc ( n ), locc ( n ) integer ( ip ), intent ( out ) :: lerr , inform integer ( ip ), intent ( out ) :: iw ( m ) !------------------------------------------------------------------ ! lu1or3  looks for duplicate elements in an m by n matrix A ! defined by the column list  indc, lenc, locc. ! iw  is used as a work vector of length  m. ! ! xx Feb 1985: Original version. ! 17 Oct 2000: indc, indr now have size lena to allow nelem = 0. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. !------------------------------------------------------------------ integer ( ip ) :: i , j , l , l1 , l2 iw ( 1 : m ) = 0 lerr = 0 do j = 1 , n if ( lenc ( j ) > 0 ) then l1 = locc ( j ) l2 = l1 + lenc ( j ) - 1 do l = l1 , l2 i = indc ( l ) if ( iw ( i ) == j ) go to 910 iw ( i ) = j end do end if end do inform = 0 return 910 lerr = l inform = 1 return end subroutine lu1or3 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1or4 ( m , n , nelem , lena , indc , indr , lenc , lenr , locc , locr ) integer ( ip ), intent ( in ) :: m , n , nelem , lena integer ( ip ), intent ( in ) :: indc ( lena ), lenc ( n ), locc ( n ), lenr ( m ) integer ( ip ), intent ( out ) :: indr ( lena ), locr ( m ) !------------------------------------------------------------------ ! lu1or4     constructs a row list  indr, locr ! from a corresponding column list  indc, locc, ! given the lengths of both columns and rows in  lenc, lenr. ! ! xx Feb 1985: Original version. ! 17 Oct 2000: indc, indr now have size lena to allow nelem = 0. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. !------------------------------------------------------------------ integer ( ip ) :: i , j , jdummy , l , l1 , l2 , lr ! Initialize  locr(i)  to point just beyond where the ! last component of row  i  will be stored. l = 1 do i = 1 , m l = l + lenr ( i ) locr ( i ) = l end do ! By processing the columns backwards and decreasing  locr(i) ! each time it is accessed, it will end up pointing to the ! beginning of row  i  as required. l2 = nelem j = n + 1 do jdummy = 1 , n j = j - 1 if ( lenc ( j ) > 0 ) then l1 = locc ( j ) do l = l1 , l2 i = indc ( l ) lr = locr ( i ) - 1 locr ( i ) = lr indr ( lr ) = j end do l2 = l1 - 1 end if end do end subroutine lu1or4 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1pq1 ( m , n , len , iperm , loc , inv , num ) integer ( ip ), intent ( in ) :: m , n integer ( ip ), intent ( in ) :: len ( m ) integer ( ip ), intent ( out ) :: iperm ( m ), loc ( n ), inv ( m ) integer ( ip ), intent ( out ) :: num ( n ) ! workspace !------------------------------------------------------------------ ! lu1pq1  constructs a permutation  iperm  from the array  len. ! ! On entry: ! len(i)  holds the number of nonzeros in the i-th row (say) !         of an m by n matrix. ! num(*)  can be anything (workspace). ! ! On exit: ! iperm   contains a list of row numbers in the order !         rows of length 0,  rows of length 1,..., rows of length n. ! loc(nz) points to the first row containing  nz  nonzeros, !         nz = 1, n. ! inv(i)  points to the position of row i within iperm(*). ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. !------------------------------------------------------------------ integer ( ip ) :: i , l , nz , nzero ! Count the number of rows of each length. nzero = 0 num ( 1 : n ) = 0 loc ( 1 : n ) = 0 do i = 1 , m nz = len ( i ) if ( nz == 0 ) then nzero = nzero + 1 else num ( nz ) = num ( nz ) + 1 end if end do ! Set starting locations for each length. l = nzero + 1 do nz = 1 , n loc ( nz ) = l l = l + num ( nz ) num ( nz ) = 0 end do ! Form the list. nzero = 0 do i = 1 , m nz = len ( i ) if ( nz == 0 ) then nzero = nzero + 1 iperm ( nzero ) = i else l = loc ( nz ) + num ( nz ) iperm ( l ) = i num ( nz ) = num ( nz ) + 1 end if end do ! Define the inverse of iperm. do l = 1 , m i = iperm ( l ) inv ( i ) = l end do end subroutine lu1pq1 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1pq2 ( nzpiv , nzchng , indr , lenold , lennew , iqloc , q , iqinv ) integer ( ip ), intent ( in ) :: nzpiv integer ( ip ), intent ( in ) :: lenold ( nzpiv ), lennew ( * ) integer ( ip ), intent ( inout ) :: indr ( nzpiv ), iqloc ( * ), q ( * ), iqinv ( * ) integer ( ip ), intent ( out ) :: nzchng !=============================================================== ! lu1pq2 frees the space occupied by the pivot row, ! and updates the column permutation q. ! ! Also used to free the pivot column and update the row perm p. ! ! nzpiv   (input)    is the length of the pivot row (or column). ! nzchng  (output)   is the net change in total nonzeros. ! ! 14 Apr 1989:  First version. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. !=============================================================== integer ( ip ) :: j , jnew , l , lnew , lr , next , nz , nznew nzchng = 0 do lr = 1 , nzpiv j = indr ( lr ) indr ( lr ) = 0 nz = lenold ( lr ) nznew = lennew ( j ) if ( nz /= nznew ) then l = iqinv ( j ) nzchng = nzchng + ( nznew - nz ) ! l above is the position of column j in q  (so j = q(l)). if ( nz < nznew ) then ! Column j has to move toward the end of q. 110 next = nz + 1 lnew = iqloc ( next ) - 1 if ( lnew /= l ) then jnew = q ( lnew ) q ( l ) = jnew iqinv ( jnew ) = l end if l = lnew iqloc ( next ) = lnew nz = next if ( nz < nznew ) go to 110 else ! Column j has to move toward the front of q. 120 lnew = iqloc ( nz ) if ( lnew /= l ) then jnew = q ( lnew ) q ( l ) = jnew iqinv ( jnew ) = l end if l = lnew iqloc ( nz ) = lnew + 1 nz = nz - 1 if ( nz > nznew ) go to 120 end if q ( lnew ) = j iqinv ( j ) = lnew end if end do end subroutine lu1pq2 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1pq3 ( n , len , iperm , iw , nrank ) integer ( ip ), intent ( in ) :: n integer ( ip ), intent ( in ) :: len ( n ) integer ( ip ), intent ( inout ) :: iperm ( n ) integer ( ip ), intent ( out ) :: iw ( n ) ! workspace !------------------------------------------------------------------ ! lu1pq3  looks at the permutation  iperm(*)  and moves any entries ! to the end whose corresponding length  len(*)  is zero. ! ! 09 Feb 1994: Added work array iw(*) to improve efficiency. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. !------------------------------------------------------------------ integer ( ip ) :: i , k , nrank , nzero nrank = 0 nzero = 0 do k = 1 , n i = iperm ( k ) if ( len ( i ) == 0 ) then nzero = nzero + 1 iw ( nzero ) = i else nrank = nrank + 1 iperm ( nrank ) = i end if end do do k = 1 , nzero iperm ( nrank + k ) = iw ( k ) end do end subroutine lu1pq3 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1rec ( n , reals , luparm , ltop , ilast , & lena , a , ind , lenc , locc ) logical , intent ( in ) :: reals integer ( ip ), intent ( in ) :: n , lena integer ( ip ), intent ( inout ) :: ltop integer ( ip ), intent ( out ) :: ilast integer ( ip ), intent ( inout ) :: luparm ( 30 ), ind ( lena ), lenc ( n ), locc ( n ) real ( rp ), intent ( inout ) :: a ( lena ) !------------------------------------------------------------------ ! lu1rec recovers space in the column or row lists. ! 00 Jun 1983: Original version of lu1rec followed John Reid's !              compression routine in LA05.  It recovered space !              in ind(*) and optionally a(*) by eliminating entries !              with ind(l) = 0. !              The elements of ind(*) could not be negative. !              If len(i) was positive, entry i contained !              that many elements, starting at  loc(i). !              Otherwise, entry i was eliminated. ! ! 23 Mar 2001: Realised we could have len(i) = 0 in rare cases! !              (Mostly during TCP when the pivot row contains !              a column of length 1 that couldn't be a pivot.) !              Revised storage scheme to !                 keep        entries with       ind(l) >  0, !                 squeeze out entries with -n <= ind(l) <= 0, !              and to allow len(i) = 0. !              Empty items are moved to the end of the compressed !              ind(*) and/or a(*) arrays are given one empty space. !              Items with len(i) < 0 are still eliminated. ! ! 27 Mar 2001: Decided to use only ind(l) > 0 and = 0 in lu1fad. !              Still have to keep entries with len(i) = 0. ! ! On exit: ! ltop         is the length of useful entries in ind(*), a(*). ! ind(ltop+1)  is \"i=ilast\" such that len(i), loc(i) belong to the !              last item in ind(*), a(*). ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. ! 20 Dec 2015: ilast is output instead of ind(ltop+1). !------------------------------------------------------------------ integer ( ip ) :: i , k , klast , l , leni , lprint , nempty , nout nempty = 0 do i = 1 , n leni = lenc ( i ) if ( leni > 0 ) then l = locc ( i ) + leni - 1 lenc ( i ) = ind ( l ) ind ( l ) = - ( n + i ) else if ( leni == 0 ) then nempty = nempty + 1 end if end do k = 0 klast = 0 ! Previous k ilast = 0 ! Last entry moved. do l = 1 , ltop i = ind ( l ) if ( i > 0 ) then k = k + 1 ind ( k ) = i if ( reals ) a ( k ) = a ( l ) else if ( i < - n ) then ! This is the end of entry  i. i = - ( i + n ) ilast = i k = k + 1 ind ( k ) = lenc ( i ) if ( reals ) a ( k ) = a ( l ) locc ( i ) = klast + 1 lenc ( i ) = k - klast klast = k end if end do ! Move any empty items to the end, adding 1 free entry for each. if ( nempty > 0 ) then do i = 1 , n if ( lenc ( i ) == 0 ) then k = k + 1 locc ( i ) = k ind ( k ) = 0 ilast = i end if end do end if nout = luparm ( 1 ) lprint = luparm ( 2 ) if ( lprint >= 50 ) write ( nout , 1000 ) ltop , k , reals , nempty luparm ( 26 ) = luparm ( 26 ) + 1 ! ncp ! 20 Dec 2015: Return ilast itself instead of ind(ltop + 1). ltop = k ! ind(ltop+1) = ilast return 1000 format ( ' lu1rec.  File compressed from' , i10 , '   to' , i10 , l3 , '  nempty =' , i8 ) end subroutine lu1rec !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1slk ( m , n , lena , q , iqloc , a , indc , locc , nslack , w ) integer ( ip ), intent ( in ) :: m , n , lena integer ( ip ), intent ( in ) :: q ( n ), iqloc ( m ), indc ( lena ), locc ( n ) integer ( ip ), intent ( out ) :: nslack real ( rp ), intent ( in ) :: a ( lena ) real ( rp ), intent ( out ) :: w ( n ) !------------------------------------------------------------------ ! lu1slk  sets w(j) > 0 if column j is a unit vector. ! ! 21 Nov 2000: First version.  lu1fad needs it for TCP. !              Note that w(*) is nominally an integer(ip) array, !              but the only spare space is the double array w(*). ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. ! 12 Dec 2015: Always call lu1slk from lu1fac to obtain nslack. !              Need indc(*) and markr(*) to count 1 slack per row. !------------------------------------------------------------------ integer ( ip ) :: markr ( m ) integer ( ip ) :: i , j , lc1 , lq , lq1 , lq2 nslack = 0 markr ( 1 : m ) = 0 w ( 1 : n ) = zero ! Check all columns of length 1. lq1 = iqloc ( 1 ) lq2 = n if ( m > 1 ) lq2 = iqloc ( 2 ) - 1 do lq = lq1 , lq2 j = q ( lq ) lc1 = locc ( j ) if ( abs ( a ( lc1 ) ) == one ) then i = indc ( lc1 ) if ( markr ( i ) == 0 ) then nslack = nslack + 1 markr ( i ) = i w ( j ) = one end if end if end do end subroutine lu1slk !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1ful ( m , n , lena , lenD , lu1 , TPP , & mleft , nleft , nrank , nrowu , & lenL , lenU , nsing , & keepLU , small , & a , d , indc , indr , p , q , & lenc , lenr , locc , ipinv , ipvt ) logical , intent ( in ) :: TPP , keepLU integer ( ip ), intent ( in ) :: m , n , lena , lenD , lu1 , & mleft , nleft , nrank , nrowu integer ( ip ), intent ( in ) :: locc ( n ) real ( rp ), intent ( in ) :: small integer ( ip ), intent ( inout ) :: lenL , lenU integer ( ip ), intent ( inout ) :: indc ( lena ), indr ( lena ), p ( m ), q ( n ), & lenc ( n ) , lenr ( m ) real ( rp ), intent ( inout ) :: a ( lena ) integer ( ip ), intent ( out ) :: ipvt ( m ), ipinv ( m ) ! workspace integer ( ip ), intent ( out ) :: nsing ! not used outside real ( rp ), intent ( out ) :: d ( lenD ) !------------------------------------------------------------------ ! lu1ful computes a dense (full) LU factorization of the ! mleft by nleft matrix that remains to be factored at the ! beginning of the nrowu-th pass through the main loop of lu1fad. ! ! 02 May 1989: First version. ! 05 Feb 1994: Column interchanges added to lu1DPP. ! 08 Feb 1994: ipinv reconstructed, since lu1pq3 may alter p. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. !------------------------------------------------------------------ integer ( ip ) :: i , ibest , ipbase , j , jbest , k , l , l1 , l2 , & la , lc , lc1 , lc2 , ld , ldbase , ldiagU , & lkk , lkn , ll , lq , lu , nrowd , ncold real ( rp ) :: ai , aj !------------------------------------------------------------------ ! If lu1pq3 moved any empty rows, reset ipinv = inverse of p. !------------------------------------------------------------------ if ( nrank < m ) then do l = 1 , m i = p ( l ) ipinv ( i ) = l end do end if !------------------------------------------------------------------ ! Copy the remaining matrix into the dense matrix D. !------------------------------------------------------------------ d ( 1 : lenD ) = zero ipbase = nrowu - 1 ldbase = 1 - nrowu do lq = nrowu , n j = q ( lq ) lc1 = locc ( j ) lc2 = lc1 + lenc ( j ) - 1 do lc = lc1 , lc2 i = indc ( lc ) ld = ldbase + ipinv ( i ) d ( ld ) = a ( lc ) end do ldbase = ldbase + mleft end do !------------------------------------------------------------------ ! Call our favorite dense LU factorizer. !------------------------------------------------------------------ if ( TPP ) then call lu1DPP ( d , mleft , mleft , nleft , small , nsing , ipvt , q ( nrowu ) ) else call lu1DCP ( d , mleft , mleft , nleft , small , nsing , ipvt , q ( nrowu ) ) end if !------------------------------------------------------------------ ! Move D to the beginning of A, ! and pack L and U at the top of a, indc, indr. ! In the process, apply the row permutation to p. ! lkk points to the diagonal of U. !------------------------------------------------------------------ a ( 1 : lenD ) = d ( 1 : lenD ) ldiagU = lena - n lkk = 1 lkn = lenD - mleft + 1 lu = lu1 do k = 1 , min ( mleft , nleft ) l1 = ipbase + k l2 = ipbase + ipvt ( k ) if ( l1 /= l2 ) then i = p ( l1 ) p ( l1 ) = p ( l2 ) p ( l2 ) = i end if ibest = p ( l1 ) jbest = q ( l1 ) if ( keepLU ) then !=========================================================== ! Pack the next column of L. !=========================================================== la = lkk ll = lu nrowd = 1 do i = k + 1 , mleft la = la + 1 ai = a ( la ) if ( abs ( ai ) > small ) then nrowd = nrowd + 1 ll = ll - 1 a ( ll ) = ai indc ( ll ) = p ( ipbase + i ) indr ( ll ) = ibest end if end do !=========================================================== ! Pack the next row of U. ! We go backwards through the row of D ! so the diagonal ends up at the front of the row of  U. ! Beware -- the diagonal may be zero. !=========================================================== la = lkn + mleft lu = ll ncold = 0 do j = nleft , k , - 1 la = la - mleft aj = a ( la ) if ( abs ( aj ) > small . or . j == k ) then ncold = ncold + 1 lu = lu - 1 a ( lu ) = aj indr ( lu ) = q ( ipbase + j ) end if end do lenr ( ibest ) = - ncold lenc ( jbest ) = - nrowd lenL = lenL + nrowd - 1 lenU = lenU + ncold lkn = lkn + 1 else !=========================================================== ! Store just the diagonal of U, in natural order. !=========================================================== a ( ldiagU + jbest ) = a ( lkk ) end if lkk = lkk + mleft + 1 end do end subroutine lu1ful !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1DPP ( a , lda , m , n , small , nsing , ipvt , q ) integer ( ip ), intent ( in ) :: lda , m , n real ( rp ), intent ( in ) :: small integer ( ip ), intent ( inout ) :: q ( n ) real ( rp ), intent ( inout ) :: a ( lda , n ) integer ( ip ), intent ( out ) :: nsing ! not used outside integer ( ip ), intent ( out ) :: ipvt ( m ) !------------------------------------------------------------------ ! lu1DPP factors a dense m x n matrix A by Gaussian elimination, ! using row interchanges for stability, as in dgefa from LINPACK. ! This version also uses column interchanges if all elements in a ! pivot column are smaller than (or equal to) \"small\".  Such columns ! are changed to zero and permuted to the right-hand end. ! ! As in LINPACK, ipvt(*) keeps track of pivot rows. ! Rows of U are interchanged, but we don't have to physically ! permute rows of L.  In contrast, column interchanges are applied ! directly to the columns of both L and U, and to the column ! permutation vector q(*). ! ! 02 May 1989: First version derived from dgefa !              in LINPACK (version dated 08/14/78). ! 05 Feb 1994: Generalized to treat rectangular matrices !              and use column interchanges when necessary. !              ipvt is retained, but column permutations are applied !              directly to q(*). ! 21 Dec 1994: Bug found via example from Steve Dirkse. !              Loop 100 added to set ipvt(*) for singular rows. ! 26 Mar 2006: nsing redefined (see below). !              Changed to implicit none. ! ! 10 Jan 2010: First f90 version.  Need to do more f90-ing. ! 12 Dec 2011: Declare intent and local variables. ! 03 Feb 2012: a is intent(inout), not (out). !              a(kp1:m,j) = t*a(kp1:m,k) + a(kp1:m,j)  needs the last :m !------------------------------------------------------------------ ! ! On entry: ! ! a       Array holding the matrix A to be factored. ! lda     The leading dimension of the array  a. ! m       The number of rows    in  A. ! n       The number of columns in  A. ! small   A drop tolerance.  Must be zero or positive. ! ! On exit: ! ! a       An upper triangular matrix and the multipliers !         which were used to obtain it. !         The factorization can be written  A = L*U  where ! L       is a product of permutation and unit lower !         triangular matrices and  U  is upper triangular. ! nsing   Number of singularities detected. ! 26 Mar 2006: nsing redefined to be more meaningful. !              Users may define rankU = n - nsing and regard !              U as upper-trapezoidal, with the first rankU columns !              being triangular and the rest trapezoidal. !              It would be better to return rankU, but we still !              return nsing for compatibility (even though lu1fad !              no longer uses it). ! ipvt    Records the pivot rows. ! q       A vector to which column interchanges are applied. !------------------------------------------------------------------ integer ( ip ) :: i , j , k , kp1 , l , last , lencol , rankU real ( rp ) :: t rankU = 0 k = 1 last = n !------------------------------------------------------------------ ! Start of elimination loop. !------------------------------------------------------------------ 10 kp1 = k + 1 lencol = m - k + 1 ! Find l, the pivot row. l = jdamax ( lencol , a ( k : m , k ), i1 ) + k - 1 ipvt ( k ) = l if ( abs ( a ( l , k ) ) <= small ) then !============================================================== ! Do column interchange, changing old pivot column to zero. ! Reduce \"last\" and try again with same k. !============================================================== j = q ( last ) q ( last ) = q ( k ) q ( k ) = j do i = 1 , k - 1 t = a ( i , last ) a ( i , last ) = a ( i , k ) a ( i , k ) = t end do do i = k , m t = a ( i , last ) a ( i , last ) = zero a ( i , k ) = t end do last = last - 1 if ( k <= last ) go to 10 else rankU = rankU + 1 if ( k < m ) then !=========================================================== ! Do row interchange if necessary. !=========================================================== if ( l /= k ) then t = a ( l , k ) a ( l , k ) = a ( k , k ) a ( k , k ) = t end if !=========================================================== ! Compute multipliers. ! Do row elimination with column indexing. !=========================================================== t = - one / a ( k , k ) ! call dscal ( m-k, t, a(kp1,k), i1 ) a ( kp1 : m , k ) = t * a ( kp1 : m , k ) do j = kp1 , last t = a ( l , j ) if ( l /= k ) then a ( l , j ) = a ( k , j ) a ( k , j ) = t end if ! call daxpy ( m-k, t, a(kp1,k), i1, a(kp1,j), i1 ) a ( kp1 : m , j ) = t * a ( kp1 : m , k ) + a ( kp1 : m , j ) end do k = k + 1 if ( k <= last ) go to 10 end if end if ! Set ipvt(*) for singular rows. do k = last + 1 , m ipvt ( k ) = k end do nsing = n - rankU end subroutine lu1DPP !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu1DCP ( a , lda , m , n , small , nsing , ipvt , q ) integer ( ip ), intent ( in ) :: lda , m , n real ( rp ), intent ( in ) :: small integer ( ip ), intent ( inout ) :: q ( n ) real ( rp ), intent ( inout ) :: a ( lda , n ) integer ( ip ), intent ( out ) :: nsing ! not used outside integer ( ip ), intent ( out ) :: ipvt ( m ) !------------------------------------------------------------------ ! lu1DCP factors a dense m x n matrix A by Gaussian elimination, ! using Complete Pivoting (row and column interchanges) for ! stability. ! This version also uses column interchanges if all elements in a ! pivot column are smaller than (or equal to) \"small\".  Such columns ! are changed to zero and permuted to the right-hand end. ! ! As in LINPACK's dgefa, ipvt(*) keeps track of pivot rows. ! Rows of U are interchanged, but we don't have to physically ! permute rows of L.  In contrast, column interchanges are applied ! directly to the columns of both L and U, and to the column ! permutation vector q(*). ! ! 01 May 2002: First dense Complete Pivoting, derived from lu1DPP. ! 07 May 2002: Another break needed at end of first loop. ! 26 Mar 2006: Cosmetic mods while looking for \"nsing\" bug when m<n. !              nsing redefined (see below). !              Changed to implicit none. ! ! 10 Jan 2010: First f90 version. ! 12 Dec 2011: Declare intent and local variables. ! 03 Feb 2012: a(kp1:m,j) = t*a(kp1:m,k) + a(kp1:m,j)  needs the last :m ! 21 Dec 2015: t = 0 caused divide by zero. !              Add test to exit if aijmax <= small. !------------------------------------------------------------------ ! ! On entry: ! a       Array holding the matrix A to be factored. ! lda     The leading dimension of the array  a. ! m       The number of rows    in  A. ! n       The number of columns in  A. ! small   A drop tolerance.  Must be zero or positive. ! ! On exit: ! a       An upper triangular matrix and the multipliers !         that were used to obtain it. !         The factorization can be written A = L*U, where !         L is a product of permutation and unit lower !         triangular matrices and U is upper triangular. ! nsing   Number of singularities detected. ! ! 26 Mar 2006: nsing redefined to be more meaningful. !              Users may define rankU = n - nsing and regard !              U as upper-trapezoidal, with the first rankU columns !              being triangular and the rest trapezoidal. !              It would be better to return rankU, but we still !              return nsing for compatibility (even though lu1fad !              no longer uses it). ! ipvt    Records the pivot rows. ! q       A vector to which column interchanges are applied. !------------------------------------------------------------------ real ( rp ) :: aijmax , ajmax , t integer ( ip ) :: i , imax , j , jlast , jmax , jnew , & k , kp1 , l , last , lencol , rankU rankU = 0 lencol = m + 1 last = n !----------------------------------------------------------------- ! Start of elimination loop. !----------------------------------------------------------------- do k = 1 , n kp1 = k + 1 lencol = lencol - 1 ! Find the biggest aij in row imax and column jmax. aijmax = zero imax = k jmax = k jlast = last do j = k , jlast 10 l = jdamax ( lencol , a ( k : m , j ), i1 ) + k - 1 ajmax = abs ( a ( l , j )) if ( ajmax <= small ) then !======================================================== ! Do column interchange, changing old column to zero. ! Reduce \"last\" and try again with same j. !======================================================== jnew = q ( last ) q ( last ) = q ( j ) q ( j ) = jnew do i = 1 , k - 1 t = a ( i , last ) a ( i , last ) = a ( i , j ) a ( i , j ) = t end do do i = k , m t = a ( i , last ) a ( i , last ) = zero a ( i , j ) = t end do last = last - 1 if ( j <= last ) go to 10 ! repeat go to 200 ! break end if ! Check if this column has biggest aij so far. if ( aijmax < ajmax ) then aijmax = ajmax imax = l jmax = j end if if ( j >= last ) go to 200 ! break end do 200 ipvt ( k ) = imax ! 21 Dec 2015: Exit if aijmax is essentially zero. if ( aijmax <= small ) go to 500 rankU = rankU + 1 if ( jmax /= k ) then ! Do column interchange (k and jmax). jnew = q ( jmax ) q ( jmax ) = q ( k ) q ( k ) = jnew do i = 1 , m t = a ( i , jmax ) a ( i , jmax ) = a ( i , k ) a ( i , k ) = t end do end if if ( k < m ) then ! Do row interchange if necessary. t = a ( imax , k ) if ( imax /= k ) then a ( imax , k ) = a ( k , k ) a ( k , k ) = t end if !=========================================================== ! Compute multipliers. ! Do row elimination with column indexing. !=========================================================== t = - one / t ! call dscal ( m-k, t, a(kp1,k), i1 ) a ( kp1 : m , k ) = t * a ( kp1 : m , k ) do j = kp1 , last t = a ( imax , j ) if ( imax /= k ) then a ( imax , j ) = a ( k , j ) a ( k , j ) = t end if ! call daxpy ( m-k, t, a(kp1,k), i1, a(kp1,j), i1 ) a ( kp1 : m , j ) = t * a ( kp1 : m , k ) + a ( kp1 : m , j ) end do else go to 500 ! break end if if ( k >= last ) go to 500 ! break end do ! Set ipvt(*) for singular rows. 500 do k = last + 1 , m ipvt ( k ) = k end do nsing = n - rankU end subroutine lu1DCP !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! File lusol2.f90 ! ! Hbuild   Hchange  Hdelete  Hdown    Hinsert  Hup ! ! Heap-management routines for LUSOL's lu1fac. ! May be useful for other applications. ! ! 11 Feb 2002: MATLAB version derived from \"Algorithms\" by R. Sedgewick. ! 03 Mar 2002: F77    version derived from MATLAB version. ! 07 May 2002: Safeguard input parameters k, N, Nk. !              We don't want them to be output! ! 19 Dec 2004: Hdelete: Nin is new input parameter for length of Hj, Ha. ! 12 Dec 2011: First f90 version. ! 19 Dec 2015: Current version of lusol2.f90. !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! ! For LUSOL, the heap structure involves three arrays of length N. ! N        is the current number of entries in the heap. ! Ha(1:N)  contains the values that the heap is partially sorting. !          For LUSOL they are double precision values -- the largest !          element in each remaining column of the updated matrix. !          The biggest entry is in Ha(1), the top of the heap. ! Hj(1:N)  contains column numbers j. !          Ha(k) is the biggest entry in column j = Hj(k). ! Hk(1:N)  contains indices within the heap.  It is the !          inverse of Hj(1:N), so  k = Hk(j)  <=>  j = Hj(k). !          Column j is entry k in the heap. ! hops     is the number of heap operations, !          i.e., the number of times an entry is moved !          (the number of \"hops\" up or down the heap). ! Together, Hj and Hk let us find values inside the heap ! whenever we want to change one of the values in Ha. ! For other applications, Ha may need to be some other data type, ! like the keys that sort routines operate on. !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine Hbuild ( Ha , Hj , Hk , N , Nk , hops ) integer ( ip ), intent ( in ) :: N , Nk integer ( ip ), intent ( inout ) :: Hj ( N ), Hk ( Nk ) integer ( ip ), intent ( out ) :: hops real ( rp ), intent ( inout ) :: Ha ( N ) !================================================================== ! Hbuild initializes the heap by inserting each element of Ha. ! Input:  Ha, Hj. ! Output: Ha, Hj, Hk, hops. ! ! 01 May 2002: Use k for new length of heap, not k-1 for old length. ! 05 May 2002: Use kk in call to stop loop variable k being altered. !              (Actually Hinsert no longer alters that parameter.) ! 07 May 2002: ftnchek wants us to protect Nk, Ha(k), Hj(k) too. ! 07 May 2002: Current version of Hbuild. ! 12 Dec 2011: First f90 version. !================================================================== integer ( ip ) :: h , jv , k , kk , Nkk real ( rp ) :: v Nkk = Nk hops = 0 do k = 1 , N kk = k v = Ha ( k ) jv = Hj ( k ) call Hinsert ( Ha , Hj , Hk , kk , Nkk , v , jv , h ) hops = hops + h end do end subroutine Hbuild !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine Hchange ( Ha , Hj , Hk , N , Nk , k , v , jv , hops ) integer ( ip ), intent ( in ) :: N , Nk , k , jv real ( rp ), intent ( in ) :: v integer ( ip ), intent ( inout ) :: Hj ( N ), Hk ( Nk ) real ( rp ), intent ( inout ) :: Ha ( N ) integer ( ip ), intent ( out ) :: hops !================================================================== ! Hchange changes Ha(k) to v in heap of length N. ! ! 01 May 2002: Need Nk for length of Hk. ! 07 May 2002: Protect input parameters N, Nk, k. ! 07 May 2002: Current version of Hchange. ! 12 Dec 2011: First f90 version. !================================================================== integer ( ip ) :: kx , Nx , Nkx real ( rp ) :: v1 Nx = N Nkx = Nk kx = k v1 = Ha ( k ) Ha ( k ) = v Hj ( k ) = jv Hk ( jv ) = k if ( v1 < v ) then call Hup ( Ha , Hj , Hk , Nx , Nkx , kx , hops ) else call Hdown ( Ha , Hj , Hk , Nx , Nkx , kx , hops ) end if end subroutine Hchange !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine Hdelete ( Ha , Hj , Hk , Nin , N , Nk , k , hops ) integer ( ip ), intent ( in ) :: Nin , Nk , k integer ( ip ), intent ( inout ) :: N integer ( ip ), intent ( inout ) :: Hj ( Nin ), Hk ( Nk ) real ( rp ), intent ( inout ) :: Ha ( Nin ) integer ( ip ), intent ( out ) :: hops !================================================================== ! Hdelete deletes Ha(k) from heap of length N. ! ! 03 Apr 2002: Current version of Hdelete. ! 01 May 2002: Need Nk for length of Hk. ! 07 May 2002: Protect input parameters N, Nk, k. ! 19 Dec 2004: Nin is new input parameter for length of Hj, Ha. ! 19 Dec 2004: Current version of Hdelete. ! 12 Dec 2011: First f90 version. !================================================================== integer ( ip ) :: jv , kx , Nkx , Nx real ( rp ) :: v kx = k Nkx = Nk Nx = N v = Ha ( N ) jv = Hj ( N ) N = N - 1 hops = 0 if ( k <= N ) then call Hchange ( Ha , Hj , Hk , Nx , Nkx , kx , v , jv , hops ) end if end subroutine Hdelete !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine Hdown ( Ha , Hj , Hk , N , Nk , kk , hops ) integer ( ip ), intent ( in ) :: N , Nk , kk integer ( ip ), intent ( inout ) :: Hj ( N ), Hk ( Nk ) real ( rp ), intent ( inout ) :: Ha ( N ) integer ( ip ), intent ( out ) :: hops !================================================================== ! Hdown  updates heap by moving down tree from node k. ! ! 01 May 2002: Need Nk for length of Hk. ! 05 May 2002: Change input parameter k to kk to stop k being output. ! 05 May 2002: Current version of Hdown. ! 12 Dec 2011: First f90 version. !================================================================== integer ( ip ) :: j , jj , jv , k , N2 real ( rp ) :: v k = kk hops = 0 v = Ha ( k ) jv = Hj ( k ) N2 = N / 2 do if ( k > N2 ) exit hops = hops + 1 j = k + k if ( j < N ) then if ( Ha ( j ) < Ha ( j + 1 )) j = j + 1 end if if ( v >= Ha ( j )) exit Ha ( k ) = Ha ( j ) jj = Hj ( j ) Hj ( k ) = jj Hk ( jj ) = k k = j end do Ha ( k ) = v Hj ( k ) = jv Hk ( jv ) = k end subroutine Hdown !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine Hinsert ( Ha , Hj , Hk , N , Nk , v , jv , hops ) integer ( ip ), intent ( in ) :: Nk , jv real ( rp ), intent ( in ) :: v integer ( ip ), intent ( inout ) :: N integer ( ip ), intent ( inout ) :: Hj ( N ), Hk ( Nk ) real ( rp ), intent ( inout ) :: Ha ( N ) integer ( ip ), intent ( out ) :: hops !================================================================== ! Hinsert inserts (v,jv) into heap of length N-1 ! to make heap of length N. ! ! 03 Apr 2002: First version of Hinsert. ! 01 May 2002: Require N to be final length, not old length. !              Need Nk for length of Hk. ! 07 May 2002: Protect input parameters N, Nk. ! 07 May 2002: Current version of Hinsert. ! 12 Dec 2011: First f90 version. !================================================================== integer ( ip ) :: kk , Nkk , Nnew Nnew = N Nkk = Nk kk = Nnew Ha ( Nnew ) = v Hj ( Nnew ) = jv Hk ( jv ) = Nnew call Hup ( Ha , Hj , Hk , Nnew , Nkk , kk , hops ) end subroutine Hinsert !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine Hup ( Ha , Hj , Hk , N , Nk , kk , hops ) integer ( ip ), intent ( in ) :: N , Nk , kk integer ( ip ), intent ( inout ) :: Hj ( N ), Hk ( Nk ) real ( rp ), intent ( inout ) :: Ha ( N ) integer ( ip ), intent ( out ) :: hops !================================================================== ! Hup updates heap by moving up tree from node k. ! ! 01 May 2002: Need Nk for length of Hk. ! 05 May 2002: Change input parameter k to kk to stop k being output. ! 05 May 2002: Current version of Hup. ! 13 Dec 2011: First f90 version. !================================================================== integer ( ip ) :: j , jv , k , k2 real ( rp ) :: v k = kk hops = 0 v = Ha ( k ) jv = Hj ( k ) do if ( k < 2 ) exit k2 = k / 2 if ( v < Ha ( k2 )) exit hops = hops + 1 Ha ( k ) = Ha ( k2 ) j = Hj ( k2 ) Hj ( k ) = j Hk ( j ) = k k = k2 end do Ha ( k ) = v Hj ( k ) = jv Hk ( jv ) = k end subroutine Hup !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! File lusol6a.f90 ! ! lu6sol   lu6L     lu6Lt     lu6U     Lu6Ut   lu6LD    lu6chk ! ! 26 Apr 2002: lu6 routines put into a separate file. ! 15 Dec 2002: lu6sol modularized via lu6L, lu6Lt, lu6U, lu6Ut. !              lu6LD implemented to allow solves with LDL' or L|D|L'. ! 23 Apr 2004: lu6chk modified.  TRP can judge singularity better !              by comparing all diagonals to DUmax. ! 27 Jun 2004: lu6chk.  Allow write only if nout > 0 . ! 13 Dec 2011: First f90 version. ! 20 Jan 2016: Current version of lusol6a.f90. !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu6sol ( mode , m , n , v , w , & lena , luparm , parmlu , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & inform ) integer ( ip ), intent ( in ) :: mode , m , n , lena integer ( ip ), intent ( in ) :: indc ( lena ), indr ( lena ), p ( m ), q ( n ), & lenc ( n ), lenr ( m ), locc ( n ), locr ( m ) real ( rp ), intent ( in ) :: a ( lena ) integer ( ip ), intent ( inout ) :: luparm ( 30 ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), v ( m ), w ( n ) integer ( ip ), intent ( out ) :: inform !----------------------------------------------------------------------- ! lu6sol  uses the factorization  A = L U  as follows: ! ! mode !  1    v  solves   L v = v(input).   w  is not touched. !  2    v  solves   L'v = v(input).   w  is not touched. !  3    w  solves   U w = v.          v  is not altered. !  4    v  solves   U'v = w.          w  is destroyed. !  5    w  solves   A w = v.          v  is altered as in 1. !  6    v  solves   A'v = w.          w  is destroyed. ! ! If mode = 3,4,5,6, v and w must not be the same arrays. ! ! If lu1fac has just been used to factorize a symmetric matrix A ! (which must be definite or quasi-definite), the factors A = L U ! may be regarded as A = LDL', where D = diag(U).  In such cases, ! ! mode !  7    v  solves   A v = L D L'v = v(input).   w  is not touched. !  8    v  solves       L |D| L'v = v(input).   w  is not touched. ! ! p(*), q(*)        hold row and column numbers in pivotal order. ! lenc(k)           is the length of the k-th column of initial L. ! lenr(i)           is the length of the i-th row of U. ! locc(*)           is not used. ! locr(i)           is the start  of the i-th row of U. ! ! U is assumed to be in upper-trapezoidal form (nrank by n). ! The first entry for each row is the diagonal element ! (according to the permutations p, q).  It is stored at ! location locr(i) in a(*), indr(*). ! ! On exit, inform = 0 except as follows. ! If mode = 3,4,5,6 and if U (and hence A) is singular, then ! inform = 1 if there is a nonzero residual in solving the system ! involving U.  parmlu(20) returns the norm of the residual. ! ! July 1987:   Early version. ! 09 May 1988: f77 version. ! 27 Apr 2000: Abolished the dreaded \"computed go to\". !              But hard to change other \"go to\"s to \"if then else\". ! 15 Dec 2002: lu6L, lu6Lt, lu6U, lu6Ut added to modularize lu6sol. ! 13 Dec 2011: First f90 version. !-------------------------------------------------------------------- if ( mode == 1 ) then ! Solve  L v(new) = v. call lu6L ( inform , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc ) else if ( mode == 2 ) then ! Solve  L'v(new) = v. call lu6Lt ( inform , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc ) else if ( mode == 3 ) then ! Solve  U w = v. call lu6U ( inform , m , n , v , w , & lena , luparm , parmlu , a , indr , p , q , lenr , locr ) else if ( mode == 4 ) then ! Solve  U'v = w. call lu6Ut ( inform , m , n , v , w , & lena , luparm , parmlu , a , indr , p , q , lenr , locr ) else if ( mode == 5 ) then ! Solve  A w      = v ! via    L v(new) = v ! and    U w = v(new). call lu6L ( inform , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc ) call lu6U ( inform , m , n , v , w , & lena , luparm , parmlu , a , indr , p , q , lenr , locr ) else if ( mode == 6 ) then ! Solve  A'v = w ! via    U'v = w ! and    L'v(new) = v. call lu6Ut ( inform , m , n , v , w , & lena , luparm , parmlu , a , indr , p , q , lenr , locr ) call lu6Lt ( inform , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc ) else if ( mode == 7 ) then ! Solve  LDv(bar) = v ! and    L'v(new) = v(bar). call lu6LD ( inform , i1 , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc , locr ) call lu6Lt ( inform , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc ) else if ( mode == 8 ) then ! Solve  L|D|v(bar) = v ! and    L'v(new) = v(bar). call lu6LD ( inform , i2 , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc , locr ) call lu6Lt ( inform , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc ) end if end subroutine lu6sol !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu6L ( inform , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc ) integer ( ip ), intent ( in ) :: m , n , lena integer ( ip ), intent ( in ) :: indc ( lena ), indr ( lena ), lenc ( n ) real ( rp ), intent ( in ) :: a ( lena ) integer ( ip ), intent ( inout ) :: luparm ( 30 ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), v ( m ) integer ( ip ), intent ( out ) :: inform !------------------------------------------------------------------ ! lu6L   solves   L v = v(input). ! ! 15 Dec 2002: First version derived from lu6sol. ! 15 Dec 2002: Current version. ! 13 Dec 2011: First f90 version. !------------------------------------------------------------------ integer ( ip ) :: i , ipiv , j , k , l , l1 , ldummy , len , lenL , lenL0 , numL , numL0 real ( rp ) :: small , vpiv numL0 = luparm ( 20 ) lenL0 = luparm ( 21 ) lenL = luparm ( 23 ) small = parmlu ( 3 ) inform = 0 l1 = lena + 1 do k = 1 , numL0 len = lenc ( k ) l = l1 l1 = l1 - len ipiv = indr ( l1 ) vpiv = v ( ipiv ) if ( abs ( vpiv ) > small ) then !***** This loop could be coded specially. do ldummy = 1 , len l = l - 1 j = indc ( l ) v ( j ) = v ( j ) + a ( l ) * vpiv end do end if end do l = lena - lenL0 + 1 numL = lenL - lenL0 !***** This loop could be coded specially. do ldummy = 1 , numL l = l - 1 i = indr ( l ) if ( abs ( v ( i )) > small ) then j = indc ( l ) v ( j ) = v ( j ) + a ( l ) * v ( i ) end if end do ! Exit. luparm ( 10 ) = inform end subroutine lu6L !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu6Lt ( inform , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc ) integer ( ip ), intent ( in ) :: m , n , lena integer ( ip ), intent ( in ) :: indc ( lena ), indr ( lena ), lenc ( n ) real ( rp ), intent ( in ) :: a ( lena ) integer ( ip ), intent ( inout ) :: luparm ( 30 ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), v ( m ) integer ( ip ), intent ( out ) :: inform !------------------------------------------------------------------ ! lu6Lt  solves   L'v = v(input). ! ! 15 Dec 2002: First version derived from lu6sol. ! 15 Dec 2002: Current version. ! 13 Dec 2011: First f90 version. !------------------------------------------------------------------ integer ( ip ) :: i , ipiv , j , k , l , l1 , l2 , len , lenL , lenL0 , numL0 real ( rp ) :: small , sum numL0 = luparm ( 20 ) lenL0 = luparm ( 21 ) lenL = luparm ( 23 ) small = parmlu ( 3 ) inform = 0 l1 = lena - lenL + 1 l2 = lena - lenL0 !***** This loop could be coded specially. do l = l1 , l2 j = indc ( l ) if ( abs ( v ( j )) > small ) then i = indr ( l ) v ( i ) = v ( i ) + a ( l ) * v ( j ) end if end do do k = numL0 , 1 , - 1 len = lenc ( k ) sum = zero l1 = l2 + 1 l2 = l2 + len !***** This loop could be coded specially. do l = l1 , l2 j = indc ( l ) sum = sum + a ( l ) * v ( j ) end do ipiv = indr ( l1 ) v ( ipiv ) = v ( ipiv ) + sum end do ! Exit. luparm ( 10 ) = inform end subroutine lu6Lt !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu6U ( inform , m , n , v , w , & lena , luparm , parmlu , a , indr , p , q , lenr , locr ) integer ( ip ), intent ( in ) :: m , n , lena integer ( ip ), intent ( in ) :: indr ( lena ), p ( m ), q ( n ), lenr ( m ), locr ( m ) real ( rp ), intent ( in ) :: a ( lena ) real ( rp ), intent ( in ) :: v ( m ) integer ( ip ), intent ( inout ) :: luparm ( 30 ) real ( rp ), intent ( inout ) :: parmlu ( 30 ) integer ( ip ), intent ( out ) :: inform real ( rp ), intent ( out ) :: w ( n ) !------------------------------------------------------------------ ! lu6U   solves   U w = v.          v  is not altered. ! ! 15 Dec 2002: First version derived from lu6sol. ! 15 Dec 2002: Current version. ! 13 Dec 2011: First f90 version. !------------------------------------------------------------------ integer ( ip ) :: i , j , k , klast , l , l1 , l2 , l3 , nrank , nrank1 real ( rp ) :: resid , small , t nrank = luparm ( 16 ) small = parmlu ( 3 ) inform = 0 nrank1 = nrank + 1 resid = zero ! Find the first nonzero in v(1:nrank), counting backwards. do klast = nrank , 1 , - 1 i = p ( klast ) if ( abs ( v ( i )) > small ) exit end do do k = klast + 1 , n j = q ( k ) w ( j ) = zero end do ! Do the back-substitution, using rows 1:klast of U. do k = klast , 1 , - 1 i = p ( k ) t = v ( i ) l1 = locr ( i ) l2 = l1 + 1 l3 = l1 + lenr ( i ) - 1 !***** This loop could be coded specially. do l = l2 , l3 j = indr ( l ) t = t - a ( l ) * w ( j ) end do j = q ( k ) if ( abs ( t ) <= small ) then w ( j ) = zero else w ( j ) = t / a ( l1 ) end if end do ! Compute residual for overdetermined systems. do k = nrank1 , m i = p ( k ) resid = resid + abs ( v ( i )) end do ! Exit. if ( resid > zero ) inform = 1 luparm ( 10 ) = inform parmlu ( 20 ) = resid end subroutine lu6U !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu6Ut ( inform , m , n , v , w , & lena , luparm , parmlu , a , indr , p , q , lenr , locr ) integer ( ip ), intent ( in ) :: m , n , lena integer ( ip ), intent ( in ) :: indr ( lena ), p ( m ), q ( n ), lenr ( m ), locr ( m ) real ( rp ), intent ( in ) :: a ( lena ) integer ( ip ), intent ( inout ) :: luparm ( 30 ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), w ( n ) integer ( ip ), intent ( out ) :: inform real ( rp ), intent ( out ) :: v ( m ) !------------------------------------------------------------------ ! lu6Ut  solves   U'v = w.          w  is destroyed. ! ! 15 Dec 2002: First version derived from lu6sol. ! 15 Dec 2002: Current version. ! 13 Dec 2011: First f90 version. !------------------------------------------------------------------ integer ( ip ) :: i , j , k , l , l1 , l2 , nrank , nrank1 real ( rp ) :: resid , small , t nrank = luparm ( 16 ) small = parmlu ( 3 ) inform = 0 nrank1 = nrank + 1 resid = zero do k = nrank1 , m i = p ( k ) v ( i ) = zero end do ! Do the forward-substitution, skipping columns of U(transpose) ! when the associated element of w(*) is negligible. do k = 1 , nrank i = p ( k ) j = q ( k ) t = w ( j ) if ( abs ( t ) <= small ) then v ( i ) = zero cycle end if l1 = locr ( i ) t = t / a ( l1 ) v ( i ) = t l2 = l1 + lenr ( i ) - 1 l1 = l1 + 1 !***** This loop could be coded specially. do l = l1 , l2 j = indr ( l ) w ( j ) = w ( j ) - t * a ( l ) end do end do ! Compute residual for overdetermined systems. do k = nrank1 , n j = q ( k ) resid = resid + abs ( w ( j )) end do ! Exit. if ( resid > zero ) inform = 1 luparm ( 10 ) = inform parmlu ( 20 ) = resid end subroutine lu6Ut !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu6LD ( inform , mode , m , n , v , & lena , luparm , parmlu , a , indc , indr , lenc , locr ) integer ( ip ), intent ( in ) :: mode , m , n , lena integer ( ip ), intent ( in ) :: indc ( lena ), indr ( lena ), lenc ( n ), locr ( m ) real ( rp ), intent ( in ) :: a ( lena ) integer ( ip ), intent ( inout ) :: luparm ( 30 ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), v ( m ) integer ( ip ), intent ( out ) :: inform !------------------------------------------------------------------- ! lu6LD  assumes lu1fac has computed factors A = LU of a ! symmetric definite or quasi-definite matrix A, ! using Threshold Symmetric Pivoting (TSP),   luparm(6) = 3, ! or    Threshold Diagonal  Pivoting (TDP),   luparm(6) = 4. ! It also assumes that no updates have been performed. ! In such cases,  U = D L', where D = diag(U). ! lu6LDL returns v as follows: ! ! mode ! 1    v  solves   L D v = v(input). ! 2    v  solves   L|D|v = v(input). ! ! 15 Dec 2002: First version of lu6LD. ! 15 Dec 2002: Current version. ! 13 Dec 2011: First f90 version. !----------------------------------------------------------------------- ! ! Solve L D v(new) = v  or  L|D|v(new) = v, depending on mode. ! The code for L is the same as in lu6L, ! but when a nonzero entry of v arises, we divide by ! the corresponding entry of D or |D|. integer ( ip ) :: ipiv , j , k , l , l1 , ldummy , len , numL0 real ( rp ) :: diag , small , vpiv numL0 = luparm ( 20 ) small = parmlu ( 3 ) inform = 0 l1 = lena + 1 do k = 1 , numL0 len = lenc ( k ) l = l1 l1 = l1 - len ipiv = indr ( l1 ) vpiv = v ( ipiv ) if ( abs ( vpiv ) > small ) then !***** This loop could be coded specially. do ldummy = 1 , len l = l - 1 j = indc ( l ) v ( j ) = v ( j ) + a ( l ) * vpiv end do ! Find diag = U(ipiv,ipiv) and divide by diag or |diag|. l = locr ( ipiv ) diag = a ( l ) if ( mode == 2 ) diag = abs ( diag ) v ( ipiv ) = vpiv / diag end if end do end subroutine lu6LD !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu6chk ( mode , m , n , nslack , w , lena , luparm , parmlu , & a , indc , indr , p , q , lenc , lenr , locc , locr , inform ) integer ( ip ), intent ( in ) :: mode , m , n , nslack , lena integer ( ip ), intent ( in ) :: indc ( lena ), indr ( lena ), p ( m ), q ( n ), & lenc ( n ), lenr ( m ), locc ( n ), locr ( m ) real ( rp ), intent ( in ) :: a ( lena ) integer ( ip ), intent ( inout ) :: inform integer ( ip ), intent ( inout ) :: luparm ( 30 ) real ( rp ), intent ( inout ) :: parmlu ( 30 ) real ( rp ), intent ( inout ) :: w ( n ) !----------------------------------------------------------------- ! lu6chk  looks at the LU factorization  A = L*U. ! ! If mode = 1, lu6chk is being called by lu1fac. ! (Other modes not yet implemented.) ! The important input parameters are ! ! lprint = luparm(2) ! luparm(6) = 1 if TRP ! keepLU = luparm(8) ! Utol1  = parmlu(4) ! Utol2  = parmlu(5) ! ! and the significant output parameters are ! ! inform = luparm(10) ! nsing  = luparm(11) ! jsing  = luparm(12) ! jumin  = luparm(19) ! Lmax   = parmlu(11) ! Umax   = parmlu(12) ! DUmax  = parmlu(13) ! DUmin  = parmlu(14) ! and      w(*). ! ! Lmax  and Umax  return the largest elements in L and U. ! DUmax and DUmin return the largest and smallest diagonals of U ! (excluding diagonals that are exactly zero). ! ! In general, w(j) is set to the maximum absolute element in ! the j-th column of U.  However, if the corresponding diagonal ! of U is small in absolute terms or relative to w(j) ! (as judged by the parameters Utol1, Utol2 respectively), ! then w(j) is changed to - w(j). ! ! Thus, if w(j) is not positive, the j-th column of A ! appears to be dependent on the other columns of A. ! The number of such columns, and the position of the last one, ! are returned as nsing and jsing. ! ! Note that nrank is assumed to be set already, and is not altered. ! Typically, nsing will satisfy      nrank + nsing = n,  but if ! Utol1 and Utol2 are rather large,  nsing > n - nrank   may occur. ! ! If keepLU = 0, !              Lmax  and Umax  are already set by lu1fac. !              The diagonals of U are in the top of A. !              Only Utol1 is used in the singularity test to set w(*). ! ! inform = 0  if A appears to have full column rank (nsing = 0). ! inform = 1  otherwise (nsing > 0). ! ! 00 Jul 1987: Early version. ! 09 May 1988: f77 version. ! 11 Mar 2001: Allow for keepLU = 0. ! 17 Nov 2001: Briefer output for singular factors. ! 05 May 2002: Comma needed in format 1100 (via Kenneth Holmstrom). ! 06 May 2002: With keepLU = 0, diags of U are in natural order. !              They were not being extracted correctly. ! 23 Apr 2004: TRP can judge singularity better by comparing !              all diagonals to DUmax. ! 27 Jun 2004: (PEG) Allow write only if nout > 0 . ! 13 Dec 2011: First f90 version. ! 12 Dec 2015: nslack ensures slacks are kept with w(j) > 0. !------------------------------------------------------------------ character ( 1 ) :: mnkey logical :: keepLU , TRP integer ( ip ) :: i , j , jsing , jumin , k , l , l1 , l2 , ldiagU , lenL , & lprint , ndefic , nout , nrank , nsing real ( rp ) :: aij , diag , DUmax , DUmin , Lmax , Umax , Utol1 , Utol2 nout = luparm ( 1 ) lprint = luparm ( 2 ) TRP = luparm ( 6 ) == 1 ! Threshold Rook Pivoting keepLU = luparm ( 8 ) /= 0 nrank = luparm ( 16 ) lenL = luparm ( 23 ) Utol1 = parmlu ( 4 ) Utol2 = parmlu ( 5 ) inform = 0 Lmax = zero Umax = zero nsing = 0 jsing = 0 jumin = 0 DUmax = zero DUmin = 1.0d+30 ! w(j) is already set by lu1slk. ! w(1:n) = zero if ( keepLU ) then !-------------------------------------------------------------- ! Find  Lmax. !-------------------------------------------------------------- do l = lena + 1 - lenL , lena Lmax = max ( Lmax , abs ( a ( l )) ) end do !-------------------------------------------------------------- ! Find Umax and set w(j) = maximum element in j-th column of U. !-------------------------------------------------------------- do k = nslack + 1 , nrank ! 12 Dec 2015: Allow for nslack. i = p ( k ) l1 = locr ( i ) l2 = l1 + lenr ( i ) - 1 do l = l1 , l2 j = indr ( l ) aij = abs ( a ( l ) ) w ( j ) = max ( w ( j ), aij ) Umax = max ( Umax , aij ) end do end do parmlu ( 11 ) = Lmax parmlu ( 12 ) = Umax !-------------------------------------------------------------- ! Find DUmax and DUmin, the extreme diagonals of U. !-------------------------------------------------------------- do k = nslack + 1 , nrank ! 12 Dec 2015: Allow for nslack. j = q ( k ) i = p ( k ) l1 = locr ( i ) diag = abs ( a ( l1 ) ) DUmax = max ( DUmax , diag ) if ( DUmin > diag ) then DUmin = diag jumin = j end if end do else !-------------------------------------------------------------- ! keepLU = 0. ! Only diag(U) is stored.  Set w(*) accordingly. ! Find DUmax and DUmin, the extreme diagonals of U. !-------------------------------------------------------------- ldiagU = lena - n do k = nslack + 1 , nrank ! 12 Dec 2015: Allow for nslack. j = q ( k ) ! diag   = abs( a(ldiagU + k) ) ! 06 May 2002: Diags diag = abs ( a ( ldiagU + j ) ) ! are in natural order w ( j ) = diag DUmax = max ( DUmax , diag ) if ( DUmin > diag ) then DUmin = diag jumin = j end if end do end if !-------------------------------------------------------------- ! Negate w(j) if the corresponding diagonal of U is ! too small in absolute terms or relative to the other elements ! in the same column of  U. ! ! 23 Apr 2004: TRP ensures that diags are NOT small relative to !              other elements in their own column. !              Much better, we can compare all diags to DUmax. ! 13 Nov 2015: This causes slacks to replace slacks when DUmax !              is big.  It seems better to leave Utol1 alone. ! 12 Dec 2015: Allow for nslack. !              DUmax now excludes slack rows, so we can !              reset Utol1 again for TRP. !-------------------------------------------------------------- if ( mode == 1 . and . TRP ) then Utol1 = max ( Utol1 , Utol2 * DUmax ) end if if ( keepLU ) then do k = nslack + 1 , n ! 12 Dec 2015: Allow for nslack. j = q ( k ) if ( k > nrank ) then diag = zero else i = p ( k ) l1 = locr ( i ) diag = abs ( a ( l1 ) ) end if if ( diag <= Utol1 . or . diag <= Utol2 * w ( j )) then nsing = nsing + 1 jsing = j w ( j ) = - w ( j ) end if end do else ! keepLU = 0 do k = nslack + 1 , n ! 12 Dec 2015: Allow for nslack. j = q ( k ) diag = w ( j ) if ( diag <= Utol1 ) then nsing = nsing + 1 jsing = j w ( j ) = - w ( j ) end if end do end if !----------------------------------------------------------------- ! Set output parameters. !----------------------------------------------------------------- if ( jumin == 0 ) DUmin = zero luparm ( 11 ) = nsing luparm ( 12 ) = jsing luparm ( 19 ) = jumin parmlu ( 13 ) = DUmax parmlu ( 14 ) = DUmin if ( nsing > 0 ) then ! The matrix has been judged singular. inform = 1 ndefic = n - nrank if ( nout > 0 . and . lprint >= 0 ) then if ( m > n ) then mnkey = '>' else if ( m == n ) then mnkey = '=' else mnkey = '<' end if write ( nout , 1100 ) mnkey , nrank , ndefic , nsing end if end if ! Exit. luparm ( 10 ) = inform return 1100 format ( ' Singular(m' , a , 'n)' , '  rank' , i9 , '  n-rank' , i8 , '  nsing' , i9 ) end subroutine lu6chk !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! File lusol7a.f90 ! ! lu7add   lu7cyc   lu7elm   lu7for   lu7rnk   lu7zap ! Utilities for LUSOL's update routines. ! lu7for is the most important -- the forward sweep. ! ! 01 May 2002: Derived from LUSOL's original lu7a.f file. ! 13 Dec 2011: First f90 version. ! 20 Jan 2016: Current version of lusol7a.f90. !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu7add ( m , n , jadd , v , lena , luparm , parmlu , & lenL , lenU , lrow , nrank , & a , indr , p , lenr , locr , & inform , klast , vnorm ) integer ( ip ), intent ( in ) :: m , n , jadd , lena , nrank , & p ( m ) integer ( ip ), intent ( inout ) :: luparm ( 30 ), lenL , lenU , lrow , & indr ( lena ), lenr ( m ), locr ( m ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), a ( lena ), v ( m ) integer ( ip ), intent ( out ) :: inform , klast real ( rp ), intent ( out ) :: vnorm !------------------------------------------------------------------ ! lu7add  inserts the first nrank elements of the vector v(*) ! as column jadd of U.  We assume that U does not yet have any ! entries in this column. ! Elements no larger than parmlu(3) are treated as zero. ! klast  will be set so that the last row to be affected ! (in pivotal order) is row p(klast). ! ! 09 May 1988: First f77 version. ! 13 Dec 2011: First f90 version. ! 20 Dec 2015: ilast is now output by lu1rec. !------------------------------------------------------------------ integer ( ip ) :: i , ilast , j , k , leni , l , lr1 , lr2 , minfre , nfree real ( rp ) :: small small = parmlu ( 3 ) vnorm = zero klast = 0 do k = 1 , nrank i = p ( k ) if ( abs ( v ( i )) <= small ) cycle klast = k vnorm = vnorm + abs ( v ( i )) leni = lenr ( i ) ! Compress row file if necessary. minfre = leni + 1 nfree = lena - lenL - lrow if ( nfree < minfre ) then call lu1rec ( m , . true ., luparm , lrow , ilast , & lena , a , indr , lenr , locr ) nfree = lena - lenL - lrow if ( nfree < minfre ) go to 970 end if ! Move row i to the end of the row file, ! unless it is already there. ! No need to move if there is a gap already. if ( leni == 0 ) locr ( i ) = lrow + 1 lr1 = locr ( i ) lr2 = lr1 + leni - 1 if ( lr2 == lrow ) go to 150 if ( indr ( lr2 + 1 ) == 0 ) go to 180 locr ( i ) = lrow + 1 do l = lr1 , lr2 lrow = lrow + 1 a ( lrow ) = a ( l ) j = indr ( l ) indr ( l ) = 0 indr ( lrow ) = j end do 150 lr2 = lrow lrow = lrow + 1 ! Add the element of  v. 180 lr2 = lr2 + 1 a ( lr2 ) = v ( i ) indr ( lr2 ) = jadd lenr ( i ) = leni + 1 lenU = lenU + 1 end do ! Normal exit. inform = 0 go to 990 ! Not enough storage. 970 inform = 7 990 return end subroutine lu7add !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu7cyc ( kfirst , klast , p ) integer ( ip ), intent ( in ) :: kfirst , klast integer ( ip ), intent ( inout ) :: p ( klast ) !------------------------------------------------------------------ ! lu7cyc performs a cyclic permutation on the row or column ordering ! stored in p, moving entry kfirst down to klast. ! If kfirst .ge. klast, lu7cyc should not be called. ! Sometimes klast = 0 and nothing should happen. ! ! 09 May 1988: First f77 version. ! 13 Dec 2011: First f90 version. !------------------------------------------------------------------ integer ( ip ) :: ifirst , k if ( kfirst < klast ) then ifirst = p ( kfirst ) do k = kfirst , klast - 1 p ( k ) = p ( k + 1 ) end do p ( klast ) = ifirst end if end subroutine lu7cyc !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu7elm ( m , n , jelm , v , lena , luparm , parmlu , & lenL , lenU , lrow , nrank , & a , indc , indr , p , q , lenr , locc , locr , & inform , diag ) integer ( ip ), intent ( in ) :: m , n , jelm , lena , nrank integer ( ip ), intent ( in ) :: lenU , q ( n ) ! not used real ( rp ), intent ( in ) :: v ( m ) integer ( ip ), intent ( inout ) :: luparm ( 30 ), lenL , lrow , & indc ( lena ), indr ( lena ), p ( m ), & lenr ( m ), locc ( n ), locr ( m ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), a ( lena ) integer ( ip ), intent ( out ) :: inform real ( rp ), intent ( out ) :: diag !------------------------------------------------------------------ ! lu7elm  eliminates the subdiagonal elements of a vector  v(*), ! where  L*v = y  for some vector y. ! If  jelm > 0,  y  has just become column  jelm  of the matrix  A. ! lu7elm  should not be called unless  m  is greater than  nrank. ! ! inform = 0 if y contained no subdiagonal nonzeros to eliminate. ! inform = 1 if y contained at least one nontrivial subdiagonal. ! inform = 7 if there is insufficient storage. ! ! 09 May 1988: First f77 version. !              No longer calls lu7for at end.  lu8rpc, lu8mod do so. ! 13 Dec 2011: First f90 version. ! 20 Dec 2015: ilast is now output by lu1rec. !------------------------------------------------------------------ integer ( ip ) :: i , ilast , imax , k , kmax , l , l1 , l2 , lmax , & minfre , nfree , nrank1 real ( rp ) :: small , vi , vmax small = parmlu ( 3 ) nrank1 = nrank + 1 diag = zero ! Compress row file if necessary. minfre = m - nrank nfree = lena - lenL - lrow if ( nfree < minfre ) then call lu1rec ( m , . true ., luparm , lrow , ilast , & lena , a , indr , lenr , locr ) nfree = lena - lenL - lrow if ( nfree < minfre ) go to 970 end if ! Pack the subdiagonals of  v  into  L,  and find the largest. vmax = zero kmax = 0 l = lena - lenL + 1 do k = nrank1 , m i = p ( k ) vi = abs ( v ( i )) if ( vi <= small ) cycle l = l - 1 a ( l ) = v ( i ) indc ( l ) = i if ( vmax >= vi ) cycle vmax = vi kmax = k lmax = l end do if ( kmax == 0 ) go to 900 !------------------------------------------------------------------ ! Remove  vmax  by overwriting it with the last packed  v(i). ! Then set the multipliers in  L  for the other elements. !------------------------------------------------------------------ imax = p ( kmax ) vmax = a ( lmax ) a ( lmax ) = a ( l ) indc ( lmax ) = indc ( l ) l1 = l + 1 l2 = lena - lenL lenL = lenL + ( l2 - l ) do l = l1 , l2 a ( l ) = - a ( l ) / vmax indr ( l ) = imax end do ! Move the row containing vmax to pivotal position nrank + 1. p ( kmax ) = p ( nrank1 ) p ( nrank1 ) = imax diag = vmax !------------------------------------------------------------------ ! If jelm is positive, insert  vmax  into a new row of  U. ! This is now the only subdiagonal element. !------------------------------------------------------------------ if ( jelm > 0 ) then lrow = lrow + 1 locr ( imax ) = lrow lenr ( imax ) = 1 a ( lrow ) = vmax indr ( lrow ) = jelm end if inform = 1 go to 990 ! No elements to eliminate. 900 inform = 0 go to 990 ! Not enough storage. 970 inform = 7 990 return end subroutine lu7elm !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu7for ( m , n , kfirst , klast , lena , luparm , parmlu , & lenL , lenU , lrow , & a , indc , indr , p , q , lenr , locc , locr , & inform , diag ) integer ( ip ), intent ( in ) :: m , n , kfirst , klast , lena integer ( ip ), intent ( in ) :: q ( n ) integer ( ip ), intent ( inout ) :: luparm ( 30 ), lenL , lenU , lrow integer ( ip ), intent ( inout ) :: indc ( lena ), indr ( lena ), & p ( m ), lenr ( m ), locc ( n ), locr ( m ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), a ( lena ) integer ( ip ), intent ( out ) :: inform real ( rp ), intent ( out ) :: diag !------------------------------------------------------------------ ! lu7for  (forward sweep) updates the LU factorization A = L*U ! when row iw = p(klast) of U is eliminated by a forward ! sweep of stabilized row operations, leaving p*U*q upper triangular. ! ! The row permutation p is updated to preserve stability and/or ! sparsity.  The column permutation q is not altered. ! ! kfirst  is such that row p(kfirst) is the first row involved ! in eliminating row  iw.  (Hence,  kfirst  marks the first nonzero ! in row  iw  in pivotal order.)  If  kfirst  is unknown it may be ! input as  1. ! ! klast   is such that row p(klast) is the row being eliminated. ! klast   is not altered. ! ! lu7for  should be called only if  kfirst .le. klast. ! If  kfirst = klast,  there are no nonzeros to eliminate, but the ! diagonal element of row p(klast) may need to be moved to the ! front of the row. ! ! On entry,  locc(*)  must be zero. ! ! On exit: ! inform = 0  if row iw has a nonzero diagonal (could be small). ! inform = 1  if row iw has no diagonal. ! inform = 7  if there is not enough storage to finish the update. ! ! On a successful exit (inform le 1),  locc(*)  will again be zero. ! !    Jan 1985: Final f66 version. ! 09 May 1988: First f77 version. ! 13 Dec 2011: First f90 version. ! 20 Dec 2015: ilast is now output by lu1rec. !------------------------------------------------------------------ logical :: swappd integer ( ip ) :: ilast , iv , iw , j , jfirst , jlast , jv , & k , kbegin , kstart , kstop , & l , ldiag , lenv , lenw , lfirst , limit , & lv , lv1 , lv2 , lv3 , lw , lw1 , lw2 , & minfre , nfree real ( rp ) :: amult , Ltol , Uspace , small , vj , wj Ltol = parmlu ( 2 ) small = parmlu ( 3 ) Uspace = parmlu ( 6 ) kbegin = kfirst swappd = . false . ! We come back here from below if a row interchange is performed. 100 iw = p ( klast ) lenw = lenr ( iw ) if ( lenw == 0 ) go to 910 lw1 = locr ( iw ) lw2 = lw1 + lenw - 1 jfirst = q ( kbegin ) if ( kbegin >= klast ) go to 700 ! Make sure there is room at the end of the row file ! in case row  iw  is moved there and fills in completely. minfre = n + 1 nfree = lena - lenL - lrow if ( nfree < minfre ) then call lu1rec ( m , . true ., luparm , lrow , ilast , & lena , a , indr , lenr , locr ) lw1 = locr ( iw ) lw2 = lw1 + lenw - 1 nfree = lena - lenL - lrow if ( nfree < minfre ) go to 970 end if ! Set markers on row iw. do l = lw1 , lw2 j = indr ( l ) locc ( j ) = l end do !================================================================== ! Main elimination loop. !================================================================== kstart = kbegin kstop = min ( klast , n ) do k = kstart , kstop jfirst = q ( k ) lfirst = locc ( jfirst ) if ( lfirst == 0 ) go to 490 ! Row  iw  has its first element in column  jfirst. wj = a ( lfirst ) if ( k == klast ) go to 490 !--------------------------------------------------------------- ! We are about to use the first element of row iv ! to eliminate the first element of row iw. ! However, we may wish to interchange the rows instead, ! to preserve stability and/or sparsity. !--------------------------------------------------------------- iv = p ( k ) lenv = lenr ( iv ) lv1 = locr ( iv ) vj = zero if ( lenv == 0 ) go to 150 if ( indr ( lv1 ) /= jfirst ) go to 150 vj = a ( lv1 ) if ( swappd ) go to 200 if ( Ltol * abs ( wj ) < abs ( vj )) go to 200 if ( Ltol * abs ( vj ) < abs ( wj )) go to 150 if ( lenv <= lenw ) go to 200 !--------------------------------------------------------------- ! Interchange rows iv and iw. !--------------------------------------------------------------- 150 p ( klast ) = iv p ( k ) = iw kbegin = k swappd = . true . go to 600 !--------------------------------------------------------------- ! Delete the eliminated element from row iw ! by overwriting it with the last element. !--------------------------------------------------------------- 200 a ( lfirst ) = a ( lw2 ) jlast = indr ( lw2 ) indr ( lfirst ) = jlast indr ( lw2 ) = 0 locc ( jlast ) = lfirst locc ( jfirst ) = 0 lenw = lenw - 1 lenU = lenU - 1 if ( lrow == lw2 ) lrow = lrow - 1 lw2 = lw2 - 1 !--------------------------------------------------------------- ! Form the multiplier and store it in the L file. !--------------------------------------------------------------- if ( abs ( wj ) <= small ) go to 490 amult = - wj / vj l = lena - lenL a ( l ) = amult indr ( l ) = iv indc ( l ) = iw lenL = lenL + 1 !--------------------------------------------------------------- ! Add the appropriate multiple of row iv to row iw. ! We use two different inner loops.  The first one is for the ! case where row iw is not at the end of storage. !--------------------------------------------------------------- if ( lenv == 1 ) go to 490 lv2 = lv1 + 1 lv3 = lv1 + lenv - 1 if ( lw2 == lrow ) go to 400 !............................................................... ! This inner loop will be interrupted only if ! fill-in occurs enough to bump into the next row. !............................................................... do lv = lv2 , lv3 jv = indr ( lv ) lw = locc ( jv ) if ( lw > 0 ) then ! No fill-in. a ( lw ) = a ( lw ) + amult * a ( lv ) if ( abs ( a ( lw )) <= small ) then ! Delete small computed element. a ( lw ) = a ( lw2 ) j = indr ( lw2 ) indr ( lw ) = j indr ( lw2 ) = 0 locc ( j ) = lw locc ( jv ) = 0 lenU = lenU - 1 lenw = lenw - 1 lw2 = lw2 - 1 end if else ! Row iw doesn't have an element in column jv yet ! so there is a fill-in. if ( indr ( lw2 + 1 ) /= 0 ) go to 360 lenU = lenU + 1 lenw = lenw + 1 lw2 = lw2 + 1 a ( lw2 ) = amult * a ( lv ) indr ( lw2 ) = jv locc ( jv ) = lw2 end if end do go to 490 ! Fill-in interrupted the previous loop. ! Move row  iw  to the end of the row file. 360 lv2 = lv locr ( iw ) = lrow + 1 do l = lw1 , lw2 lrow = lrow + 1 a ( lrow ) = a ( l ) j = indr ( l ) indr ( l ) = 0 indr ( lrow ) = j locc ( j ) = lrow end do lw1 = locr ( iw ) lw2 = lrow !............................................................... ! Inner loop with row iw at the end of storage. !............................................................... 400 do lv = lv2 , lv3 jv = indr ( lv ) lw = locc ( jv ) if ( lw > 0 ) then ! No fill-in a ( lw ) = a ( lw ) + amult * a ( lv ) if ( abs ( a ( lw )) <= small ) then ! Delete small computed element a ( lw ) = a ( lw2 ) j = indr ( lw2 ) indr ( lw ) = j indr ( lw2 ) = 0 locc ( j ) = lw locc ( jv ) = 0 lenU = lenU - 1 lenw = lenw - 1 lw2 = lw2 - 1 end if else ! Row iw doesn't have an element in column jv yet ! so there is a fill-in lenU = lenU + 1 lenw = lenw + 1 lw2 = lw2 + 1 a ( lw2 ) = amult * a ( lv ) indr ( lw2 ) = jv locc ( jv ) = lw2 end if end do lrow = lw2 ! The k-th element of row iw has been processed. ! Reset swappd before looking at the next element. 490 swappd = . false . end do !================================================================= ! End of main elimination loop. !================================================================== ! Cancel markers on row iw. 600 lenr ( iw ) = lenw if ( lenw == 0 ) go to 910 do l = lw1 , lw2 j = indr ( l ) locc ( j ) = 0 end do ! Move the diagonal element to the front of row iw. ! At this stage, lenw > 0 and klast <= n. 700 do l = lw1 , lw2 ldiag = l if ( indr ( l ) == jfirst ) go to 730 ! not exit !!! end do go to 910 730 diag = a ( ldiag ) a ( ldiag ) = a ( lw1 ) a ( lw1 ) = diag indr ( ldiag ) = indr ( lw1 ) indr ( lw1 ) = jfirst ! If an interchange is needed, repeat from the beginning with the ! new row iw, knowing that the opposite interchange cannot occur. if ( swappd ) go to 100 inform = 0 go to 950 ! Singular 910 diag = zero inform = 1 ! Force a compression if the file for U is much longer than the ! no. of nonzeros in U (i.e. if lrow is much bigger than lenU). ! This should prevent memory fragmentation when there is far more ! memory than necessary (i.e. when lena is huge). 950 limit = int ( Uspace * real ( lenU )) + m + n + 1000 if ( lrow > limit ) then call lu1rec ( m , . true ., luparm , lrow , ilast , & lena , a , indr , lenr , locr ) end if go to 990 ! Not enough storage. 970 inform = 7 ! Exit. 990 return end subroutine lu7for !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu7rnk ( m , n , jsing , lena , parmlu , & lenL , lenU , lrow , nrank , & a , indc , indr , p , q , lenr , locc , locr , & inform , diag ) integer ( ip ), intent ( in ) :: m , n , jsing , lena , & p ( m ) integer ( ip ), intent ( inout ) :: lenL , lenU , lrow , nrank , & indc ( lena ), indr ( lena ), q ( n ), & lenr ( m ), locc ( n ), locr ( m ) real ( rp ), intent ( inout ) :: parmlu ( 30 ) ! not used real ( rp ), intent ( inout ) :: a ( lena ) integer ( ip ), intent ( out ) :: inform real ( rp ), intent ( out ) :: diag !------------------------------------------------------------------ ! lu7rnk (check rank) assumes U is currently nrank by n ! and determines if row nrank contains an acceptable pivot. ! If not, the row is deleted and nrank is decreased by 1. ! jsing is an input parameter (not altered).  If jsing is positive, ! column jsing has already been judged dependent.  A substitute ! (if any) must be some other column. ! ! On exit, ! inform = -1 if nrank decreases by 1 !        =  0 if nrank stays the same !        =  1 if there's a fatal error.  (Currently we stop.) ! ! -- Jul 1987: First version. ! 09 May 1988: First f77 version. ! 13 Dec 2011: First f90 version. ! 01 Jan 2012: luparm not used. !------------------------------------------------------------------ integer ( ip ) :: iw , jmax , kmax , l , l1 , l2 , lenw , lmax real ( rp ) :: Umax , Utol1 Utol1 = parmlu ( 4 ) diag = zero ! Find Umax, the largest element in row nrank. iw = p ( nrank ) lenw = lenr ( iw ) if ( lenw == 0 ) go to 400 l1 = locr ( iw ) l2 = l1 + lenw - 1 Umax = zero lmax = l1 do l = l1 , l2 if ( Umax < abs ( a ( l ))) then Umax = abs ( a ( l )) lmax = l end if end do ! Find which column that guy is in (in pivotal order). ! Interchange him with column nrank, then move him to be ! the new diagonal at the front of row nrank. diag = a ( lmax ) jmax = indr ( lmax ) l = 0 do kmax = nrank , n if ( q ( kmax ) == jmax ) then l = kmax ! l allows check below for fatal error exit end if end do if ( l == 0 ) go to 800 ! Fatal error q ( kmax ) = q ( nrank ) q ( nrank ) = jmax a ( lmax ) = a ( l1 ) a ( l1 ) = diag indr ( lmax ) = indr ( l1 ) indr ( l1 ) = jmax ! See if the new diagonal is big enough. if ( Umax <= Utol1 ) go to 400 if ( jmax == jsing ) go to 400 !------------------------------------------------------------------ ! The rank stays the same. !------------------------------------------------------------------ inform = 0 go to 900 !------------------------------------------------------------------ ! The rank decreases by one. !------------------------------------------------------------------ 400 inform = - 1 nrank = nrank - 1 if ( lenw > 0 ) then ! Delete row nrank from U. lenU = lenU - lenw lenr ( iw ) = 0 do l = l1 , l2 indr ( l ) = 0 end do if ( l2 == lrow ) then ! This row was at the end of the data structure. ! We have to reset lrow. ! Preceding rows might already have been deleted, so we ! have to be prepared to go all the way back to 1. do l = 1 , l2 if ( indr ( lrow ) > 0 ) go to 900 lrow = lrow - 1 end do end if end if go to 900 ! 15 Dec 2011: Fatal error (should never happen!). ! This is a safeguard during work on the f90 version. 800 inform = 1 write ( * , * ) 'Fatal error in LUSOL lu7rnk.  Stopping now' stop 900 return end subroutine lu7rnk !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu7zap ( m , n , jzap , kzap , lena , lenU , lrow , nrank , & a , indr , p , q , lenr , locr ) integer ( ip ), intent ( in ) :: m , n , jzap , lena , nrank , & p ( m ) integer ( ip ), intent ( inout ) :: lenU , lrow , & indr ( lena ), q ( n ), lenr ( m ), locr ( m ) real ( rp ), intent ( inout ) :: a ( lena ) integer ( ip ), intent ( out ) :: kzap !------------------------------------------------------------------ ! lu7zap  eliminates all nonzeros in column  jzap  of  U. ! It also sets  kzap  to the position of  jzap  in pivotal order. ! Thus, on exit we have  q(kzap) = jzap. ! ! -- Jul 1987: nrank added. ! 10 May 1988: First f77 version. ! 13 Dec 2011: First f90 version. !------------------------------------------------------------------ integer ( ip ) :: i , k , leni , l , lr1 , lr2 do k = 1 , nrank i = p ( k ) leni = lenr ( i ) if ( leni == 0 ) go to 90 lr1 = locr ( i ) lr2 = lr1 + leni - 1 do l = lr1 , lr2 if ( indr ( l ) == jzap ) go to 60 end do go to 90 ! Delete the old element. 60 a ( l ) = a ( lr2 ) indr ( l ) = indr ( lr2 ) indr ( lr2 ) = 0 lenr ( i ) = leni - 1 lenU = lenU - 1 ! Stop if we know there are no more rows containing  jzap. 90 kzap = k if ( q ( k ) == jzap ) go to 800 end do ! nrank must be smaller than n because we haven't found kzap yet. do k = nrank + 1 , n kzap = k if ( q ( k ) == jzap ) exit end do ! See if we zapped the last element in the file. 800 if ( lrow > 0 ) then if ( indr ( lrow ) == 0 ) lrow = lrow - 1 end if end subroutine lu7zap !********************************************************************* ! File lusol8a.f90 ! ! lu8rpc ! ! Sparse LU update: Replace Column ! LUSOL's sparse implementation of the Bartels-Golub update. ! ! 01 May 2002: Derived from LUSOL's original lu8a.f file. ! 01 May 2002: Current version of lusol8a.f. ! 15 Sep 2004: Test nout. gt. 0 to protect write statements. ! 13 Dec 2011: First f90 version. ! 20 Jan 2016: Current version of lusol8a.f90. !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ subroutine lu8rpc ( mode1 , mode2 , m , n , jrep , v , w , & lena , luparm , parmlu , & a , indc , indr , p , q , & lenc , lenr , locc , locr , & inform , diag , vnorm ) integer ( ip ), intent ( in ) :: mode1 , mode2 , m , n , jrep , lena integer ( ip ), intent ( inout ) :: luparm ( 30 ), & indc ( lena ), indr ( lena ), p ( m ), q ( n ), & lenc ( n ), lenr ( m ), locc ( n ), locr ( m ) real ( rp ), intent ( inout ) :: parmlu ( 30 ), a ( lena ), v ( m ), & w ( n ) ! not used integer ( ip ), intent ( out ) :: inform real ( rp ), intent ( out ) :: diag , vnorm !------------------------------------------------------------------ ! lu8rpc  updates the LU factorization A = L*U when column jrep ! is replaced by some vector v = a(new). ! ! lu8rpc  is an implementation of the Bartels-Golub update, ! designed for the case where A is rectangular and/or singular. ! L is a product of stabilized eliminations (m x m, nonsingular). ! P U Q is upper trapezoidal (m x n, rank nrank). ! ! If  mode1 = 0,  the old column is taken to be zero ! (so it does not have to be removed from U). ! ! If  mode1 = 1,  the old column need not have been zero. ! ! If  mode2 = 0,  the new column is taken to be zero. !                 v(*) is not used or altered. ! ! If  mode2 = 1,  v(*) must contain the new column a(new). ! On exit,  v(*)  will satisfy L*v = a(new). ! ! If  mode2 = 2,  v(*) must satisfy L*v = a(new). ! ! The array w(*) is not used or altered. ! ! On entry, all elements of locc are assumed to be zero. ! On a successful exit (inform /= 7), this will again be true. ! ! On exit: ! inform = -1  if the rank of U decreased by 1. ! inform =  0  if the rank of U stayed the same. ! inform =  1  if the rank of U increased by 1. ! inform =  2  if the update seemed to be unstable !              (diag much bigger than vnorm). ! inform =  7  if the update was not completed (lack of storage). ! inform =  8  if jrep is not between 1 and n. ! ! -- Jan 1985: Original F66 version. ! -- Jul 1987: Modified to maintain U in trapezoidal form. ! 10 May 1988: First f77 version. ! 16 Oct 2000: Added test for instability (inform = 2). ! 13 Dec 2011: First f90 version. !------------------------------------------------------------------ logical :: singlr integer ( ip ) :: iw , j1 , jsing , klast , krep , & l1 , lenL , lenU , lprint , lrow , nout , nrank , nrank0 real ( rp ) :: Utol1 , Utol2 nout = luparm ( 1 ) lprint = luparm ( 2 ) nrank = luparm ( 16 ) lenL = luparm ( 23 ) lenU = luparm ( 24 ) lrow = luparm ( 25 ) Utol1 = parmlu ( 4 ) Utol2 = parmlu ( 5 ) nrank0 = nrank diag = zero vnorm = zero if ( jrep < 1 ) go to 980 if ( jrep > n ) go to 980 !------------------------------------------------------------------ ! If mode1 = 0, there are no elements to be removed from  U ! but we still have to set  krep  (using a backward loop). ! Otherwise, use lu7zap to remove column  jrep  from  U ! and set  krep  at the same time. !------------------------------------------------------------------ if ( mode1 == 0 ) then krep = n + 1 10 krep = krep - 1 if ( q ( krep ) /= jrep ) go to 10 else call lu7zap ( m , n , jrep , krep , lena , lenU , lrow , nrank , & a , indr , p , q , lenr , locr ) end if !------------------------------------------------------------------ ! Insert a new column of u and find klast. !------------------------------------------------------------------ if ( mode2 == 0 ) then klast = 0 else if ( mode2 == 1 ) then ! Transform v = a(new) to satisfy  L*v = a(new). call lu6sol ( i1 , m , n , v , w , lena , luparm , parmlu , & a , indc , indr , p , q , & lenc , lenr , locc , locr , inform ) end if ! Insert into U any nonzeros in the top of v. ! row p(klast) will contain the last nonzero in pivotal order. ! Note that klast will be in the range ( 0, nrank ). call lu7add ( m , n , jrep , v , & lena , luparm , parmlu , & lenL , lenU , lrow , nrank , & a , indr , p , lenr , locr , & inform , klast , vnorm ) if ( inform == 7 ) go to 970 end if !------------------------------------------------------------------ ! In general, the new column causes U to look like this: ! !                 krep        n                 krep  n ! !                ....a.........          ..........a... !                 .  a        .           .        a  . !                  . a        .            .       a  . !                   .a        .             .      a  . !        P U Q =     a        .    or        .     a  . !                    b.       .               .    a  . !                    b .      .                .   a  . !                    b  .     .                 .  a  . !                    b   ......                  ..a...  nrank !                    c                             c !                    c                             c !                    c                             c     m ! !     klast points to the last nonzero \"a\" or \"b\". !     klast = 0 means all \"a\" and \"b\" entries are zero. !------------------------------------------------------------------ if ( mode2 == 0 ) then if ( krep > nrank ) go to 900 else if ( nrank < m ) then ! Eliminate any \"c\"s (in either case). ! Row nrank + 1 may end up containing one nonzero. call lu7elm ( m , n , jrep , v , lena , luparm , parmlu , & lenL , lenU , lrow , nrank , & a , indc , indr , p , q , lenr , locc , locr , & inform , diag ) if ( inform == 7 ) go to 970 if ( inform == 1 ) then ! The nonzero is apparently significant. ! Increase nrank by 1 and make klast point to the bottom. nrank = nrank + 1 klast = nrank end if end if if ( nrank < n ) then ! The column rank is low. ! ! In the first case, we want the new column to end up in ! position nrank, so the trapezoidal columns will have a chance ! later on (in lu7rnk) to pivot in that position. ! ! Otherwise the new column is not part of the triangle.  We ! swap it into position nrank so we can judge it for singularity. ! lu7rnk might choose some other trapezoidal column later. if ( krep < nrank ) then klast = nrank else q ( krep ) = q ( nrank ) q ( nrank ) = jrep krep = nrank end if end if !------------------------------------------------------------------ ! If krep < klast, there are some \"b\"s to eliminate: ! !                  krep ! !                ....a......... !                 .  a        . !                  . a        . !                   .a        . !        P U Q =     a        .  krep !                    b.       . !                    b .      . !                    b  .     . !                    b   ......  nrank ! !     If krep == klast, there are no \"b\"s, but the last \"a\" still !     has to be moved to the front of row krep (by lu7for). !------------------------------------------------------------------ if ( krep <= klast ) then ! Perform a cyclic permutation on the current pivotal order, ! and eliminate the resulting row spike.  krep becomes klast. ! The final diagonal (if any) will be correctly positioned at ! the front of the new krep-th row.  nrank stays the same. call lu7cyc ( krep , klast , p ) call lu7cyc ( krep , klast , q ) call lu7for ( m , n , krep , klast , & lena , luparm , parmlu , & lenL , lenU , lrow , & a , indc , indr , p , q , lenr , locc , locr , & inform , diag ) if ( inform == 7 ) go to 970 krep = klast ! Test for instability (diag much bigger than vnorm). singlr = vnorm < Utol2 * abs ( diag ) if ( singlr ) go to 920 end if !------------------------------------------------------------------ ! Test for singularity in column krep (where krep .le. nrank). !------------------------------------------------------------------ diag = zero iw = p ( krep ) singlr = lenr ( iw ) == 0 if (. not . singlr ) then l1 = locr ( iw ) j1 = indr ( l1 ) singlr = j1 /= jrep if (. not . singlr ) then diag = a ( l1 ) singlr = abs ( diag ) <= Utol1 . or . & abs ( diag ) <= Utol2 * vnorm end if end if if ( singlr . and . krep < nrank ) then ! Perform cyclic permutations to move column jrep to the end. ! Move the corresponding row to position nrank ! then eliminate the resulting row spike. call lu7cyc ( krep , nrank , p ) call lu7cyc ( krep , n , q ) call lu7for ( m , n , krep , nrank , & lena , luparm , parmlu , & lenL , lenU , lrow , & a , indc , indr , p , q , lenr , locc , locr , & inform , diag ) if ( inform == 7 ) go to 970 end if ! Find the best column to be in position nrank. ! If singlr, it can't be the new column, jrep. ! If nothing satisfactory exists, nrank will be decreased. if ( singlr . or . nrank < n ) then jsing = 0 if ( singlr ) jsing = jrep call lu7rnk ( m , n , jsing , lena , parmlu , & lenL , lenU , lrow , nrank , & a , indc , indr , p , q , lenr , locc , locr , & inform , diag ) end if !------------------------------------------------------------------ ! Set inform for exit. !------------------------------------------------------------------ 900 if ( nrank == nrank0 ) then inform = 0 else if ( nrank < nrank0 ) then inform = - 1 if ( nrank0 == n ) then if ( nout > 0 . and . lprint >= 0 ) write ( nout , 1100 ) jrep , diag end if else inform = 1 end if go to 990 ! Instability. 920 inform = 2 if ( nout > 0 . and . lprint >= 0 ) write ( nout , 1200 ) jrep , diag go to 990 ! Not enough storage. 970 inform = 7 if ( nout > 0 . and . lprint >= 0 ) write ( nout , 1700 ) lena go to 990 ! jrep  is out of range. 980 inform = 8 if ( nout > 0 . and . lprint >= 0 ) write ( nout , 1800 ) m , n , jrep ! Exit. 990 luparm ( 10 ) = inform luparm ( 15 ) = luparm ( 15 ) + 1 luparm ( 16 ) = nrank luparm ( 23 ) = lenL luparm ( 24 ) = lenU luparm ( 25 ) = lrow return 1100 format ( / ' lu8rpc  warning.  Singularity after replacing column.' , & '    jrep =' , i8 , '    diag =' , es12 . 2 ) 1200 format ( / ' lu8rpc  warning.  Instability after replacing column.' , & '    jrep =' , i8 , '    diag =' , es12 . 2 ) 1700 format ( / ' lu8rpc  error...  Insufficient storage.' , & '    lena =' , i8 ) 1800 format ( / ' lu8rpc  error...  jrep  is out of range.' , & '    m =' , i8 , '    n =' , i8 , '    jrep =' , i8 ) end subroutine lu8rpc !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ function jdamax ( n , x , incx ) result ( iAmax ) integer ( ip ), intent ( in ) :: n , incx real ( rp ), intent ( in ) :: x (:) integer ( ip ) :: iAmax !=========================================================================== ! jdamax does the same as idamax in most cases. ! jdamax > 0 if x contains normal values. ! jdamax = 0 if n = 0. ! jdamax < 0 means x(-jdamax) contains the first NaN or Inf. ! ! 29 Jul 2003: First version of jdamax implemented for s5setx. ! 29 Jul 2003: Current version of jdamax ! 15 Mar 2008: First f90 version. !=========================================================================== intrinsic :: huge integer ( ip ) :: i , ix , kmax real ( rp ) :: dmax , xi real ( rp ), parameter :: realmax = huge ( realmax ) if ( n < 1 ) then iAmax = 0 return end if dmax = zero ix = 1 kmax = 1 do i = 1 , n xi = abs ( x ( ix ) ) if ( xi <= realmax ) then ! false if xi = Nan or Inf if ( dmax < xi ) then dmax = xi kmax = ix end if else go to 800 end if ix = ix + incx end do iAmax = kmax return 800 iAmax = - ix end function jdamax end module lusol","tags":"","loc":"sourcefile/lusol.f90.html"},{"title":"problem_18.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_18.f90~~EfferentGraph sourcefile~problem_18.f90 problem_18.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_18.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_18 use aoc_utilities use iso_fortran_env implicit none integer ( ip ) :: iresult call clk % tic () call go (. false ., iresult ); write ( * , * ) '18a:' , iresult call go (. true ., iresult ); write ( * , * ) '18b:' , iresult call clk % toc ( '18' ) contains subroutine go ( partb , iresult ) logical , intent ( in ) :: partb !! if solving part b integer ( ip ), intent ( out ) :: iresult integer :: iunit , iline , n_lines , n character ( len = :), allocatable :: line , hex type ( string ), dimension (:), allocatable :: vals character ( len = 1 ) :: direction integer ( ip ), dimension ( 2 ) :: iloc , iloc2 integer ( ip ) :: ival , isteps real ( wp ), dimension (:), allocatable :: xvec , yvec character ( len = 1 ), dimension ( 0 : 3 ) :: direction_str = [ 'R' , 'D' , 'L' , 'U' ] ! directions for part b : 0,1,2,3 ! open(newunit=iunit, file='inputs/day18_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day18.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) iloc = [ 0 , 0 ] ! where to start isteps = 0 xvec = [ 0 ]; yvec = [ 0 ] do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ! direction, number, (hex) if ( partb ) then ! values encoded in hex hex = vals ( 3 )% str ival = hex2int ( hex ( 3 : 7 )) direction = direction_str ( int ( hex ( 8 : 8 ))) else direction = vals ( 1 )% str ival = int ( vals ( 2 )% str ) end if isteps = isteps + ival ! keep track of the total perimeter size iloc2 = destination ( iloc , direction , ival ) ! destination oint xvec = [ xvec , real ( iloc2 ( 1 ), wp )] ! save the points of the polygon yvec = [ yvec , real ( iloc2 ( 2 ), wp )] ! iloc = iloc2 ! update for next move end do close ( iunit ) ! the area including the boundary = area + 1/2 the perimeter + 1 ! using NSWC parea function! n = size ( xvec ) iresult = int ( abs ( parea ( yvec , xvec , n )) + real ( isteps , wp ) / 2_ip + 1_ip , ip ) end subroutine go pure function destination ( initial , direction , steps ) result ( final ) !! get destination point integer ( ip ), dimension ( 2 ), intent ( in ) :: initial character ( len = 1 ), intent ( in ) :: direction integer ( ip ), intent ( in ) :: steps integer ( ip ), dimension ( 2 ) :: final !! x,y of desination point select case ( direction ) case ( 'R' ); final = [ initial ( 1 ), initial ( 2 ) + steps ] case ( 'L' ); final = [ initial ( 1 ), initial ( 2 ) - steps ] case ( 'D' ); final = [ initial ( 1 ) + steps , initial ( 2 )] case ( 'U' ); final = [ initial ( 1 ) - steps , initial ( 2 )] end select end function destination end program problem_18","tags":"","loc":"sourcefile/problem_18.f90.html"},{"title":"problem_23.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_23.f90~~EfferentGraph sourcefile~problem_23.f90 problem_23.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_23.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_23 !! alternate one... collapse the maze into a graph ! Process: !   1. locate the start and end nodes (top and bottom) !   2. find all the cells that have 3 or 4 adjacent cells: ! !      1    2    3    4 !     ###  #.#  ###  #.# !-->  #.#  #.#  ...  ... !     #.#  #.#  #.#  #.# ! !     those are the nodes, and the paths between them are the edges !   3. compute the edges between each node combination and construct the graph !   4. DFS all paths to find the longest. use iso_fortran_env use aoc_utilities implicit none type :: node integer ( ip ), dimension (:), allocatable :: inext !! the node connected to this one integer ( ip ), dimension (:), allocatable :: idist !! distance to inext nodes end type node type ( node ), dimension (:), allocatable :: nodes !! the list of nodes logical :: slopes !! a=true, b=false logical , dimension (:,:), allocatable :: visited logical , dimension (:), allocatable :: nodes_visited integer ( ip ), dimension (:), allocatable :: inodes , jnodes !! node coordinates integer ( ip ) :: max_dist , total_nodes , nrows , ncols character ( len = 1 ), dimension (:,:), allocatable :: array integer ( ip ), dimension (:), allocatable :: node_dist integer ( ip ), dimension (:), allocatable :: node_prev call clk % tic () ! call go('23a', 'inputs/day23_test.txt', .true. ) ! call go('23b', 'inputs/day23_test.txt', .false.) call go ( '23a' , 'inputs/day23.txt' , . true . ) call go ( '23b' , 'inputs/day23.txt' , . false .) call clk % toc ( '23' ) contains subroutine go ( case , filename , parta ) !! solve the case character ( len =* ), intent ( in ) :: case !! case name for printing character ( len =* ), intent ( in ) :: filename !! input file to read logical , intent ( in ) :: parta !! if this is part a, then consider the slopes integer ( ip ), dimension ( 1 ) :: iloc integer ( ip ) :: istart , iend , idist , i , j logical , parameter :: use_dijkstra = . false . !.... doesn't work yet .... don't know why ....... ! initialize: max_dist = 0 slopes = parta if ( allocated ( nodes )) deallocate ( nodes ) if ( allocated ( visited )) deallocate ( visited ) if ( allocated ( nodes_visited )) deallocate ( nodes_visited ) if ( allocated ( inodes )) deallocate ( inodes ) if ( allocated ( jnodes )) deallocate ( jnodes ) if ( allocated ( node_dist )) deallocate ( node_dist ) if ( allocated ( node_prev )) deallocate ( node_prev ) ! read the data file: array = read_file_to_char_array ( filename ) nrows = size ( array , 1 ) ncols = size ( array , 2 ) iloc = findloc ( array ( 1 ,:), '.' ); istart = iloc ( 1 ) ! get start and end columns iloc = findloc ( array ( nrows ,:), '.' ); iend = iloc ( 1 ) ! ! identify the coordinates of all the nodes: inodes = [ 1 ] ! start node jnodes = [ istart ] do i = 1 , nrows do j = 1 , ncols if ( count_adjacent ( i , j ) >= 3 ) then inodes = [ inodes , i ] jnodes = [ jnodes , j ] end if end do end do inodes = [ inodes , nrows ] ! end node jnodes = [ jnodes , iend ] total_nodes = size ( inodes ) ! for each node, find the other nodes they are ! connected to and the distances between them (the edges) allocate ( nodes ( total_nodes )) allocate ( visited ( nrows , ncols )) do i = 1 , total_nodes visited = . false . idist = 0 call build_graph ( i , inodes ( i ), jnodes ( i ), idist , visited ) end do if ( use_dijkstra ) then !write(*,*) 'hello use_dijkstra'         ! ... something wrong here... don't get the right answer ! based on AOC 2021, Problem 15 allocate ( node_dist ( total_nodes )); node_dist = - 1 ; node_dist ( 1 ) = 0 allocate ( node_prev ( total_nodes )); node_prev = - 1 allocate ( nodes_visited ( total_nodes )); nodes_visited = . false . do iloc = maxloc ( node_dist , mask = . not . nodes_visited ) i = iloc ( 1 ) nodes_visited ( i ) = . true . if ( i == total_nodes ) exit ! we are done! !write(*,*) 'visited ', i if ( allocated ( nodes ( i )% inext )) then do j = 1 , size ( nodes ( i )% inext ) ! adjacent nodes to this one call dijkstra ( i , j ) end do end if !if (all(nodes_visited)) exit ! done end do !write(*,*) case, node_dist(size(node_dist)) ! result for this case (last node) !write(*,*) nodes_visited !write(*,*) node_dist else ! start at first, and find the longest that gets to the last. ! recursively traverse the graph. visited = . false . allocate ( nodes_visited ( total_nodes )); nodes_visited = . false . call traverse ( 1_ip , 0_ip , nodes_visited ) write ( * , * ) case , max_dist ! result for this case end if end subroutine go subroutine dijkstra ( u , inext ) integer ( ip ), intent ( in ) :: u ! current integer ( ip ), intent ( in ) :: inext ! index in inext array of the next node integer ( ip ) :: idist associate ( next_node => nodes ( u )% inext ( inext ), & distance_to_next_node => nodes ( u )% idist ( inext )) if ( nodes_visited ( next_node )) return ! already visited this one idist = node_dist ( u ) + distance_to_next_node ! add distance from u to v if ( idist > node_dist ( next_node )) then !write(*,*) 'highest so far: ', idist node_dist ( next_node ) = idist node_prev ( next_node ) = u end if end associate end subroutine dijkstra recursive subroutine build_graph ( node_num , i , j , idist , visited ) integer ( ip ), intent ( in ) :: node_num !! current node number integer ( ip ), intent ( in ) :: i , j !! current position integer ( ip ), intent ( in ) :: idist !! current distance (number of steps) logical , dimension (:,:), intent ( in ) :: visited !! elements visited in this path (not counting this one) logical , dimension (:,:), allocatable :: tmp_visited integer ( ip ) :: child_node_num if ( i < 1 . or . i > nrows . or . j < 1 . or . j > ncols ) return if ( visited ( i , j )) return if ( array ( i , j ) == '#' ) return ! can't continue from here ! go until we hit another node child_node_num = node_number ( i , j ) if ( child_node_num > 0 . and . child_node_num /= node_num ) then ! we have reached another node call add_edge ( node_num , child_node_num , idist ) else ! continue processing this edge tmp_visited = visited !make a copy and mark this one tmp_visited ( i , j ) = . true . ! we are here now associate ( a => get_cell ( i , j )) ! paths (.), forest (#), and steep slopes (&#94;, >, v, and <). select case ( a ) case ( '.' ) ! path call build_graph ( node_num , i - 1 , j , idist + 1 , tmp_visited ) call build_graph ( node_num , i + 1 , j , idist + 1 , tmp_visited ) call build_graph ( node_num , i , j + 1 , idist + 1 , tmp_visited ) call build_graph ( node_num , i , j - 1 , idist + 1 , tmp_visited ) ! these don't have a choice, must go in these directions: case ( '&#94;' ); call build_graph ( node_num , i - 1 , j , idist + 1 , tmp_visited ) case ( 'v' ); call build_graph ( node_num , i + 1 , j , idist + 1 , tmp_visited ) case ( '>' ); call build_graph ( node_num , i , j + 1 , idist + 1 , tmp_visited ) case ( '<' ); call build_graph ( node_num , i , j - 1 , idist + 1 , tmp_visited ) end select end associate end if end subroutine build_graph recursive subroutine traverse ( node_num , idist , nodes_visited ) !! traverse the graph until we get to the end and check the max distance integer ( ip ), intent ( in ) :: node_num !! current node integer ( ip ), intent ( in ) :: idist !! distance to get here logical , dimension (:), intent ( in ) :: nodes_visited logical , dimension (:), allocatable :: tmp_nodes_visited integer :: i if ( nodes_visited ( node_num )) return ! already visited this node if ( node_num == total_nodes ) then ! reached the destination if ( idist > max_dist ) max_dist = idist ! best so far else ! are their child nodes? if ( allocated ( nodes ( node_num )% inext )) then tmp_nodes_visited = nodes_visited tmp_nodes_visited ( node_num ) = . true . ! mark this node do i = 1 , size ( nodes ( node_num )% inext ) call traverse ( nodes ( node_num )% inext ( i ), idist + nodes ( node_num )% idist ( i ), tmp_nodes_visited ) end do end if end if end subroutine traverse pure logical function is_node ( i , j ) !! returns true if a node is at these coordinates integer ( ip ), intent ( in ) :: i , j is_node = any ( inodes == i . and . jnodes == j ) end function is_node subroutine add_edge ( inode , ichild , idist ) !! add an edge to this node (path to another node with the specified distance) integer ( ip ), intent ( in ) :: inode , ichild , idist if (. not . allocated ( nodes ( inode )% inext )) then allocate ( nodes ( inode )% inext ( 0 )) allocate ( nodes ( inode )% idist ( 0 )) end if nodes ( inode )% inext = [ nodes ( inode )% inext , ichild ] nodes ( inode )% idist = [ nodes ( inode )% idist , idist ] end subroutine add_edge pure integer ( ip ) function node_number ( i , j ) !! returns the index of these coordinates in !! the list of nodes (0 if it is not a node) integer ( ip ), intent ( in ) :: i , j integer ( ip ), dimension ( 1 ) :: iloc iloc = findloc ( inodes == i . and . jnodes == j , . true .) node_number = iloc ( 1 ) end function node_number pure function count_adjacent ( i , j ) result ( icount ) !! count the number of adjacent cells not a tree integer ( ip ), intent ( in ) :: i , j integer ( ip ) :: icount icount = 0 if ( i >= 1 ) icount = icount + count ([ not_tree ( i - 1 , j )]) if ( i <= nrows ) icount = icount + count ([ not_tree ( i + 1 , j )]) if ( j <= ncols ) icount = icount + count ([ not_tree ( i , j + 1 )]) if ( j >= 1 ) icount = icount + count ([ not_tree ( i , j - 1 )]) end function count_adjacent pure function get_cell ( i , j ) result ( a ) integer ( ip ), intent ( in ) :: i , j !! coordinates character ( len = 1 ) :: a if ( slopes ) then a = array ( i , j ) else a = '.' ! ignore the slopes for part b end if end function get_cell pure logical function not_tree ( i , j ) !! returns true if the cell isn't a tree integer ( ip ), intent ( in ) :: i , j !! coordinates if ( i < 1 . or . i > nrows . or . j < 1 . or . j > ncols ) then not_tree = . false . ! off the board, call it a tree else not_tree = array ( i , j ) /= '#' end if end function not_tree end program problem_23","tags":"","loc":"sourcefile/problem_23.f90.html"},{"title":"problem_12b.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_12b.f90~~EfferentGraph sourcefile~problem_12b.f90 problem_12b.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_12b.f90->sourcefile~aoc_utilities.f90 sourcefile~cache_module.f90~2 cache_module.f90 sourcefile~problem_12b.f90->sourcefile~cache_module.f90~2 sourcefile~cache_module.f90~2->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_12b !! completely reworked solution from part a !! this one starts with the int list and checks it against the pattern. !! it also employs a function cache to speed it up. use iso_fortran_env use aoc_utilities use aoc_cache_module implicit none ! note: these are negative because we are appending ! them to the pattern for the cache integer ( ip ), parameter :: POINT = - 1 ! . integer ( ip ), parameter :: NUMBER = - 2 ! # integer ( ip ), parameter :: QUESTION = - 3 ! ? ! some global variables integer :: iunit , n_lines , iline character ( len = :), allocatable :: line , pattern type ( string ), dimension (:), allocatable :: vals integer ( ip ), dimension (:), allocatable :: ints , ipattern integer ( ip ) :: isum , ival type ( function_cache ) :: cache !! to cache the [[go]] function values call clk % tic () call cache % initialize ( isize = 10000 , chunk_size = 1000 ) ! open(newunit=iunit, file='inputs/day12_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day12.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) isum = 0 do iline = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ' ' ) ints = parse_ints ( vals ( 2 )% str ) ! integer list pattern = vals ( 1 )% str ! the pattern ! will convert the pattern to an array of numbers: ipattern = str_to_int64_array_with_mapping ( pattern ,[ '.' , '#' , '?' ],& [ POINT , NUMBER , QUESTION ]) ! expand the input ipattern = [ ipattern , QUESTION , ipattern , QUESTION , & ipattern , QUESTION , ipattern , QUESTION , & ipattern ] ints = [ ints , ints , ints , ints , ints ] ival = go ( ipattern , ints ) isum = isum + ival end do write ( * , * ) '12b: ' , isum call clk % toc ( '12b' ) contains recursive function go ( ipattern , ints ) result ( ival ) integer ( ip ), dimension (:), intent ( in ) :: ipattern integer ( ip ), dimension (:), intent ( in ) :: ints integer ( ip ) :: ival integer ( ip ), dimension (:), allocatable :: ival_vec integer ( ip ) :: idx logical :: found ! first check the cache: call cache % get ([ ipattern , ints ], idx , ival_vec , found ) if ( found ) then ival = ival_vec ( 1 ) else if ( size ( ints ) == 0 ) then ! no more ints ival = merge ( 0 , 1 , any ( ipattern == NUMBER )) ! if any more numbers, invalid else if ( size ( ipattern ) == 0 ) then ival = 0 ! too many ints else ! process next element in pattern select case ( ipattern ( 1 )) case ( NUMBER ); ival = ipound ( ipattern , ints ) case ( POINT ); ival = ipoint ( ipattern , ints ) case ( QUESTION ); ival = ipoint ( ipattern , ints ) + ipound ( ipattern , ints ) end select end if ! cache this function call: ival_vec = [ ival ] call cache % put ( idx ,[ ipattern , ints ], ival_vec ) end if end function go recursive integer ( ip ) function ipound ( ipattern , ints ) integer ( ip ), dimension (:), intent ( in ) :: ipattern !! first char is a # integer ( ip ), dimension (:), intent ( in ) :: ints integer ( ip ), dimension (:), allocatable :: this_group ! check for the number of # that correspond to the first group if ( size ( ipattern ) >= ints ( 1 )) then this_group = ipattern ( 1 : ints ( 1 )) where ( this_group == QUESTION ) this_group = NUMBER ! replace ? with # if ( any ( this_group /= NUMBER )) then ! can't fit all the #'s so not valid ipound = 0 return else ! so far so good end if else ! not enough room to hold all the #'s ipound = 0 return end if if ( size ( ipattern ) == ints ( 1 )) then ! if this is the last group, then we are done ipound = merge ( 1 , 0 , size ( ints ) == 1 ) else ! the next character after this number must be a ? or . if ( size ( ipattern ) >= ints ( 1 ) + 1 ) then if ( any ( ipattern ( ints ( 1 ) + 1 ) == [ QUESTION , POINT ])) then block integer ( ip ), dimension (:), allocatable :: ipattern_tmp , ints_tmp ! to handle edge cases ! skip it and process the next group if ( size ( ipattern ) >= ints ( 1 ) + 2 ) then ipattern_tmp = ipattern ( ints ( 1 ) + 2 :) else allocate ( ipattern_tmp ( 0 )) end if if ( size ( ints ) >= 2 ) then ints_tmp = ints ( 2 :) else allocate ( ints_tmp ( 0 )) end if ipound = go ( ipattern_tmp , ints_tmp ) return end block end if end if ! not valid at this point ipound = 0 end if end function ipound recursive integer ( ip ) function ipoint ( ipattern , ints ) integer ( ip ), dimension (:), intent ( in ) :: ipattern !! first char is a . integer ( ip ), dimension (:), intent ( in ) :: ints if ( size ( ipattern ) <= 1 ) then ipoint = go ([ integer ( ip ) :: ], ints ) ! done, pass in empty array else ipoint = go ( ipattern ( 2 :), ints ) ! skip it and go to next one end if end function ipoint end program problem_12b","tags":"","loc":"sourcefile/problem_12b.f90.html"},{"title":"lsqr_kinds.F90 – AoC-2023","text":"Files dependent on this one sourcefile~~lsqr_kinds.f90~~AfferentGraph sourcefile~lsqr_kinds.f90 lsqr_kinds.F90 sourcefile~lsqr.f90 lsqr.f90 sourcefile~lsqr.f90->sourcefile~lsqr_kinds.f90 sourcefile~lsqrblas.f90 lsqrblas.f90 sourcefile~lsqr.f90->sourcefile~lsqrblas.f90 sourcefile~lsqrblas.f90->sourcefile~lsqr_kinds.f90 sourcefile~lsqrtest_ez.f90 lsqrtest_ez.f90 sourcefile~lsqrtest_ez.f90->sourcefile~lsqr_kinds.f90 sourcefile~lsqrtest_ez.f90->sourcefile~lsqr.f90 sourcefile~lsqrtest_module.f90 lsqrtest_module.f90 sourcefile~lsqrtest_module.f90->sourcefile~lsqr_kinds.f90 sourcefile~lsqrtest_module.f90->sourcefile~lsqr.f90 sourcefile~lsqrtest_module.f90->sourcefile~lsqrblas.f90 sourcefile~lsqrtest.f90 lsqrtest.f90 sourcefile~lsqrtest.f90->sourcefile~lsqrtest_module.f90 sourcefile~nlesolver_module.f90 nlesolver_module.F90 sourcefile~nlesolver_module.f90->sourcefile~lsqr.f90 sourcefile~nlesolver_test_1.f90 nlesolver_test_1.f90 sourcefile~nlesolver_test_1.f90->sourcefile~nlesolver_module.f90 sourcefile~sparse_test.f90 sparse_test.f90 sourcefile~sparse_test.f90->sourcefile~nlesolver_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !*************************************************************************************************** !> !  Module for LSQR kinds and parameters ! !### History !  * Jacob Williams : 8 Nov 2019 : created module module lsqr_kinds use iso_fortran_env implicit none private #ifdef REAL32 integer , parameter , public :: wp = real32 !! default real kind [4 bytes] #elif REAL64 integer , parameter , public :: wp = real64 !! default real kind [8 bytes] #elif REAL128 integer , parameter , public :: wp = real128 !! default real kind [16 bytes] #else integer , parameter , public :: wp = real64 !! default real kind [8 bytes] #endif ! parameters: real ( wp ), parameter , public :: zero = 0.0_wp real ( wp ), parameter , public :: one = 1.0_wp !*************************************************************************************************** end module lsqr_kinds !***************************************************************************************************","tags":"","loc":"sourcefile/lsqr_kinds.f90.html"},{"title":"lsqrtest_ez.f90 – AoC-2023","text":"This file depends on sourcefile~~lsqrtest_ez.f90~~EfferentGraph sourcefile~lsqrtest_ez.f90 lsqrtest_ez.f90 sourcefile~lsqr.f90 lsqr.f90 sourcefile~lsqrtest_ez.f90->sourcefile~lsqr.f90 sourcefile~lsqr_kinds.f90 lsqr_kinds.F90 sourcefile~lsqrtest_ez.f90->sourcefile~lsqr_kinds.f90 sourcefile~lsqr.f90->sourcefile~lsqr_kinds.f90 sourcefile~lsqrblas.f90 lsqrblas.f90 sourcefile~lsqr.f90->sourcefile~lsqrblas.f90 sourcefile~lsqrblas.f90->sourcefile~lsqr_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !*************************************************************************************************** !> !  Main program for EZ test. program main use lsqr_kinds use lsqr_module , only : lsqr_solver_ez use iso_fortran_env , only : output_unit implicit none ! define a 3x3 dense system to solve: integer , parameter :: m = 3 !! number of rows in `A` matrix integer , parameter :: n = 3 !! number of columns in `A` matrix real ( wp ), dimension ( m ), parameter :: b = real ([ 1 , 2 , 3 ], wp ) integer , dimension ( m * n ), parameter :: icol = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ] integer , dimension ( m * n ), parameter :: irow = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] real ( wp ), dimension ( m * n ), parameter :: a = real ([ 1 , 4 , 7 , 2 , 5 , 88 , 3 , 66 , 9 ], wp ) real ( wp ), parameter :: damp = zero real ( wp ), dimension ( m , 1 ), parameter :: b_vec = reshape ( b ,[ m , 1 ]) real ( wp ), dimension ( m , n ), parameter :: a_mat = reshape ( a ,[ 3 , 3 ]) type ( lsqr_solver_ez ) :: solver real ( wp ), dimension ( n ) :: x real ( wp ), dimension ( 1 ) :: se !! not used real ( wp ), dimension ( n , 1 ) :: x_vec integer :: istop call solver % initialize ( m , n , a , irow , icol ,& itnlim = 100 ,& nout = output_unit ) call solver % solve ( b , damp , x , istop ) x_vec ( 1 : 3 , 1 ) = x write ( * , * ) '' write ( * , * ) 'istop = ' , istop write ( * , * ) '' write ( * , '(1P,A,*(E16.6))' ) 'x       = ' , x write ( * , '(1P,A,*(E16.6))' ) 'A*x     = ' , matmul ( a_mat , x_vec ) write ( * , '(1P,A,*(E16.6))' ) 'A*x - b = ' , matmul ( a_mat , x_vec ) - b_vec if ( any ( abs ( matmul ( a_mat , x_vec ) - b_vec ) > 1.0e-12 )) error stop 'TEST FAILED' end program main !***************************************************************************************************","tags":"","loc":"sourcefile/lsqrtest_ez.f90.html"},{"title":"problem_04.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_04.f90~~EfferentGraph sourcefile~problem_04.f90 problem_04.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_04.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_4 use iso_fortran_env use aoc_utilities implicit none integer :: iunit , n_lines , i , points , j , iwin type ( string ), dimension (:), allocatable :: vals , vals2 integer , dimension (:), allocatable :: iwinning , ihave , n_matches character ( len = :), allocatable :: line integer , dimension (:,:), allocatable :: card_matrix call clk % tic () ! open(newunit=iunit, file='inputs/day4_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day4.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( n_matches ( n_lines )) ! for part 2 allocate ( card_matrix ( 0 : n_lines , n_lines )) ! for part 2 ! Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53 points = 0 do i = 1 , n_lines line = read_line ( iunit ) vals = split ( line , ': ' ) vals2 = split ( vals ( 2 ), ' | ' ) iwinning = parse_ints ( vals2 ( 1 )% str ) ! winning list ihave = parse_ints ( vals2 ( 2 )% str ) ! ones you have ! count the number of ones you have in the winning set: iwin = 0 do j = 1 , size ( ihave ) iwin = iwin + count ( ihave ( j ) == iwinning ) end do n_matches ( i ) = iwin points = points + 2 ** ( iwin - 1 ) end do close ( iunit ) write ( * , * ) '4a : points : ' , points card_matrix = 0 card_matrix ( 0 ,:) = 1 ! start with one card each do i = 1 , n_lines associate ( n => n_matches ( i )) if ( n > 0 ) card_matrix ( i , i + 1 : i + n ) = sum ( card_matrix (:, i )) end associate end do write ( * , * ) '4b : scratchcards :' , sum ( card_matrix ) call clk % toc ( '4' ) end program problem_4","tags":"","loc":"sourcefile/problem_04.f90.html"},{"title":"problem_06.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_06.f90~~EfferentGraph sourcefile~problem_06.f90 problem_06.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_06.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_6 use iso_fortran_env use aoc_utilities implicit none ! just copy and paste the inputs here: ! a integer ( ip ), dimension ( * ), parameter :: time_a = [ 60 , 94 , 78 , 82 ] integer ( ip ), dimension ( * ), parameter :: distance_a = [ 475 , 2138 , 1015 , 1650 ] ! b integer ( ip ), dimension ( * ), parameter :: time_b = [ 60947882_ip ] integer ( ip ), dimension ( * ), parameter :: distance_b = [ 475213810151650_ip ] call clk % tic () print * , '6a: ways to win:' , go ( time_a , distance_a ) print * , '6b: ways to win:' , go ( time_b , distance_b ) call clk % toc ( '6' ) contains function go ( time , distance ) result ( iproduct ) integer ( ip ), dimension (:), intent ( in ) :: time integer ( ip ), dimension (:), intent ( in ) :: distance integer ( ip ) :: iproduct integer ( ip ) :: i , ihold , iways , idistance iproduct = 1 do i = 1 , size ( time ) iways = 0 do ihold = 1 , time ( i ) ! time to hold the button idistance = ihold * ( time ( i ) - ihold ) if ( idistance > distance ( i )) iways = iways + 1 end do iproduct = iproduct * iways end do end function go end program problem_6","tags":"","loc":"sourcefile/problem_06.f90.html"},{"title":"lsqr.f90 – AoC-2023","text":"This file depends on sourcefile~~lsqr.f90~~EfferentGraph sourcefile~lsqr.f90 lsqr.f90 sourcefile~lsqr_kinds.f90 lsqr_kinds.F90 sourcefile~lsqr.f90->sourcefile~lsqr_kinds.f90 sourcefile~lsqrblas.f90 lsqrblas.f90 sourcefile~lsqr.f90->sourcefile~lsqrblas.f90 sourcefile~lsqrblas.f90->sourcefile~lsqr_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~lsqr.f90~~AfferentGraph sourcefile~lsqr.f90 lsqr.f90 sourcefile~lsqrtest_ez.f90 lsqrtest_ez.f90 sourcefile~lsqrtest_ez.f90->sourcefile~lsqr.f90 sourcefile~lsqrtest_module.f90 lsqrtest_module.f90 sourcefile~lsqrtest_module.f90->sourcefile~lsqr.f90 sourcefile~nlesolver_module.f90 nlesolver_module.F90 sourcefile~nlesolver_module.f90->sourcefile~lsqr.f90 sourcefile~lsqrtest.f90 lsqrtest.f90 sourcefile~lsqrtest.f90->sourcefile~lsqrtest_module.f90 sourcefile~nlesolver_test_1.f90 nlesolver_test_1.f90 sourcefile~nlesolver_test_1.f90->sourcefile~nlesolver_module.f90 sourcefile~sparse_test.f90 sparse_test.f90 sourcefile~sparse_test.f90->sourcefile~nlesolver_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !*************************************************************************************************** !> !  Module for [[LSQR]]. ! !### History !  * Jacob Williams : 8 Nov 2019 : created module module lsqr_module use lsqr_kinds use lsqpblas_module implicit none private type , abstract , public :: lsqr_solver !! main class to access the [[lsqr]] solver. !! !! You can use this class directory by extending it !! and specifying `aprod`, or you can use the !! [[lsqr_solver_ez]] class that has an easier !! interface. private contains private procedure ( aprod_func ), deferred , public :: aprod !! User function to access the sparse matrix `A`. procedure , public :: lsqr !! main solver routine procedure , public :: acheck procedure , public :: xcheck end type lsqr_solver type , public , extends ( lsqr_solver ) :: lsqr_solver_ez !! a simplier version of [[lsqr_solver]] where !! the `aprod` function is provided internally. !! To use, first call the `initialize` method !! to set the matrix and other inputs. private integer :: m = 0 !! number of rows in `A` matrix integer :: n = 0 !! number of columns in `A` matrix integer :: num_nonzero_elements = 0 !! number of nonzero elements in `A` matrix integer , dimension (:), allocatable :: irow !! sparsity row indices integer , dimension (:), allocatable :: icol !! sparsity column indices real ( wp ), dimension (:), allocatable :: a !! sparse `A` matrix real ( wp ) :: atol = zero !! relative error in definition of `A` real ( wp ) :: btol = zero !! relative error in definition of `b` real ( wp ) :: conlim = zero !! An upper limit on `cond(Abar)`, the apparent !! condition number of the matrix `Abar`. integer :: itnlim = 100 !! max iterations integer :: nout = 0 !! output unit for printing ! used in aprod_ez: real ( wp ), dimension (:), allocatable :: Ax !! `A*x` (dimension m) real ( wp ), dimension (:), allocatable :: Aty !! `A(transpose)*y` (dimension n) real ( wp ), dimension (:), allocatable :: v !! workspace array (dimension n) real ( wp ), dimension (:), allocatable :: w !! workspace array (dimension n) contains private procedure , public :: initialize => initialize_ez !! Constructor. Must be call first. procedure , public :: solve => solve_ez procedure , public :: aprod => aprod_ez !! internal routine end type lsqr_solver_ez abstract interface subroutine aprod_func ( me , mode , m , n , x , y ) !! User function to access the sparse matrix `A`. import :: wp , lsqr_solver implicit none class ( lsqr_solver ), intent ( inout ) :: me integer , intent ( in ) :: mode !! * If `mode = 1`, compute `y = y + A*x`. !!   `y` should be altered without changing x. !! * If `mode = 2`, compute `x = x + A(transpose)*y`. !!   `x` should be altered without changing `y`. integer , intent ( in ) :: m !! number of rows in `A` matrix integer , intent ( in ) :: n !! number of columns in `A` matrix real ( wp ), dimension (:), intent ( inout ) :: x real ( wp ), dimension (:), intent ( inout ) :: y end subroutine aprod_func end interface contains !*************************************************************************************************** !******************************************************************************* !> !  Constructor for [[lsqr_solver_ez]]. subroutine initialize_ez ( me , m , n , a , irow , icol , atol , btol , conlim , itnlim , nout ) implicit none class ( lsqr_solver_ez ), intent ( out ) :: me integer , intent ( in ) :: m !! number of rows in `A` matrix integer , intent ( in ) :: n !! number of columns in `A` matrix integer , dimension (:), intent ( in ) :: irow !! row indices of nonzero elements of `A` integer , dimension (:), intent ( in ) :: icol !! column indices of nonzero elements of `A` real ( wp ), dimension (:), intent ( in ) :: a !! nonzero elements of `A` real ( wp ), intent ( in ), optional :: atol !! relative error in definition of `A` real ( wp ), intent ( in ), optional :: btol !! relative error in definition of `b` real ( wp ), intent ( in ), optional :: conlim !! An upper limit on `cond(Abar)`, the apparent !! condition number of the matrix `Abar`. integer , intent ( in ), optional :: itnlim !! max iterations integer , intent ( in ), optional :: nout !! output unit for printing ! check for consistent inputs: if ( any ( size ( a ) /= [ size ( irow ), size ( icol )])) error stop 'invalid a,icol,irow sizes in initialize_ez' if ( any ( irow > m )) error stop 'invalid irow or m in initialize_ez' if ( any ( icol > n )) error stop 'invalid icol or n in initialize_ez' me % num_nonzero_elements = size ( irow ) me % m = m me % n = n me % irow = irow me % icol = icol me % a = a ! optional inputs: if ( present ( atol )) me % atol = atol if ( present ( btol )) me % btol = btol if ( present ( conlim )) me % conlim = conlim if ( present ( itnlim )) me % itnlim = itnlim if ( present ( nout )) me % nout = nout end subroutine initialize_ez !******************************************************************************* !******************************************************************************* !> !  The internal `aprod` function for the [[lsqr_solver_ez]] class. subroutine aprod_ez ( me , mode , m , n , x , y ) implicit none class ( lsqr_solver_ez ), intent ( inout ) :: me integer , intent ( in ) :: mode !! * If `mode = 1`, compute `y = y + A*x`. !!   `y` should be altered without changing x. !! * If `mode = 2`, compute `x = x + A(transpose)*y`. !!   `x` should be altered without changing `y`. integer , intent ( in ) :: m !! number of rows in `A` matrix integer , intent ( in ) :: n !! number of columns in `A` matrix real ( wp ), dimension (:), intent ( inout ) :: x !! [n] real ( wp ), dimension (:), intent ( inout ) :: y !! [m] integer :: i !! counter integer :: r !! row index integer :: c !! column index if ( m /= me % m . or . n /= me % n ) error stop 'lsqr_solver_ez class not properly initialized' select case ( mode ) case ( 1 ) ! y = y + A*x !   A    x   Ax !  ---   -   - !  X0X   X   X !  0X0 * X = X !  00X   X   X !  00X       X ! A*x: if (. not . allocated ( me % Ax )) allocate ( me % Ax ( me % m )) me % Ax = zero do i = 1 , me % num_nonzero_elements r = me % irow ( i ) c = me % icol ( i ) me % Ax ( r ) = me % Ax ( r ) + me % a ( i ) * x ( c ) end do y = y + me % Ax case ( 2 ) ! x = x + A(transpose)*y !   A     Y   ATy !  ---    -   - !  X000   Y   X !  0X00 * Y = X !  X0XX   Y   X !         Y ! A(transpose)*y if (. not . allocated ( me % Aty )) allocate ( me % Aty ( me % n )) me % Aty = zero do i = 1 , me % num_nonzero_elements r = me % irow ( i ) c = me % icol ( i ) me % Aty ( c ) = me % Aty ( c ) + me % a ( i ) * y ( r ) end do x = x + me % Aty case default error stop 'invalid mode in aprod_ez' end select end subroutine aprod_ez !*************************************************************************************************** !*************************************************************************************************** !> !  Wrapper for [[lsqr]] for the easy version of the class. subroutine solve_ez ( me , b , damp , x , istop , & se , itn , anorm , acond , rnorm , arnorm , xnorm ) implicit none class ( lsqr_solver_ez ), intent ( inout ) :: me real ( wp ), dimension ( me % m ), intent ( in ) :: b real ( wp ), intent ( in ) :: damp real ( wp ), dimension ( me % n ), intent ( out ) :: x !! the computed solution `x`. integer , intent ( out ) :: istop !! exit code (see [[lsqr]]). real ( wp ), dimension ( me % n ), intent ( out ), optional :: se integer , intent ( out ) , optional :: itn real ( wp ), intent ( out ), optional :: anorm real ( wp ), intent ( out ), optional :: acond real ( wp ), intent ( out ), optional :: rnorm real ( wp ), intent ( out ), optional :: arnorm real ( wp ), intent ( out ), optional :: xnorm real ( wp ), dimension (:), allocatable :: u !! copy of `b` for call to [[lsqr]] real ( wp ), dimension (:), allocatable :: se_ logical :: wantse !! if `se` is to be returned integer :: itn_ real ( wp ) :: anorm_ , acond_ , rnorm_ , arnorm_ , xnorm_ ! get optional inputs: wantse = present ( se ) if ( wantse ) then allocate ( se_ ( me % n )) else allocate ( se_ ( 1 )) ! not needed end if allocate ( u ( me % m )) if (. not . allocated ( me % v )) allocate ( me % v ( me % n )) if (. not . allocated ( me % w )) allocate ( me % w ( me % n )) u = b ! make a copy for input to lsqr (since it will be overwritten) ! main routine: call me % lsqr ( me % m , me % n , damp , wantse , & u , me % v , me % w , x , se_ , & me % atol , me % btol , me % conlim , me % itnlim , me % nout , & istop , itn_ , anorm_ , acond_ , rnorm_ , arnorm_ , xnorm_ ) ! optional outputs: if ( wantse ) se = se_ if ( present ( itn )) itn = itn_ if ( present ( anorm )) anorm = anorm_ if ( present ( acond )) acond = acond_ if ( present ( rnorm )) rnorm = rnorm_ if ( present ( arnorm )) arnorm = arnorm_ if ( present ( xnorm )) xnorm = xnorm_ end subroutine solve_ez !*************************************************************************************************** !*************************************************************************************************** !> !  LSQR finds a solution x to the following problems: ! !  1. Unsymmetric equations -- solve:   \\mathbf{A} \\cdot \\mathbf{x} = \\mathbf{b}  !  2. Linear least squares  -- solve (in the least-squares sense):   \\mathbf{A} \\cdot \\mathbf{x} = \\mathbf{b}  !  3. Damped least squares  -- solve (in the least-squares sense):  \\left[ \\begin{array}{c} \\mathbf{A}\\\\ damp \\cdot \\mathbf{I} \\end{array} \\right] \\cdot \\mathbf{x} = \\left[ \\begin{array}{c} \\mathbf{b}\\\\ \\mathbf{0} \\end{array} \\right]  ! !  where A is a matrix with m rows and n columns, b is an !  m-vector, and `damp` is a scalar.  (All quantities are real.) !  The matrix A is intended to be large and sparse.  It is accessed !  by means of subroutine calls to `aprod`. ! !  The rhs vector b is input via u, and subsequently overwritten. ! !  Note:  LSQR uses an iterative method to approximate the solution. !  The number of iterations required to reach a certain accuracy !  depends strongly on the scaling of the problem.  Poor scaling of !  the rows or columns of A should therefore be avoided where !  possible. ! !  For example, in problem 1 the solution is unaltered by !  row-scaling.  If a row of A is very small or large compared to !  the other rows of A, the corresponding row of ( A  b ) should be !  scaled up or down. ! !  In problems 1 and 2, the solution x is easily recovered !  following column-scaling.  Unless better information is known, !  the nonzero columns of A should be scaled so that they all have !  the same Euclidean norm (e.g., 1.0). ! !  In problem 3, there is no freedom to re-scale if damp is !  nonzero.  However, the value of damp should be assigned only !  after attention has been paid to the scaling of A. ! !  The parameter damp is intended to help regularize !  ill-conditioned systems, by preventing the true solution from !  being very large.  Another aid to regularization is provided by !  the parameter acond, which may be used to terminate iterations !  before the computed solution becomes very large. ! !  Note that x is not an input parameter. !  If some initial estimate x0 is known and if damp = 0, !  one could proceed as follows: ! !  1. Compute a residual vector      r_0 = b - A \\cdot x_0 . !  2. Use LSQR to solve the system   A \\cdot \\Delta x = r_0 . !  3. Add the correction dx to obtain a final solution  x = x_0 + \\Delta x . ! !  This requires that x0 be available before and after the call !  to LSQR.  To judge the benefits, suppose LSQR takes k1 iterations !  to solve A*x = b and k2 iterations to solve A*dx = r0. !  If x0 is \"good\", norm(r0) will be smaller than norm(b). !  If the same stopping tolerances atol and btol are used for each !  system, k1 and k2 will be similar, but the final solution x0 + dx !  should be more accurate.  The only way to reduce the total work !  is to use a larger stopping tolerance for the second system. !  If some value btol is suitable for A*x = b, the larger value !  btol*norm(b)/norm(r0)  should be suitable for A*dx = r0. ! !  Preconditioning is another way to reduce the number of iterations. !  If it is possible to solve a related system M*x = b efficiently, !  where M approximates A in some helpful way !  (e.g. M - A has low rank or its elements are small relative to !  those of A), LSQR may converge more rapidly on the system !        A*M(inverse)*z = b, !  after which x can be recovered by solving M*x = z. ! !  NOTE: If A is symmetric, LSQR should not be used! !  Alternatives are the symmetric conjugate-gradient method (cg) !  and/or SYMMLQ. !  SYMMLQ is an implementation of symmetric cg that applies to !  any symmetric A and will converge more rapidly than LSQR. !  If A is positive definite, there are other implementations of !  symmetric cg that require slightly less work per iteration !  than SYMMLQ (but will take the same number of iterations). ! !### Notation ! ! The following quantities are used in discussing the subroutine ! parameters: ! !``` !     Abar   =  (   A    ),         bbar  =  ( b ) !               ( damp*I )                   ( 0 ) ! !     r      = b  -  A*x,           rbar  = bbar  -  Abar*x ! !     rnorm  = sqrt( norm(r)**2  +  damp**2 * norm(x)**2 ) !            = norm( rbar ) ! !     relpr  = the relative precision of floating-point arithmetic !              on the machine being used.  On most machines, !              relpr is about 1.0e-7 and 1.0d-16 in single and double !              precision respectively. !``` ! ! LSQR  minimizes the function `rnorm` with respect to `x`. ! !### References ! !  * C.C. Paige and M.A. Saunders,  LSQR: An algorithm for sparse !    linear equations and sparse least squares, !    ACM Transactions on Mathematical Software 8, 1 (March 1982), !    pp. 43-71. ! !  * C.C. Paige and M.A. Saunders,  Algorithm 583, LSQR: Sparse !    linear equations and least-squares problems, !    ACM Transactions on Mathematical Software 8, 2 (June 1982), !    pp. 195-209. ! !  * C.L. Lawson, R.J. Hanson, D.R. Kincaid and F.T. Krogh, !    Basic linear algebra subprograms for Fortran usage, !    ACM Transactions on Mathematical Software 5, 3 (Sept 1979), !    pp. 308-323 and 324-325. ! !### LSQR development ! !  * 22 Feb 1982: LSQR sent to ACM TOMS to become Algorithm 583. !  * 15 Sep 1985: Final F66 version.  LSQR sent to \"misc\" in netlib. !  * 13 Oct 1987: Bug (Robert Davies, DSIR).  Have to delete !                     if ( (one + dabs(t)) <= one ) GO TO 200 !                  from loop 200.  The test was an attempt to reduce !                  underflows, but caused w(i) not to be updated. !  * 17 Mar 1989: First F77 version. !  * 04 May 1989: Bug (David Gay, AT&T).  When the second beta is zero, !                  rnorm = 0 and !                  test2 = arnorm / (anorm * rnorm) overflows. !                  Fixed by testing for rnorm = 0. !  * 05 May 1989: Sent to \"misc\" in netlib. !  * 14 Mar 1990: Bug (John Tomlin via IBM OSL testing). !                  Setting rhbar2 = rhobar**2 + dampsq can give zero !                  if rhobar underflows and damp = 0. !                  Fixed by testing for damp = 0 specially. !  * 15 Mar 1990: Converted to lower case. !  * 21 Mar 1990: d2norm introduced to avoid overflow in numerous !                  items like  c = sqrt( a**2 + b**2 ). !  * 04 Sep 1991: wantse added as an argument to LSQR, to make !                  standard errors optional.  This saves storage and !                  time when se(*) is not wanted. !  * 13 Feb 1992: istop now returns a value in [1,5], not [1,7]. !                  1, 2 or 3 means that x solves one of the problems !                  Ax = b,  min norm(Ax - b)  or  damped least squares. !                  4 means the limit on cond(A) was reached. !                  5 means the limit on iterations was reached. !  * 07 Dec 1994: Keep track of dxmax = max_k norm( phi_k * d_k ). !                  So far, this is just printed at the end. !                  A large value (relative to norm(x)) indicates !                  significant cancellation in forming !                  x  = D*f  = sum( phi_k * d_k ). !                  A large column of D need NOT be serious if the !                  corresponding phi_k is small. !  * 27 Dec 1994: Include estimate of alfa_opt in iteration log. !                  alfa_opt is the optimal scale factor for the !                  residual in the \"augmented system\", as described by !                  A. Bjorck (1992), !                  Pivoting and stability in the augmented system method, !                  in D. F. Griffiths and G. A. Watson (eds.), !                  \"Numerical Analysis 1991\", !                  Proceedings of the 14th Dundee Conference, !                  Pitman Research Notes in Mathematics 260, !                  Longman Scientific and Technical, Harlow, Essex, 1992. !  * 12 Nov 2019 : Jacob Williams : significant refactoring into modern Fortran. ! !### Author ! * Michael A. Saunders, Dept of Operations Research, Stanford University ! !@note The number of iterations required by LSQR will usually decrease !      if the computation is performed in higher precision. subroutine LSQR ( me , m , n , damp , wantse , & u , v , w , x , se , & atol , btol , conlim , itnlim , nout , & istop , itn , anorm , acond , rnorm , arnorm , xnorm ) class ( lsqr_solver ), intent ( inout ) :: me integer , intent ( in ) :: m !! the number of rows in `A`. integer , intent ( in ) :: n !! the number of columns in `A`. real ( wp ), intent ( in ) :: damp !! The damping parameter for problem 3 above. !! (damp should be 0.0 for problems 1 and 2.) !! If the system `A*x = b` is incompatible, values !! of `damp` in the range 0 to `sqrt(relpr)*norm(A)` !! will probably have a negligible effect. !! Larger values of `damp` will tend to decrease !! the norm of `x` and reduce the number of !! iterations required by LSQR. !! !! The work per iteration and the storage needed !! by LSQR are the same for all values of `damp`. logical , intent ( in ) :: wantse !! A logical variable to say if the array `se(*)` !! of standard error estimates should be computed. !! If `m > n`  or  `damp > 0`,  the system is !! overdetermined and the standard errors may be !! useful.  (See the first LSQR reference.) !! Otherwise (`m <= n`  and  `damp = 0`) they do not !! mean much.  Some time and storage can be saved !! by setting `wantse = .false.` and using any !! convenient array for `se(*)`, which won't be !! touched. real ( wp ), intent ( inout ) :: u ( m ) !! The rhs vector `b`.  Beware that `u` is !! over-written by LSQR. real ( wp ), intent ( inout ) :: v ( n ) !! workspace real ( wp ), intent ( inout ) :: w ( n ) !! workspace real ( wp ), intent ( out ) :: x ( n ) !! Returns the computed solution `x`. real ( wp ), dimension ( * ), intent ( out ) :: se !! If `wantse` is true, the dimension of `se` must be !! `n` or more. `se(*)` then returns standard error !! estimates for the components of `x`. !! For each `i`, `se(i)` is set to the value !! `rnorm * sqrt( sigma(i,i) / t )`, !! where `sigma(i,i)` is an estimate of the i-th !! diagonal of the inverse of `Abar(transpose)*Abar` !! and: !! * `t = 1      if  m <= n` !! * `t = m - n  if  m > n  and  damp = 0` !! * `t = m      if  damp /= 0` !! !! If `wantse` is false, `se(*)` will not be touched. !! The actual parameter can be any suitable array !! of any length. real ( wp ), intent ( in ) :: atol !! An estimate of the relative error in the data !! defining the matrix `A`.  For example, !! if `A` is accurate to about 6 digits, set !! `atol = 1.0e-6`. real ( wp ), intent ( in ) :: btol !! An estimate of the relative error in the data !! defining the rhs vector `b`.  For example, !! if `b` is accurate to about 6 digits, set !! `btol = 1.0e-6`. real ( wp ), intent ( in ) :: conlim !! An upper limit on `cond(Abar)`, the apparent !! condition number of the matrix `Abar`. !! Iterations will be terminated if a computed !! estimate of `cond(Abar)` exceeds `conlim`. !! This is intended to prevent certain small or !! zero singular values of `A` or `Abar` from !! coming into effect and causing unwanted growth !! in the computed solution. !! !! `conlim` and `damp` may be used separately or !! together to regularize ill-conditioned systems. !! !! Normally, `conlim` should be in the range !! 1000 to `1/relpr`. !! !! Suggested value: !! !! * `conlim = 1/(100*relpr)` for compatible systems, !! * `conlim = 1/(10*sqrt(relpr))` for least squares. !! !! Note:  If the user is not concerned about the parameters !! `atol`, `btol` and `conlim`, any or all of them may be set !! to zero.  The effect will be the same as the values !! `relpr`, `relpr` and `1/relpr` respectively. integer , intent ( in ) :: itnlim !! An upper limit on the number of iterations. !! Suggested value: !! * `itnlim = n/2` for well-conditioned systems !!   with clustered singular values, !! * `itnlim = 4*n` otherwise. integer , intent ( in ) :: nout !! File number for printed output.  If nonzero, !! a summary will be printed on file `nout`. integer , intent ( out ) :: istop !! An integer giving the reason for termination: !! !! * 0 -- `x` = 0  is the exact solution. !!   No iterations were performed. !! * 1 -- The equations `A*x = b` are probably !!   compatible.  `Norm(A*x - b)` is sufficiently !!   small, given the values of `atol` and `btol`. !! * 2 -- `damp` is zero.  The system `A*x = b` is probably !!   not compatible.  A least-squares solution has !!   been obtained that is sufficiently accurate, !!   given the value of `atol`. !! * 3 -- `damp` is nonzero.  A damped least-squares !!   solution has been obtained that is sufficiently !!   accurate, given the value of `atol`. !! * 4 -- An estimate of `cond(Abar)` has exceeded !!   `conlim`.  The system `A*x = b` appears to be !!   ill-conditioned.  Otherwise, there could be an !!   error in subroutine `aprod`. !! * 5 -- The iteration limit `itnlim` was reached. integer , intent ( out ) :: itn !! The number of iterations performed. real ( wp ), intent ( out ) :: anorm !! An estimate of the Frobenius norm of `Abar`. !! This is the square-root of the sum of squares !! of the elements of `Abar`. !! If `damp` is small and if the columns of `A` !! have all been scaled to have length 1.0, !! `anorm` should increase to roughly `sqrt(n)`. !! A radically different value for `anorm` may !! indicate an error in subroutine `aprod` (there !! may be an inconsistency between modes 1 and 2). real ( wp ), intent ( out ) :: acond !! An estimate of `cond(Abar)`, the condition !! number of `Abar`.  A very high value of `acond` !! may again indicate an error in `aprod`. real ( wp ), intent ( out ) :: rnorm !! An estimate of the final value of `norm(rbar)`, !! the function being minimized (see notation !! above).  This will be small if `A*x = b` has !! a solution. real ( wp ), intent ( out ) :: arnorm !! An estimate of the final value of !! `norm( Abar(transpose)*rbar )`, the norm of !! the residual for the usual normal equations. !! This should be small in all cases.  (arnorm !! will often be smaller than the true value !! computed from the output vector `x`.) real ( wp ), intent ( out ) :: xnorm !! An estimate of the norm of the final !! solution vector `x`. logical :: damped integer :: i , maxdx , nconv , nstop real ( wp ) :: alfopt , alpha , beta , bnorm , & cs , cs1 , cs2 , ctol , & delta , dknorm , dnorm , dxk , dxmax , & gamma , gambar , phi , phibar , psi , & res2 , rho , rhobar , rhbar1 , & rhs , rtol , sn , sn1 , sn2 , & t , tau , temp , test1 , test2 , test3 , & theta , t1 , t2 , t3 , xnorm1 , z , zbar logical :: print_iter logical , parameter :: extra = . true . !! for extra printing below. character ( len =* ), parameter :: enter = ' Enter LSQR.  ' character ( len =* ), parameter :: exit = ' Exit  LSQR.  ' character ( len =* ), dimension ( 0 : 5 ), parameter :: msg = [ 'The exact solution is x = 0                          ' ,& 'A solution to Ax = b was found, given atol, btol     ' ,& 'A least-squares solution was found, given atol       ' ,& 'A damped least-squares solution was found, given atol' ,& 'Cond(Abar) seems to be too large, given conlim       ' ,& 'The iteration limit was reached                      ' ] ! Initialize. if ( nout /= 0 ) then write ( nout , '(//A)' ) enter // '     Least-squares solution of  Ax = b' write ( nout , '(A,I7,A,I7,A)' ) ' The matrix  A  has' , m , ' rows   and' , n , ' columns' write ( nout , '(1P,A,E22.14,3X,A,L10)' ) ' damp   =' , damp , 'wantse =' , wantse write ( nout , '(1P,A,E10.2,15x,A,E10.2)' ) ' atol   =' , atol , 'conlim =' , conlim write ( nout , '(1P,A,E10.2,15x,A,I10)' ) ' btol   =' , btol , 'itnlim =' , itnlim end if damped = damp > zero itn = 0 istop = 0 nstop = 0 maxdx = 0 if ( conlim > zero ) then ctol = one / conlim else ctol = zero end if anorm = zero acond = zero dnorm = zero dxmax = zero res2 = zero psi = zero xnorm = zero xnorm1 = zero cs2 = - one sn2 = zero z = zero ! Set up the first vectors u and v for the bidiagonalization. ! These satisfy  beta*u = b,  alpha*v = A(transpose)*u. do i = 1 , n v ( i ) = zero x ( i ) = zero end do if ( wantse ) then do i = 1 , n se ( i ) = zero end do end if alpha = zero beta = dnrm2 ( m , u , 1 ) if ( beta > zero ) then call dscal ( m , ( one / beta ), u , 1 ) call me % aprod ( 2 , m , n , v , u ) alpha = dnrm2 ( n , v , 1 ) end if if ( alpha > zero ) then call dscal ( n , ( one / alpha ), v , 1 ) call dcopy ( n , v , 1 , w , 1 ) end if arnorm = alpha * beta if ( arnorm /= zero ) then rhobar = alpha phibar = beta bnorm = beta rnorm = beta if ( nout /= 0 ) then if ( damped ) then write ( nout , '(//A)' ) & '   Itn       x(1)           Function     Compatible   LS     Norm Abar Cond Abar' else write ( nout , '(//A)' ) & '   Itn       x(1)           Function     Compatible   LS        Norm A    Cond A' end if test1 = one test2 = alpha / beta if ( extra ) then write ( nout , '(80X,A)' ) '    phi    dknorm   dxk  alfa_opt' end if write ( nout , '(1P, I6, 2E17.9, 4E10.2, E9.1, 3E8.1)' ) itn , x ( 1 ), rnorm , test1 , test2 write ( nout , '(A)' ) '' end if do ! Main iteration loop. itn = itn + 1 ! Perform the next step of the bidiagonalization to obtain the ! next  beta, u, alpha, v.  These satisfy the relations ! beta*u  = A*v  -  alpha*u, ! alpha*v  = A(transpose)*u  -  beta*v. call dscal ( m , ( - alpha ), u , 1 ) call me % aprod ( 1 , m , n , v , u ) beta = dnrm2 ( m , u , 1 ) ! Accumulate  anorm = || Bk || = sqrt( sum of  alpha**2 + beta**2 + damp**2 ). temp = d2norm ( alpha , beta ) temp = d2norm ( temp , damp ) anorm = d2norm ( anorm , temp ) if ( beta > zero ) then call dscal ( m , ( one / beta ), u , 1 ) call dscal ( n , ( - beta ), v , 1 ) call me % aprod ( 2 , m , n , v , u ) alpha = dnrm2 ( n , v , 1 ) if ( alpha > zero ) then call dscal ( n , ( one / alpha ), v , 1 ) end if end if ! Use a plane rotation to eliminate the damping parameter. ! This alters the diagonal (rhobar) of the lower-bidiagonal matrix. rhbar1 = rhobar if ( damped ) then rhbar1 = d2norm ( rhobar , damp ) cs1 = rhobar / rhbar1 sn1 = damp / rhbar1 psi = sn1 * phibar phibar = cs1 * phibar end if ! Use a plane rotation to eliminate the subdiagonal element (beta) ! of the lower-bidiagonal matrix, giving an upper-bidiagonal matrix. rho = d2norm ( rhbar1 , beta ) cs = rhbar1 / rho sn = beta / rho theta = sn * alpha rhobar = - cs * alpha phi = cs * phibar phibar = sn * phibar tau = sn * phi ! Update  x, w  and (perhaps) the standard error estimates. t1 = phi / rho t2 = - theta / rho t3 = one / rho dknorm = zero if ( wantse ) then do i = 1 , n t = w ( i ) x ( i ) = t1 * t + x ( i ) w ( i ) = t2 * t + v ( i ) t = ( t3 * t ) ** 2 se ( i ) = t + se ( i ) dknorm = t + dknorm end do else do i = 1 , n t = w ( i ) x ( i ) = t1 * t + x ( i ) w ( i ) = t2 * t + v ( i ) dknorm = ( t3 * t ) ** 2 + dknorm end do end if ! Monitor the norm of d_k, the update to x. ! dknorm = norm( d_k ) ! dnorm  = norm( D_k ),        where   D_k = (d_1, d_2, ..., d_k ) ! dxk    = norm( phi_k d_k ),  where new x = x_k + phi_k d_k. dknorm = sqrt ( dknorm ) dnorm = d2norm ( dnorm , dknorm ) dxk = abs ( phi * dknorm ) if ( dxmax < dxk ) then dxmax = dxk maxdx = itn end if ! Use a plane rotation on the right to eliminate the ! super-diagonal element (theta) of the upper-bidiagonal matrix. ! Then use the result to estimate  norm(x). delta = sn2 * rho gambar = - cs2 * rho rhs = phi - delta * z zbar = rhs / gambar xnorm = d2norm ( xnorm1 , zbar ) gamma = d2norm ( gambar , theta ) cs2 = gambar / gamma sn2 = theta / gamma z = rhs / gamma xnorm1 = d2norm ( xnorm1 , z ) ! Test for convergence. ! First, estimate the norm and condition of the matrix  Abar, ! and the norms of  rbar  and  Abar(transpose)*rbar. acond = anorm * dnorm res2 = d2norm ( res2 , psi ) rnorm = d2norm ( res2 , phibar ) arnorm = alpha * abs ( tau ) ! Now use these norms to estimate certain other quantities, ! some of which will be small near a solution. alfopt = sqrt ( rnorm / ( dnorm * xnorm ) ) test1 = rnorm / bnorm test2 = zero if ( rnorm > zero ) test2 = arnorm / ( anorm * rnorm ) test3 = one / acond t1 = test1 / ( one + anorm * xnorm / bnorm ) rtol = btol + atol * anorm * xnorm / bnorm ! The following tests guard against extremely small values of ! atol, btol  or  ctol.  (The user may have set any or all of ! the parameters  atol, btol, conlim  to zero.) ! The effect is equivalent to the normal tests using ! atol = relpr,  btol = relpr,  conlim = 1/relpr. t3 = one + test3 t2 = one + test2 t1 = one + t1 if ( itn >= itnlim ) istop = 5 if ( t3 <= one ) istop = 4 if ( t2 <= one ) istop = 2 if ( t1 <= one ) istop = 1 ! Allow for tolerances set by the user. if ( test3 <= ctol ) istop = 4 if ( test2 <= atol ) istop = 2 if ( test1 <= rtol ) istop = 1 ! See if it is time to print something. if ( nout /= 0 ) then print_iter = ( n <= 40 ) . or . & ( itn <= 10 ) . or . & ( itn >= itnlim - 10 ) . or . & ( mod ( itn , 10 ) == 0 ) . or . & ( test3 <= 2.0 * ctol ) . or . & ( test2 <= 1 0.0 * atol ) . or . & ( test1 <= 1 0.0 * rtol ) . or . & ( istop /= 0 ) if ( print_iter ) then ! Print a line for this iteration. ! \"extra\" is for experimental purposes. if ( extra ) then write ( nout , '(1P, I6, 2E17.9, 4E10.2, E9.1, 3E8.1)' ) & itn , x ( 1 ), rnorm , test1 , test2 , anorm , acond , phi , dknorm , dxk , alfopt else write ( nout , '(1P, I6, 2E17.9, 4E10.2, E9.1, 3E8.1)' ) & itn , x ( 1 ), rnorm , test1 , test2 , anorm , acond end if !if (mod(itn,10) == 0) write(nout, '(A)') '' end if end if ! Stop if appropriate. ! The convergence criteria are required to be met on nconv ! consecutive iterations, where nconv is set below. ! Suggested value:  nconv = 1, 2 or 3. if ( istop == 0 ) then nstop = 0 else nconv = 1 nstop = nstop + 1 if ( nstop < nconv . and . itn < itnlim ) istop = 0 end if if ( istop /= 0 ) exit end do ! End of iteration loop. ! Finish off the standard error estimates. if ( wantse ) then t = one if ( m > n ) t = m - n if ( damped ) t = m t = rnorm / sqrt ( t ) do i = 1 , n se ( i ) = t * sqrt ( se ( i ) ) end do end if end if ! Decide if istop = 2 or 3. ! Print the stopping condition. if ( damped . and . istop == 2 ) istop = 3 if ( nout /= 0 ) then write ( nout , '(//A,5X,A,I2,15X,A,I8)' ) exit , 'istop  =' , istop , 'itn    =' , itn write ( nout , '(1P,A,5X,A,E12.5,5X,A,E12.5)' ) exit , 'anorm  =' , anorm , 'acond  =' , acond write ( nout , '(1P,A,5X,A,E12.5,5X,A,E12.5)' ) exit , 'bnorm  =' , bnorm , 'xnorm  =' , xnorm write ( nout , '(1P,A,5X,A,E12.5,5X,A,E12.5)' ) exit , 'rnorm  =' , rnorm , 'arnorm =' , arnorm write ( nout , '(1P,A,5X,A,E8.1,A,I8)' ) exit , 'max dx =' , dxmax , ' occurred at itn ' , maxdx write ( nout , '(1P,A,5X,A,E8.1,A)' ) exit , '       =' , dxmax / ( xnorm + 1.0e-20_wp ), '*xnorm' write ( nout , '(A,5X,A)' ) exit , msg ( istop ) end if end subroutine LSQR !*************************************************************************************************** !*************************************************************************************************** !> !  Checks the two modes of aprod for [[lsqr]]. ! !  acheck may be called to test the user-written subroutine !  aprod required by LSQR and CRAIG.  For some m x n matrix A, !  aprod with mode = 1 and 2 supplies LSQR and CRAIG with products !  of the form !     y := y + Ax  and  x := x + A'y !  respectively, where A' means A(transpose). !  acheck tries to verify that A and A' refer to the same matrix. ! !### Method !  We cook up some \"unlikely\" vectors x and y of unit length !  and test if  y'(y + Ax)  =  x'(x + A'y). ! !### History ! * 04 Sep 1991  Initial design and code. !   Michael Saunders, Dept of Operations Research, !   Stanford University ! * 10 Feb 1992  aprod and eps added as parameters. !   tol defined via power. subroutine acheck ( me , m , n , nout , eps , & v , w , x , y , inform ) implicit none class ( lsqr_solver ), intent ( inout ) :: me integer , intent ( in ) :: m !! No. of rows of A. integer , intent ( in ) :: n !! No. of columns of A. integer , intent ( in ) :: nout !! A file number for printed output. integer , intent ( out ) :: inform !! Error indicator. !! inform = 0 if aprod seems to be !! consistent. !! inform = 1 otherwise. real ( wp ), intent ( in ) :: eps !! The machine precision. real ( wp ) :: v ( n ) real ( wp ) :: w ( m ) real ( wp ) :: x ( n ) real ( wp ) :: y ( m ) real ( wp ), parameter :: power = 0.5_wp !! eps**power is used as the tolerance for judging !! whether `y'(y + Ax)  =  x'(x + A'y)` !! to sufficient accuracy. !! power should be in the range (0.25, 0.9) say. !! For example, power = 0.75 means that we are happy !! if three quarters of the available digits agree. !! power = 0.5 seems a reasonable requirement !! (asking for half the digits to agree). integer :: i , j real ( wp ) :: alfa , beta , t , test1 , test2 , test3 , tol tol = eps ** power if ( nout /= 0 ) write ( nout , '(//A)' ) & 'Enter acheck. Test of aprod for LSQR and CRAIG' ! ================================================================== ! Cook up some \"unlikely\" vectors x and y of unit length. ! ================================================================== t = one do j = 1 , n t = t + one x ( j ) = sqrt ( t ) end do t = one do i = 1 , m t = t + one y ( i ) = one / sqrt ( t ) end do alfa = dnrm2 ( n , x , 1 ) beta = dnrm2 ( m , y , 1 ) call dscal ( n , ( one / alfa ), x , 1 ) call dscal ( m , ( one / beta ), y , 1 ) ! ================================================================== ! Test if y'(y + Ax) = x'(x + A'y). ! ================================================================== ! First set w = y + Ax, v = x + A'y. call dcopy ( m , y , 1 , w , 1 ) call dcopy ( n , x , 1 , v , 1 ) call me % aprod ( 1 , m , n , x , w ) call me % aprod ( 2 , m , n , v , y ) ! Now set alfa = y'w, beta = x'v. alfa = ddot ( m , y , 1 , w , 1 ) beta = ddot ( n , x , 1 , v , 1 ) test1 = abs ( alfa - beta ) test2 = one + abs ( alfa ) + abs ( beta ) test3 = test1 / test2 ! See if alfa and beta are essentially the same. if ( test3 <= tol ) then inform = 0 if ( nout /= 0 ) write ( nout , '(1P,A,1X,E10.1)' ) & 'aprod seems OK. Relative error =' , test3 else inform = 1 if ( nout /= 0 ) write ( nout , '(1P,A,1X,E10.1)' ) & 'aprod seems incorrect. Relative error =' , test3 end if end subroutine acheck !*************************************************************************************************** !*************************************************************************************************** !> !  Tests if `x` solves a certain least-squares problem. ! !  xcheck computes residuals and norms associated with the !  vector x and the least-squares problem solved by LSQR or CRAIG. !  It determines whether x seems to be a solution to any of three !  possible systems: ! !  1.  Ax = b !  2.  min norm(Ax - b) !  3.  min norm(Ax - b)&#94;2 + damp&#94;2 * norm(x)&#94;2 ! !### History ! * 07 Feb 1992  Initial design and code. !   Michael Saunders, Dept of Operations Research, !   Stanford University. subroutine xcheck ( me , m , n , nout , anorm , damp , eps , & b , u , v , w , x , & inform , test1 , test2 , test3 ) implicit none class ( lsqr_solver ), intent ( inout ) :: me integer , intent ( in ) :: m !! The number of rows in A. integer , intent ( in ) :: n !! The number of columns in A. integer , intent ( in ) :: nout !! A file number for printed output. !! If nout = 0, nothing is printed. integer , intent ( out ) :: inform !! inform = 0 if b = 0 and x = 0. !! inform = 1, 2 or 3 if x seems to !! solve systems 1 2 or 3 above. real ( wp ), intent ( in ) :: anorm !! An estimate of norm(A) or !! norm( A, delta*I ) if delta > 0. !! Normally this will be available !! from LSQR or CRAIG. real ( wp ), intent ( in ) :: damp !! Possibly defines a damped problem. real ( wp ), intent ( in ) :: eps !! Machine precision. real ( wp ), intent ( out ) :: test1 !! These are dimensionless quantities !! that should be \"small\" if x does !! seem to solve one of the systems. !! \"small\" means less than !! tol = eps**power, where power is !! defined as a parameter below. real ( wp ), intent ( out ) :: test2 !! These are dimensionless quantities !! that should be \"small\" if x does !! seem to solve one of the systems. !! \"small\" means less than !! tol = eps**power, where power is !! defined as a parameter below. real ( wp ), intent ( out ) :: test3 !! These are dimensionless quantities !! that should be \"small\" if x does !! seem to solve one of the systems. !! \"small\" means less than !! tol = eps**power, where power is !! defined as a parameter below. real ( wp ), intent ( in ) :: b ( m ) !! The right-hand side of Ax = b etc. real ( wp ), intent ( out ) :: u ( m ) !! On exit, u = r (where r = b - Ax). real ( wp ), intent ( out ) :: v ( n ) !! On exit, v = A'r. real ( wp ), intent ( out ) :: w ( n ) !! On exit, w = A'r - damp&#94;2 x. real ( wp ), intent ( in ) :: x ( n ) !! The given estimate of a solution. real ( wp ), parameter :: power = 0.5_wp integer :: j real ( wp ) :: bnorm , dampsq , rho1 , rho2 , sigma1 , sigma2 , & tol , snorm , xnorm , xsnorm real ( wp ), dimension ( n ) :: xtmp dampsq = damp ** 2 tol = eps ** power xtmp = x ! Compute u = b - Ax via u = -b + Ax, u = -u. ! This is usual residual vector r. call dcopy ( m , b , 1 , u , 1 ) call dscal ( m , ( - one ), u , 1 ) call me % aprod ( 1 , m , n , xtmp , u ) call dscal ( m , ( - one ), u , 1 ) ! Compute v = A'u via v = 0, v = v + A'u. do j = 1 , n v ( j ) = zero end do call me % aprod ( 2 , m , n , v , u ) ! Compute w = A'u - damp**2 * x. ! This will be close to zero in all cases ! if x is close to a solution. call dcopy ( n , v , 1 , w , 1 ) if ( damp /= zero ) then do j = 1 , n w ( j ) = w ( j ) - dampsq * x ( j ) end do end if ! Compute the norms associated with b, x, u, v, w. bnorm = dnrm2 ( m , b , 1 ) xnorm = dnrm2 ( n , x , 1 ) rho1 = dnrm2 ( m , u , 1 ) sigma1 = dnrm2 ( n , v , 1 ) if ( nout /= 0 ) then write ( nout , '(//A)' ) 'Enter xcheck. Does x solve Ax = b, etc?' write ( nout , '(1P,A,E10.3)' ) ' damp            =' , damp write ( nout , '(1P,A,E10.3)' ) ' norm(x)         =' , xnorm write ( nout , '(1P,A,E15.8,A)' ) ' norm(r)         =' , rho1 , ' = rho1' write ( nout , '(1P,A,E10.3,5X,A)' ) ' norm(A''r)       =' , sigma1 , ' = sigma1' end if if ( damp == zero ) then rho2 = rho1 sigma2 = sigma1 else rho2 = sqrt ( rho1 ** 2 + dampsq * xnorm ** 2 ) sigma2 = dnrm2 ( n , w , 1 ) snorm = rho1 / damp xsnorm = rho2 / damp if ( nout /= 0 ) then write ( nout , '(1P/A,E10.3)' ) ' norm(s)         =' , snorm write ( nout , '(1P,A,E10.3)' ) ' norm(x,s)       =' , xsnorm write ( nout , '(1P,A,E15.8,A)' ) ' norm(rbar)      =' , rho2 , ' = rho2' write ( nout , '(1P,A,E10.3,5X,A)' ) ' norm(Abar''rbar) =' , sigma2 , ' = sigma2' end if end if ! See if x seems to solve Ax = b or min norm(Ax - b) ! or the damped least-squares system. if ( bnorm == zero . and . xnorm == zero ) then inform = 0 test1 = zero test2 = zero test3 = zero else inform = 4 test1 = rho1 / ( bnorm + anorm * xnorm ) test2 = zero if ( rho1 > zero ) test2 = sigma1 / ( anorm * rho1 ) test3 = test2 if ( rho2 > zero ) test3 = sigma2 / ( anorm * rho2 ) if ( test3 <= tol ) inform = 3 if ( test2 <= tol ) inform = 2 if ( test1 <= tol ) inform = 1 end if if ( nout /= 0 ) then write ( nout , '(/A,I2)' ) ' inform          =' , inform write ( nout , '(1P,A,E10.3)' ) ' tol             =' , tol write ( nout , '(1P,A,E10.3,A)' ) ' test1           =' , test1 , ' (Ax = b)' write ( nout , '(1P,A,E10.3,A)' ) ' test2           =' , test2 , ' (least-squares)' write ( nout , '(1P,A,E10.3,A)' ) ' test3           =' , test3 , ' (damped least-squares)' end if end subroutine xcheck !*************************************************************************************************** !*************************************************************************************************** !> !  Returns  \\sqrt{ a&#94;2 + b&#94;2 }  with precautions to avoid overflow. ! !### History ! * 21 Mar 1990: First version. pure function d2norm ( a , b ) real ( wp ) :: d2norm real ( wp ), intent ( in ) :: a real ( wp ), intent ( in ) :: b real ( wp ) :: scale scale = abs ( a ) + abs ( b ) if ( scale == zero ) then d2norm = zero else d2norm = scale * sqrt ( ( a / scale ) ** 2 + ( b / scale ) ** 2 ) end if end function d2norm !*************************************************************************************************** !*************************************************************************************************** end module lsqr_module !***************************************************************************************************","tags":"","loc":"sourcefile/lsqr.f90.html"},{"title":"problem_22.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_22.f90~~EfferentGraph sourcefile~problem_22.f90 problem_22.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_22.f90->sourcefile~aoc_utilities.f90 sourcefile~cache_module.f90~2 cache_module.f90 sourcefile~problem_22.f90->sourcefile~cache_module.f90~2 sourcefile~cache_module.f90~2->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_22 use iso_fortran_env use aoc_utilities use aoc_cache_module implicit none integer :: iunit , n_lines integer ( ip ) :: i , j , k character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: start_end , starts , ends integer ( ip ), dimension (:,:), allocatable :: istart_array integer ( ip ), dimension (:,:), allocatable :: iend_array integer ( ip ), dimension (:,:,:), allocatable :: array integer ( ip ), dimension (:), allocatable :: ipieces_above , ipieces_below integer ( ip ) :: ok_to_disintegrate , isum , isum_total logical :: ok_tmp type ( function_cache ) :: above_cache , below_cache call clk % tic () !find the ones we can remove without any other falling: !  to do that, look to see if any above it are not otherwise held up by another piece call initialize () ok_to_disintegrate = 0 do i = 1 , n_lines ipieces_above = get_pieces_above ( i ) if ( size ( ipieces_above ) == 0 ) then ! nothing above, it so ok to remove ok_to_disintegrate = ok_to_disintegrate + 1 else ok_tmp = . true . do j = 1 , size ( ipieces_above ) ! check all the pieces above. if ALL have other supporters then OK to remove ipieces_below = get_pieces_below ( ipieces_above ( j )) if ( all ( ipieces_below == i )) then ! only supported by i , so can't remove i ok_tmp = . false . exit end if end do if ( ok_tmp ) ok_to_disintegrate = ok_to_disintegrate + 1 end if end do write ( * , * ) '22a: ' , ok_to_disintegrate ! for part 2, we need to find all the nodes in the tree ! that are only supportd by ones below that in the tree ! !  777  44444 ! 66111222  9 !88 333333333   <--- deleting 3 will cause 1, 2, 4, 9 to fall, but not 6,7,8 ! just use a cache to save the ones above/below a given piece ! since there is a lot of duplication in that calculation call above_cache % initialize ( isize = 1000 , chunk_size = 1000 ) call below_cache % initialize ( isize = 1000 , chunk_size = 1000 ) call initialize () isum_total = 0 do i = 1 , n_lines ! try remove piece i ipieces_above = get_all_pieces_above ( i ) isum = size ( ipieces_above ) ! start out assuming they will all fall if ( isum > 0 ) then main : do j = 1 , size ( ipieces_above ) ! for all the ones, see if there are any below that are not in the above set. ! is so, then it will not fall. ipieces_below = get_all_pieces_below ( ipieces_above ( j ), iskip = i ) ipieces_below = pack ( ipieces_below , ipieces_below /= i ) ! remove i if present (the one being removed) do k = 1 , size ( ipieces_below ) if (. not . any ( ipieces_below ( k ) == [ ipieces_above ])) then isum = isum - 1 ! this one will not fall, so remove it from total cycle main end if end do end do main end if isum_total = isum_total + isum end do write ( * , * ) '22b: ' , isum_total call clk % toc ( '22' ) contains subroutine initialize () !! read the data ! open(newunit=iunit, file='inputs/day22_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day22.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) if ( allocated ( istart_array )) deallocate ( istart_array ); allocate ( istart_array ( n_lines , 3 )) if ( allocated ( iend_array )) deallocate ( iend_array ); allocate ( iend_array ( n_lines , 3 )) do i = 1 , n_lines line = read_line ( iunit ); start_end = split ( line , '~' ) starts = split ( start_end ( 1 )% str , ',' ) ends = split ( start_end ( 2 )% str , ',' ) istart_array ( i ,:) = [( int ( starts ( j )% str ), j = 1 , 3 )] iend_array ( i ,:) = [( int ( ends ( j )% str ), j = 1 , 3 )] end do close ( iunit ) ! create the array to hold all the pieces: if ( allocated ( array )) deallocate ( array ) allocate ( array ( 0 : maxval ([ istart_array (:, 1 ), iend_array (:, 1 )]),& 0 : maxval ([ istart_array (:, 2 ), iend_array (:, 2 )]),& 0 : maxval ([ istart_array (:, 3 ), iend_array (:, 3 )]))) call update_array () ! set array values from the start/end arrays call drop () ! continue forward in time until all the bricks settle. end subroutine initialize subroutine drop () !! continue forward in time until all the bricks settle. logical :: moved , tmp_moved integer ( ip ) :: i do moved = . false . do i = 1 , n_lines call move_piece_down ( i , tmp_moved ) if ( tmp_moved ) moved = . true . ! at least one was moved end do if (. not . moved ) exit ! done moving all the pieces end do end subroutine drop recursive function get_all_pieces_above ( i ) result ( ipieces ) !! reursively get a list of all pieces above piece i integer ( ip ), intent ( in ) :: i integer ( ip ), dimension (:), allocatable :: ipieces integer :: j !! counter logical :: found integer ( ip ) :: idx call above_cache % get ([ i ], idx , ipieces , found ) if (. not . found ) then allocate ( ipieces ( 0 )) associate ( tmp => get_pieces_above ( i )) if ( size ( tmp ) > 0 ) then ipieces = [ ipieces , tmp ] ! ones directly above do j = 1 , size ( tmp ) ! go up the tree ipieces = [ ipieces , get_all_pieces_above ( tmp ( j ))] end do ipieces = unique ( ipieces ) end if end associate call above_cache % put ( idx ,[ i ], ipieces ) end if end function get_all_pieces_above recursive function get_all_pieces_below ( i , iskip ) result ( ipieces ) !! reursively get a list of all pieces below piece i integer ( ip ), intent ( in ) :: i integer ( ip ), intent ( in ) :: iskip !! skip this one and it's children integer ( ip ), dimension (:), allocatable :: ipieces integer :: j !! counter logical :: found integer ( ip ) :: idx integer ( ip ), dimension (:), allocatable :: tmp call below_cache % get ([ i , iskip ], idx , ipieces , found ) if (. not . found ) then allocate ( ipieces ( 0 )) if ( i == iskip ) return tmp = get_pieces_below ( i ) if ( size ( tmp ) > 0 ) then tmp = pack ( tmp , tmp /= iskip ) ! remove the skipped one ipieces = [ ipieces , tmp ] ! ones directly below do j = 1 , size ( tmp ) ! go down the tree ipieces = [ ipieces , get_all_pieces_below ( tmp ( j ), iskip = iskip )] end do ipieces = unique ( ipieces ) end if call below_cache % put ( idx ,[ i , iskip ], ipieces ) end if end function get_all_pieces_below subroutine update_array () !! populate the array using the start/end indices integer :: i array = 0 do i = 1 , n_lines array ( istart_array ( i , 1 ): iend_array ( i , 1 ),& istart_array ( i , 2 ): iend_array ( i , 2 ),& istart_array ( i , 3 ): iend_array ( i , 3 )) = i end do end subroutine update_array function get_pieces_above ( i ) result ( ipieces ) !! get set of pieces directly above piece i integer ( ip ), intent ( in ) :: i integer ( ip ), dimension (:), allocatable :: ipieces integer ( ip ) :: x , y , z !! counter allocate ( ipieces ( 0 )) do x = istart_array ( i , 1 ), iend_array ( i , 1 ) do y = istart_array ( i , 2 ), iend_array ( i , 2 ) do z = istart_array ( i , 3 ), iend_array ( i , 3 ) if ( z + 1 <= ubound ( array , 3 )) then if ( array ( x , y , z + 1 ) /= 0 ) ipieces = [ ipieces , array ( x , y , z + 1 )] ! above this one end if end do end do end do ipieces = unique ( pack ( ipieces , ipieces /= i )) ! exclude the ones in this piece end function get_pieces_above function get_pieces_below ( i ) result ( ipieces ) !! get set of pieces directly below piece i integer ( ip ), intent ( in ) :: i integer ( ip ), dimension (:), allocatable :: ipieces integer ( ip ) :: x , y , z !! counter allocate ( ipieces ( 0 )) do x = istart_array ( i , 1 ), iend_array ( i , 1 ) do y = istart_array ( i , 2 ), iend_array ( i , 2 ) do z = istart_array ( i , 3 ), iend_array ( i , 3 ) if ( z - 1 > 0 ) then ! 0 is the floor if ( array ( x , y , z - 1 ) /= 0 ) ipieces = [ ipieces , array ( x , y , z - 1 )] ! below this one end if end do end do end do ipieces = unique ( pack ( ipieces , ipieces /= i )) ! exclude the ones in this piece end function get_pieces_below subroutine move_piece_down ( i , moved ) !! move a piece down (fall one square) if it can be moved integer ( ip ), intent ( in ) :: i !! piece number logical , intent ( out ) :: moved !! if it was actually movec moved = . false . if ( size ( get_pieces_below ( i )) == 0 ) then ! can only move if nothing below if ( istart_array ( i , 3 ) > 1 . and . iend_array ( i , 3 ) > 1 ) then istart_array ( i , 3 ) = istart_array ( i , 3 ) - 1 iend_array ( i , 3 ) = iend_array ( i , 3 ) - 1 moved = . true . call update_array () end if end if end subroutine move_piece_down end program problem_22","tags":"","loc":"sourcefile/problem_22.f90.html"},{"title":"problem_05.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_05.f90~~EfferentGraph sourcefile~problem_05.f90 problem_05.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_05.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_5 use iso_fortran_env use aoc_utilities implicit none integer :: i , iunit , n_lines character ( len = :), allocatable :: line type ( string ), dimension (:), allocatable :: vals integer ( ip ), dimension (:), allocatable :: seeds_list integer ( ip ) :: ilocation_min , ilocation , iseed integer ( ip ), dimension (:), allocatable :: ilocation_min_parallel type :: mapping ! save the source and destination start and end values integer ( ip ), dimension (:), allocatable :: dest_start , dest_end , src_start , src_end end type mapping integer , parameter :: NSTAGES = 7 type ( mapping ), dimension ( NSTAGES ) :: mappings ! seed_to_soil, soil_to_fertilizer, fertilizer_to_water, water_to_light, ! light_to_temperature, temperature_to_humidity, humidity_to_location integer :: parsing_state ! index in mappings (1 to NSTAGES) call clk % tic () do i = 1 , NSTAGES allocate ( mappings ( i )% dest_start ( 0 ), mappings ( i )% dest_end ( 0 ),& mappings ( i )% src_start ( 0 ), mappings ( i )% src_end ( 0 )) end do ! open(newunit=iunit, file='inputs/day5_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day5.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) parsing_state = 0 do i = 1 , n_lines line = read_line ( iunit ) if ( line == '' ) cycle ! blank line if ( startswith ( line , 'seeds:' )) then ; seeds_list = parse_ints64 ( line ( 7 :)) else if ( index ( line , 'map:' ) > 0 ) then ; parsing_state = parsing_state + 1 ! one of the 7 stages else ! parse the numbers for the given state: call populate ( parse_ints64 ( line ), mappings ( parsing_state )) end if end do close ( iunit ) ! ------------ part 1 ----------------- ilocation_min = huge ( 1 ) do i = 1 , size ( seeds_list ) ilocation = traverse ( seeds_list ( i ),. false .) if ( ilocation < ilocation_min ) ilocation_min = ilocation end do print * , '5a: ' , ilocation_min ! ------------ part 2 ----------------- !  so it doesn't run in the CI !! if (. false .) then ! brute force, openMP version. just run the part a algorithm for all the seeds. ! takes a minute or so on my computer. allocate ( ilocation_min_parallel ( size ( seeds_list ) / 2 )) ilocation_min_parallel = huge ( 1 ) !$OMP PARALLEL DO SHARED(ilocation_min_parallel) PRIVATE(i,iseed,ilocation) do i = 1 , size ( seeds_list ), 2 do iseed = seeds_list ( i ), seeds_list ( i ) + seeds_list ( i + 1 ) - 1 ilocation = traverse ( iseed , . false .) if ( ilocation < ilocation_min_parallel (( i + 1 ) / 2 )) ilocation_min_parallel (( i + 1 ) / 2 ) = ilocation end do end do !$OMP END PARALLEL DO print * , '5b: ' , minval ( ilocation_min_parallel ) end if ! ------------ part 2 ----------------- ! Alternate version, go backwards from the location to the seed ! and see if it is contained in the seed set. ! this one is pretty fast (< 1 sec) do ilocation = minval ( mappings ( 7 )% dest_start ), maxval ( mappings ( 7 )% dest_end ) ! up to the max ilocation value iseed = traverse ( ilocation , reverse = . true .) ! from ilocation to iseed if ( in_seed_list ( iseed )) exit ! found the min end do print * , '5b: ' , ilocation call clk % toc ( '5' ) contains logical function in_seed_list ( iseed ) ! for part b, is the seed in the initial list integer ( ip ), intent ( in ) :: iseed integer :: i do i = 1 , size ( seeds_list ), 2 if ( iseed >= seeds_list ( i ) . and . iseed <= seeds_list ( i ) + seeds_list ( i + 1 ) - 1 ) then in_seed_list = . true . return end if end do in_seed_list = . false . end function in_seed_list subroutine populate ( nums , m ) integer ( ip ), dimension ( 3 ), intent ( in ) :: nums ! the three numbers from the line: ! [dest range start, src range start, range length type ( mapping ), intent ( inout ) :: m ! structure to add this data to associate ( dest => nums ( 1 ), source => nums ( 2 ), range => nums ( 3 ) ) m % dest_start = [ m % dest_start , dest ] m % dest_end = [ m % dest_end , dest + range - 1 ] m % src_start = [ m % src_start , source ] m % src_end = [ m % src_end , source + range - 1 ] end associate end subroutine populate pure function map ( ival , m , reverse ) result ( idest ) integer ( ip ), intent ( in ) :: ival type ( mapping ), intent ( in ) :: m logical , intent ( in ) :: reverse ! if reversed, go from: dest -> src integer ( ip ) :: idest integer :: i if ( reverse ) then do i = 1 , size ( m % src_start ) ! locate ival (dest) in the dest start:end range if ( ival >= m % dest_start ( i ) . and . ival <= m % dest_end ( i )) then ! found it, map to dest idest = m % src_start ( i ) + ( ival - m % dest_start ( i )) ! this is the resultant isource return end if end do else do i = 1 , size ( m % src_start ) ! locate ival (source) in the source start:end range if ( ival >= m % src_start ( i ) . and . ival <= m % src_end ( i )) then ! found it, map to dest idest = m % dest_start ( i ) + ( ival - m % src_start ( i )) return end if end do end if idest = ival ! if not found in any of the sets end function map pure function traverse ( iseed , reverse ) result ( ilocation ) integer ( ip ), intent ( in ) :: iseed logical , intent ( in ) :: reverse !! if reverse, then ilocation -> iseed integer ( ip ) :: ilocation integer :: i ilocation = iseed ! initialize if ( reverse ) then do i = NSTAGES , 1 , - 1 ilocation = map ( ilocation , mappings ( i ), reverse ) ! this is really iseed end do else do i = 1 , NSTAGES ilocation = map ( ilocation , mappings ( i ), reverse ) end do end if end function traverse end program problem_5","tags":"","loc":"sourcefile/problem_05.f90.html"},{"title":"problem_10.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_10.f90~~EfferentGraph sourcefile~problem_10.f90 problem_10.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_10.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_10 use iso_fortran_env use aoc_utilities implicit none integer :: i , j , nrows , ncols , imove , l , m logical , dimension (:,:), allocatable :: icounts character ( len = 1 ), dimension (:,:), allocatable :: array integer , dimension (:,:), allocatable :: distance , distance_reverse logical , dimension (:,:), allocatable :: visited real ( wp ), dimension (:), allocatable :: x , y !! path cooidinates integer , dimension ( 2 ) :: Sij !! i,j of the S char in array call clk % tic () array = read_file_to_char_array ( 'inputs/day10.txt' , '.' ) ! pad with . to simplify edge logic nrows = size ( array , 1 ) ncols = size ( array , 2 ) allocate ( distance ( nrows , ncols )); distance = - 1 allocate ( distance_reverse ( nrows , ncols )); distance_reverse = - 1 allocate ( visited ( nrows , ncols )) ! start at the S coordinate: Sij = findloc ( array , 'S' ) x = [ Sij ( 1 )] ! to store the path for part b y = [ Sij ( 2 )] ! traverse the maze: visited = . false .; visited ( Sij ( 1 ), Sij ( 2 )) = . true .; distance ( Sij ( 1 ), Sij ( 2 )) = 0 do imove = 1 , 4 call move ( Sij ( 1 ), Sij ( 2 ), imove , distance , . true .) end do ! traverse the maze again in reverse: visited = . false .; visited ( Sij ( 1 ), Sij ( 2 )) = . true .; distance_reverse ( Sij ( 1 ), Sij ( 2 )) = 0 do imove = 4 , 1 , - 1 call move ( Sij ( 1 ), Sij ( 2 ), imove , distance_reverse , . false .) end do ! where they match is the distance furthest away from the start write ( * , * ) '10a: ' , pack ( distance , mask = ( distance == distance_reverse . and . distance > 0 )) ! for part b, use locpt to test all the points ! allow openmp to be used here to do each row in parallel allocate ( icounts ( nrows , ncols )); icounts = . false . !$OMP PARALLEL DO SHARED(icounts,x,y) PRIVATE(i,j,l,m) do i = 2 , nrows - 1 ! we can skip the padding do j = 2 , ncols - 1 if ( any ( i == x . and . j == y )) cycle ! skip if on path call locpt ( real ( i , wp ), real ( j , wp ), x , y , size ( x ), l , m ) if ( l == 1 ) icounts ( i , j ) = . true . ! if (i,j) is inside the polygonal path end do end do !$OMP END PARALLEL DO write ( * , * ) '10b: ' , count ( icounts ) call clk % toc ( '10' ) contains recursive subroutine move ( i , j , direction , distance , save_path ) integer , intent ( in ) :: i , j , direction integer , dimension (:,:), intent ( inout ) :: distance logical , intent ( in ) :: save_path !! to save the path coordinates integer :: inew , jnew , imove logical :: valid_move select case ( direction ) case ( 1 ); inew = i - 1 ; jnew = j ! north case ( 2 ); inew = i + 1 ; jnew = j ! south case ( 3 ); inew = i ; jnew = j + 1 ! east case ( 4 ); inew = i ; jnew = j - 1 ! west end select if ( visited ( inew , jnew ) . or . array ( inew , jnew ) == '.' ) return ! can we move in this direction? valid_move = . false . associate ( current_pipe => array ( i , j ), & current_distance => distance ( i , j ), & move_to => array ( inew , jnew ) ) select case ( current_pipe ) case ( 'S' ) ! don't know what the first pip is, so have to try them all select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '|' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south end select case ( '-' ) select case ( direction ) case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'L' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select case ( 'J' ) select case ( direction ) case ( 1 ); valid_move = index ( pipe_info ( move_to ), 'S' ) > 0 ! north case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( '7' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 4 ); valid_move = index ( pipe_info ( move_to ), 'E' ) > 0 ! west end select case ( 'F' ) select case ( direction ) case ( 2 ); valid_move = index ( pipe_info ( move_to ), 'N' ) > 0 ! south case ( 3 ); valid_move = index ( pipe_info ( move_to ), 'W' ) > 0 ! east end select end select if ( valid_move ) then distance ( inew , jnew ) = current_distance + 1 visited ( inew , jnew ) = . true . do imove = 1 , 4 call move ( inew , jnew , imove , distance , save_path ) end do if ( save_path ) then x = [ x , real ( inew , wp )] ! save cordinates of point on the path y = [ y , real ( jnew , wp )] end if end if end associate end subroutine move pure character ( len = 2 ) function pipe_info ( p ) character ( len = 1 ), intent ( in ) :: p select case ( p ) case ( '|' ); pipe_info = 'NS' ! | is a vertical pipe connecting north and south. case ( '-' ); pipe_info = 'EW' ! - is a horizontal pipe connecting east and west. case ( 'L' ); pipe_info = 'NE' ! L is a 90-degree bend connecting north and east. case ( 'J' ); pipe_info = 'NW' ! J is a 90-degree bend connecting north and west. case ( '7' ); pipe_info = 'SW' ! 7 is a 90-degree bend connecting south and west. case ( 'F' ); pipe_info = 'SE' ! F is a 90-degree bend connecting south and east. end select end function pipe_info end program problem_10","tags":"","loc":"sourcefile/problem_10.f90.html"},{"title":"problem_19.f90 – AoC-2023","text":"This file depends on sourcefile~~problem_19.f90~~EfferentGraph sourcefile~problem_19.f90 problem_19.f90 sourcefile~aoc_utilities.f90 aoc_utilities.F90 sourcefile~problem_19.f90->sourcefile~aoc_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program problem_19 use aoc_utilities use iso_fortran_env implicit none integer :: iunit , n_lines , iline , i character ( len = :), allocatable :: line !, name type ( string ), dimension (:), allocatable :: vals logical :: accepted integer ( ip ) :: total_accepted type :: part integer ( ip ), dimension ( 4 ) :: xmas ! [x,m,a,s] end type part type ( part ), dimension (:), allocatable :: parts type :: rule logical :: accept = . false . logical :: reject = . false . integer :: operator = 0 ! 1:<, 2:> integer :: operator_arg = 0 ! 1:x, 2:m, 3:a, 4:s integer :: operator_val = 0 ! value to compare to character ( len = :), allocatable :: goto ! where to next (workflow name) end type rule type :: workflow character ( len = :), allocatable :: name type ( rule ), dimension (:), allocatable :: rules end type workflow type ( workflow ), dimension (:), allocatable :: workflows type ( workflow ), allocatable :: w call clk % tic () ! open(newunit=iunit, file='inputs/day19_test.txt', status='OLD') open ( newunit = iunit , file = 'inputs/day19.txt' , status = 'OLD' ) n_lines = number_of_lines_in_file ( iunit ) allocate ( workflows ( 0 )) do iline = 1 , n_lines line = read_line ( iunit ) if ( line == '' ) then !now parse part ratings allocate ( parts ( 0 )) end if if ( allocated ( parts )) then ! parsing parts if ( line == '' ) cycle ! {x=787,m=2655,a=1222,s=2876} vals = split ( line , ',' ) parts = [ parts , part ( xmas = [ int ( vals ( 1 )% str ( 4 :)), & int ( vals ( 2 )% str ( 3 :)), & int ( vals ( 3 )% str ( 3 :)), & int ( vals ( 4 )% str ( 3 : len ( vals ( 4 )% str ) - 1 ))])] else ! parsing workflows : qqz{s>2770:qs,m<1801:hdj,R} if ( allocated ( w )) deallocate ( w ); allocate ( w ) ! blank one vals = split ( line , '{' ) w % name = vals ( 1 )% str ! workflow name !write(*,*) '--->'//w%name//'<-----' vals ( 2 )% str = vals ( 2 )% str ( 1 : len ( vals ( 2 )% str ) - 1 ) ! remove last bracket vals = split ( vals ( 2 )% str , ',' ) ! workflow rules ! add each rule to the workflow allocate ( w % rules ( 0 )) do i = 1 , size ( vals ) w % rules = [ w % rules , parse_rule ( vals ( i )% str )] end do workflows = [ workflows , w ] end if end do total_accepted = 0 do i = 1 , size ( parts ) accepted = process ( parts ( i )) !write(*,*) parts(i), accepted if ( accepted ) then total_accepted = total_accepted + rating ( parts ( i )) end if end do write ( * , * ) '19a: ' , total_accepted call clk % toc ( '19' ) contains pure integer ( ip ) function rating ( p ) type ( part ), intent ( in ) :: p rating = sum ( p % xmas ) end function rating function process ( p ) result ( accepted ) !! process this part through all the workflows. type ( part ), intent ( in ) :: p logical :: accepted integer :: i , irule i = workflow_name_to_index ( 'in' ) ! start at the first workflow irule = 1 ! first rule do associate ( r => workflows ( i )% rules ( irule ) ) ! check if we are done if ( r % accept ) then ; accepted = . true .; return ; end if if ( r % reject ) then ; accepted = . false .; return ; end if if ( r % operator > 0 ) then ! process the operator select case ( r % operator ) case ( 1 ) ! < if ( p % xmas ( r % operator_arg ) < r % operator_val ) then ! check if done if ( r % goto == 'A' ) then ; accepted = . true .; return ; end if if ( r % goto == 'R' ) then ; accepted = . false .; return ; end if ! go to next workflow: i = workflow_name_to_index ( r % goto ) !write(*,*) 'goto '//r%goto irule = 1 ! start at first rule of new workflow else irule = irule + 1 ! next rule end if case ( 2 ) ! > if ( p % xmas ( r % operator_arg ) > r % operator_val ) then ! check if done if ( r % goto == 'A' ) then ; accepted = . true .; return ; end if if ( r % goto == 'R' ) then ; accepted = . false .; return ; end if ! go to next workflow: i = workflow_name_to_index ( r % goto ) irule = 1 ! start at first rule of new workflow else irule = irule + 1 ! next rule end if end select else ! goto another workflow i = workflow_name_to_index ( r % goto ) irule = 1 ! start at first rule of new workflow end if end associate end do end function process function workflow_name_to_index ( name ) result ( idx ) !! get the index of this workflow in the array character ( len =* ), intent ( in ) :: name integer :: idx do idx = 1 , size ( workflows ) if ( name == workflows ( idx )% name ) return ! found it end do if ( idx > size ( workflows )) error stop 'workflow not found: ' // name end function workflow_name_to_index function parse_rule ( s ) result ( r ) character ( len =* ), intent ( in ) :: s type ( rule ) :: r type ( string ), dimension (:), allocatable :: v character ( len =* ), parameter :: xmas = 'xmas' ! 1,2,3,4 if ( s == 'A' ) then r % accept = . true . else if ( s == 'R' ) then r % reject = . true . else if ( index ( s , '>' ) > 0 ) then v = split ( s ( 3 :), ':' ) ! example: a<2006:qkq r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 2 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else if ( index ( s , '<' ) > 0 ) then v = split ( s ( 3 :), ':' ) r % operator_arg = index ( xmas , s ( 1 : 1 )) r % operator = 1 r % operator_val = int ( v ( 1 )% str ) r % goto = v ( 2 )% str ! can be a workflow or A or R else r % goto = s ! it's a workflow name end if end if end function parse_rule end program problem_19","tags":"","loc":"sourcefile/problem_19.f90.html"}]}